# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package open;
0.000853,2,0.000427,use warnings;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.10';
0.000000,0,0.000000,
0.000015,1,0.000015,require 5.008001; # for PerlIO::get_layers()
0.000000,0,0.000000,
0.000001,1,0.000001,my $locale_encoding;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_encname {
0.000000,0,0.000000,return ($1, Encode::resolve_alias($1)) if $_[0] =~ /^:?encoding\((.+)\)$/;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak {
0.000000,0,0.000000,require Carp; goto &Carp::croak;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _drop_oldenc {
0.000000,0,0.000000,# If by the time we arrive here there already is at the top of the
0.000000,0,0.000000,# perlio layer stack an encoding identical to what we would like
0.000000,0,0.000000,# to push via this open pragma, we will pop away the old encoding
0.000000,0,0.000000,# (+utf8) so that we can push ourselves in place (this is easier
0.000000,0,0.000000,# than ignoring pushing ourselves because of the way how ${^OPEN}
0.000000,0,0.000000,# works).  So we are looking for something like
0.000000,0,0.000000,#
0.000000,0,0.000000,#   stdio encoding(xxx) utf8
0.000000,0,0.000000,#
0.000000,0,0.000000,# in the existing layer stack, and in the new stack chunk for
0.000000,0,0.000000,#
0.000000,0,0.000000,#   :encoding(xxx)
0.000000,0,0.000000,#
0.000000,0,0.000000,# If we find a match, we pop the old stack (once, since
0.000000,0,0.000000,# the utf8 is just a flag on the encoding layer)
0.000000,0,0.000000,my ($h, @new) = @_;
0.000000,0,0.000000,return unless @new >= 1 && $new[-1] =~ /^:encoding\(.+\)$/;
0.000000,0,0.000000,my @old = PerlIO::get_layers($h);
0.000000,0,0.000000,return unless @old >= 3 &&
0.000000,0,0.000000,$old[-1] eq 'utf8' &&
0.000000,0,0.000000,$old[-2] =~ /^encoding\(.+\)$/;
0.000000,0,0.000000,require Encode;
0.000000,0,0.000000,my ($loname, $lcname) = _get_encname($old[-2]);
0.000000,0,0.000000,unless (defined $lcname) { # Should we trust get_layers()?
0.000000,0,0.000000,croak("open: Unknown encoding '$loname'");
0.000000,0,0.000000,}
0.000000,0,0.000000,my ($voname, $vcname) = _get_encname($new[-1]);
0.000000,0,0.000000,unless (defined $vcname) {
0.000000,0,0.000000,croak("open: Unknown encoding '$voname'");
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($lcname eq $vcname) {
0.000000,0,0.000000,binmode($h, ":pop"); # utf8 is part of the encoding layer
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000002,1,0.000002,my ($class,@args) = @_;
0.000002,1,0.000002,croak("open: needs explicit list of PerlIO layers") unless @args;
0.000001,1,0.000001,my $std;
0.000004,1,0.000004,my ($in,$out) = split(/\0/,(${^OPEN} || "\0"), -1);
0.000005,1,0.000005,while (@args) {
0.000003,2,0.000002,my $type = shift(@args);
0.000003,2,0.000001,my $dscp;
0.000024,2,0.000012,if ($type =~ /^:?(utf8|locale|encoding\(.+\))$/) {
0.000001,1,0.000001,$type = 'IO';
0.000003,1,0.000003,$dscp = ":$1";
0.000000,0,0.000000,} elsif ($type eq ':std') {
0.000001,1,0.000001,$std = 1;
0.000002,1,0.000002,next;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$dscp = shift(@args) || '';
0.000000,0,0.000000,}
0.000001,1,0.000001,my @val;
0.000004,1,0.000004,foreach my $layer (split(/\s+/,$dscp)) {
0.000011,1,0.000011,$layer =~ s/^://;
0.000009,1,0.000009,if ($layer eq 'locale') {
0.000000,0,0.000000,require Encode;
0.000000,0,0.000000,require encoding;
0.000000,0,0.000000,$locale_encoding = encoding::_get_locale_encoding()
0.000000,0,0.000000,unless defined $locale_encoding;
0.000000,0,0.000000,(warnings::warnif("layer", "Cannot figure out an encoding to use"), last)
0.000000,0,0.000000,unless defined $locale_encoding;
0.000000,0,0.000000,$layer = "encoding($locale_encoding)";
0.000000,0,0.000000,$std = 1;
0.000000,0,0.000000,} else {
0.000002,1,0.000002,my $target = $layer;		# the layer name itself
0.000010,1,0.000010,$target =~ s/^(\w+)\(.+\)$/$1/;	# strip parameters
0.000000,0,0.000000,
0.000285,3,0.000095,unless(PerlIO::Layer::->find($target,1)) {
0.000000,0,0.000000,warnings::warnif("layer", "Unknown PerlIO layer '$target'");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000003,1,0.000003,push(@val,":$layer");
0.000011,1,0.000011,if ($layer =~ /^(crlf|raw)$/) {
0.000000,0,0.000000,$^H{"open_$type"} = $layer;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000005,1,0.000005,if ($type eq 'IN') {
0.000000,0,0.000000,_drop_oldenc(*STDIN, @val) if $std;
0.000000,0,0.000000,$in  = join(' ', @val);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'OUT') {
0.000000,0,0.000000,if ($std) {
0.000000,0,0.000000,_drop_oldenc(*STDOUT, @val);
0.000000,0,0.000000,_drop_oldenc(*STDERR, @val);
0.000000,0,0.000000,}
0.000000,0,0.000000,$out = join(' ', @val);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type eq 'IO') {
0.000001,1,0.000001,if ($std) {
0.000000,0,0.000000,_drop_oldenc(*STDIN, @val);
0.000000,0,0.000000,_drop_oldenc(*STDOUT, @val);
0.000000,0,0.000000,_drop_oldenc(*STDERR, @val);
0.000000,0,0.000000,}
0.000003,1,0.000003,$in = $out = join(' ', @val);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "Unknown PerlIO layer class '$type' (need IN, OUT or IO)";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000007,1,0.000007,${^OPEN} = join("\0", $in, $out);
0.000008,1,0.000008,if ($std) {
0.000003,1,0.000003,if ($in) {
0.000061,1,0.000061,if ($in =~ /:utf8\b/) {
0.000000,0,0.000000,binmode(STDIN,  ":utf8");
0.000000,0,0.000000,} elsif ($in =~ /(\w+\(.+\))/) {
0.000000,0,0.000000,binmode(STDIN,  ":$1");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000003,1,0.000003,if ($out) {
0.000016,1,0.000016,if ($out =~ /:utf8\b/) {
0.000000,0,0.000000,binmode(STDOUT,  ":utf8");
0.000000,0,0.000000,binmode(STDERR,  ":utf8");
0.000000,0,0.000000,} elsif ($out =~ /(\w+\(.+\))/) {
0.000026,1,0.000026,binmode(STDOUT,  ":$1");
0.000026,1,0.000026,binmode(STDERR,  ":$1");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,__END__
