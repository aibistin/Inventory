# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,package Log::Log4perl::DateFormat;
0.000000,0,0.000000,###########################################
0.000042,2,0.000021,use warnings;
0.000035,2,0.000017,use strict;
0.000000,0,0.000000,
0.001332,2,0.000666,use Carp qw( croak );
0.000000,0,0.000000,
0.000002,1,0.000002,our $GMTIME = 0;
0.000000,0,0.000000,
0.000005,1,0.000005,my @MONTH_NAMES = qw(
0.000000,0,0.000000,January February March April May June July
0.000000,0,0.000000,August September October November December);
0.000000,0,0.000000,
0.000003,1,0.000003,my @WEEK_DAYS = qw(
0.000000,0,0.000000,Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,###########################################
0.000002,1,0.000002,my($class, $format) = @_;
0.000000,0,0.000000,
0.000003,1,0.000003,my $self = { 
0.000000,0,0.000000,stack => [],
0.000000,0,0.000000,fmt   => undef,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000002,1,0.000002,bless $self, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,# Predefined formats
0.000002,1,0.000002,if($format eq "ABSOLUTE") {
0.000000,0,0.000000,$format = "HH:mm:ss,SSS";
0.000000,0,0.000000,} elsif($format eq "DATE") {
0.000000,0,0.000000,$format = "dd MMM yyyy HH:mm:ss,SSS";
0.000000,0,0.000000,} elsif($format eq "ISO8601") {
0.000000,0,0.000000,$format = "yyyy-MM-dd HH:mm:ss,SSS";
0.000000,0,0.000000,} elsif($format eq "APACHE") {
0.000000,0,0.000000,$format = "[EEE MMM dd HH:mm:ss yyyy]";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,if($format) { 
0.000000,0,0.000000,$self->prepare($format);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub prepare {
0.000000,0,0.000000,###########################################
0.000002,1,0.000002,my($self, $format) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# the actual DateTime spec allows for literal text delimited by
0.000000,0,0.000000,# single quotes; a single quote can be embedded in the literal
0.000000,0,0.000000,# text by using two single quotes.
0.000000,0,0.000000,#
0.000000,0,0.000000,# my strategy here is to split the format into active and literal
0.000000,0,0.000000,# "chunks"; active chunks are prepared using $self->rep() as
0.000000,0,0.000000,# before, while literal chunks get transformed to accomodate
0.000000,0,0.000000,# single quotes and to protect percent signs.
0.000000,0,0.000000,#
0.000000,0,0.000000,# motivation: the "recommended" ISO-8601 date spec for a time in
0.000000,0,0.000000,# UTC is actually:
0.000000,0,0.000000,#
0.000000,0,0.000000,#     YYYY-mm-dd'T'hh:mm:ss.SSS'Z'
0.000000,0,0.000000,
0.000002,1,0.000002,my $fmt = "";
0.000000,0,0.000000,
0.000005,1,0.000005,foreach my $chunk ( split /('(?:''|[^'])*')/, $format ) {
0.000020,1,0.000020,if ( $chunk =~ /\A'(.*)'\z/ ) {
0.000000,0,0.000000,# literal text
0.000000,0,0.000000,my $literal = $1;
0.000000,0,0.000000,$literal =~ s/''/'/g;
0.000000,0,0.000000,$literal =~ s/\%/\%\%/g;
0.000000,0,0.000000,$fmt .= $literal;
0.000000,0,0.000000,} elsif ( $chunk =~ /'/ ) {
0.000000,0,0.000000,# single quotes should always be in a literal
0.000000,0,0.000000,croak "bad date format \"$format\": " .
0.000000,0,0.000000,"unmatched single quote in chunk \"$chunk\"";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# handle active chunks just like before
0.000100,7,0.000014,$chunk =~ s/(([GyMdhHmsSEeDFwWakKzZ])\2*)/$self->rep($1)/ge;
0.000002,1,0.000002,$fmt .= $chunk;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,return $self->{fmt} = $fmt;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub rep {
0.000000,0,0.000000,###########################################
0.000013,6,0.000002,my ($self, $string) = @_;
0.000000,0,0.000000,
0.000010,6,0.000002,my $first = substr $string, 0, 1;
0.000009,6,0.000002,my $len   = length $string;
0.000000,0,0.000000,
0.000016,6,0.000003,my $time=time();
0.000028,6,0.000005,my @g = gmtime($time);
0.000041,6,0.000007,my @t = localtime($time);
0.000020,6,0.000003,my $z = $t[1]-$g[1]+($t[2]-$g[2])*60+($t[7]-$g[7])*1440+
0.000000,0,0.000000,($t[5]-$g[5])*(525600+(abs($t[7]-$g[7])>364)*1440);
0.000016,6,0.000003,my $offset = sprintf("%+.2d%.2d", $z/60, "00");
0.000000,0,0.000000,
0.000000,0,0.000000,#my ($s,$mi,$h,$d,$mo,$y,$wd,$yd,$dst) = localtime($time);
0.000000,0,0.000000,
0.000000,0,0.000000,# Here's how this works:
0.000000,0,0.000000,# Detect what kind of parameter we're dealing with and determine
0.000000,0,0.000000,# what type of sprintf-placeholder to return (%d, %02d, %s or whatever).
0.000000,0,0.000000,# Then, we're setting up an array, specific to the current format,
0.000000,0,0.000000,# that can be used later on to compute the components of the placeholders
0.000000,0,0.000000,# one by one when we get the components of the current time later on
0.000000,0,0.000000,# via localtime.
0.000000,0,0.000000,
0.000000,0,0.000000,# So, we're parsing the "yyyy/MM" format once, replace it by, say
0.000000,0,0.000000,# "%04d:%02d" and store an array that says "for the first placeholder,
0.000000,0,0.000000,# get the localtime-parameter on index #5 (which is years since the
0.000000,0,0.000000,# epoch), add 1900 to it and pass it on to sprintf(). For the 2nd 
0.000000,0,0.000000,# placeholder, get the localtime component at index #2 (which is hours)
0.000000,0,0.000000,# and pass it on unmodified to sprintf.
0.000000,0,0.000000,
0.000000,0,0.000000,# So, the array to compute the time format at logtime contains
0.000000,0,0.000000,# as many elements as the original SimpleDateFormat contained. Each
0.000000,0,0.000000,# entry is a arrary ref, holding an array with 2 elements: The index
0.000000,0,0.000000,# into the localtime to obtain the value and a reference to a subroutine
0.000000,0,0.000000,# to do computations eventually. The subroutine expects the orginal
0.000000,0,0.000000,# localtime() time component (like year since the epoch) and returns
0.000000,0,0.000000,# the desired value for sprintf (like y+1900).
0.000000,0,0.000000,
0.000000,0,0.000000,# This way, we're parsing the original format only once (during system
0.000000,0,0.000000,# startup) and during runtime all we do is call localtime *once* and
0.000000,0,0.000000,# run a number of blazingly fast computations, according to the number
0.000000,0,0.000000,# of placeholders in the format.
0.000000,0,0.000000,
0.000000,0,0.000000,###########
0.000000,0,0.000000,#G - epoch#
0.000000,0,0.000000,###########
0.000015,6,0.000002,if($first eq "G") {
0.000000,0,0.000000,# Always constant
0.000000,0,0.000000,return "AD";
0.000000,0,0.000000,
0.000000,0,0.000000,###################
0.000000,0,0.000000,#e - epoch seconds#
0.000000,0,0.000000,###################
0.000000,0,0.000000,} elsif($first eq "e") {
0.000000,0,0.000000,# index (0) irrelevant, but we return time() which 
0.000000,0,0.000000,# comes in as 2nd parameter
0.000000,0,0.000000,push @{$self->{stack}}, [0, sub { return $_[1] }];
0.000000,0,0.000000,return "%d";
0.000000,0,0.000000,
0.000000,0,0.000000,##########
0.000000,0,0.000000,#y - year#
0.000000,0,0.000000,##########
0.000000,0,0.000000,} elsif($first eq "y") {
0.000002,1,0.000002,if($len >= 4) {
0.000000,0,0.000000,# 4-digit year
0.000026,3,0.000009,push @{$self->{stack}}, [5, sub { return $_[0] + 1900 }];
0.000009,1,0.000009,return "%04d";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# 2-digit year
0.000000,0,0.000000,push @{$self->{stack}}, [5, sub { $_[0] % 100 }];
0.000000,0,0.000000,return "%02d";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########
0.000000,0,0.000000,#M - month#
0.000000,0,0.000000,###########
0.000000,0,0.000000,} elsif($first eq "M") {
0.000002,1,0.000002,if($len >= 3) {
0.000000,0,0.000000,# Use month name
0.000000,0,0.000000,push @{$self->{stack}}, [4, sub { return $MONTH_NAMES[$_[0]] }];
0.000000,0,0.000000,if($len >= 4) {
0.000000,0,0.000000,return "%s";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return "%.3s";
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif($len == 2) {
0.000000,0,0.000000,# Use zero-padded month number
0.000019,3,0.000006,push @{$self->{stack}}, [4, sub { $_[0]+1 }];
0.000007,1,0.000007,return "%02d";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Use zero-padded month number
0.000000,0,0.000000,push @{$self->{stack}}, [4, sub { $_[0]+1 }];
0.000000,0,0.000000,return "%d";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################
0.000000,0,0.000000,#d - day of month#
0.000000,0,0.000000,##################
0.000000,0,0.000000,} elsif($first eq "d") {
0.000017,3,0.000006,push @{$self->{stack}}, [3, sub { return $_[0] }];
0.000008,1,0.000008,return "%0" . $len . "d";
0.000000,0,0.000000,
0.000000,0,0.000000,##################
0.000000,0,0.000000,#h - am/pm hour#
0.000000,0,0.000000,##################
0.000000,0,0.000000,} elsif($first eq "h") {
0.000000,0,0.000000,push @{$self->{stack}}, [2, sub { ($_[0] % 12) || 12 }];
0.000000,0,0.000000,return "%0" . $len . "d";
0.000000,0,0.000000,
0.000000,0,0.000000,##################
0.000000,0,0.000000,#H - 24 hour#
0.000000,0,0.000000,##################
0.000000,0,0.000000,} elsif($first eq "H") {
0.000017,3,0.000006,push @{$self->{stack}}, [2, sub { return $_[0] }];
0.000007,1,0.000007,return "%0" . $len . "d";
0.000000,0,0.000000,
0.000000,0,0.000000,##################
0.000000,0,0.000000,#m - minute#
0.000000,0,0.000000,##################
0.000000,0,0.000000,} elsif($first eq "m") {
0.000018,3,0.000006,push @{$self->{stack}}, [1, sub { return $_[0] }];
0.000007,1,0.000007,return "%0" . $len . "d";
0.000000,0,0.000000,
0.000000,0,0.000000,##################
0.000000,0,0.000000,#s - second#
0.000000,0,0.000000,##################
0.000000,0,0.000000,} elsif($first eq "s") {
0.000017,3,0.000006,push @{$self->{stack}}, [0, sub { return $_[0] }];
0.000007,1,0.000007,return "%0" . $len . "d";
0.000000,0,0.000000,
0.000000,0,0.000000,##################
0.000000,0,0.000000,#E - day of week #
0.000000,0,0.000000,##################
0.000000,0,0.000000,} elsif($first eq "E") {
0.000000,0,0.000000,push @{$self->{stack}}, [6, sub { $WEEK_DAYS[$_[0]] }];
0.000000,0,0.000000,if($len >= 4) {
0.000000,0,0.000000,return "%${len}s";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return "%.3s";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,######################
0.000000,0,0.000000,#D - day of the year #
0.000000,0,0.000000,######################
0.000000,0,0.000000,} elsif($first eq "D") {
0.000000,0,0.000000,push @{$self->{stack}}, [7, sub { $_[0] + 1}];
0.000000,0,0.000000,return "%0" . $len . "d";
0.000000,0,0.000000,
0.000000,0,0.000000,######################
0.000000,0,0.000000,#a - am/pm marker    #
0.000000,0,0.000000,######################
0.000000,0,0.000000,} elsif($first eq "a") {
0.000000,0,0.000000,push @{$self->{stack}}, [2, sub { $_[0] < 12 ? "AM" : "PM" }];
0.000000,0,0.000000,return "%${len}s";
0.000000,0,0.000000,
0.000000,0,0.000000,######################
0.000000,0,0.000000,#S - milliseconds    #
0.000000,0,0.000000,######################
0.000000,0,0.000000,} elsif($first eq "S") {
0.000000,0,0.000000,push @{$self->{stack}}, 
0.000000,0,0.000000,[9, sub { substr sprintf("%06d", $_[0]), 0, $len }];
0.000000,0,0.000000,return "%s";
0.000000,0,0.000000,
0.000000,0,0.000000,###############################
0.000000,0,0.000000,#Z - RFC 822 time zone  -0800 #
0.000000,0,0.000000,###############################
0.000000,0,0.000000,} elsif($first eq "Z") {
0.000000,0,0.000000,push @{$self->{stack}}, [10, sub { $offset }];
0.000000,0,0.000000,return "$offset";
0.000000,0,0.000000,
0.000000,0,0.000000,#############################
0.000000,0,0.000000,#Something that's not defined
0.000000,0,0.000000,#(F=day of week in month
0.000000,0,0.000000,# w=week in year W=week in month
0.000000,0,0.000000,# k=hour in day K=hour in am/pm
0.000000,0,0.000000,# z=timezone
0.000000,0,0.000000,#############################
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return "-- '$first' not (yet) implemented --";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub format {
0.000000,0,0.000000,###########################################
0.000004,2,0.000002,my($self, $secs, $msecs) = @_;
0.000000,0,0.000000,
0.000003,2,0.000002,$msecs = 0 unless defined $msecs;
0.000000,0,0.000000,
0.000003,2,0.000001,my @time; 
0.000000,0,0.000000,
0.000007,2,0.000003,if($GMTIME) {
0.000000,0,0.000000,@time = gmtime($secs);
0.000000,0,0.000000,} else {
0.000025,2,0.000012,@time = localtime($secs);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# add milliseconds
0.000004,2,0.000002,push @time, $msecs;
0.000000,0,0.000000,
0.000003,2,0.000002,my @values = ();
0.000000,0,0.000000,
0.000008,2,0.000004,for(@{$self->{stack}}) {
0.000022,12,0.000002,my($val, $code) = @$_;
0.000094,12,0.000008,if($code) {
0.000000,0,0.000000,push @values, $code->($time[$val], $secs);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,push @values, $time[$val];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000022,2,0.000011,return sprintf($self->{fmt}, @values);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
