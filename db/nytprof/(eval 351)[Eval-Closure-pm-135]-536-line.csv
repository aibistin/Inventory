# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Eval::Closure::Sandbox_163;
0.000000,0,0.000000,sub {
0.000002,1,0.000002,my $defaults = ${$_[0]};
0.000001,1,0.000001,my $meta = ${$_[1]};
0.000001,1,0.000001,my $triggers = ${$_[2]};
0.000002,1,0.000002,my @type_coercions = @{$_[3]};
0.000002,1,0.000002,my @type_constraint_bodies = @{$_[4]};
0.000002,1,0.000002,my @type_constraint_messages = @{$_[5]};
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,$class = Scalar::Util::blessed($class) || $class;
0.000000,0,0.000000,return $class->Moose::Object::new(@_)
0.000000,0,0.000000,if $class ne 'Crypt::PBKDF2';
0.000000,0,0.000000,my $params = 
0.000000,0,0.000000,do {
0.000000,0,0.000000,my $params;
0.000000,0,0.000000,if (scalar @_ == 1) {
0.000000,0,0.000000,if (!defined($_[0]) || ref($_[0]) ne 'HASH') {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Single parameters to new() must be a HASH ref", depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$params = { %{ $_[0] } };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@_ % 2) {
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,"The new() method for $class expects a hash reference or a key/value list. You passed an odd number of arguments"
0.000000,0,0.000000,);
0.000000,0,0.000000,$params = {@_, undef};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$params = {@_};
0.000000,0,0.000000,}
0.000000,0,0.000000,$params;
0.000000,0,0.000000,}
0.000000,0,0.000000,;
0.000000,0,0.000000,my $instance = bless {} => $class;
0.000000,0,0.000000,## _lazy_hasher
0.000000,0,0.000000,## encoding
0.000000,0,0.000000,if (exists $params->{'encoding'}) {
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($params->{'encoding'}) } ) && !ref($params->{'encoding'}) } ) && (ref(\$params->{'encoding'}) eq "SCALAR" || ref(\(my $val = $params->{'encoding'})) eq "SCALAR") } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (encoding) does not pass the type constraint because: " . do { local $_ = $params->{'encoding'}; $type_constraint_messages[1]->($params->{'encoding'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"encoding"} = $params->{'encoding'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $default = $defaults->[1];
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($default) } ) && !ref($default) } ) && (ref(\$default) eq "SCALAR" || ref(\(my $val = $default)) eq "SCALAR") } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (encoding) does not pass the type constraint because: " . do { local $_ = $default; $type_constraint_messages[1]->($default)}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"encoding"} = $default;
0.000000,0,0.000000,}
0.000000,0,0.000000,## hash_args
0.000000,0,0.000000,if (exists $params->{'hash_args'}) {
0.000000,0,0.000000,if (! (( do { ref($params->{'hash_args'}) eq "HASH" } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (hash_args) does not pass the type constraint because: " . do { local $_ = $params->{'hash_args'}; $type_constraint_messages[2]->($params->{'hash_args'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"hash_args"} = $params->{'hash_args'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $default = $defaults->[2]->($instance);
0.000000,0,0.000000,if (! (( do { ref($default) eq "HASH" } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (hash_args) does not pass the type constraint because: " . do { local $_ = $default; $type_constraint_messages[2]->($default)}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"hash_args"} = $default;
0.000000,0,0.000000,}
0.000000,0,0.000000,## hash_class
0.000000,0,0.000000,if (exists $params->{'hash_class'}) {
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($params->{'hash_class'}) } ) && !ref($params->{'hash_class'}) } ) && (ref(\$params->{'hash_class'}) eq "SCALAR" || ref(\(my $val = $params->{'hash_class'})) eq "SCALAR") } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (hash_class) does not pass the type constraint because: " . do { local $_ = $params->{'hash_class'}; $type_constraint_messages[3]->($params->{'hash_class'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"hash_class"} = $params->{'hash_class'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $default = $defaults->[3];
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($default) } ) && !ref($default) } ) && (ref(\$default) eq "SCALAR" || ref(\(my $val = $default)) eq "SCALAR") } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (hash_class) does not pass the type constraint because: " . do { local $_ = $default; $type_constraint_messages[3]->($default)}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"hash_class"} = $default;
0.000000,0,0.000000,}
0.000000,0,0.000000,## hasher
0.000000,0,0.000000,if (exists $params->{'hasher'}) {
0.000000,0,0.000000,if (! (( do { Moose::Util::does_role($params->{'hasher'}, "Crypt::PBKDF2::Hash") } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (hasher) does not pass the type constraint because: " . do { local $_ = $params->{'hasher'}; $type_constraint_messages[4]->($params->{'hasher'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"hasher"} = $params->{'hasher'};
0.000000,0,0.000000,}
0.000000,0,0.000000,## iterations
0.000000,0,0.000000,if (exists $params->{'iterations'}) {
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($params->{'iterations'}) } ) && !ref($params->{'iterations'}) } ) && (my $val = $params->{'iterations'}) =~ /\A-?[0-9]+\z/ } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (iterations) does not pass the type constraint because: " . do { local $_ = $params->{'iterations'}; $type_constraint_messages[5]->($params->{'iterations'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"iterations"} = $params->{'iterations'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $default = $defaults->[5];
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($default) } ) && !ref($default) } ) && (my $val = $default) =~ /\A-?[0-9]+\z/ } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (iterations) does not pass the type constraint because: " . do { local $_ = $default; $type_constraint_messages[5]->($default)}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"iterations"} = $default;
0.000000,0,0.000000,}
0.000000,0,0.000000,## output_len
0.000000,0,0.000000,if (exists $params->{'output_len'}) {
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($params->{'output_len'}) } ) && !ref($params->{'output_len'}) } ) && (my $val = $params->{'output_len'}) =~ /\A-?[0-9]+\z/ } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (output_len) does not pass the type constraint because: " . do { local $_ = $params->{'output_len'}; $type_constraint_messages[6]->($params->{'output_len'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"output_len"} = $params->{'output_len'};
0.000000,0,0.000000,}
0.000000,0,0.000000,## salt_len
0.000000,0,0.000000,if (exists $params->{'salt_len'}) {
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($params->{'salt_len'}) } ) && !ref($params->{'salt_len'}) } ) && (my $val = $params->{'salt_len'}) =~ /\A-?[0-9]+\z/ } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (salt_len) does not pass the type constraint because: " . do { local $_ = $params->{'salt_len'}; $type_constraint_messages[7]->($params->{'salt_len'})}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"salt_len"} = $params->{'salt_len'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $default = $defaults->[7];
0.000000,0,0.000000,if (! (( do { ( do { ( do { defined($default) } ) && !ref($default) } ) && (my $val = $default) =~ /\A-?[0-9]+\z/ } ))) {
0.000000,0,0.000000,die Moose::Error::Util::create_error(message => "Attribute (salt_len) does not pass the type constraint because: " . do { local $_ = $default; $type_constraint_messages[7]->($default)}, depth   => -1, );
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->{"salt_len"} = $default;
0.000000,0,0.000000,}
0.000000,0,0.000000,$instance->Crypt::PBKDF2::BUILD($params);
0.000000,0,0.000000,return $instance
0.000000,0,0.000000,}
0.000018,2,0.000009,}
0.000000,0,0.000000,;
