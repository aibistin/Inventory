# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Class::MOP;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Class::MOP::AUTHORITY = 'cpan:STEVAN';
0.000035,1,0.000035,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Class::MOP::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000031,2,0.000016,use strict;
0.000031,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000183,2,0.000092,use 5.008;
0.000000,0,0.000000,
0.000109,2,0.000055,use MRO::Compat;
0.000000,0,0.000000,
0.000036,2,0.000018,use Carp          'confess';
0.000054,3,0.000018,use Class::Load 0.07 ();
0.000033,2,0.000017,use Scalar::Util  'weaken', 'isweak', 'reftype', 'blessed';
0.000032,2,0.000016,use Data::OptList;
0.000033,2,0.000017,use Try::Tiny;
0.000000,0,0.000000,
0.000110,2,0.000055,use Class::MOP::Mixin::AttributeCore;
0.000106,2,0.000053,use Class::MOP::Mixin::HasAttributes;
0.000114,2,0.000057,use Class::MOP::Mixin::HasMethods;
0.000122,2,0.000061,use Class::MOP::Class;
0.000118,2,0.000059,use Class::MOP::Attribute;
0.000082,2,0.000041,use Class::MOP::Method;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,*IS_RUNNING_ON_5_10 = ($] < 5.009_005)
0.000000,0,0.000000,? sub () { 0 }
0.000003,1,0.000003,: sub () { 1 };
0.000000,0,0.000000,
0.000000,0,0.000000,# this is either part of core or set up appropriately by MRO::Compat
0.000008,1,0.000008,*check_package_cache_flag = \&mro::get_pkg_gen;
0.002051,1,0.002051,}
0.000000,0,0.000000,
0.000000,0,0.000000,XSLoader::load(
0.000000,0,0.000000,'Moose',
0.000106,1,0.000106,$Class::MOP::{VERSION} ? ${ $Class::MOP::{VERSION} } : ()
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# Metaclasses are singletons, so we cache them here.
0.000000,0,0.000000,# there is no need to worry about destruction though
0.000000,0,0.000000,# because they should die only when the program dies.
0.000000,0,0.000000,# After all, do package definitions even get reaped?
0.000000,0,0.000000,# Anonymous classes manage their own destruction.
0.000005,2,0.000002,my %METAS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_metaclasses         {        %METAS         }
0.000000,0,0.000000,sub get_all_metaclass_instances { values %METAS         }
0.000000,0,0.000000,sub get_all_metaclass_names     { keys   %METAS         }
0.013989,1552,0.000009,sub get_metaclass_by_name       { $METAS{$_[0]}         }
0.000417,71,0.000006,sub store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
0.000000,0,0.000000,sub weaken_metaclass            { weaken($METAS{$_[0]}) }
0.000768,74,0.000010,sub metaclass_is_weak           { isweak($METAS{$_[0]}) }
0.000000,0,0.000000,sub does_metaclass_exist        { exists $METAS{$_[0]} && defined $METAS{$_[0]} }
0.000000,0,0.000000,sub remove_metaclass_by_name    { delete $METAS{$_[0]}; return }
0.000000,0,0.000000,
0.000000,0,0.000000,# This handles instances as well as class names
0.000000,0,0.000000,sub class_of {
0.000043,28,0.000002,return unless defined $_[0];
0.000207,28,0.000007,my $class = blessed($_[0]) || $_[0];
0.000166,28,0.000006,return $METAS{$class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# We only cache metaclasses, meaning instances of
0.000000,0,0.000000,# Class::MOP::Class. We do not cache instance of
0.000000,0,0.000000,# Class::MOP::Package or Class::MOP::Module. Mostly
0.000000,0,0.000000,# because I don't yet see a good reason to do so.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_class {
0.000000,0,0.000000,goto &Class::Load::load_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub load_first_existing_class {
0.000000,0,0.000000,goto &Class::Load::load_first_existing_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_class_loaded {
0.000000,0,0.000000,goto &Class::Load::is_class_loaded;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _definition_context {
0.000175,123,0.000001,my %context;
0.000668,123,0.000005,@context{qw(package file line)} = caller(1);
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000815,123,0.000007,definition_context => \%context,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## ----------------------------------------------------------------------------
0.000000,0,0.000000,## Setting up our environment ...
0.000000,0,0.000000,## ----------------------------------------------------------------------------
0.000000,0,0.000000,## Class::MOP needs to have a few things in the global perl environment so
0.000000,0,0.000000,## that it can operate effectively. Those things are done here.
0.000000,0,0.000000,## ----------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,# ... nothing yet actually ;)
0.000000,0,0.000000,
0.000000,0,0.000000,## ----------------------------------------------------------------------------
0.000000,0,0.000000,## Bootstrapping
0.000000,0,0.000000,## ----------------------------------------------------------------------------
0.000000,0,0.000000,## The code below here is to bootstrap our MOP with itself. This is also
0.000000,0,0.000000,## sometimes called "tying the knot". By doing this, we make it much easier
0.000000,0,0.000000,## to extend the MOP through subclassing and such since now you can use the
0.000000,0,0.000000,## MOP itself to extend itself.
0.000000,0,0.000000,##
0.000000,0,0.000000,## Yes, I know, that's weird and insane, but it's a good thing, trust me :)
0.000000,0,0.000000,## ----------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to add in the meta-attributes here so that
0.000000,0,0.000000,# any subclass of Class::MOP::* will be able to
0.000000,0,0.000000,# inherit them using _construct_instance
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Mixin::HasMethods
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Mixin::HasMethods->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('_methods' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'_method_map' => \&Class::MOP::Mixin::HasMethods::_method_map
0.000000,0,0.000000,},
0.000012,2,0.000006,default => sub { {} },
0.000031,1,0.000031,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000022,1,0.000022,Class::MOP::Mixin::HasMethods->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('method_metaclass' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'method_metaclass' => \&Class::MOP::Mixin::HasMethods::method_metaclass
0.000000,0,0.000000,},
0.000000,0,0.000000,default  => 'Class::MOP::Method',
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000022,1,0.000022,Class::MOP::Mixin::HasMethods->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('wrapped_method_metaclass' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'wrapped_method_metaclass' => \&Class::MOP::Mixin::HasMethods::wrapped_method_metaclass
0.000000,0,0.000000,},
0.000000,0,0.000000,default  => 'Class::MOP::Method::Wrapped',
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Mixin::HasMethods
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Mixin::HasAttributes->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('attributes' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE: we need to do this in order
0.000000,0,0.000000,# for the instance meta-object to
0.000000,0,0.000000,# not fall into meta-circular death
0.000000,0,0.000000,#
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'_attribute_map' => \&Class::MOP::Mixin::HasAttributes::_attribute_map
0.000000,0,0.000000,},
0.000013,2,0.000007,default  => sub { {} },
0.000025,1,0.000025,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000022,1,0.000022,Class::MOP::Mixin::HasAttributes->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('attribute_metaclass' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'attribute_metaclass' => \&Class::MOP::Mixin::HasAttributes::attribute_metaclass
0.000000,0,0.000000,},
0.000000,0,0.000000,default  => 'Class::MOP::Attribute',
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Package
0.000000,0,0.000000,
0.000026,1,0.000026,Class::MOP::Package->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('package' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE: we need to do this in order
0.000000,0,0.000000,# for the instance meta-object to
0.000000,0,0.000000,# not fall into meta-circular death
0.000000,0,0.000000,#
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'name' => \&Class::MOP::Package::name
0.000000,0,0.000000,},
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Package->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('namespace' => (
0.000000,0,0.000000,reader => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'namespace' => \&Class::MOP::Package::namespace
0.000000,0,0.000000,},
0.000000,0,0.000000,init_arg => undef,
0.000013,2,0.000007,default  => sub { \undef },
0.000024,1,0.000024,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Module
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# yeah this is kind of stretching things a bit,
0.000000,0,0.000000,# but truthfully the version should be an attribute
0.000000,0,0.000000,# of the Module, the weirdness comes from having to
0.000000,0,0.000000,# stick to Perl 5 convention and store it in the
0.000000,0,0.000000,# $VERSION package variable. Basically if you just
0.000000,0,0.000000,# squint at it, it will look how you want it to look.
0.000000,0,0.000000,# Either as a package variable, or as a attribute of
0.000000,0,0.000000,# the metaclass, isn't abstraction great :)
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Module->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('version' => (
0.000000,0,0.000000,reader => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'version' => \&Class::MOP::Module::version
0.000000,0,0.000000,},
0.000000,0,0.000000,init_arg => undef,
0.000012,2,0.000006,default  => sub { \undef },
0.000028,1,0.000028,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# By following the same conventions as version here,
0.000000,0,0.000000,# we are opening up the possibility that people can
0.000000,0,0.000000,# use the $AUTHORITY in non-Class::MOP modules as
0.000000,0,0.000000,# well.
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Module->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('authority' => (
0.000000,0,0.000000,reader => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'authority' => \&Class::MOP::Module::authority
0.000000,0,0.000000,},
0.000000,0,0.000000,init_arg => undef,
0.000012,2,0.000006,default  => sub { \undef },
0.000024,1,0.000024,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Class
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Class->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('superclasses' => (
0.000000,0,0.000000,accessor => {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'superclasses' => \&Class::MOP::Class::superclasses
0.000000,0,0.000000,},
0.000000,0,0.000000,init_arg => undef,
0.000012,2,0.000006,default  => sub { \undef },
0.000028,1,0.000028,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Class->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('instance_metaclass' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE: we need to do this in order
0.000000,0,0.000000,# for the instance meta-object to
0.000000,0,0.000000,# not fall into meta-circular death
0.000000,0,0.000000,#
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'instance_metaclass' => \&Class::MOP::Class::instance_metaclass
0.000000,0,0.000000,},
0.000000,0,0.000000,default  => 'Class::MOP::Instance',
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Class->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('immutable_trait' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'immutable_trait' => \&Class::MOP::Class::immutable_trait
0.000000,0,0.000000,},
0.000000,0,0.000000,default => "Class::MOP::Class::Immutable::Trait",
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Class->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('constructor_name' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'constructor_name' => \&Class::MOP::Class::constructor_name,
0.000000,0,0.000000,},
0.000000,0,0.000000,default => "new",
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Class->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('constructor_class' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'constructor_class' => \&Class::MOP::Class::constructor_class,
0.000000,0,0.000000,},
0.000000,0,0.000000,default => "Class::MOP::Method::Constructor",
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Class->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('destructor_class' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'destructor_class' => \&Class::MOP::Class::destructor_class,
0.000000,0,0.000000,},
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we don't actually need to tie the knot with
0.000000,0,0.000000,# Class::MOP::Class here, it is actually handled
0.000000,0,0.000000,# within Class::MOP::Class itself in the
0.000000,0,0.000000,# _construct_class_instance method.
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Mixin::AttributeCore
0.000022,1,0.000022,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('name' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE: we need to do this in order
0.000000,0,0.000000,# for the instance meta-object to
0.000000,0,0.000000,# not fall into meta-circular death
0.000000,0,0.000000,#
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'name' => \&Class::MOP::Mixin::AttributeCore::name
0.000000,0,0.000000,},
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('accessor' => (
0.000000,0,0.000000,reader    => { 'accessor'     => \&Class::MOP::Mixin::AttributeCore::accessor     },
0.000000,0,0.000000,predicate => { 'has_accessor' => \&Class::MOP::Mixin::AttributeCore::has_accessor },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('reader' => (
0.000000,0,0.000000,reader    => { 'reader'     => \&Class::MOP::Mixin::AttributeCore::reader     },
0.000000,0,0.000000,predicate => { 'has_reader' => \&Class::MOP::Mixin::AttributeCore::has_reader },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('initializer' => (
0.000000,0,0.000000,reader    => { 'initializer'     => \&Class::MOP::Mixin::AttributeCore::initializer     },
0.000000,0,0.000000,predicate => { 'has_initializer' => \&Class::MOP::Mixin::AttributeCore::has_initializer },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000022,1,0.000022,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('definition_context' => (
0.000000,0,0.000000,reader    => { 'definition_context'     => \&Class::MOP::Mixin::AttributeCore::definition_context     },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000021,1,0.000021,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('writer' => (
0.000000,0,0.000000,reader    => { 'writer'     => \&Class::MOP::Mixin::AttributeCore::writer     },
0.000000,0,0.000000,predicate => { 'has_writer' => \&Class::MOP::Mixin::AttributeCore::has_writer },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('predicate' => (
0.000000,0,0.000000,reader    => { 'predicate'     => \&Class::MOP::Mixin::AttributeCore::predicate     },
0.000000,0,0.000000,predicate => { 'has_predicate' => \&Class::MOP::Mixin::AttributeCore::has_predicate },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('clearer' => (
0.000000,0,0.000000,reader    => { 'clearer'     => \&Class::MOP::Mixin::AttributeCore::clearer     },
0.000000,0,0.000000,predicate => { 'has_clearer' => \&Class::MOP::Mixin::AttributeCore::has_clearer },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('builder' => (
0.000000,0,0.000000,reader    => { 'builder'     => \&Class::MOP::Mixin::AttributeCore::builder     },
0.000000,0,0.000000,predicate => { 'has_builder' => \&Class::MOP::Mixin::AttributeCore::has_builder },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('init_arg' => (
0.000000,0,0.000000,reader    => { 'init_arg'     => \&Class::MOP::Mixin::AttributeCore::init_arg     },
0.000000,0,0.000000,predicate => { 'has_init_arg' => \&Class::MOP::Mixin::AttributeCore::has_init_arg },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('default' => (
0.000000,0,0.000000,# default has a custom 'reader' method ...
0.000000,0,0.000000,predicate => { 'has_default' => \&Class::MOP::Mixin::AttributeCore::has_default },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000021,1,0.000021,Class::MOP::Mixin::AttributeCore->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('insertion_order' => (
0.000000,0,0.000000,reader      => { 'insertion_order' => \&Class::MOP::Mixin::AttributeCore::insertion_order },
0.000000,0,0.000000,writer      => { '_set_insertion_order' => \&Class::MOP::Mixin::AttributeCore::_set_insertion_order },
0.000000,0,0.000000,predicate   => { 'has_insertion_order' => \&Class::MOP::Mixin::AttributeCore::has_insertion_order },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Attribute
0.000023,1,0.000023,Class::MOP::Attribute->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('associated_class' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,# NOTE: we need to do this in order
0.000000,0,0.000000,# for the instance meta-object to
0.000000,0,0.000000,# not fall into meta-circular death
0.000000,0,0.000000,#
0.000000,0,0.000000,# we just alias the original method
0.000000,0,0.000000,# rather than re-produce it here
0.000000,0,0.000000,'associated_class' => \&Class::MOP::Attribute::associated_class
0.000000,0,0.000000,},
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Attribute->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('associated_methods' => (
0.000000,0,0.000000,reader   => { 'associated_methods' => \&Class::MOP::Attribute::associated_methods },
0.000060,9,0.000007,default  => sub { [] },
0.000021,1,0.000021,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Attribute->meta->add_method('clone' => sub {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,$self->meta->clone_object($self, @_);
0.000012,1,0.000012,});
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Method
0.000024,1,0.000024,Class::MOP::Method->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('body' => (
0.000000,0,0.000000,reader   => { 'body' => \&Class::MOP::Method::body },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Method->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('associated_metaclass' => (
0.000000,0,0.000000,reader   => { 'associated_metaclass' => \&Class::MOP::Method::associated_metaclass },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Method->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('package_name' => (
0.000000,0,0.000000,reader   => { 'package_name' => \&Class::MOP::Method::package_name },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Method->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('name' => (
0.000000,0,0.000000,reader   => { 'name' => \&Class::MOP::Method::name },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Method->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('original_method' => (
0.000000,0,0.000000,reader   => { 'original_method'      => \&Class::MOP::Method::original_method },
0.000000,0,0.000000,writer   => { '_set_original_method' => \&Class::MOP::Method::_set_original_method },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Method::Wrapped
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# the way this item is initialized, this
0.000000,0,0.000000,# really does not follow the standard
0.000000,0,0.000000,# practices of attributes, but we put
0.000000,0,0.000000,# it here for completeness
0.000022,1,0.000022,Class::MOP::Method::Wrapped->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('modifier_table' => (
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Method::Generated
0.000000,0,0.000000,
0.000023,1,0.000023,Class::MOP::Method::Generated->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('is_inline' => (
0.000000,0,0.000000,reader   => { 'is_inline' => \&Class::MOP::Method::Generated::is_inline },
0.000000,0,0.000000,default  => 0,
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Method::Generated->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('definition_context' => (
0.000000,0,0.000000,reader   => { 'definition_context' => \&Class::MOP::Method::Generated::definition_context },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Method::Inlined
0.000000,0,0.000000,
0.000025,1,0.000025,Class::MOP::Method::Inlined->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('_expected_method_class' => (
0.000000,0,0.000000,reader   => { '_expected_method_class' => \&Class::MOP::Method::Inlined::_expected_method_class },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Method::Accessor
0.000000,0,0.000000,
0.000023,1,0.000023,Class::MOP::Method::Accessor->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('attribute' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'associated_attribute' => \&Class::MOP::Method::Accessor::associated_attribute
0.000000,0,0.000000,},
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Method::Accessor->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('accessor_type' => (
0.000000,0,0.000000,reader   => { 'accessor_type' => \&Class::MOP::Method::Accessor::accessor_type },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Method::Constructor
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Method::Constructor->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('options' => (
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'options' => \&Class::MOP::Method::Constructor::options
0.000000,0,0.000000,},
0.000000,0,0.000000,default  => sub { +{} },
0.000026,1,0.000026,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Method::Constructor->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('associated_metaclass' => (
0.000000,0,0.000000,init_arg => "metaclass", # FIXME alias and rename
0.000000,0,0.000000,reader   => {
0.000000,0,0.000000,'associated_metaclass' => \&Class::MOP::Method::Constructor::associated_metaclass
0.000000,0,0.000000,},
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Instance
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# these don't yet do much of anything, but are just
0.000000,0,0.000000,# included for completeness
0.000000,0,0.000000,
0.000023,1,0.000023,Class::MOP::Instance->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('associated_metaclass',
0.000000,0,0.000000,reader   => { associated_metaclass => \&Class::MOP::Instance::associated_metaclass },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Instance->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('_class_name',
0.000000,0,0.000000,init_arg => undef,
0.000000,0,0.000000,reader   => { _class_name => \&Class::MOP::Instance::_class_name },
0.000000,0,0.000000,#lazy     => 1, # not yet supported by Class::MOP but out our version does it anyway
0.000000,0,0.000000,#default  => sub { $_[0]->associated_metaclass->name },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000019,1,0.000019,Class::MOP::Instance->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('attributes',
0.000000,0,0.000000,reader   => { attributes => \&Class::MOP::Instance::get_all_attributes },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Instance->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('slots',
0.000000,0,0.000000,reader   => { slots => \&Class::MOP::Instance::slots },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,Class::MOP::Instance->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('slot_hash',
0.000000,0,0.000000,reader   => { slot_hash => \&Class::MOP::Instance::slot_hash },
0.000000,0,0.000000,_definition_context(),
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Object
0.000000,0,0.000000,
0.000000,0,0.000000,# need to replace the meta method there with a real meta method object
0.000019,1,0.000019,Class::MOP::Object->meta->_add_meta_method('meta');
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Class::MOP::Mixin
0.000000,0,0.000000,
0.000000,0,0.000000,# need to replace the meta method there with a real meta method object
0.000016,1,0.000016,Class::MOP::Mixin->meta->_add_meta_method('meta');
0.000000,0,0.000000,
0.000129,1,0.000129,require Class::MOP::Deprecated unless our $no_deprecated;
0.000000,0,0.000000,
0.000000,0,0.000000,# we need the meta instance of the meta instance to be created now, in order
0.000000,0,0.000000,# for the constructor to be able to use it
0.000011,1,0.000011,Class::MOP::Instance->meta->get_meta_instance;
0.000000,0,0.000000,
0.000000,0,0.000000,# pretend the add_method never happened. it hasn't yet affected anything
0.000006,1,0.000006,undef Class::MOP::Instance->meta->{_package_cache_flag};
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## Now close all the Class::MOP::* classes
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: we don't need to inline the accessors this only lengthens the compile
0.000000,0,0.000000,# time of the MOP, and gives us no actual benefits.
0.000000,0,0.000000,
0.000000,0,0.000000,$_->meta->make_immutable(
0.000000,0,0.000000,inline_constructor  => 0,
0.000000,0,0.000000,constructor_name    => "_new",
0.000000,0,0.000000,inline_accessors => 0,
0.000177,1,0.000177,) for qw/
0.000000,0,0.000000,Class::MOP::Package
0.000000,0,0.000000,Class::MOP::Module
0.000000,0,0.000000,Class::MOP::Class
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Attribute
0.000000,0,0.000000,Class::MOP::Method
0.000000,0,0.000000,Class::MOP::Instance
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Object
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Method::Generated
0.000000,0,0.000000,Class::MOP::Method::Inlined
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Method::Accessor
0.000000,0,0.000000,Class::MOP::Method::Constructor
0.000000,0,0.000000,Class::MOP::Method::Wrapped
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::Method::Meta
0.000000,0,0.000000,Class::MOP::Method::Overload
0.000000,0,0.000000,/;
0.000000,0,0.000000,
0.000000,0,0.000000,$_->meta->make_immutable(
0.000000,0,0.000000,inline_constructor  => 0,
0.000000,0,0.000000,constructor_name    => undef,
0.000000,0,0.000000,inline_accessors => 0,
0.000052,1,0.000052,) for qw/
0.000000,0,0.000000,Class::MOP::Mixin
0.000000,0,0.000000,Class::MOP::Mixin::AttributeCore
0.000000,0,0.000000,Class::MOP::Mixin::HasAttributes
0.000000,0,0.000000,Class::MOP::Mixin::HasMethods
0.000000,0,0.000000,/;
0.000000,0,0.000000,
0.000138,1,0.000138,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: A Meta Object Protocol for Perl 5
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
