# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Log::Log4perl::Config::PropertyConfigurator;
0.000110,2,0.000055,use Log::Log4perl::Config::BaseConfigurator;
0.000000,0,0.000000,
0.000044,2,0.000022,use warnings;
0.000106,2,0.000053,use strict;
0.000000,0,0.000000,
0.000008,1,0.000008,our @ISA = qw(Log::Log4perl::Config::BaseConfigurator);
0.000000,0,0.000000,
0.000005,1,0.000005,our %NOT_A_MULT_VALUE = map { $_ => 1 }
0.000000,0,0.000000,qw(conversionpattern);
0.000000,0,0.000000,
0.000000,0,0.000000,#poor man's export
0.000002,1,0.000002,*eval_if_perl = \&Log::Log4perl::Config::eval_if_perl;
0.000002,1,0.000002,*compile_if_perl = \&Log::Log4perl::Config::compile_if_perl;
0.000003,1,0.000003,*unlog4j      = \&Log::Log4perl::Config::unlog4j;
0.000000,0,0.000000,
0.000596,2,0.000298,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000021,1,0.000021,our $COMMENT_REGEX = qr/[#;!]/;
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,sub parse {
0.000000,0,0.000000,################################################
0.000000,0,0.000000,my($self, $newtext) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->text($newtext) if defined $newtext;
0.000000,0,0.000000,
0.000000,0,0.000000,my $text = $self->{text};
0.000000,0,0.000000,
0.000000,0,0.000000,die "Config parser has nothing to parse" unless defined $text;
0.000000,0,0.000000,
0.000000,0,0.000000,my $data = {};
0.000000,0,0.000000,my %var_subst = ();
0.000000,0,0.000000,
0.000000,0,0.000000,while (@$text) {
0.000000,0,0.000000,local $_ = shift @$text;
0.000000,0,0.000000,s/^\s*$COMMENT_REGEX.*//;
0.000000,0,0.000000,next unless /\S/;
0.000000,0,0.000000,
0.000000,0,0.000000,my @parts = ();
0.000000,0,0.000000,
0.000000,0,0.000000,while (/(.+?)\\\s*$/) {
0.000000,0,0.000000,my $prev = $1;
0.000000,0,0.000000,my $next = shift(@$text);
0.000000,0,0.000000,$next =~ s/^ +//g;  #leading spaces
0.000000,0,0.000000,$next =~ s/^$COMMENT_REGEX.*//;
0.000000,0,0.000000,$_ = $prev. $next;
0.000000,0,0.000000,chomp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(my($key, $val) = /(\S+?)\s*=\s*(.*)/) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $key_org = $key;
0.000000,0,0.000000,
0.000000,0,0.000000,$val =~ s/\s+$//;
0.000000,0,0.000000,
0.000000,0,0.000000,# Everything could potentially be a variable assignment
0.000000,0,0.000000,$var_subst{$key} = $val;
0.000000,0,0.000000,
0.000000,0,0.000000,# Substitute any variables
0.000000,0,0.000000,$val =~ s/\$\{(.*?)\}/
0.000000,0,0.000000,Log::Log4perl::Config::var_subst($1, \%var_subst)/gex;
0.000000,0,0.000000,
0.000000,0,0.000000,$key = unlog4j($key);
0.000000,0,0.000000,
0.000000,0,0.000000,my $how_deep = 0;
0.000000,0,0.000000,my $ptr = $data;
0.000000,0,0.000000,for my $part (split /\.|::/, $key) {
0.000000,0,0.000000,push @parts, $part;
0.000000,0,0.000000,$ptr->{$part} = {} unless exists $ptr->{$part};
0.000000,0,0.000000,$ptr = $ptr->{$part};
0.000000,0,0.000000,++$how_deep;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#here's where we deal with turning multiple values like this:
0.000000,0,0.000000,# log4j.appender.jabbender.to = him@a.jabber.server
0.000000,0,0.000000,# log4j.appender.jabbender.to = her@a.jabber.server
0.000000,0,0.000000,#into an arrayref like this:
0.000000,0,0.000000,#to => { value => 
0.000000,0,0.000000,#       ["him\@a.jabber.server", "her\@a.jabber.server"] },
0.000000,0,0.000000,# 
0.000000,0,0.000000,# This only is allowed for properties of appenders
0.000000,0,0.000000,# not listed in %NOT_A_MULT_VALUE (see top of file).
0.000000,0,0.000000,if (exists $ptr->{value} && 
0.000000,0,0.000000,$how_deep > 2 &&
0.000000,0,0.000000,defined $parts[0] && lc($parts[0]) eq "appender" && 
0.000000,0,0.000000,defined $parts[2] && ! exists $NOT_A_MULT_VALUE{lc($parts[2])}
0.000000,0,0.000000,) {
0.000000,0,0.000000,if (ref ($ptr->{value}) ne 'ARRAY') {
0.000000,0,0.000000,my $temp = $ptr->{value};
0.000000,0,0.000000,$ptr->{value} = [];
0.000000,0,0.000000,push (@{$ptr->{value}}, $temp);
0.000000,0,0.000000,}
0.000000,0,0.000000,push (@{$ptr->{value}}, $val);
0.000000,0,0.000000,}else{
0.000000,0,0.000000,if(defined $ptr->{value}) {
0.000000,0,0.000000,if(! $Log::Log4perl::Logger::NO_STRICT) {
0.000000,0,0.000000,die "$key_org redefined";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$ptr->{value} = $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{data} = $data;
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,sub value {
0.000000,0,0.000000,################################################
0.000000,0,0.000000,my($self, $path) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$path = unlog4j($path);
0.000000,0,0.000000,
0.000000,0,0.000000,my @p = split /::/, $path;
0.000000,0,0.000000,
0.000000,0,0.000000,my $found = 0;
0.000000,0,0.000000,my $r = $self->{data};
0.000000,0,0.000000,
0.000000,0,0.000000,while (my $n = shift @p) {
0.000000,0,0.000000,if (exists $r->{$n}) {
0.000000,0,0.000000,$r = $r->{$n};
0.000000,0,0.000000,$found = 1;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$found = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($found and exists $r->{value}) {
0.000000,0,0.000000,return $r->{value};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
