# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package re;
0.000000,0,0.000000,
0.000000,0,0.000000,# pragma for controlling the regexp engine
0.000032,2,0.000016,use strict;
0.001009,2,0.000504,use warnings;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION     = "0.23";
0.000008,1,0.000008,our @ISA         = qw(Exporter);
0.000003,1,0.000003,our @EXPORT_OK   = ('regmust',
0.000000,0,0.000000,qw(is_regexp regexp_pattern
0.000000,0,0.000000,regname regnames regnames_count));
0.000008,1,0.000008,our %EXPORT_OK = map { $_ => 1 } @EXPORT_OK;
0.000000,0,0.000000,
0.000002,1,0.000002,my %bitmask = (
0.000000,0,0.000000,taint   => 0x00100000, # HINT_RE_TAINT
0.000000,0,0.000000,eval    => 0x00200000, # HINT_RE_EVAL
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,my $flags_hint = 0x02000000; # HINT_RE_FLAGS
0.000001,1,0.000001,my $PMMOD_SHIFT = 0;
0.000006,1,0.000006,my %reflags = (
0.000000,0,0.000000,m => 1 << ($PMMOD_SHIFT + 0),
0.000000,0,0.000000,s => 1 << ($PMMOD_SHIFT + 1),
0.000000,0,0.000000,i => 1 << ($PMMOD_SHIFT + 2),
0.000000,0,0.000000,x => 1 << ($PMMOD_SHIFT + 3),
0.000000,0,0.000000,p => 1 << ($PMMOD_SHIFT + 4),
0.000000,0,0.000000,# special cases:
0.000000,0,0.000000,d => 0,
0.000000,0,0.000000,l => 1,
0.000000,0,0.000000,u => 2,
0.000000,0,0.000000,a => 3,
0.000000,0,0.000000,aa => 4,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub setcolor {
0.000000,0,0.000000,eval {				# Ignore errors
0.000000,0,0.000000,require Term::Cap;
0.000000,0,0.000000,
0.000000,0,0.000000,my $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
0.000000,0,0.000000,my $props = $ENV{PERL_RE_TC} || 'md,me,so,se,us,ue';
0.000000,0,0.000000,my @props = split /,/, $props;
0.000000,0,0.000000,my $colors = join "\t", map {$terminal->Tputs($_,1)} @props;
0.000000,0,0.000000,
0.000000,0,0.000000,$colors =~ s/\0//g;
0.000000,0,0.000000,$ENV{PERL_RE_COLORS} = $colors;
0.000000,0,0.000000,};
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,$ENV{PERL_RE_COLORS} ||= qq'\t\t> <\t> <\t\t';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,my %flags = (
0.000000,0,0.000000,COMPILE         => 0x0000FF,
0.000000,0,0.000000,PARSE           => 0x000001,
0.000000,0,0.000000,OPTIMISE        => 0x000002,
0.000000,0,0.000000,TRIEC           => 0x000004,
0.000000,0,0.000000,DUMP            => 0x000008,
0.000000,0,0.000000,FLAGS           => 0x000010,
0.000000,0,0.000000,
0.000000,0,0.000000,EXECUTE         => 0x00FF00,
0.000000,0,0.000000,INTUIT          => 0x000100,
0.000000,0,0.000000,MATCH           => 0x000200,
0.000000,0,0.000000,TRIEE           => 0x000400,
0.000000,0,0.000000,
0.000000,0,0.000000,EXTRA           => 0xFF0000,
0.000000,0,0.000000,TRIEM           => 0x010000,
0.000000,0,0.000000,OFFSETS         => 0x020000,
0.000000,0,0.000000,OFFSETSDBG      => 0x040000,
0.000000,0,0.000000,STATE           => 0x080000,
0.000000,0,0.000000,OPTIMISEM       => 0x100000,
0.000000,0,0.000000,STACK           => 0x280000,
0.000000,0,0.000000,BUFFERS         => 0x400000,
0.000000,0,0.000000,GPOS            => 0x800000,
0.000000,0,0.000000,);
0.000002,1,0.000002,$flags{ALL} = -1 & ~($flags{OFFSETS}|$flags{OFFSETSDBG}|$flags{BUFFERS});
0.000002,1,0.000002,$flags{All} = $flags{all} = $flags{DUMP} | $flags{EXECUTE};
0.000002,1,0.000002,$flags{Extra} = $flags{EXECUTE} | $flags{COMPILE} | $flags{GPOS};
0.000002,1,0.000002,$flags{More} = $flags{MORE} = $flags{All} | $flags{TRIEC} | $flags{TRIEM} | $flags{STATE};
0.000002,1,0.000002,$flags{State} = $flags{DUMP} | $flags{EXECUTE} | $flags{STATE};
0.000002,1,0.000002,$flags{TRIE} = $flags{DUMP} | $flags{EXECUTE} | $flags{TRIEC};
0.000000,0,0.000000,
0.000005,1,0.000005,if (defined &DynaLoader::boot_DynaLoader) {
0.000002,1,0.000002,require XSLoader;
0.000230,1,0.000230,XSLoader::load();
0.000000,0,0.000000,}
0.000000,0,0.000000,# else we're miniperl
0.000000,0,0.000000,# We need to work for miniperl, because the XS toolchain uses Text::Wrap, which
0.000000,0,0.000000,# uses re 'taint'.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_unload {
0.000000,0,0.000000,my ($on)= @_;
0.000000,0,0.000000,if ($on) {
0.000000,0,0.000000,# We call install() every time, as if we didn't, we wouldn't
0.000000,0,0.000000,# "see" any changes to the color environment var since
0.000000,0,0.000000,# the last time it was called.
0.000000,0,0.000000,
0.000000,0,0.000000,# install() returns an integer, which if casted properly
0.000000,0,0.000000,# in C resolves to a structure containing the regexp
0.000000,0,0.000000,# hooks. Setting it to a random integer will guarantee
0.000000,0,0.000000,# segfaults.
0.000000,0,0.000000,$^H{regcomp} = install();
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $^H{regcomp};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bits {
0.000006,4,0.000002,my $on = shift;
0.000006,4,0.000001,my $bits = 0;
0.000000,0,0.000000,ARG:
0.000017,4,0.000004,foreach my $idx (0..$#_){
0.000007,4,0.000002,my $s=$_[$idx];
0.000058,4,0.000014,if ($s eq 'Debug' or $s eq 'Debugcolor') {
0.000000,0,0.000000,setcolor() if $s =~/color/i;
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} = 0 unless defined ${^RE_DEBUG_FLAGS};
0.000000,0,0.000000,for my $idx ($idx+1..$#_) {
0.000000,0,0.000000,if ($flags{$_[$idx]}) {
0.000000,0,0.000000,if ($on) {
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} |= $flags{$_[$idx]};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,${^RE_DEBUG_FLAGS} &= ~ $flags{$_[$idx]};
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp("Unknown \"re\" Debug flag '$_[$idx]', possible flags: ",
0.000000,0,0.000000,join(", ",sort keys %flags ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,_load_unload($on ? 1 : ${^RE_DEBUG_FLAGS});
0.000000,0,0.000000,last;
0.000000,0,0.000000,} elsif ($s eq 'debug' or $s eq 'debugcolor') {
0.000000,0,0.000000,setcolor() if $s =~/color/i;
0.000000,0,0.000000,_load_unload($on);
0.000000,0,0.000000,last;
0.000000,0,0.000000,} elsif (exists $bitmask{$s}) {
0.000000,0,0.000000,$bits |= $bitmask{$s};
0.000000,0,0.000000,} elsif ($EXPORT_OK{$s}) {
0.000000,0,0.000000,require Exporter;
0.000000,0,0.000000,re->export_to_level(2, 're', $s);
0.000000,0,0.000000,} elsif ($s =~ s/^\///) {
0.000006,3,0.000002,my $reflags = $^H{reflags} || 0;
0.000004,3,0.000001,my $seen_charset;
0.000030,3,0.000010,while ($s =~ m/( . )/gx) {
0.000009,3,0.000003,local $_ = $1;
0.000044,3,0.000015,if (/[adul]/) {
0.000000,0,0.000000,# The 'a' may be repeated; hide this from the rest of the
0.000000,0,0.000000,# code by counting and getting rid of all of them, then
0.000000,0,0.000000,# changing to 'aa' if there is a repeat.
0.000009,3,0.000003,if ($_ eq 'a') {
0.000005,3,0.000002,my $sav_pos = pos $s;
0.000025,3,0.000008,my $a_count = $s =~ s/a//g;
0.000009,3,0.000003,pos $s = $sav_pos - 1;  # -1 because got rid of the 'a'
0.000010,3,0.000003,if ($a_count > 2) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "a" flag may only appear a maximum of twice'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($a_count == 2) {
0.000005,3,0.000002,$_ = 'aa';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000009,3,0.000003,if ($on) {
0.000004,3,0.000001,if ($seen_charset) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,if ($seen_charset ne $_) {
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "$seen_charset" and "$_" flags '
0.000000,0,0.000000,.qq 'are exclusive'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq 'The "$seen_charset" flag may not appear '
0.000000,0,0.000000,.qq 'twice'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000011,3,0.000004,$^H{reflags_charset} = $reflags{$_};
0.000005,3,0.000002,$seen_charset = $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,delete $^H{reflags_charset}
0.000000,0,0.000000,if  defined $^H{reflags_charset}
0.000000,0,0.000000,&& $^H{reflags_charset} == $reflags{$_};
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif (exists $reflags{$_}) {
0.000000,0,0.000000,$on
0.000000,0,0.000000,? $reflags |= $reflags{$_}
0.000000,0,0.000000,: ($reflags &= ~$reflags{$_});
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,qq'Unknown regular expression flag "$_"'
0.000000,0,0.000000,);
0.000000,0,0.000000,next ARG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000012,3,0.000004,($^H{reflags} = $reflags or defined $^H{reflags_charset})
0.000000,0,0.000000,? $^H |= $flags_hint
0.000000,0,0.000000,: ($^H &= ~$flags_hint);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::carp("Unknown \"re\" subpragma '$s' (known ones are: ",
0.000000,0,0.000000,join(', ', map {qq('$_')} 'debug', 'debugcolor', sort keys %bitmask),
0.000000,0,0.000000,")");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000023,4,0.000006,$bits;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000006,4,0.000002,shift;
0.000041,4,0.000010,$^H |= bits(1, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,$^H &= ~ bits(0, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,1,0.000017,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
