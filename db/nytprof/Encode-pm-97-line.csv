# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#
0.000000,0,0.000000,# $Id: Encode.pm,v 2.49 2013/03/05 03:13:47 dankogai Exp dankogai $
0.000000,0,0.000000,#
0.000000,0,0.000000,package Encode;
0.000032,2,0.000016,use strict;
0.000072,2,0.000036,use warnings;
0.000018,1,0.000018,our $VERSION = sprintf "%d.%02d", q$Revision: 2.49 $ =~ /(\d+)/g;
0.000042,2,0.000021,use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
0.000044,2,0.000022,use XSLoader ();
0.000248,1,0.000248,XSLoader::load( __PACKAGE__, $VERSION );
0.000000,0,0.000000,
0.000002,1,0.000002,require Exporter;
0.000295,2,0.000148,use base qw/Exporter/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Public, encouraged API is exported by default
0.000000,0,0.000000,
0.000003,1,0.000003,our @EXPORT = qw(
0.000000,0,0.000000,decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
0.000000,0,0.000000,encodings  find_encoding clone_encoding
0.000000,0,0.000000,);
0.000003,1,0.000003,our @FB_FLAGS = qw(
0.000000,0,0.000000,DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
0.000000,0,0.000000,PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
0.000000,0,0.000000,);
0.000003,1,0.000003,our @FB_CONSTS = qw(
0.000000,0,0.000000,FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
0.000000,0,0.000000,FB_PERLQQ FB_HTMLCREF FB_XMLCREF
0.000000,0,0.000000,);
0.000005,1,0.000005,our @EXPORT_OK = (
0.000000,0,0.000000,qw(
0.000000,0,0.000000,_utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
0.000000,0,0.000000,is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
0.000000,0,0.000000,),
0.000000,0,0.000000,@FB_FLAGS, @FB_CONSTS,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000013,1,0.000013,our %EXPORT_TAGS = (
0.000000,0,0.000000,all          => [ @EXPORT,    @EXPORT_OK ],
0.000000,0,0.000000,default      => [ @EXPORT ],
0.000000,0,0.000000,fallbacks    => [ @FB_CONSTS ],
0.000000,0,0.000000,fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Documentation moved after __END__ for speed - NI-S
0.000000,0,0.000000,
0.000002,1,0.000002,our $ON_EBCDIC = ( ord("A") == 193 );
0.000000,0,0.000000,
0.001309,2,0.000654,use Encode::Alias;
0.000000,0,0.000000,
0.000000,0,0.000000,# Make a %Encoding package variable to allow a certain amount of cheating
0.000001,1,0.000001,our %Encoding;
0.000001,1,0.000001,our %ExtModule;
0.000179,1,0.000179,require Encode::Config;
0.000000,0,0.000000,#  See
0.000000,0,0.000000,#  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
0.000000,0,0.000000,#  to find why sig handers inside eval{} are disabled.
0.000002,1,0.000002,eval {
0.000003,1,0.000003,local $SIG{__DIE__};
0.000002,1,0.000002,local $SIG{__WARN__};
0.000111,1,0.000111,require Encode::ConfigLocal;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub encodings {
0.000000,0,0.000000,my %enc;
0.000000,0,0.000000,my $arg  = $_[1] || '';
0.000000,0,0.000000,if ( $arg eq ":all" ) {
0.000000,0,0.000000,%enc = ( %Encoding, %ExtModule );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,%enc = %Encoding;
0.000000,0,0.000000,for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
0.000000,0,0.000000,DEBUG and warn $mod;
0.000000,0,0.000000,for my $enc ( keys %ExtModule ) {
0.000000,0,0.000000,$ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return sort { lc $a cmp lc $b }
0.000000,0,0.000000,grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub perlio_ok {
0.000000,0,0.000000,my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
0.000000,0,0.000000,$obj->can("perlio_ok") and return $obj->perlio_ok();
0.000000,0,0.000000,return 0;    # safety net
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub define_encoding {
0.000006,4,0.000002,my $obj  = shift;
0.000006,4,0.000002,my $name = shift;
0.000008,4,0.000002,$Encoding{$name} = $obj;
0.000007,4,0.000002,my $lc = lc($name);
0.000006,4,0.000002,define_alias( $lc => $obj ) unless $lc eq $name;
0.000012,4,0.000003,while (@_) {
0.000000,0,0.000000,my $alias = shift;
0.000000,0,0.000000,define_alias( $alias, $obj );
0.000000,0,0.000000,}
0.000023,4,0.000006,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub getEncoding {
0.000010,6,0.000002,my ( $class, $name, $skip_external ) = @_;
0.000000,0,0.000000,
0.000043,6,0.000007,$name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796
0.000000,0,0.000000,
0.000008,6,0.000001,ref($name) && $name->can('renew') and return $name;
0.000017,6,0.000003,exists $Encoding{$name} and return $Encoding{$name};
0.000009,5,0.000002,my $lc = lc $name;
0.000011,5,0.000002,exists $Encoding{$lc} and return $Encoding{$lc};
0.000000,0,0.000000,
0.000028,5,0.000006,my $oc = $class->find_alias($name);
0.000024,5,0.000005,defined($oc) and return $oc;
0.000000,0,0.000000,$lc ne $name and $oc = $class->find_alias($lc);
0.000000,0,0.000000,defined($oc) and return $oc;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($skip_external) {
0.000000,0,0.000000,if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
0.000000,0,0.000000,$mod =~ s,::,/,g;
0.000000,0,0.000000,$mod .= '.pm';
0.000000,0,0.000000,eval { require $mod; };
0.000000,0,0.000000,exists $Encoding{$name} and return $Encoding{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_encoding($;$) {
0.000010,6,0.000002,my ( $name, $skip_external ) = @_;
0.000057,6,0.000010,return __PACKAGE__->getEncoding( $name, $skip_external );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub resolve_alias($) {
0.000000,0,0.000000,my $obj = find_encoding(shift);
0.000000,0,0.000000,defined $obj and return $obj->name;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone_encoding($) {
0.000000,0,0.000000,my $obj = find_encoding(shift);
0.000000,0,0.000000,ref $obj or return;
0.000000,0,0.000000,eval { require Storable };
0.000000,0,0.000000,$@ and return;
0.000000,0,0.000000,return Storable::dclone($obj);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub encode($$;$) {
0.000000,0,0.000000,my ( $name, $string, $check ) = @_;
0.000000,0,0.000000,return undef unless defined $string;
0.000000,0,0.000000,$string .= '';    # stringify;
0.000000,0,0.000000,$check ||= 0;
0.000000,0,0.000000,unless ( defined $name ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Encoding name should not be undef");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $enc = find_encoding($name);
0.000000,0,0.000000,unless ( defined $enc ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Unknown encoding '$name'");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $octets = $enc->encode( $string, $check );
0.000000,0,0.000000,$_[1] = $string if $check and !ref $check and !( $check & LEAVE_SRC() );
0.000000,0,0.000000,return $octets;
0.000000,0,0.000000,}
0.000003,1,0.000003,*str2bytes = \&encode;
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode($$;$) {
0.000004,2,0.000002,my ( $name, $octets, $check ) = @_;
0.000003,2,0.000002,return undef unless defined $octets;
0.000003,2,0.000002,$octets .= '';
0.000003,2,0.000002,$check ||= 0;
0.000010,2,0.000005,my $enc = find_encoding($name);
0.000003,2,0.000002,unless ( defined $enc ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Unknown encoding '$name'");
0.000000,0,0.000000,}
0.000039,2,0.000020,my $string = $enc->decode( $octets, $check );
0.000003,2,0.000002,$_[1] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
0.000015,2,0.000008,return $string;
0.000000,0,0.000000,}
0.000002,1,0.000002,*bytes2str = \&decode;
0.000000,0,0.000000,
0.000000,0,0.000000,sub from_to($$$;$) {
0.000000,0,0.000000,my ( $string, $from, $to, $check ) = @_;
0.000000,0,0.000000,return undef unless defined $string;
0.000000,0,0.000000,$check ||= 0;
0.000000,0,0.000000,my $f = find_encoding($from);
0.000000,0,0.000000,unless ( defined $f ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Unknown encoding '$from'");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $t = find_encoding($to);
0.000000,0,0.000000,unless ( defined $t ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Unknown encoding '$to'");
0.000000,0,0.000000,}
0.000000,0,0.000000,my $uni = $f->decode($string);
0.000000,0,0.000000,$_[0] = $string = $t->encode( $uni, $check );
0.000000,0,0.000000,return undef if ( $check && length($uni) );
0.000000,0,0.000000,return defined( $_[0] ) ? length($string) : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub encode_utf8($) {
0.000000,0,0.000000,my ($str) = @_;
0.000000,0,0.000000,utf8::encode($str);
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $utf8enc;
0.000000,0,0.000000,
0.000000,0,0.000000,sub decode_utf8($;$) {
0.000000,0,0.000000,my ( $octets, $check ) = @_;
0.000000,0,0.000000,return $octets if is_utf8($octets);
0.000000,0,0.000000,return undef unless defined $octets;
0.000000,0,0.000000,$octets .= '' if ref $octets;
0.000000,0,0.000000,$check   ||= 0;
0.000000,0,0.000000,$utf8enc ||= find_encoding('utf8');
0.000000,0,0.000000,my $string = $utf8enc->decode( $octets, $check );
0.000000,0,0.000000,$_[0] = $octets if $check and !ref $check and !( $check & LEAVE_SRC() );
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# sub decode_utf8($;$) {
0.000000,0,0.000000,#     my ( $str, $check ) = @_;
0.000000,0,0.000000,#     return $str if is_utf8($str);
0.000000,0,0.000000,#     if ($check) {
0.000000,0,0.000000,#         return decode( "utf8", $str, $check );
0.000000,0,0.000000,#     }
0.000000,0,0.000000,#     else {
0.000000,0,0.000000,#         return decode( "utf8", $str );
0.000000,0,0.000000,#         return $str;
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# }
0.000000,0,0.000000,
0.000005,1,0.000005,predefine_encodings(1);
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# This is to restore %Encoding if really needed;
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,sub predefine_encodings {
0.000131,1,0.000131,require Encode::Encoding;
0.000527,2,0.000263,no warnings 'redefine';
0.000002,1,0.000002,my $use_xs = shift;
0.000003,1,0.000003,if ($ON_EBCDIC) {
0.000000,0,0.000000,
0.000000,0,0.000000,# was in Encode::UTF_EBCDIC
0.000000,0,0.000000,package Encode::UTF_EBCDIC;
0.000000,0,0.000000,push @Encode::UTF_EBCDIC::ISA, 'Encode::Encoding';
0.000000,0,0.000000,*decode = sub {
0.000000,0,0.000000,my ( undef, $str, $chk ) = @_;
0.000000,0,0.000000,my $res = '';
0.000000,0,0.000000,for ( my $i = 0 ; $i < length($str) ; $i++ ) {
0.000000,0,0.000000,$res .=
0.000000,0,0.000000,chr(
0.000000,0,0.000000,utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $res;
0.000000,0,0.000000,};
0.000000,0,0.000000,*encode = sub {
0.000000,0,0.000000,my ( undef, $str, $chk ) = @_;
0.000000,0,0.000000,my $res = '';
0.000000,0,0.000000,for ( my $i = 0 ; $i < length($str) ; $i++ ) {
0.000000,0,0.000000,$res .=
0.000000,0,0.000000,chr(
0.000000,0,0.000000,utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $res;
0.000000,0,0.000000,};
0.000000,0,0.000000,$Encode::Encoding{Unicode} =
0.000000,0,0.000000,bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,package Encode::Internal;
0.000007,1,0.000007,push @Encode::Internal::ISA, 'Encode::Encoding';
0.000000,0,0.000000,*decode = sub {
0.000000,0,0.000000,my ( undef, $str, $chk ) = @_;
0.000000,0,0.000000,utf8::upgrade($str);
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $str;
0.000004,1,0.000004,};
0.000002,1,0.000002,*encode = \&decode;
0.000003,1,0.000003,$Encode::Encoding{Unicode} =
0.000000,0,0.000000,bless { Name => "Internal" } => "Encode::Internal";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,# was in Encode::utf8
0.000008,1,0.000008,package Encode::utf8;
0.000005,1,0.000005,push @Encode::utf8::ISA, 'Encode::Encoding';
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000003,1,0.000003,if ($use_xs) {
0.000000,0,0.000000,Encode::DEBUG and warn __PACKAGE__, " XS on";
0.000002,1,0.000002,*decode = \&decode_xs;
0.000002,1,0.000002,*encode = \&encode_xs;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Encode::DEBUG and warn __PACKAGE__, " XS off";
0.000000,0,0.000000,*decode = sub {
0.000000,0,0.000000,my ( undef, $octets, $chk ) = @_;
0.000000,0,0.000000,my $str = Encode::decode_utf8($octets);
0.000000,0,0.000000,if ( defined $str ) {
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,};
0.000000,0,0.000000,*encode = sub {
0.000000,0,0.000000,my ( undef, $string, $chk ) = @_;
0.000000,0,0.000000,my $octets = Encode::encode_utf8($string);
0.000000,0,0.000000,$_[1] = '' if $chk;
0.000000,0,0.000000,return $octets;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,*cat_decode = sub {    # ($obj, $dst, $src, $pos, $trm, $chk)
0.000000,0,0.000000,# currently ignores $chk
0.000000,0,0.000000,my ( undef, undef, undef, $pos, $trm ) = @_;
0.000000,0,0.000000,my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
0.000762,2,0.000381,use bytes;
0.000000,0,0.000000,if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
0.000000,0,0.000000,$$rdst .=
0.000000,0,0.000000,substr( $$rsrc, $pos, $npos - $pos + length($trm) );
0.000000,0,0.000000,$$rpos = $npos + length($trm);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$$rdst .= substr( $$rsrc, $pos );
0.000000,0,0.000000,$$rpos = length($$rsrc);
0.000000,0,0.000000,return '';
0.000003,1,0.000003,};
0.000003,1,0.000003,$Encode::Encoding{utf8} =
0.000000,0,0.000000,bless { Name => "utf8" } => "Encode::utf8";
0.000003,1,0.000003,$Encode::Encoding{"utf-8-strict"} =
0.000000,0,0.000000,bless { Name => "utf-8-strict", strict_utf8 => 1 } 
0.000000,0,0.000000,=> "Encode::utf8";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,1,0.000014,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
