# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Meta::TypeConstraint::Union;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::TypeConstraint::Union::AUTHORITY = 'cpan:STEVAN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Moose::Meta::TypeConstraint::Union::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000032,2,0.000016,use warnings;
0.000043,2,0.000021,use metaclass;
0.000000,0,0.000000,
0.000119,2,0.000059,use Moose::Meta::TypeCoercion::Union;
0.000000,0,0.000000,
0.000036,2,0.000018,use List::MoreUtils qw(all);
0.000037,2,0.000018,use List::Util qw(first);
0.000000,0,0.000000,
0.000916,2,0.000458,use base 'Moose::Meta::TypeConstraint';
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('type_constraints' => (
0.000000,0,0.000000,accessor  => 'type_constraints',
0.000000,0,0.000000,default   => sub { [] },
0.000016,1,0.000016,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ($class, %options) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $name = join '|' => sort { $a cmp $b }
0.000000,0,0.000000,map { $_->name } @{ $options{type_constraints} };
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = $class->SUPER::new(
0.000000,0,0.000000,name => $name,
0.000000,0,0.000000,%options,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_set_constraint( $self->_compiled_type_constraint );
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX - this is a rather gross implementation of laziness for the benefit of
0.000000,0,0.000000,# MX::Types. If we try to call ->has_coercion on the objects during object
0.000000,0,0.000000,# construction, this does not work when defining a recursive constraint with
0.000000,0,0.000000,# MX::Types.
0.000000,0,0.000000,sub coercion {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{coercion} if exists $self->{coercion};
0.000000,0,0.000000,
0.000000,0,0.000000,# Using any instead of grep here causes a weird error with some corner
0.000000,0,0.000000,# cases when MX::Types is in use. See RT #61001.
0.000000,0,0.000000,if ( grep { $_->has_coercion } @{ $self->type_constraints } ) {
0.000000,0,0.000000,return $self->{coercion} = Moose::Meta::TypeCoercion::Union->new(
0.000000,0,0.000000,type_constraint => $self );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self->{coercion} = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_coercion {
0.000000,0,0.000000,return defined $_[0]->coercion;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _actually_compile_type_constraint {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @constraints = @{ $self->type_constraints };
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,foreach my $type (@constraints) {
0.000000,0,0.000000,return 1 if $type->check($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# This was originally done with all() from List::MoreUtils, but that
0.000000,0,0.000000,# caused some sort of bizarro parsing failure under 5.10.
0.000000,0,0.000000,for my $tc ( @{ $self->type_constraints } ) {
0.000000,0,0.000000,return 0 unless $tc->can_be_inlined;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $val  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return '('
0.000000,0,0.000000,. (
0.000000,0,0.000000,join ' || ', map { '(' . $_->_inline_check($val) . ')' }
0.000000,0,0.000000,@{ $self->type_constraints }
0.000000,0,0.000000,)
0.000000,0,0.000000,. ')';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_environment {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return { map { %{ $_->inline_environment } }
0.000000,0,0.000000,@{ $self->type_constraints } };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub equals {
0.000000,0,0.000000,my ( $self, $type_or_name ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $other->isa(__PACKAGE__);
0.000000,0,0.000000,
0.000000,0,0.000000,my @self_constraints  = @{ $self->type_constraints };
0.000000,0,0.000000,my @other_constraints = @{ $other->type_constraints };
0.000000,0,0.000000,
0.000000,0,0.000000,return unless @self_constraints == @other_constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME presort type constraints for efficiency?
0.000000,0,0.000000,constraint: foreach my $constraint ( @self_constraints ) {
0.000000,0,0.000000,for ( my $i = 0; $i < @other_constraints; $i++ ) {
0.000000,0,0.000000,if ( $constraint->equals($other_constraints[$i]) ) {
0.000000,0,0.000000,splice @other_constraints, $i, 1;
0.000000,0,0.000000,next constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return @other_constraints == 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parent {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($first, @rest) = @{ $self->type_constraints };
0.000000,0,0.000000,
0.000000,0,0.000000,for my $parent ( $first->_collect_all_parents ) {
0.000000,0,0.000000,return $parent if all { $_->is_a_type_of($parent) } @rest;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,my $message;
0.000000,0,0.000000,foreach my $type (@{$self->type_constraints}) {
0.000000,0,0.000000,my $err = $type->validate($value);
0.000000,0,0.000000,return unless defined $err;
0.000000,0,0.000000,$message .= ($message ? ' and ' : '') . $err
0.000000,0,0.000000,if defined $err;
0.000000,0,0.000000,}
0.000000,0,0.000000,return ($message . ' in (' . $self->name . ')') ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_type_for {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return first { $_->check($value) } @{ $self->type_constraints };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_a_type_of {
0.000000,0,0.000000,my ($self, $type_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return all { $_->is_a_type_of($type_name) } @{ $self->type_constraints };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_subtype_of {
0.000000,0,0.000000,my ($self, $type_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return all { $_->is_subtype_of($type_name) } @{ $self->type_constraints };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_child_type {
0.000000,0,0.000000,my ( $self, %opts ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $constraint
0.000000,0,0.000000,= Moose::Meta::TypeConstraint->new( %opts, parent => $self );
0.000000,0,0.000000,
0.000000,0,0.000000,# if we have a type constraint union, and no
0.000000,0,0.000000,# type check, this means we are just aliasing
0.000000,0,0.000000,# the union constraint, which means we need to
0.000000,0,0.000000,# handle this differently.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,if ( not( defined $opts{constraint} )
0.000000,0,0.000000,&& $self->has_coercion ) {
0.000000,0,0.000000,$constraint->coercion(
0.000000,0,0.000000,Moose::Meta::TypeCoercion::Union->new(
0.000000,0,0.000000,type_constraint => $self,
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: A union of Moose type constraints
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
