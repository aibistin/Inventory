# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package DateTime::Duration;
0.000000,0,0.000000,{
0.000005,2,0.000003,$DateTime::Duration::VERSION = '1.03';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000016,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000027,2,0.000014,use Carp ();
0.000032,2,0.000016,use DateTime;
0.000117,2,0.000058,use DateTime::Helpers;
0.000144,2,0.000072,use Params::Validate qw( validate SCALAR );
0.000000,0,0.000000,
0.000000,0,0.000000,use overload (
0.000012,1,0.000012,fallback => 1,
0.000000,0,0.000000,'+'      => '_add_overload',
0.000000,0,0.000000,'-'      => '_subtract_overload',
0.000000,0,0.000000,'*'      => '_multiply_overload',
0.000000,0,0.000000,'<=>'    => '_compare_overload',
0.000000,0,0.000000,'cmp'    => '_compare_overload',
0.000028,1,0.000028,);
0.000000,0,0.000000,
0.001493,2,0.000746,use constant MAX_NANOSECONDS => 1_000_000_000;    # 1E9 = almost 32 bits
0.000000,0,0.000000,
0.000003,1,0.000003,my @all_units = qw( months days minutes seconds nanoseconds );
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX - need to reject non-integers but accept infinity, NaN, &
0.000000,0,0.000000,# 1.56e+18
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p     = validate(
0.000000,0,0.000000,@_, {
0.000000,0,0.000000,years        => { type => SCALAR, default => 0 },
0.000000,0,0.000000,months       => { type => SCALAR, default => 0 },
0.000000,0,0.000000,weeks        => { type => SCALAR, default => 0 },
0.000000,0,0.000000,days         => { type => SCALAR, default => 0 },
0.000000,0,0.000000,hours        => { type => SCALAR, default => 0 },
0.000000,0,0.000000,minutes      => { type => SCALAR, default => 0 },
0.000000,0,0.000000,seconds      => { type => SCALAR, default => 0 },
0.000000,0,0.000000,nanoseconds  => { type => SCALAR, default => 0 },
0.000000,0,0.000000,end_of_month => {
0.000000,0,0.000000,type  => SCALAR, default => undef,
0.000000,0,0.000000,regex => qr/^(?:wrap|limit|preserve)$/
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = bless {}, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{months} = ( $p{years} * 12 ) + $p{months};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{days} = ( $p{weeks} * 7 ) + $p{days};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{minutes} = ( $p{hours} * 60 ) + $p{minutes};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{seconds} = $p{seconds};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $p{nanoseconds} ) {
0.000000,0,0.000000,$self->{nanoseconds} = $p{nanoseconds};
0.000000,0,0.000000,$self->_normalize_nanoseconds;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# shortcut - if they don't need nanoseconds
0.000000,0,0.000000,$self->{nanoseconds} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{end_of_month} = (
0.000000,0,0.000000,defined $p{end_of_month} ? $p{end_of_month}
0.000000,0,0.000000,: $self->{months} < 0      ? 'preserve'
0.000000,0,0.000000,: 'wrap'
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# make the signs of seconds, nanos the same; 0 < abs(nanos) < MAX_NANOS
0.000000,0,0.000000,# NB this requires nanoseconds != 0 (callers check this already)
0.000000,0,0.000000,sub _normalize_nanoseconds {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000000,0,0.000000,if ( $self->{nanoseconds} == DateTime::INFINITY()
0.000000,0,0.000000,|| $self->{nanoseconds} == DateTime::NEG_INFINITY()
0.000000,0,0.000000,|| $self->{nanoseconds} eq DateTime::NAN() );
0.000000,0,0.000000,
0.000000,0,0.000000,my $seconds = $self->{seconds} + $self->{nanoseconds} / MAX_NANOSECONDS;
0.000000,0,0.000000,$self->{seconds}     = int($seconds);
0.000000,0,0.000000,$self->{nanoseconds} = $self->{nanoseconds} % MAX_NANOSECONDS;
0.000000,0,0.000000,$self->{nanoseconds} -= MAX_NANOSECONDS if $seconds < 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone { bless { %{ $_[0] } }, ref $_[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub years       { abs( $_[0]->in_units('years') ) }
0.000000,0,0.000000,sub months      { abs( $_[0]->in_units( 'months', 'years' ) ) }
0.000000,0,0.000000,sub weeks       { abs( $_[0]->in_units('weeks') ) }
0.000000,0,0.000000,sub days        { abs( $_[0]->in_units( 'days', 'weeks' ) ) }
0.000000,0,0.000000,sub hours       { abs( $_[0]->in_units('hours') ) }
0.000000,0,0.000000,sub minutes     { abs( $_[0]->in_units( 'minutes', 'hours' ) ) }
0.000000,0,0.000000,sub seconds     { abs( $_[0]->in_units('seconds') ) }
0.000000,0,0.000000,sub nanoseconds { abs( $_[0]->in_units( 'nanoseconds', 'seconds' ) ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_positive { $_[0]->_has_positive  && !$_[0]->_has_negative }
0.000000,0,0.000000,sub is_negative { !$_[0]->_has_positive && $_[0]->_has_negative }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _has_positive {
0.000000,0,0.000000,( grep { $_ > 0 } @{ $_[0] }{@all_units} ) ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _has_negative {
0.000000,0,0.000000,( grep { $_ < 0 } @{ $_[0] }{@all_units} ) ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_zero {
0.000000,0,0.000000,return 0 if grep { $_ != 0 } @{ $_[0] }{@all_units};
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub delta_months      { $_[0]->{months} }
0.000000,0,0.000000,sub delta_days        { $_[0]->{days} }
0.000000,0,0.000000,sub delta_minutes     { $_[0]->{minutes} }
0.000000,0,0.000000,sub delta_seconds     { $_[0]->{seconds} }
0.000000,0,0.000000,sub delta_nanoseconds { $_[0]->{nanoseconds} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub deltas {
0.000000,0,0.000000,map { $_ => $_[0]->{$_} } @all_units;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub in_units {
0.000000,0,0.000000,my $self  = shift;
0.000000,0,0.000000,my @units = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %units = map { $_ => 1 } @units;
0.000000,0,0.000000,
0.000000,0,0.000000,my %ret;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $months, $days, $minutes, $seconds )
0.000000,0,0.000000,= @{$self}{qw( months days minutes seconds )};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{years} ) {
0.000000,0,0.000000,$ret{years} = int( $months / 12 );
0.000000,0,0.000000,$months -= $ret{years} * 12;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{months} ) {
0.000000,0,0.000000,$ret{months} = $months;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{weeks} ) {
0.000000,0,0.000000,$ret{weeks} = int( $days / 7 );
0.000000,0,0.000000,$days -= $ret{weeks} * 7;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{days} ) {
0.000000,0,0.000000,$ret{days} = $days;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{hours} ) {
0.000000,0,0.000000,$ret{hours} = int( $minutes / 60 );
0.000000,0,0.000000,$minutes -= $ret{hours} * 60;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{minutes} ) {
0.000000,0,0.000000,$ret{minutes} = $minutes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{seconds} ) {
0.000000,0,0.000000,$ret{seconds} = $seconds;
0.000000,0,0.000000,$seconds = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $units{nanoseconds} ) {
0.000000,0,0.000000,$ret{nanoseconds} = $seconds * MAX_NANOSECONDS + $self->{nanoseconds};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,wantarray ? @ret{@units} : $ret{ $units[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_wrap_mode     { $_[0]->{end_of_month} eq 'wrap'     ? 1 : 0 }
0.000000,0,0.000000,sub is_limit_mode    { $_[0]->{end_of_month} eq 'limit'    ? 1 : 0 }
0.000000,0,0.000000,sub is_preserve_mode { $_[0]->{end_of_month} eq 'preserve' ? 1 : 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub end_of_month_mode { $_[0]->{end_of_month} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub calendar_duration {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return ( ref $self )
0.000000,0,0.000000,->new( map { $_ => $self->{$_} } qw( months days end_of_month ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clock_duration {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return ( ref $self )
0.000000,0,0.000000,->new( map { $_ => $self->{$_} }
0.000000,0,0.000000,qw( minutes seconds nanoseconds end_of_month ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inverse {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %p    = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %new;
0.000000,0,0.000000,foreach my $u (@all_units) {
0.000000,0,0.000000,$new{$u} = $self->{$u};
0.000000,0,0.000000,
0.000000,0,0.000000,# avoid -0 bug
0.000000,0,0.000000,$new{$u} *= -1 if $new{$u};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$new{end_of_month} = $p{end_of_month}
0.000000,0,0.000000,if exists $p{end_of_month};
0.000000,0,0.000000,
0.000000,0,0.000000,return ( ref $self )->new(%new);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_duration {
0.000000,0,0.000000,my ( $self, $dur ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $u (@all_units) {
0.000000,0,0.000000,$self->{$u} += $dur->{$u};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_normalize_nanoseconds if $self->{nanoseconds};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->add_duration( ( ref $self )->new(@_) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtract_duration { return $_[0]->add_duration( $_[1]->inverse ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtract {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->subtract_duration( ( ref $self )->new(@_) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub multiply {
0.000000,0,0.000000,my $self       = shift;
0.000000,0,0.000000,my $multiplier = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $u (@all_units) {
0.000000,0,0.000000,$self->{$u} *= $multiplier;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_normalize_nanoseconds if $self->{nanoseconds};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub compare {
0.000000,0,0.000000,my ( $class, $dur1, $dur2, $dt ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$dt ||= DateTime->now;
0.000000,0,0.000000,
0.000000,0,0.000000,return DateTime->compare( $dt->clone->add_duration($dur1),
0.000000,0,0.000000,$dt->clone->add_duration($dur2) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _add_overload {
0.000000,0,0.000000,my ( $d1, $d2, $rev ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,( $d1, $d2 ) = ( $d2, $d1 ) if $rev;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( DateTime::Helpers::isa( $d2, 'DateTime' ) ) {
0.000000,0,0.000000,$d2->add_duration($d1);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# will also work if $d1 is a DateTime.pm object
0.000000,0,0.000000,return $d1->clone->add_duration($d2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _subtract_overload {
0.000000,0,0.000000,my ( $d1, $d2, $rev ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,( $d1, $d2 ) = ( $d2, $d1 ) if $rev;
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak(
0.000000,0,0.000000,"Cannot subtract a DateTime object from a DateTime::Duration object")
0.000000,0,0.000000,if DateTime::Helpers::isa( $d2, 'DateTime' );
0.000000,0,0.000000,
0.000000,0,0.000000,return $d1->clone->subtract_duration($d2);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _multiply_overload {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $self->clone;
0.000000,0,0.000000,
0.000000,0,0.000000,return $new->multiply(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compare_overload {
0.000000,0,0.000000,Carp::croak( 'DateTime::Duration does not overload comparison.'
0.000000,0,0.000000,. '  See the documentation on the compare() method for details.'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Duration objects for date math
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
