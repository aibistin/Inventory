# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Meta::Method::Delegation;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::Method::Delegation::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::Method::Delegation::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000041,2,0.000021,use Carp         'confess';
0.000039,2,0.000020,use Scalar::Util 'blessed', 'weaken';
0.000000,0,0.000000,
0.000010,1,0.000010,use base 'Moose::Meta::Method',
0.000485,1,0.000485,'Class::MOP::Method::Generated';
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class   = shift;
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,( exists $options{attribute} )
0.000000,0,0.000000,|| confess "You must supply an attribute to construct with";
0.000000,0,0.000000,
0.000000,0,0.000000,( blessed( $options{attribute} )
0.000000,0,0.000000,&& $options{attribute}->isa('Moose::Meta::Attribute') )
0.000000,0,0.000000,|| confess
0.000000,0,0.000000,"You must supply an attribute which is a 'Moose::Meta::Attribute' instance";
0.000000,0,0.000000,
0.000000,0,0.000000,( $options{package_name} && $options{name} )
0.000000,0,0.000000,|| confess
0.000000,0,0.000000,"You must supply the package_name and name parameters $Class::MOP::Method::UPGRADE_ERROR_TEXT";
0.000000,0,0.000000,
0.000000,0,0.000000,( $options{delegate_to_method} && ( !ref $options{delegate_to_method} )
0.000000,0,0.000000,|| ( 'CODE' eq ref $options{delegate_to_method} ) )
0.000000,0,0.000000,|| confess
0.000000,0,0.000000,'You must supply a delegate_to_method which is a method name or a CODE reference';
0.000000,0,0.000000,
0.000000,0,0.000000,exists $options{curried_arguments}
0.000000,0,0.000000,|| ( $options{curried_arguments} = [] );
0.000000,0,0.000000,
0.000000,0,0.000000,( $options{curried_arguments} &&
0.000000,0,0.000000,( 'ARRAY' eq ref $options{curried_arguments} ) )
0.000000,0,0.000000,|| confess 'You must supply a curried_arguments which is an ARRAY reference';
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = $class->_new( \%options );
0.000000,0,0.000000,
0.000000,0,0.000000,weaken( $self->{'attribute'} );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_initialize_body;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $options = @_ == 1 ? $_[0] : {@_};
0.000000,0,0.000000,
0.000000,0,0.000000,return bless $options, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub curried_arguments { (shift)->{'curried_arguments'} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub associated_attribute { (shift)->{'attribute'} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub delegate_to_method { (shift)->{'delegate_to_method'} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _initialize_body {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $method_to_call = $self->delegate_to_method;
0.000000,0,0.000000,return $self->{body} = $method_to_call
0.000000,0,0.000000,if ref $method_to_call;
0.000000,0,0.000000,
0.000000,0,0.000000,my $accessor = $self->_get_delegate_accessor;
0.000000,0,0.000000,
0.000000,0,0.000000,my $handle_name = $self->name;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: we used to do a goto here, but the goto didn't handle
0.000000,0,0.000000,# failure correctly (it just returned nothing), so I took that
0.000000,0,0.000000,# out. However, the more I thought about it, the less I liked it
0.000000,0,0.000000,# doing the goto, and I preferred the act of delegation being
0.000000,0,0.000000,# actually represented in the stack trace.  - SL
0.000000,0,0.000000,# not inlining this, since it won't really speed things up at
0.000000,0,0.000000,# all... the only thing that would end up different would be
0.000000,0,0.000000,# interpolating in $method_to_call, and a bunch of things in the
0.000000,0,0.000000,# error handling that mostly never gets called - doy
0.000000,0,0.000000,$self->{body} = sub {
0.000000,0,0.000000,my $instance = shift;
0.000000,0,0.000000,my $proxy    = $instance->$accessor();
0.000000,0,0.000000,
0.000000,0,0.000000,my $error
0.000000,0,0.000000,= !defined $proxy                 ? ' is not defined'
0.000000,0,0.000000,: ref($proxy) && !blessed($proxy) ? qq{ is not an object (got '$proxy')}
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($error) {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,"Cannot delegate $handle_name to $method_to_call because "
0.000000,0,0.000000,. "the value of "
0.000000,0,0.000000,. $self->associated_attribute->name
0.000000,0,0.000000,. $error,
0.000000,0,0.000000,method_name => $method_to_call,
0.000000,0,0.000000,object      => $instance
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,unshift @_, @{ $self->curried_arguments };
0.000000,0,0.000000,$proxy->$method_to_call(@_);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_delegate_accessor {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $attr = $self->associated_attribute;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# always use a named method when
0.000000,0,0.000000,# possible, if you use the method
0.000000,0,0.000000,# ref and there are modifiers on
0.000000,0,0.000000,# the accessors then it will not
0.000000,0,0.000000,# pick up the modifiers too. Only
0.000000,0,0.000000,# the named method will assure that
0.000000,0,0.000000,# we also have any modifiers run.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,my $accessor = $attr->has_read_method
0.000000,0,0.000000,? $attr->get_read_method
0.000000,0,0.000000,: $attr->get_read_method_ref;
0.000000,0,0.000000,
0.000000,0,0.000000,$accessor = $accessor->body if Scalar::Util::blessed $accessor;
0.000000,0,0.000000,
0.000000,0,0.000000,return $accessor;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: A Moose Method metaclass for delegation methods
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
