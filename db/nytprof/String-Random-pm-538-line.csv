# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# String::Random - Generates a random string from a pattern
0.000000,0,0.000000,# Copyright (C) 1999-2006 Steven Pritchard <steve@silug.org>
0.000000,0,0.000000,#
0.000000,0,0.000000,# This program is free software; you can redistribute it
0.000000,0,0.000000,# and/or modify it under the same terms as Perl itself.
0.000000,0,0.000000,#
0.000000,0,0.000000,# This program is distributed in the hope that it will be useful,
0.000000,0,0.000000,# but WITHOUT ANY WARRANTY; without even the implied warranty of
0.000000,0,0.000000,# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
0.000000,0,0.000000,#
0.000000,0,0.000000,# $Id: Random.pm,v 1.4 2006/09/21 17:34:07 steve Exp $
0.000000,0,0.000000,
0.000000,0,0.000000,package String::Random;
0.000000,0,0.000000,
0.000014,1,0.000014,require 5.006_001;
0.000000,0,0.000000,
0.000036,2,0.000018,use strict;
0.000033,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000035,2,0.000018,use Carp;
0.001770,2,0.000885,use Exporter ();
0.000000,0,0.000000,
0.000008,1,0.000008,our @ISA = qw(Exporter);
0.000003,1,0.000003,our %EXPORT_TAGS = ( 'all' => [ qw(
0.000000,0,0.000000,&random_string
0.000000,0,0.000000,&random_regex
0.000000,0,0.000000,) ] );
0.000002,1,0.000002,our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );
0.000002,1,0.000002,our @EXPORT = ();
0.000002,1,0.000002,our $VERSION = '0.22';
0.000000,0,0.000000,
0.000000,0,0.000000,# These are the various character sets.
0.000005,1,0.000005,our @upper=("A".."Z");
0.000005,1,0.000005,our @lower=("a".."z");
0.000003,1,0.000003,our @digit=("0".."9");
0.000014,1,0.000014,our @punct=map { chr($_); } (33..47,58..64,91..96,123..126);
0.000012,1,0.000012,our @any=(@upper, @lower, @digit, @punct);
0.000009,1,0.000009,our @salt=(@upper, @lower, @digit, ".", "/");
0.000089,1,0.000089,our @binary=map { chr($_) } (0..255);
0.000000,0,0.000000,
0.000000,0,0.000000,# What's important is how they relate to the pattern characters.
0.000000,0,0.000000,# These are the old patterns for randpattern/random_string.
0.000067,1,0.000067,our %old_patterns = (
0.000000,0,0.000000,'C' => [ @upper ],
0.000000,0,0.000000,'c' => [ @lower ],
0.000000,0,0.000000,'n' => [ @digit ],
0.000000,0,0.000000,'!' => [ @punct ],
0.000000,0,0.000000,'.' => [ @any ],
0.000000,0,0.000000,'s' => [ @salt ],
0.000000,0,0.000000,'b' => [ @binary ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# These are the regex-based patterns.
0.000000,0,0.000000,our %patterns = (
0.000000,0,0.000000,# These are the regex-equivalents.
0.000000,0,0.000000,'.' => [ @any ],
0.000000,0,0.000000,'\d' => [ @digit ],
0.000000,0,0.000000,'\D' => [ @upper, @lower, @punct ],
0.000000,0,0.000000,'\w' => [ @upper, @lower, @digit, "_" ],
0.000071,1,0.000071,'\W' => [ grep { $_ ne "_" } @punct ],
0.000000,0,0.000000,'\s' => [ " ", "\t" ], # Would anything else make sense?
0.000000,0,0.000000,'\S' => [ @upper, @lower, @digit, @punct ],
0.000000,0,0.000000,
0.000000,0,0.000000,# These are translated to their double quoted equivalents.
0.000000,0,0.000000,'\t' => [ "\t" ],
0.000000,0,0.000000,'\n' => [ "\n" ],
0.000000,0,0.000000,'\r' => [ "\r" ],
0.000000,0,0.000000,'\f' => [ "\f" ],
0.000000,0,0.000000,'\a' => [ "\a" ],
0.000000,0,0.000000,'\e' => [ "\e" ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# These characters are treated specially in randregex().
0.000000,0,0.000000,our %regch = (
0.000000,0,0.000000,"\\" => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,if (@{$chars}) {
0.000000,0,0.000000,my $tmp=shift(@{$chars});
0.000000,0,0.000000,if ($tmp eq "x") {
0.000000,0,0.000000,# This is supposed to be a number in hex, so
0.000000,0,0.000000,# there had better be at least 2 characters left.
0.000000,0,0.000000,$tmp=shift(@{$chars}) . shift(@{$chars});
0.000000,0,0.000000,push(@{$string}, [chr(hex($tmp))]);
0.000000,0,0.000000,} elsif ($tmp=~/[0-7]/) {
0.000000,0,0.000000,carp "octal parsing not implemented.  treating literally.";
0.000000,0,0.000000,push(@{$string}, [$tmp]);
0.000000,0,0.000000,} elsif (defined($patterns{"\\$tmp"})) {
0.000000,0,0.000000,$ch.=$tmp;
0.000000,0,0.000000,push(@{$string}, $patterns{$ch});
0.000000,0,0.000000,} else {
0.000000,0,0.000000,carp "'\\$tmp' being treated as literal '$tmp'";
0.000000,0,0.000000,push(@{$string}, [$tmp]);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "regex not terminated";
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,'.' => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,push(@{$string}, $patterns{$ch});
0.000000,0,0.000000,},
0.000000,0,0.000000,'[' => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,my @tmp;
0.000000,0,0.000000,while (defined($ch=shift(@{$chars})) && ($ch ne "]")) {
0.000000,0,0.000000,if (($ch eq "-") && @{$chars} && @tmp) {
0.000000,0,0.000000,$ch=shift(@{$chars});
0.000000,0,0.000000,for (my $n=ord($tmp[$#tmp]);$n<ord($ch);$n++) {
0.000000,0,0.000000,push(@tmp, chr($n+1));
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,carp "'$ch' will be treated literally inside []"
0.000000,0,0.000000,if ($ch=~/\W/);
0.000000,0,0.000000,push(@tmp, $ch);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,croak "unmatched []" if ($ch ne "]");
0.000000,0,0.000000,push(@{$string}, \@tmp);
0.000000,0,0.000000,},
0.000000,0,0.000000,'*' => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,unshift(@{$chars}, split("", "{0,}"));
0.000000,0,0.000000,},
0.000000,0,0.000000,'+' => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,unshift(@{$chars}, split("", "{1,}"));
0.000000,0,0.000000,},
0.000000,0,0.000000,'?' => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,unshift(@{$chars}, split("", "{0,1}"));
0.000000,0,0.000000,},
0.000000,0,0.000000,'{' => sub {
0.000000,0,0.000000,my ($self, $ch, $chars, $string)=@_;
0.000000,0,0.000000,my ($n, $closed);
0.000000,0,0.000000,for ($n=0;$n<scalar(@{$chars});$n++) {
0.000000,0,0.000000,if ($chars->[$n] eq "}") {
0.000000,0,0.000000,$closed++;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($closed) {
0.000000,0,0.000000,my $tmp;
0.000000,0,0.000000,while (defined($ch=shift(@{$chars})) && ($ch ne "}")) {
0.000000,0,0.000000,croak "'$ch' inside {} not supported" if ($ch!~/[\d,]/);
0.000000,0,0.000000,$tmp.=$ch;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($tmp=~/,/) {
0.000000,0,0.000000,if (my ($min,$max) = $tmp =~ /^(\d*),(\d*)$/) {
0.000000,0,0.000000,$min = 0 if (!length($min));
0.000000,0,0.000000,$max = $self->{'_max'} if (!length($max));
0.000000,0,0.000000,croak "bad range {$tmp}" if ($min>$max);
0.000000,0,0.000000,if ($min == $max) {
0.000000,0,0.000000,$tmp = $min;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$tmp = $min + int(rand($max - $min +1));
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "malformed range {$tmp}";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($tmp) {
0.000000,0,0.000000,my $last=$string->[$#{$string}];
0.000000,0,0.000000,for ($n=0;$n<($tmp-1);$n++) {
0.000000,0,0.000000,push(@{$string}, $last);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,pop(@{$string});
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# { isn't closed, so treat it literally.
0.000000,0,0.000000,push(@{$string}, [$ch]);
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000020,1,0.000020,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $proto=shift;
0.000000,0,0.000000,my $class=ref($proto) || $proto;
0.000000,0,0.000000,my $self;
0.000000,0,0.000000,$self={ %old_patterns }; # makes $self refer to a copy of %old_patterns
0.000000,0,0.000000,my %args=();
0.000000,0,0.000000,%args=@_ if (@_);
0.000000,0,0.000000,if (defined($args{'max'})) {
0.000000,0,0.000000,$self->{'_max'}=$args{'max'};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{'_max'}=10;
0.000000,0,0.000000,}
0.000000,0,0.000000,return bless($self, $class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns a random string for each regular expression given as an
0.000000,0,0.000000,# argument, or the strings concatenated when used in a scalar context.
0.000000,0,0.000000,sub randregex {
0.000000,0,0.000000,my $self=shift;
0.000000,0,0.000000,croak "called without a reference" if (!ref($self));
0.000000,0,0.000000,
0.000000,0,0.000000,my @strings=();
0.000000,0,0.000000,
0.000000,0,0.000000,while (defined(my $pattern=shift)) {
0.000000,0,0.000000,my $ch;
0.000000,0,0.000000,my @string=();
0.000000,0,0.000000,my $string='';
0.000000,0,0.000000,
0.000000,0,0.000000,# Split the characters in the pattern
0.000000,0,0.000000,# up into a list for easier parsing.
0.000000,0,0.000000,my @chars=split(//, $pattern);
0.000000,0,0.000000,
0.000000,0,0.000000,while (defined($ch=shift(@chars))) {
0.000000,0,0.000000,if (defined($regch{$ch})) {
0.000000,0,0.000000,$regch{$ch}->($self, $ch, \@chars, \@string);
0.000000,0,0.000000,} elsif ($ch=~/[\$\^\*\(\)\+\{\}\]\|\?]/) {
0.000000,0,0.000000,# At least some of these probably should have special meaning.
0.000000,0,0.000000,carp "'$ch' not implemented.  treating literally.";
0.000000,0,0.000000,push(@string, [$ch]);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,push(@string, [$ch]);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach $ch (@string) {
0.000000,0,0.000000,$string.=$ch->[int(rand(scalar(@{$ch})))];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push(@strings, $string);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray ? @strings : join("", @strings);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# For compatibility with an ancient version, please ignore...
0.000000,0,0.000000,sub from_pattern {
0.000000,0,0.000000,my $self=shift;
0.000000,0,0.000000,croak "called without a reference" if (!ref($self));
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->randpattern(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub randpattern {
0.000000,0,0.000000,my $self=shift;
0.000000,0,0.000000,croak "called without a reference" if (!ref($self));
0.000000,0,0.000000,
0.000000,0,0.000000,my @strings=();
0.000000,0,0.000000,
0.000000,0,0.000000,while (defined(my $pattern=shift)) {
0.000000,0,0.000000,my $string='';
0.000000,0,0.000000,
0.000000,0,0.000000,for my $ch (split(//, $pattern)) {
0.000000,0,0.000000,if (defined($self->{$ch})) {
0.000000,0,0.000000,$string.=$self->{$ch}->[int(rand(scalar(@{$self->{$ch}})))];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak qq(Unknown pattern character "$ch"!);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,push(@strings, $string);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray ? @strings : join("", @strings);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub random_regex {
0.000000,0,0.000000,my $foo=new String::Random;
0.000000,0,0.000000,return $foo->randregex(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub random_string {
0.000000,0,0.000000,my($pattern,@list)=@_;
0.000000,0,0.000000,
0.000000,0,0.000000,my($n,$foo);
0.000000,0,0.000000,
0.000000,0,0.000000,$foo=new String::Random;
0.000000,0,0.000000,
0.000000,0,0.000000,for ($n=0;$n<=$#list;$n++) {
0.000000,0,0.000000,@{$foo->{$n}}=@{$list[$n]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $foo->randpattern($pattern);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000024,1,0.000024,1;
0.000000,0,0.000000,__END__
