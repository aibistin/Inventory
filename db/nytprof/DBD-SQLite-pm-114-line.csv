# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package DBD::SQLite;
0.000000,0,0.000000,
0.000051,2,0.000025,use 5.006;
0.000035,2,0.000017,use strict;
0.000049,3,0.000016,use DBI   1.57 ();
0.000078,2,0.000039,use DynaLoader ();
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.39';
0.000007,1,0.000007,our @ISA     = 'DynaLoader';
0.000000,0,0.000000,
0.000000,0,0.000000,# sqlite_version cache (set in the XS bootstrap)
0.000002,1,0.000002,our ($sqlite_version, $sqlite_version_number);
0.000000,0,0.000000,
0.000000,0,0.000000,# not sure if we still need these...
0.000001,1,0.000001,our ($err, $errstr);
0.000000,0,0.000000,
0.000011,1,0.000011,__PACKAGE__->bootstrap($VERSION);
0.000000,0,0.000000,
0.000000,0,0.000000,# New or old API?
0.000083,2,0.000042,use constant NEWAPI => ($DBI::VERSION >= 1.608);
0.000000,0,0.000000,
0.000000,0,0.000000,# global registry of collation functions, initialized with 2 builtins
0.000002,1,0.000002,our %COLLATION;
0.000008,1,0.000008,tie %COLLATION, 'DBD::SQLite::_WriteOnceHash';
0.000010,1,0.000010,$COLLATION{perl}       = sub { $_[0] cmp $_[1] };
0.000887,3,0.000296,$COLLATION{perllocale} = sub { use locale; $_[0] cmp $_[1] };
0.000000,0,0.000000,
0.000001,1,0.000001,our $drh;
0.000002,1,0.000002,my $methods_are_installed = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub driver {
0.000002,1,0.000002,return $drh if $drh;
0.000000,0,0.000000,
0.000004,1,0.000004,if (!$methods_are_installed && DBD::SQLite::NEWAPI ) {
0.000005,1,0.000005,DBI->setup_driver('DBD::SQLite');
0.000000,0,0.000000,
0.000011,1,0.000011,DBD::SQLite::db->install_method('sqlite_last_insert_rowid');
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_busy_timeout');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_create_function');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_create_aggregate');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_create_collation');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_collation_needed');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_progress_handler');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_commit_hook');
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_rollback_hook');
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_update_hook');
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_set_authorizer');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_backup_from_file');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_backup_to_file');
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_enable_load_extension');
0.000005,1,0.000005,DBD::SQLite::db->install_method('sqlite_load_extension');
0.000013,1,0.000013,DBD::SQLite::db->install_method('sqlite_register_fts3_perl_tokenizer');
0.000007,1,0.000007,DBD::SQLite::db->install_method('sqlite_trace', { O => 0x0004 });
0.000007,1,0.000007,DBD::SQLite::db->install_method('sqlite_profile', { O => 0x0004 });
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_table_column_metadata', { O => 0x0004 });
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_db_filename', { O => 0x0004 });
0.000006,1,0.000006,DBD::SQLite::db->install_method('sqlite_db_status', { O => 0x0004 });
0.000000,0,0.000000,
0.000010,1,0.000010,DBD::SQLite::st->install_method('sqlite_st_status', { O => 0x0004 });
0.000000,0,0.000000,
0.000002,1,0.000002,$methods_are_installed++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,1,0.000011,$drh = DBI::_new_drh( "$_[0]::dr", {
0.000000,0,0.000000,Name        => 'SQLite',
0.000000,0,0.000000,Version     => $VERSION,
0.000000,0,0.000000,Attribution => 'DBD::SQLite by Matt Sergeant et al',
0.000000,0,0.000000,} );
0.000000,0,0.000000,
0.000006,1,0.000006,return $drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,undef $drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package DBD::SQLite::dr;
0.000000,0,0.000000,
0.000000,0,0.000000,sub connect {
0.000003,1,0.000003,my ($drh, $dbname, $user, $auth, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Default PrintWarn to the value of $^W
0.000000,0,0.000000,# unless ( defined $attr->{PrintWarn} ) {
0.000000,0,0.000000,#    $attr->{PrintWarn} = $^W ? 1 : 0;
0.000000,0,0.000000,# }
0.000000,0,0.000000,
0.000009,1,0.000009,my $dbh = DBI::_new_dbh( $drh, {
0.000000,0,0.000000,Name => $dbname,
0.000000,0,0.000000,} );
0.000000,0,0.000000,
0.000002,1,0.000002,my $real = $dbname;
0.000015,1,0.000015,if ( $dbname =~ /=/ ) {
0.000005,1,0.000005,foreach my $attrib ( split(/;/, $dbname) ) {
0.000003,1,0.000003,my ($key, $value) = split(/=/, $attrib, 2);
0.000019,1,0.000019,if ( $key =~ /^(?:db(?:name)?|database)$/ ) {
0.000000,0,0.000000,$real = $value;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$attr->{$key} = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# To avoid unicode and long file name problems on Windows,
0.000000,0,0.000000,# convert to the shortname if the file (or parent directory) exists.
0.000008,1,0.000008,if ( $^O =~ /MSWin32/ and $real ne ':memory:' and $real ne '') {
0.000000,0,0.000000,require Win32;
0.000000,0,0.000000,require File::Basename;
0.000000,0,0.000000,my ($file, $dir, $suffix) = File::Basename::fileparse($real);
0.000000,0,0.000000,my $short = Win32::GetShortPathName($real);
0.000000,0,0.000000,if ( $short && -f $short ) {
0.000000,0,0.000000,# Existing files will work directly.
0.000000,0,0.000000,$real = $short;
0.000000,0,0.000000,} elsif ( -d $dir ) {
0.000000,0,0.000000,# We are creating a new file.
0.000000,0,0.000000,# Does the directory it's in at least exist?
0.000000,0,0.000000,$real = join '', grep { defined } Win32::GetShortPathName($dir), $file, $suffix;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# SQLite can't do mkpath anyway.
0.000000,0,0.000000,# So let it go through as it and fail.
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Hand off to the actual login function
0.000177,1,0.000177,DBD::SQLite::db::_login($dbh, $real, $user, $auth, $attr) or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,# Register the on-demand collation installer, REGEXP function and
0.000000,0,0.000000,# perl tokenizer
0.000003,1,0.000003,if ( DBD::SQLite::NEWAPI ) {
0.000020,1,0.000020,$dbh->sqlite_collation_needed( \&install_collation );
0.000014,1,0.000014,$dbh->sqlite_create_function( "REGEXP", 2, \&regexp );
0.000116,1,0.000116,$dbh->sqlite_register_fts3_perl_tokenizer();
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$dbh->func( \&install_collation, "collation_needed"  );
0.000000,0,0.000000,$dbh->func( "REGEXP", 2, \&regexp, "create_function" );
0.000000,0,0.000000,$dbh->func( "register_fts3_perl_tokenizer" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# HACK: Since PrintWarn = 0 doesn't seem to actually prevent warnings
0.000000,0,0.000000,# in DBD::SQLite we set Warn to false if PrintWarn is false.
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: According to the explanation by timbunce,
0.000000,0,0.000000,# "Warn is meant to report on bad practices or problems with
0.000000,0,0.000000,# the DBI itself (hence always on by default), while PrintWarn
0.000000,0,0.000000,# is meant to report warnings coming from the database."
0.000000,0,0.000000,# That is, if you want to disable an ineffective rollback warning
0.000000,0,0.000000,# etc (due to bad practices), you should turn off Warn,
0.000000,0,0.000000,# and to silence other warnings, turn off PrintWarn.
0.000000,0,0.000000,# Warn and PrintWarn are independent, and turning off PrintWarn
0.000000,0,0.000000,# does not silence those warnings that should be controlled by
0.000000,0,0.000000,# Warn.
0.000000,0,0.000000,
0.000000,0,0.000000,# unless ( $attr->{PrintWarn} ) {
0.000000,0,0.000000,#     $attr->{Warn} = 0;
0.000000,0,0.000000,# }
0.000000,0,0.000000,
0.000008,1,0.000008,return $dbh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_collation {
0.000000,0,0.000000,my $dbh       = shift;
0.000000,0,0.000000,my $name      = shift;
0.000000,0,0.000000,my $collation = $DBD::SQLite::COLLATION{$name};
0.000000,0,0.000000,unless ($collation) {
0.000000,0,0.000000,warn "Can't install unknown collation: $name" if $dbh->{PrintWarn};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( DBD::SQLite::NEWAPI ) {
0.000000,0,0.000000,$dbh->sqlite_create_collation( $name => $collation );
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$dbh->func( $name => $collation, "create_collation" );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# default implementation for sqlite 'REGEXP' infix operator.
0.000000,0,0.000000,# Note : args are reversed, i.e. "a REGEXP b" calls REGEXP(b, a)
0.000000,0,0.000000,# (see http://www.sqlite.org/vtab.html#xfindfunction)
0.000000,0,0.000000,sub regexp {
0.002515,2,0.001257,use locale;
0.000000,0,0.000000,return if !defined $_[0] || !defined $_[1];
0.000000,0,0.000000,return scalar($_[1] =~ $_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package DBD::SQLite::db;
0.000000,0,0.000000,
0.000000,0,0.000000,sub prepare {
0.000019,13,0.000001,my $dbh = shift;
0.000020,13,0.000002,my $sql = shift;
0.000018,13,0.000001,$sql = '' unless defined $sql;
0.000000,0,0.000000,
0.000079,13,0.000006,my $sth = DBI::_new_sth( $dbh, {
0.000000,0,0.000000,Statement => $sql,
0.000000,0,0.000000,} );
0.000000,0,0.000000,
0.000669,13,0.000051,DBD::SQLite::st::_prepare($sth, $sql, @_) or return undef;
0.000000,0,0.000000,
0.000065,13,0.000005,return $sth;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub do {
0.000027,13,0.000002,my ($dbh, $statement, $attr, @bind_values) = @_;
0.000000,0,0.000000,
0.000027,13,0.000002,my @copy = @{[@bind_values]};
0.000019,13,0.000001,my $rows = 0;
0.000000,0,0.000000,
0.000019,13,0.000001,while ($statement) {
0.000147,13,0.000011,my $sth = $dbh->prepare($statement, $attr) or return undef;
0.000891,13,0.000069,$sth->execute(splice @copy, 0, $sth->{NUM_OF_PARAMS}) or return undef;
0.000101,13,0.000008,$rows += $sth->rows;
0.000000,0,0.000000,# XXX: not sure why but $dbh->{sqlite...} wouldn't work here
0.000394,13,0.000030,last unless $dbh->FETCH('sqlite_allow_multiple_statements');
0.000000,0,0.000000,$statement = $sth->{sqlite_unprepared_statements};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# always return true if no error
0.000086,13,0.000007,return ($rows == 0) ? "0E0" : $rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ping {
0.000002,1,0.000002,my $dbh = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# $file may be undef (ie. in-memory/temporary database)
0.000018,1,0.000018,my $file = DBD::SQLite::NEWAPI ? $dbh->sqlite_db_filename
0.000000,0,0.000000,: $dbh->func("db_filename");
0.000000,0,0.000000,
0.000018,1,0.000018,return 0 if $file && !-f $file;
0.000027,1,0.000027,return $dbh->FETCH('Active') ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_version {
0.000000,0,0.000000,return ( DBD::SQLite::db::FETCH($_[0], 'sqlite_version') );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,my %info = (
0.000000,0,0.000000,17 => 'SQLite',       # SQL_DBMS_NAME
0.000000,0,0.000000,18 => \&_get_version, # SQL_DBMS_VER
0.000000,0,0.000000,29 => '"',            # SQL_IDENTIFIER_QUOTE_CHAR
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_info {
0.000000,0,0.000000,my($dbh, $info_type) = @_;
0.000000,0,0.000000,my $v = $info{int($info_type)};
0.000000,0,0.000000,$v = $v->($dbh) if ref $v eq 'CODE';
0.000000,0,0.000000,return $v;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _attached_database_list {
0.000000,0,0.000000,my $dbh = shift;
0.000000,0,0.000000,my @attached;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sth_databases = $dbh->prepare( 'PRAGMA database_list' );
0.000000,0,0.000000,$sth_databases->execute;
0.000000,0,0.000000,while ( my $db_info = $sth_databases->fetchrow_hashref ) {
0.000000,0,0.000000,push @attached, $db_info->{name} if $db_info->{seq} >= 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @attached;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# SQL/CLI (ISO/IEC JTC 1/SC 32 N 0595), 6.63 Tables
0.000000,0,0.000000,# Based on DBD::Oracle's
0.000000,0,0.000000,# See also http://www.ch-werner.de/sqliteodbc/html/sqlite3odbc_8c.html#a213
0.000000,0,0.000000,sub table_info {
0.000000,0,0.000000,my ($dbh, $cat_val, $sch_val, $tbl_val, $typ_val, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @where = ();
0.000000,0,0.000000,my $sql;
0.000000,0,0.000000,if (  defined($cat_val) && $cat_val eq '%'
0.000000,0,0.000000,&& defined($sch_val) && $sch_val eq ''
0.000000,0,0.000000,&& defined($tbl_val) && $tbl_val eq '')  { # Rule 19a
0.000000,0,0.000000,$sql = <<'END_SQL';
0.000000,0,0.000000,SELECT NULL TABLE_CAT
0.000000,0,0.000000,, NULL TABLE_SCHEM
0.000000,0,0.000000,, NULL TABLE_NAME
0.000000,0,0.000000,, NULL TABLE_TYPE
0.000000,0,0.000000,, NULL REMARKS
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (  defined($cat_val) && $cat_val eq ''
0.000000,0,0.000000,&& defined($sch_val) && $sch_val eq '%'
0.000000,0,0.000000,&& defined($tbl_val) && $tbl_val eq '') { # Rule 19b
0.000000,0,0.000000,$sql = <<'END_SQL';
0.000000,0,0.000000,SELECT NULL      TABLE_CAT
0.000000,0,0.000000,, t.tn      TABLE_SCHEM
0.000000,0,0.000000,, NULL      TABLE_NAME
0.000000,0,0.000000,, NULL      TABLE_TYPE
0.000000,0,0.000000,, NULL      REMARKS
0.000000,0,0.000000,FROM (
0.000000,0,0.000000,SELECT 'main' tn
0.000000,0,0.000000,UNION SELECT 'temp' tn
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,for my $db_name (_attached_database_list($dbh)) {
0.000000,0,0.000000,$sql .= "     UNION SELECT '$db_name' tn\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$sql .= ") t\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (  defined($cat_val) && $cat_val eq ''
0.000000,0,0.000000,&& defined($sch_val) && $sch_val eq ''
0.000000,0,0.000000,&& defined($tbl_val) && $tbl_val eq ''
0.000000,0,0.000000,&& defined($typ_val) && $typ_val eq '%') { # Rule 19c
0.000000,0,0.000000,$sql = <<'END_SQL';
0.000000,0,0.000000,SELECT NULL TABLE_CAT
0.000000,0,0.000000,, NULL TABLE_SCHEM
0.000000,0,0.000000,, NULL TABLE_NAME
0.000000,0,0.000000,, t.tt TABLE_TYPE
0.000000,0,0.000000,, NULL REMARKS
0.000000,0,0.000000,FROM (
0.000000,0,0.000000,SELECT 'TABLE' tt                  UNION
0.000000,0,0.000000,SELECT 'VIEW' tt                   UNION
0.000000,0,0.000000,SELECT 'LOCAL TEMPORARY' tt
0.000000,0,0.000000,) t
0.000000,0,0.000000,ORDER BY TABLE_TYPE
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$sql = <<'END_SQL';
0.000000,0,0.000000,SELECT *
0.000000,0,0.000000,FROM
0.000000,0,0.000000,(
0.000000,0,0.000000,SELECT NULL         TABLE_CAT
0.000000,0,0.000000,,              TABLE_SCHEM
0.000000,0,0.000000,, tbl_name     TABLE_NAME
0.000000,0,0.000000,,              TABLE_TYPE
0.000000,0,0.000000,, NULL         REMARKS
0.000000,0,0.000000,, sql          sqlite_sql
0.000000,0,0.000000,FROM (
0.000000,0,0.000000,SELECT 'main' TABLE_SCHEM, tbl_name, upper(type) TABLE_TYPE, sql
0.000000,0,0.000000,FROM sqlite_master
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT 'temp' TABLE_SCHEM, tbl_name, 'LOCAL TEMPORARY' TABLE_TYPE, sql
0.000000,0,0.000000,FROM sqlite_temp_master
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,
0.000000,0,0.000000,for my $db_name (_attached_database_list($dbh)) {
0.000000,0,0.000000,$sql .= <<"END_SQL";
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT '$db_name' TABLE_SCHEM, tbl_name, upper(type) TABLE_TYPE, sql
0.000000,0,0.000000,FROM "$db_name".sqlite_master
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$sql .= <<'END_SQL';
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT 'main' TABLE_SCHEM, 'sqlite_master'      tbl_name, 'SYSTEM TABLE' TABLE_TYPE, NULL sql
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT 'temp' TABLE_SCHEM, 'sqlite_temp_master' tbl_name, 'SYSTEM TABLE' TABLE_TYPE, NULL sql
0.000000,0,0.000000,)
0.000000,0,0.000000,)
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,$attr = {} unless ref $attr eq 'HASH';
0.000000,0,0.000000,my $escape = defined $attr->{Escape} ? " ESCAPE '$attr->{Escape}'" : '';
0.000000,0,0.000000,if ( defined $sch_val ) {
0.000000,0,0.000000,push @where, "TABLE_SCHEM LIKE '$sch_val'$escape";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined $tbl_val ) {
0.000000,0,0.000000,push @where, "TABLE_NAME LIKE '$tbl_val'$escape";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined $typ_val ) {
0.000000,0,0.000000,my $table_type_list;
0.000000,0,0.000000,$typ_val =~ s/^\s+//;
0.000000,0,0.000000,$typ_val =~ s/\s+$//;
0.000000,0,0.000000,my @ttype_list = split (/\s*,\s*/, $typ_val);
0.000000,0,0.000000,foreach my $table_type (@ttype_list) {
0.000000,0,0.000000,if ($table_type !~ /^'.*'$/) {
0.000000,0,0.000000,$table_type = "'" . $table_type . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$table_type_list = join(', ', @ttype_list);
0.000000,0,0.000000,push @where, "TABLE_TYPE IN (\U$table_type_list)" if $table_type_list;
0.000000,0,0.000000,}
0.000000,0,0.000000,$sql .= ' WHERE ' . join("\n   AND ", @where ) . "\n" if @where;
0.000000,0,0.000000,$sql .= " ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $sth = $dbh->prepare($sql) or return undef;
0.000000,0,0.000000,$sth->execute or return undef;
0.000000,0,0.000000,$sth;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub primary_key_info {
0.000000,0,0.000000,my ($dbh, $catalog, $schema, $table, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $databases = $dbh->selectall_arrayref("PRAGMA database_list", {Slice => {}});
0.000000,0,0.000000,
0.000000,0,0.000000,my @pk_info;
0.000000,0,0.000000,for my $database (@$databases) {
0.000000,0,0.000000,my $dbname = $database->{name};
0.000000,0,0.000000,next if defined $schema && $schema ne '%' && $schema ne $dbname;
0.000000,0,0.000000,
0.000000,0,0.000000,my $quoted_dbname = $dbh->quote_identifier($dbname);
0.000000,0,0.000000,
0.000000,0,0.000000,my $master_table =
0.000000,0,0.000000,($dbname eq 'main') ? 'sqlite_master' :
0.000000,0,0.000000,($dbname eq 'temp') ? 'sqlite_temp_master' :
0.000000,0,0.000000,$quoted_dbname.'.sqlite_master';
0.000000,0,0.000000,
0.000000,0,0.000000,my $sth = $dbh->prepare("SELECT name, sql FROM $master_table WHERE type = ?");
0.000000,0,0.000000,$sth->execute("table");
0.000000,0,0.000000,while(my $row = $sth->fetchrow_hashref) {
0.000000,0,0.000000,my $tbname = $row->{name};
0.000000,0,0.000000,next if defined $table && $table ne '%' && $table ne $tbname;
0.000000,0,0.000000,
0.000000,0,0.000000,my $quoted_tbname = $dbh->quote_identifier($tbname);
0.000000,0,0.000000,my $t_sth = $dbh->prepare("PRAGMA $quoted_dbname.table_info($quoted_tbname)");
0.000000,0,0.000000,$t_sth->execute;
0.000000,0,0.000000,my @pk;
0.000000,0,0.000000,while(my $col = $t_sth->fetchrow_hashref) {
0.000000,0,0.000000,push @pk, $col->{name} if $col->{pk};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If there're multiple primary key columns, we need to
0.000000,0,0.000000,# find their order from one of the auto-generated unique
0.000000,0,0.000000,# indices (note that single column integer primary key
0.000000,0,0.000000,# doesn't create an index).
0.000000,0,0.000000,if (@pk > 1 and $row->{sql} =~ /\bPRIMARY\s+KEY\s*\(\s*
0.000000,0,0.000000,(
0.000000,0,0.000000,(?:
0.000000,0,0.000000,(
0.000000,0,0.000000,[a-z_][a-z0-9_]*
0.000000,0,0.000000,| (["'`])(?:\3\3|(?!\3).)+?\3(?!\3)
0.000000,0,0.000000,| \[[^\]]+\]
0.000000,0,0.000000,)
0.000000,0,0.000000,\s*,\s*
0.000000,0,0.000000,)+
0.000000,0,0.000000,(
0.000000,0,0.000000,[a-z_][a-z0-9_]*
0.000000,0,0.000000,| (["'`])(?:\5\5|(?!\5).)+?\5(?!\5)
0.000000,0,0.000000,| \[[^\]]+\]
0.000000,0,0.000000,)
0.000000,0,0.000000,)
0.000000,0,0.000000,\s*\)/six) {
0.000000,0,0.000000,my $pk_sql = $1;
0.000000,0,0.000000,@pk = ();
0.000000,0,0.000000,while($pk_sql =~ /
0.000000,0,0.000000,(
0.000000,0,0.000000,[a-z_][a-z0-9_]*
0.000000,0,0.000000,| (["'`])(?:\2\2|(?!\2).)+?\2(?!\2)
0.000000,0,0.000000,| \[([^\]]+)\]
0.000000,0,0.000000,)
0.000000,0,0.000000,(?:\s*,\s*|$)
0.000000,0,0.000000,/sixg) {
0.000000,0,0.000000,my($col, $quote, $brack) = ($1, $2, $3);
0.000000,0,0.000000,if ( defined $quote ) {
0.000000,0,0.000000,# Dequote "'`
0.000000,0,0.000000,$col = substr $col, 1, -1;
0.000000,0,0.000000,$col =~ s/$quote$quote/$quote/g;
0.000000,0,0.000000,} elsif ( defined $brack ) {
0.000000,0,0.000000,# Dequote []
0.000000,0,0.000000,$col = $brack;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @pk, $col;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $key_seq = 0;
0.000000,0,0.000000,foreach my $pk_field (@pk) {
0.000000,0,0.000000,push @pk_info, {
0.000000,0,0.000000,TABLE_SCHEM => $dbname,
0.000000,0,0.000000,TABLE_NAME  => $tbname,
0.000000,0,0.000000,COLUMN_NAME => $pk_field,
0.000000,0,0.000000,KEY_SEQ     => ++$key_seq,
0.000000,0,0.000000,PK_NAME     => 'PRIMARY KEY',
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $sponge = DBI->connect("DBI:Sponge:", '','')
0.000000,0,0.000000,or return $dbh->DBI::set_err($DBI::err, "DBI::Sponge: $DBI::errstr");
0.000000,0,0.000000,my @names = qw(TABLE_CAT TABLE_SCHEM TABLE_NAME COLUMN_NAME KEY_SEQ PK_NAME);
0.000000,0,0.000000,my $sth = $sponge->prepare( "primary_key_info", {
0.000000,0,0.000000,rows          => [ map { [ @{$_}{@names} ] } @pk_info ],
0.000000,0,0.000000,NUM_OF_FIELDS => scalar @names,
0.000000,0,0.000000,NAME          => \@names,
0.000000,0,0.000000,}) or return $dbh->DBI::set_err(
0.000000,0,0.000000,$sponge->err,
0.000000,0,0.000000,$sponge->errstr,
0.000000,0,0.000000,);
0.000000,0,0.000000,return $sth;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000005,1,0.000005,our %DBI_code_for_rule = ( # from DBI doc; curiously, they are not exported
0.000000,0,0.000000,# by the DBI module.
0.000000,0,0.000000,# codes for update/delete constraints
0.000000,0,0.000000,'CASCADE'             => 0,
0.000000,0,0.000000,'RESTRICT'            => 1,
0.000000,0,0.000000,'SET NULL'            => 2,
0.000000,0,0.000000,'NO ACTION'           => 3,
0.000000,0,0.000000,'SET DEFAULT'         => 4,
0.000000,0,0.000000,
0.000000,0,0.000000,# codes for deferrability
0.000000,0,0.000000,'INITIALLY DEFERRED'  => 5,
0.000000,0,0.000000,'INITIALLY IMMEDIATE' => 6,
0.000000,0,0.000000,'NOT DEFERRABLE'      => 7,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000004,1,0.000004,my @FOREIGN_KEY_INFO_ODBC = (
0.000000,0,0.000000,'PKTABLE_CAT',       # The primary (unique) key table catalog identifier.
0.000000,0,0.000000,'PKTABLE_SCHEM',     # The primary (unique) key table schema identifier.
0.000000,0,0.000000,'PKTABLE_NAME',      # The primary (unique) key table identifier.
0.000000,0,0.000000,'PKCOLUMN_NAME',     # The primary (unique) key column identifier.
0.000000,0,0.000000,'FKTABLE_CAT',       # The foreign key table catalog identifier.
0.000000,0,0.000000,'FKTABLE_SCHEM',     # The foreign key table schema identifier.
0.000000,0,0.000000,'FKTABLE_NAME',      # The foreign key table identifier.
0.000000,0,0.000000,'FKCOLUMN_NAME',     # The foreign key column identifier.
0.000000,0,0.000000,'KEY_SEQ',           # The column sequence number (starting with 1).
0.000000,0,0.000000,'UPDATE_RULE',       # The referential action for the UPDATE rule.
0.000000,0,0.000000,'DELETE_RULE',       # The referential action for the DELETE rule.
0.000000,0,0.000000,'FK_NAME',           # The foreign key name.
0.000000,0,0.000000,'PK_NAME',           # The primary (unique) key name.
0.000000,0,0.000000,'DEFERRABILITY',     # The deferrability of the foreign key constraint.
0.000000,0,0.000000,'UNIQUE_OR_PRIMARY', # qualifies the key referenced by the foreign key
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Column names below are not used, but listed just for completeness's sake.
0.000000,0,0.000000,# Maybe we could add an option so that the user can choose which field
0.000000,0,0.000000,# names will be returned; the DBI spec is not very clear about ODBC vs. CLI.
0.000003,1,0.000003,my @FOREIGN_KEY_INFO_SQL_CLI = qw(
0.000000,0,0.000000,UK_TABLE_CAT 
0.000000,0,0.000000,UK_TABLE_SCHEM
0.000000,0,0.000000,UK_TABLE_NAME
0.000000,0,0.000000,UK_COLUMN_NAME
0.000000,0,0.000000,FK_TABLE_CAT
0.000000,0,0.000000,FK_TABLE_SCHEM
0.000000,0,0.000000,FK_TABLE_NAME
0.000000,0,0.000000,FK_COLUMN_NAME
0.000000,0,0.000000,ORDINAL_POSITION
0.000000,0,0.000000,UPDATE_RULE
0.000000,0,0.000000,DELETE_RULE
0.000000,0,0.000000,FK_NAME
0.000000,0,0.000000,UK_NAME
0.000000,0,0.000000,DEFERABILITY
0.000000,0,0.000000,UNIQUE_OR_PRIMARY
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub foreign_key_info {
0.000000,0,0.000000,my ($dbh, $pk_catalog, $pk_schema, $pk_table, $fk_catalog, $fk_schema, $fk_table) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $databases = $dbh->selectall_arrayref("PRAGMA database_list", {Slice => {}});
0.000000,0,0.000000,
0.000000,0,0.000000,my @fk_info;
0.000000,0,0.000000,my %table_info;
0.000000,0,0.000000,for my $database (@$databases) {
0.000000,0,0.000000,my $dbname = $database->{name};
0.000000,0,0.000000,next if defined $fk_schema && $fk_schema ne '%' && $fk_schema ne $dbname;
0.000000,0,0.000000,
0.000000,0,0.000000,my $quoted_dbname = $dbh->quote_identifier($dbname);
0.000000,0,0.000000,my $master_table =
0.000000,0,0.000000,($dbname eq 'main') ? 'sqlite_master' :
0.000000,0,0.000000,($dbname eq 'temp') ? 'sqlite_temp_master' :
0.000000,0,0.000000,$quoted_dbname.'.sqlite_master';
0.000000,0,0.000000,
0.000000,0,0.000000,my $tables = $dbh->selectall_arrayref("SELECT name FROM $master_table WHERE type = ?", undef, "table");
0.000000,0,0.000000,for my $table (@$tables) {
0.000000,0,0.000000,my $tbname = $table->[0];
0.000000,0,0.000000,next if defined $fk_table && $fk_table ne '%' && $fk_table ne $tbname;
0.000000,0,0.000000,
0.000000,0,0.000000,my $quoted_tbname = $dbh->quote_identifier($tbname);
0.000000,0,0.000000,my $sth = $dbh->prepare("PRAGMA $quoted_dbname.foreign_key_list($quoted_tbname)");
0.000000,0,0.000000,$sth->execute;
0.000000,0,0.000000,while(my $row = $sth->fetchrow_hashref) {
0.000000,0,0.000000,next if defined $pk_table && $pk_table ne '%' && $pk_table ne $row->{table};
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($table_info{$row->{table}}) {
0.000000,0,0.000000,my $quoted_tb = $dbh->quote_identifier($row->{table});
0.000000,0,0.000000,for my $db (@$databases) {
0.000000,0,0.000000,my $quoted_db = $dbh->quote_identifier($db->{name});
0.000000,0,0.000000,my $t_sth = $dbh->prepare("PRAGMA $quoted_db.table_info($quoted_tb)");
0.000000,0,0.000000,$t_sth->execute;
0.000000,0,0.000000,my $cols = {};
0.000000,0,0.000000,while(my $r = $t_sth->fetchrow_hashref) {
0.000000,0,0.000000,$cols->{$r->{name}} = $r->{pk};
0.000000,0,0.000000,}
0.000000,0,0.000000,if (keys %$cols) {
0.000000,0,0.000000,$table_info{$row->{table}} = {
0.000000,0,0.000000,schema  => $db->{name},
0.000000,0,0.000000,columns => $cols,
0.000000,0,0.000000,};
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next if defined $pk_schema && $pk_schema ne '%' && $pk_schema ne $table_info{$row->{table}}{schema};
0.000000,0,0.000000,
0.000000,0,0.000000,push @fk_info, {
0.000000,0,0.000000,PKTABLE_CAT   => undef,
0.000000,0,0.000000,PKTABLE_SCHEM => $table_info{$row->{table}}{schema},
0.000000,0,0.000000,PKTABLE_NAME  => $row->{table},
0.000000,0,0.000000,PKCOLUMN_NAME => $row->{to},
0.000000,0,0.000000,FKTABLE_CAT   => undef,
0.000000,0,0.000000,FKTABLE_SCHEM => $dbname,
0.000000,0,0.000000,FKTABLE_NAME  => $tbname,
0.000000,0,0.000000,FKCOLUMN_NAME => $row->{from},
0.000000,0,0.000000,KEY_SEQ       => $row->{seq} + 1,
0.000000,0,0.000000,UPDATE_RULE   => $DBI_code_for_rule{$row->{on_update}},
0.000000,0,0.000000,DELETE_RULE   => $DBI_code_for_rule{$row->{on_delete}},
0.000000,0,0.000000,FK_NAME       => undef,
0.000000,0,0.000000,PK_NAME       => undef,
0.000000,0,0.000000,DEFERRABILITY => undef,
0.000000,0,0.000000,UNIQUE_OR_PRIMARY => $table_info{$row->{table}}{columns}{$row->{to}} ? 'PRIMARY' : 'UNIQUE',
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $sponge_dbh = DBI->connect("DBI:Sponge:", "", "")
0.000000,0,0.000000,or return $dbh->DBI::set_err($DBI::err, "DBI::Sponge: $DBI::errstr");
0.000000,0,0.000000,my $sponge_sth = $sponge_dbh->prepare("foreign_key_info", {
0.000000,0,0.000000,NAME          => \@FOREIGN_KEY_INFO_ODBC,
0.000000,0,0.000000,rows          => [ map { [@{$_}{@FOREIGN_KEY_INFO_ODBC} ] } @fk_info ],
0.000000,0,0.000000,NUM_OF_FIELDS => scalar(@FOREIGN_KEY_INFO_ODBC),
0.000000,0,0.000000,}) or return $dbh->DBI::set_err(
0.000000,0,0.000000,$sponge_dbh->err,
0.000000,0,0.000000,$sponge_dbh->errstr,
0.000000,0,0.000000,);
0.000000,0,0.000000,return $sponge_sth;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_info_all {
0.000000,0,0.000000,return; # XXX code just copied from DBD::Oracle, not yet thought about
0.000000,0,0.000000,#    return [
0.000000,0,0.000000,#        {
0.000000,0,0.000000,#            TYPE_NAME          =>  0,
0.000000,0,0.000000,#            DATA_TYPE          =>  1,
0.000000,0,0.000000,#            COLUMN_SIZE        =>  2,
0.000000,0,0.000000,#            LITERAL_PREFIX     =>  3,
0.000000,0,0.000000,#            LITERAL_SUFFIX     =>  4,
0.000000,0,0.000000,#            CREATE_PARAMS      =>  5,
0.000000,0,0.000000,#            NULLABLE           =>  6,
0.000000,0,0.000000,#            CASE_SENSITIVE     =>  7,
0.000000,0,0.000000,#            SEARCHABLE         =>  8,
0.000000,0,0.000000,#            UNSIGNED_ATTRIBUTE =>  9,
0.000000,0,0.000000,#            FIXED_PREC_SCALE   => 10,
0.000000,0,0.000000,#            AUTO_UNIQUE_VALUE  => 11,
0.000000,0,0.000000,#            LOCAL_TYPE_NAME    => 12,
0.000000,0,0.000000,#            MINIMUM_SCALE      => 13,
0.000000,0,0.000000,#            MAXIMUM_SCALE      => 14,
0.000000,0,0.000000,#            SQL_DATA_TYPE      => 15,
0.000000,0,0.000000,#            SQL_DATETIME_SUB   => 16,
0.000000,0,0.000000,#            NUM_PREC_RADIX     => 17,
0.000000,0,0.000000,#        },
0.000000,0,0.000000,#        [ 'CHAR', 1, 255, '\'', '\'', 'max length', 1, 1, 3,
0.000000,0,0.000000,#            undef, '0', '0', undef, undef, undef, 1, undef, undef
0.000000,0,0.000000,#        ],
0.000000,0,0.000000,#        [ 'NUMBER', 3, 38, undef, undef, 'precision,scale', 1, '0', 3,
0.000000,0,0.000000,#            '0', '0', '0', undef, '0', 38, 3, undef, 10
0.000000,0,0.000000,#        ],
0.000000,0,0.000000,#        [ 'DOUBLE', 8, 15, undef, undef, undef, 1, '0', 3,
0.000000,0,0.000000,#            '0', '0', '0', undef, undef, undef, 8, undef, 10
0.000000,0,0.000000,#        ],
0.000000,0,0.000000,#        [ 'DATE', 9, 19, '\'', '\'', undef, 1, '0', 3,
0.000000,0,0.000000,#            undef, '0', '0', undef, '0', '0', 11, undef, undef
0.000000,0,0.000000,#        ],
0.000000,0,0.000000,#        [ 'VARCHAR', 12, 1024*1024, '\'', '\'', 'max length', 1, 1, 3,
0.000000,0,0.000000,#            undef, '0', '0', undef, undef, undef, 12, undef, undef
0.000000,0,0.000000,#        ]
0.000000,0,0.000000,#    ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,my @COLUMN_INFO = qw(
0.000000,0,0.000000,TABLE_CAT
0.000000,0,0.000000,TABLE_SCHEM
0.000000,0,0.000000,TABLE_NAME
0.000000,0,0.000000,COLUMN_NAME
0.000000,0,0.000000,DATA_TYPE
0.000000,0,0.000000,TYPE_NAME
0.000000,0,0.000000,COLUMN_SIZE
0.000000,0,0.000000,BUFFER_LENGTH
0.000000,0,0.000000,DECIMAL_DIGITS
0.000000,0,0.000000,NUM_PREC_RADIX
0.000000,0,0.000000,NULLABLE
0.000000,0,0.000000,REMARKS
0.000000,0,0.000000,COLUMN_DEF
0.000000,0,0.000000,SQL_DATA_TYPE
0.000000,0,0.000000,SQL_DATETIME_SUB
0.000000,0,0.000000,CHAR_OCTET_LENGTH
0.000000,0,0.000000,ORDINAL_POSITION
0.000000,0,0.000000,IS_NULLABLE
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub column_info {
0.000000,0,0.000000,my ($dbh, $cat_val, $sch_val, $tbl_val, $col_val) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $col_val and $col_val eq '%' ) {
0.000000,0,0.000000,$col_val = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Get a list of all tables ordered by TABLE_SCHEM, TABLE_NAME
0.000000,0,0.000000,my $sql = <<'END_SQL';
0.000000,0,0.000000,SELECT TABLE_SCHEM, tbl_name TABLE_NAME
0.000000,0,0.000000,FROM (
0.000000,0,0.000000,SELECT 'main' TABLE_SCHEM, tbl_name
0.000000,0,0.000000,FROM sqlite_master
0.000000,0,0.000000,WHERE type IN ('table','view')
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT 'temp' TABLE_SCHEM, tbl_name
0.000000,0,0.000000,FROM sqlite_temp_master
0.000000,0,0.000000,WHERE type IN ('table','view')
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,
0.000000,0,0.000000,for my $db_name (_attached_database_list($dbh)) {
0.000000,0,0.000000,$sql .= <<"END_SQL";
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT '$db_name' TABLE_SCHEM, tbl_name
0.000000,0,0.000000,FROM "$db_name".sqlite_master
0.000000,0,0.000000,WHERE type IN ('table','view')
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$sql .= <<'END_SQL';
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT 'main' TABLE_SCHEM, 'sqlite_master' tbl_name
0.000000,0,0.000000,UNION ALL
0.000000,0,0.000000,SELECT 'temp' TABLE_SCHEM, 'sqlite_temp_master' tbl_name
0.000000,0,0.000000,)
0.000000,0,0.000000,END_SQL
0.000000,0,0.000000,
0.000000,0,0.000000,my @where;
0.000000,0,0.000000,if ( defined $sch_val ) {
0.000000,0,0.000000,push @where, "TABLE_SCHEM LIKE '$sch_val'";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined $tbl_val ) {
0.000000,0,0.000000,push @where, "TABLE_NAME LIKE '$tbl_val'";
0.000000,0,0.000000,}
0.000000,0,0.000000,$sql .= ' WHERE ' . join("\n   AND ", @where ) . "\n" if @where;
0.000000,0,0.000000,$sql .= " ORDER BY TABLE_SCHEM, TABLE_NAME\n";
0.000000,0,0.000000,my $sth_tables = $dbh->prepare($sql) or return undef;
0.000000,0,0.000000,$sth_tables->execute or return undef;
0.000000,0,0.000000,
0.000000,0,0.000000,# Taken from Fey::Loader::SQLite
0.000000,0,0.000000,my @cols;
0.000000,0,0.000000,while ( my ($schema, $table) = $sth_tables->fetchrow_array ) {
0.000000,0,0.000000,my $sth_columns = $dbh->prepare(qq{PRAGMA "$schema".table_info("$table")});
0.000000,0,0.000000,$sth_columns->execute;
0.000000,0,0.000000,
0.000000,0,0.000000,for ( my $position = 1; my $col_info = $sth_columns->fetchrow_hashref; $position++ ) {
0.000000,0,0.000000,if ( defined $col_val ) {
0.000000,0,0.000000,# This must do a LIKE comparison
0.000000,0,0.000000,my $sth = $dbh->prepare("SELECT '$col_info->{name}' LIKE '$col_val'") or return undef;
0.000000,0,0.000000,$sth->execute or return undef;
0.000000,0,0.000000,# Skip columns that don't match $col_val
0.000000,0,0.000000,next unless ($sth->fetchrow_array)[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %col = (
0.000000,0,0.000000,TABLE_SCHEM      => $schema,
0.000000,0,0.000000,TABLE_NAME       => $table,
0.000000,0,0.000000,COLUMN_NAME      => $col_info->{name},
0.000000,0,0.000000,ORDINAL_POSITION => $position,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = $col_info->{type};
0.000000,0,0.000000,if ( $type =~ s/(\w+) ?\((\d+)(?:,(\d+))?\)/$1/ ) {
0.000000,0,0.000000,$col{COLUMN_SIZE}    = $2;
0.000000,0,0.000000,$col{DECIMAL_DIGITS} = $3;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$col{TYPE_NAME} = $type;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $col_info->{dflt_value} ) {
0.000000,0,0.000000,$col{COLUMN_DEF} = $col_info->{dflt_value}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $col_info->{notnull} ) {
0.000000,0,0.000000,$col{NULLABLE}    = 0;
0.000000,0,0.000000,$col{IS_NULLABLE} = 'NO';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$col{NULLABLE}    = 1;
0.000000,0,0.000000,$col{IS_NULLABLE} = 'YES';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @cols, \%col;
0.000000,0,0.000000,}
0.000000,0,0.000000,$sth_columns->finish;
0.000000,0,0.000000,}
0.000000,0,0.000000,$sth_tables->finish;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sponge = DBI->connect("DBI:Sponge:", '','')
0.000000,0,0.000000,or return $dbh->DBI::set_err($DBI::err, "DBI::Sponge: $DBI::errstr");
0.000000,0,0.000000,$sponge->prepare( "column_info", {
0.000000,0,0.000000,rows          => [ map { [ @{$_}{@COLUMN_INFO} ] } @cols ],
0.000000,0,0.000000,NUM_OF_FIELDS => scalar @COLUMN_INFO,
0.000000,0,0.000000,NAME          => [ @COLUMN_INFO ],
0.000000,0,0.000000,} ) or return $dbh->DBI::set_err(
0.000000,0,0.000000,$sponge->err,
0.000000,0,0.000000,$sponge->errstr,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#======================================================================
0.000000,0,0.000000,# An internal tied hash package used for %DBD::SQLite::COLLATION, to
0.000000,0,0.000000,# prevent people from unintentionally overriding globally registered collations.
0.000000,0,0.000000,
0.000000,0,0.000000,package DBD::SQLite::_WriteOnceHash;
0.000000,0,0.000000,
0.000002,1,0.000002,require Tie::Hash;
0.000000,0,0.000000,
0.000009,1,0.000009,our @ISA = qw(Tie::StdHash);
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH {
0.000007,1,0.000007,bless {}, $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORE {
0.000007,2,0.000004,! exists $_[0]->{$_[1]} or die "entry $_[1] already registered";
0.000013,2,0.000007,$_[0]->{$_[1]} = $_[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DELETE {
0.000000,0,0.000000,die "deletion of entry $_[1] is forbidden";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,1,0.000014,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
