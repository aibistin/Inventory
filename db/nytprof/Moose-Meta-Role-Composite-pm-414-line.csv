# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Meta::Role::Composite;
0.000000,0,0.000000,BEGIN {
0.000009,1,0.000009,$Moose::Meta::Role::Composite::AUTHORITY = 'cpan:STEVAN';
0.000034,1,0.000034,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::Role::Composite::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000037,2,0.000019,use strict;
0.000034,2,0.000017,use warnings;
0.000053,2,0.000027,use metaclass;
0.000000,0,0.000000,
0.000041,2,0.000021,use Class::Load qw(load_class);
0.000035,2,0.000018,use Scalar::Util 'blessed';
0.000000,0,0.000000,
0.000618,2,0.000309,use base 'Moose::Meta::Role';
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we need to override the ->name
0.000000,0,0.000000,# method from Class::MOP::Package
0.000000,0,0.000000,# since we don't have an actual
0.000000,0,0.000000,# package for this.
0.000000,0,0.000000,# - SL
0.000015,1,0.000015,__PACKAGE__->meta->add_attribute('name' => (
0.000000,0,0.000000,reader => 'name',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# Again, since we don't have a real
0.000000,0,0.000000,# package to store our methods in,
0.000000,0,0.000000,# we use a HASH ref instead.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('_methods' => (
0.000000,0,0.000000,reader  => '_method_map',
0.000000,0,0.000000,default => sub { {} },
0.000017,1,0.000017,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute(
0.000000,0,0.000000,'application_role_summation_class',
0.000000,0,0.000000,reader  => 'application_role_summation_class',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Application::RoleSummation',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ($class, %params) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# the roles param is required ...
0.000000,0,0.000000,foreach ( @{$params{roles}} ) {
0.000000,0,0.000000,unless ( $_->isa('Moose::Meta::Role') ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error("The list of roles must be instances of Moose::Meta::Role, not $_");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @composition_roles = map {
0.000000,0,0.000000,$_->composition_class_roles
0.000000,0,0.000000,} @{ $params{roles} };
0.000000,0,0.000000,
0.000000,0,0.000000,if (@composition_roles) {
0.000000,0,0.000000,my $meta = Moose::Meta::Class->create_anon_class(
0.000000,0,0.000000,superclasses => [ $class ],
0.000000,0,0.000000,roles        => [ @composition_roles ],
0.000000,0,0.000000,cache        => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,$class = $meta->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# and the name is created from the
0.000000,0,0.000000,# roles if one has not been provided
0.000000,0,0.000000,$params{name} ||= (join "|" => map { $_->name } @{$params{roles}});
0.000000,0,0.000000,$class->_new(\%params);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is largely a copy of what's in Moose::Meta::Role (itself
0.000000,0,0.000000,# largely a copy of Class::MOP::Class). However, we can't actually
0.000000,0,0.000000,# call add_package_symbol, because there's no package into which to
0.000000,0,0.000000,# add the symbol.
0.000000,0,0.000000,sub add_method {
0.000000,0,0.000000,my ($self, $method_name, $method) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( defined $method_name && $method_name ) {
0.000000,0,0.000000,Moose->throw_error("You must define a method name");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $body;
0.000000,0,0.000000,if (blessed($method)) {
0.000000,0,0.000000,$body = $method->body;
0.000000,0,0.000000,if ($method->package_name ne $self->name) {
0.000000,0,0.000000,$method = $method->clone(
0.000000,0,0.000000,package_name => $self->name,
0.000000,0,0.000000,name         => $method_name
0.000000,0,0.000000,) if $method->can('clone');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$body = $method;
0.000000,0,0.000000,$method = $self->wrap_method_body( body => $body, name => $method_name );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_method_map->{$method_name} = $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_method_list {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return keys %{ $self->_method_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_local_methods {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return values %{ $self->_method_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_method {
0.000000,0,0.000000,my ($self, $method_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return exists $self->_method_map->{$method_name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_method {
0.000000,0,0.000000,my ($self, $method_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_method_map->{$method_name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_params {
0.000000,0,0.000000,my ($self, $role_params) = @_;
0.000000,0,0.000000,load_class($self->application_role_summation_class);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->application_role_summation_class->new(
0.000000,0,0.000000,role_params => $role_params,
0.000000,0,0.000000,)->apply($self);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinitialize {
0.000000,0,0.000000,my ( $class, $old_meta, @args ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,Moose->throw_error(
0.000000,0,0.000000,'Moose::Meta::Role::Composite instances can only be reinitialized from an existing metaclass instance'
0.000000,0,0.000000,)
0.000000,0,0.000000,if !blessed $old_meta
0.000000,0,0.000000,|| !$old_meta->isa('Moose::Meta::Role::Composite');
0.000000,0,0.000000,
0.000000,0,0.000000,my %existing_classes = map { $_ => $old_meta->$_() } qw(
0.000000,0,0.000000,application_role_summation_class
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $old_meta->meta->clone_object( $old_meta, %existing_classes, @args );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: An object to represent the set of roles
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
