# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package DateTime;
0.000000,0,0.000000,{
0.000005,2,0.000003,$DateTime::VERSION = '1.03';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000052,2,0.000026,use 5.008001;
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000164,2,0.000082,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000004,2,0.000002,my $loaded = 0;
0.000000,0,0.000000,
0.000004,1,0.000004,unless ( $ENV{PERL_DATETIME_PP} ) {
0.000002,1,0.000002,local $@;
0.000003,1,0.000003,eval {
0.000002,1,0.000002,require XSLoader;
0.000000,0,0.000000,XSLoader::load(
0.000000,0,0.000000,__PACKAGE__,
0.000000,0,0.000000,exists $DateTime::{VERSION} && ${ $DateTime::{VERSION} }
0.000224,1,0.000224,? ${ $DateTime::{VERSION} }
0.000000,0,0.000000,: 42
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,$DateTime::IsPurePerl = 0;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000001,1,0.000001,die $@ if $@ && $@ !~ /object version|loadable object/;
0.000000,0,0.000000,
0.000002,1,0.000002,$loaded = 1 unless $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,if ($loaded) {
0.000000,0,0.000000,require DateTimePPExtra
0.000000,0,0.000000,unless defined &DateTime::_normalize_tai_seconds;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,require DateTimePP;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000036,2,0.000018,use Carp;
0.000127,2,0.000063,use DateTime::Duration;
0.000032,2,0.000016,use DateTime::Helpers;
0.000145,3,0.000048,use DateTime::Locale 0.41;
0.000167,3,0.000056,use DateTime::TimeZone 1.09;
0.000000,0,0.000000,use Params::Validate 0.76
0.000054,3,0.000018,qw( validate validate_pos UNDEF SCALAR BOOLEAN HASHREF OBJECT );
0.000041,2,0.000020,use POSIX qw(floor);
0.000058,2,0.000029,use Try::Tiny;
0.000000,0,0.000000,
0.000000,0,0.000000,# for some reason, overloading doesn't work unless fallback is listed
0.000000,0,0.000000,# early.
0.000000,0,0.000000,#
0.000000,0,0.000000,# 3rd parameter ( $_[2] ) means the parameters are 'reversed'.
0.000000,0,0.000000,# see: "Calling conventions for binary operations" in overload docs.
0.000000,0,0.000000,#
0.000000,0,0.000000,use overload (
0.000011,1,0.000011,'fallback' => 1,
0.000000,0,0.000000,'<=>'      => '_compare_overload',
0.000000,0,0.000000,'cmp'      => '_string_compare_overload',
0.000000,0,0.000000,'""'       => '_stringify',
0.000000,0,0.000000,'-'        => '_subtract_overload',
0.000000,0,0.000000,'+'        => '_add_overload',
0.000000,0,0.000000,'eq'       => '_string_equals_overload',
0.000000,0,0.000000,'ne'       => '_string_not_equals_overload',
0.000034,1,0.000034,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Have to load this after overloading is defined, after BEGIN blocks
0.000000,0,0.000000,# or else weird crashes ensue
0.000091,1,0.000091,require DateTime::Infinite;
0.000000,0,0.000000,
0.000042,2,0.000021,use constant MAX_NANOSECONDS => 1_000_000_000;    # 1E9 = almost 32 bits
0.000000,0,0.000000,
0.000042,2,0.000021,use constant INFINITY     => ( 9**9**9 );
0.000041,2,0.000020,use constant NEG_INFINITY => -1 * ( 9**9**9 );
0.000036,2,0.000018,use constant NAN          => INFINITY - INFINITY;
0.000000,0,0.000000,
0.000038,2,0.000019,use constant SECONDS_PER_DAY => 86400;
0.000000,0,0.000000,
0.000056,2,0.000028,use constant duration_class => 'DateTime::Duration';
0.000000,0,0.000000,
0.000002,1,0.000002,my ( @MonthLengths, @LeapYearMonthLengths );
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000003,1,0.000003,@MonthLengths = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
0.000000,0,0.000000,
0.000002,1,0.000002,@LeapYearMonthLengths = @MonthLengths;
0.000007,1,0.000007,$LeapYearMonthLengths[1]++;
0.002912,1,0.002912,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,# I'd rather use Class::Data::Inheritable for this, but there's no
0.000000,0,0.000000,# way to add the module-loading behavior to an accessor it
0.000000,0,0.000000,# creates, despite what its docs say!
0.000005,2,0.000002,my $DefaultLocale;
0.000000,0,0.000000,
0.000000,0,0.000000,sub DefaultLocale {
0.000002,1,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000004,1,0.000004,if (@_) {
0.000002,1,0.000002,my $lang = shift;
0.000000,0,0.000000,
0.000006,1,0.000006,DateTime::Locale->load($lang);
0.000000,0,0.000000,
0.000002,1,0.000002,$DefaultLocale = $lang;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,return $DefaultLocale;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# backwards compat
0.000006,1,0.000006,*DefaultLanguage = \&DefaultLocale;
0.000000,0,0.000000,}
0.000006,1,0.000006,__PACKAGE__->DefaultLocale('en_US');
0.000000,0,0.000000,
0.000000,0,0.000000,my $BasicValidate = {
0.000000,0,0.000000,year => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'is an integer' => sub { $_[0] =~ /^-?\d+$/ }
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,month => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,default   => 1,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'an integer between 1 and 12' =>
0.000000,0,0.000000,sub { $_[0] =~ /^\d+$/ && $_[0] >= 1 && $_[0] <= 12 }
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,day => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,default   => 1,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'an integer which is a possible valid day of month' =>
0.000000,0,0.000000,sub { $_[0] =~ /^\d+$/ && $_[0] >= 1 && $_[0] <= 31 }
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,hour => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,default   => 0,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'an integer between 0 and 23' =>
0.000000,0,0.000000,sub { $_[0] =~ /^\d+$/ && $_[0] >= 0 && $_[0] <= 23 },
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,minute => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,default   => 0,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'an integer between 0 and 59' =>
0.000000,0,0.000000,sub { $_[0] =~ /^\d+$/ && $_[0] >= 0 && $_[0] <= 59 },
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,second => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,default   => 0,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'an integer between 0 and 61' =>
0.000000,0,0.000000,sub { $_[0] =~ /^\d+$/ && $_[0] >= 0 && $_[0] <= 61 },
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000000,0,0.000000,nanosecond => {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,default   => 0,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'a positive integer' => sub { $_[0] =~ /^\d+$/ && $_[0] >= 0 },
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,locale => {
0.000000,0,0.000000,type    => SCALAR | OBJECT,
0.000000,0,0.000000,default => undef
0.000000,0,0.000000,},
0.000000,0,0.000000,language => {
0.000000,0,0.000000,type     => SCALAR | OBJECT,
0.000000,0,0.000000,optional => 1
0.000000,0,0.000000,},
0.000000,0,0.000000,formatter => {
0.000000,0,0.000000,type      => UNDEF | SCALAR | OBJECT,
0.000000,0,0.000000,optional  => 1,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'can format_datetime' =>
0.000000,0,0.000000,sub { defined $_[0] ? $_[0]->can('format_datetime') : 1 },
0.000000,0,0.000000,},
0.000000,0,0.000000,},
0.000029,1,0.000029,};
0.000000,0,0.000000,
0.000006,1,0.000006,my $NewValidate = {
0.000000,0,0.000000,%$BasicValidate,
0.000000,0,0.000000,time_zone => {
0.000000,0,0.000000,type    => SCALAR | OBJECT,
0.000000,0,0.000000,default => 'floating'
0.000000,0,0.000000,},
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p = validate( @_, $NewValidate );
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak(
0.000000,0,0.000000,"Invalid day of month (day = $p{day} - month = $p{month} - year = $p{year})\n"
0.000000,0,0.000000,)
0.000000,0,0.000000,if $p{day} > 28
0.000000,0,0.000000,&& $p{day} > $class->_month_length( $p{year}, $p{month} );
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->_new(%p);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p     = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak('Constructor called with reference, we expected a package')
0.000000,0,0.000000,if ref $class;
0.000000,0,0.000000,
0.000000,0,0.000000,# If this method is called from somewhere other than new(), then some of
0.000000,0,0.000000,# these default may not get applied.
0.000000,0,0.000000,$p{month}      = 1          unless exists $p{month};
0.000000,0,0.000000,$p{day}        = 1          unless exists $p{day};
0.000000,0,0.000000,$p{hour}       = 0          unless exists $p{hour};
0.000000,0,0.000000,$p{minute}     = 0          unless exists $p{minute};
0.000000,0,0.000000,$p{second}     = 0          unless exists $p{second};
0.000000,0,0.000000,$p{nanosecond} = 0          unless exists $p{nanosecond};
0.000000,0,0.000000,$p{time_zone}  = 'floating' unless exists $p{time_zone};
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = bless {}, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,$p{locale} = delete $p{language} if exists $p{language};
0.000000,0,0.000000,$p{locale} = $class->DefaultLocale unless defined $p{locale};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref $p{locale} ) {
0.000000,0,0.000000,$self->{locale} = $p{locale};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{locale} = DateTime::Locale->load( $p{locale} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{tz} = (
0.000000,0,0.000000,ref $p{time_zone}
0.000000,0,0.000000,? $p{time_zone}
0.000000,0,0.000000,: DateTime::TimeZone->new( name => $p{time_zone} )
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_rd_days} = $class->_ymd2rd( @p{qw( year month day )} );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_rd_secs}
0.000000,0,0.000000,= $class->_time_as_seconds( @p{qw( hour minute second )} );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{offset_modifier} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{rd_nanosecs} = $p{nanosecond};
0.000000,0,0.000000,$self->{formatter}   = $p{formatter};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_normalize_nanoseconds( $self->{local_rd_secs},
0.000000,0,0.000000,$self->{rd_nanosecs} );
0.000000,0,0.000000,
0.000000,0,0.000000,# Set this explicitly since it can't be calculated accurately
0.000000,0,0.000000,# without knowing our time zone offset, and it's possible that the
0.000000,0,0.000000,# offset can't be calculated without having at least a rough guess
0.000000,0,0.000000,# of the datetime's year. This year need not be correct, as long
0.000000,0,0.000000,# as its equal or greater to the correct number, so we fudge by
0.000000,0,0.000000,# adding one to the local year given to the constructor.
0.000000,0,0.000000,$self->{utc_year} = $p{year} + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_calc_utc_rd;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_offset_modifier( $p{second} );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_calc_local_rd;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $p{second} > 59 ) {
0.000000,0,0.000000,if (
0.000000,0,0.000000,$self->{tz}->is_floating
0.000000,0,0.000000,||
0.000000,0,0.000000,
0.000000,0,0.000000,# If true, this means that the actual calculated leap
0.000000,0,0.000000,# second does not occur in the second given to new()
0.000000,0,0.000000,( $self->{utc_rd_secs} - 86399 < $p{second} - 59 )
0.000000,0,0.000000,) {
0.000000,0,0.000000,Carp::croak("Invalid second value ($p{second})\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This method exists for the benefit of internal methods which create
0.000000,0,0.000000,# a new object based on the current object, like set() and truncate().
0.000000,0,0.000000,sub _new_from_self {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %p    = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %old = map { $_ => $self->$_() }
0.000000,0,0.000000,qw( year month day hour minute second nanosecond
0.000000,0,0.000000,locale time_zone );
0.000000,0,0.000000,$old{formatter} = $self->formatter()
0.000000,0,0.000000,if defined $self->formatter();
0.000000,0,0.000000,
0.000000,0,0.000000,my $method = delete $p{_skip_validation} ? '_new' : 'new';
0.000000,0,0.000000,
0.000000,0,0.000000,return ( ref $self )->$method( %old, %p );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_offset_modifier {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{offset_modifier} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $self->{tz}->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,my $second       = shift;
0.000000,0,0.000000,my $utc_is_valid = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $utc_rd_days = $self->{utc_rd_days};
0.000000,0,0.000000,
0.000000,0,0.000000,my $offset
0.000000,0,0.000000,= $utc_is_valid ? $self->offset : $self->_offset_for_local_datetime;
0.000000,0,0.000000,
0.000000,0,0.000000,if (   $offset >= 0
0.000000,0,0.000000,&& $self->{local_rd_secs} >= $offset ) {
0.000000,0,0.000000,if ( $second < 60 && $offset > 0 ) {
0.000000,0,0.000000,$self->{offset_modifier}
0.000000,0,0.000000,= $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_rd_secs} += $self->{offset_modifier};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (
0.000000,0,0.000000,$second == 60
0.000000,0,0.000000,&& (
0.000000,0,0.000000,( $self->{local_rd_secs} == $offset && $offset > 0 )
0.000000,0,0.000000,|| (   $offset == 0
0.000000,0,0.000000,&& $self->{local_rd_secs} > 86399 )
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,my $mod
0.000000,0,0.000000,= $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $mod == 0 ) {
0.000000,0,0.000000,$self->{utc_rd_secs} -= $mod;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_normalize_seconds;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($offset < 0
0.000000,0,0.000000,&& $self->{local_rd_secs} >= SECONDS_PER_DAY + $offset ) {
0.000000,0,0.000000,if ( $second < 60 ) {
0.000000,0,0.000000,$self->{offset_modifier}
0.000000,0,0.000000,= $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_rd_secs} += $self->{offset_modifier};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($second == 60
0.000000,0,0.000000,&& $self->{local_rd_secs} == SECONDS_PER_DAY + $offset ) {
0.000000,0,0.000000,my $mod
0.000000,0,0.000000,= $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $mod == 0 ) {
0.000000,0,0.000000,$self->{utc_rd_secs} -= $mod;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_normalize_seconds;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _calc_utc_rd {
0.000003,2,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000157,2,0.000079,delete $self->{utc_c};
0.000000,0,0.000000,
0.000028,2,0.000014,if ( $self->{tz}->is_utc || $self->{tz}->is_floating ) {
0.000004,2,0.000002,$self->{utc_rd_days} = $self->{local_rd_days};
0.000004,2,0.000002,$self->{utc_rd_secs} = $self->{local_rd_secs};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $offset = $self->_offset_for_local_datetime;
0.000000,0,0.000000,
0.000000,0,0.000000,$offset += $self->{offset_modifier};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{utc_rd_days} = $self->{local_rd_days};
0.000000,0,0.000000,$self->{utc_rd_secs} = $self->{local_rd_secs} - $offset;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We account for leap seconds in the new() method and nowhere else
0.000000,0,0.000000,# except date math.
0.000037,2,0.000018,$self->_normalize_tai_seconds( $self->{utc_rd_days},
0.000000,0,0.000000,$self->{utc_rd_secs} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _normalize_seconds {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $self->{utc_rd_secs} >= 0 && $self->{utc_rd_secs} <= 86399;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->{tz}->is_floating ) {
0.000000,0,0.000000,$self->_normalize_tai_seconds( $self->{utc_rd_days},
0.000000,0,0.000000,$self->{utc_rd_secs} );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->_normalize_leap_seconds( $self->{utc_rd_days},
0.000000,0,0.000000,$self->{utc_rd_secs} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _calc_local_rd {
0.000003,2,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000004,2,0.000002,delete $self->{local_c};
0.000000,0,0.000000,
0.000000,0,0.000000,# We must short circuit for UTC times or else we could end up with
0.000000,0,0.000000,# loops between DateTime.pm and DateTime::TimeZone
0.000021,2,0.000010,if ( $self->{tz}->is_utc || $self->{tz}->is_floating ) {
0.000004,2,0.000002,$self->{local_rd_days} = $self->{utc_rd_days};
0.000003,2,0.000002,$self->{local_rd_secs} = $self->{utc_rd_secs};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $offset = $self->offset;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_rd_days} = $self->{utc_rd_days};
0.000000,0,0.000000,$self->{local_rd_secs} = $self->{utc_rd_secs} + $offset;
0.000000,0,0.000000,
0.000000,0,0.000000,# intentionally ignore leap seconds here
0.000000,0,0.000000,$self->_normalize_tai_seconds( $self->{local_rd_days},
0.000000,0,0.000000,$self->{local_rd_secs} );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_rd_secs} += $self->{offset_modifier};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000025,2,0.000013,$self->_calc_local_components;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _calc_local_components {
0.000003,2,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,@{ $self->{local_c} }{
0.000026,2,0.000013,qw( year month day day_of_week
0.000000,0,0.000000,day_of_year quarter day_of_quarter)
0.000000,0,0.000000,}
0.000000,0,0.000000,= $self->_rd2ymd( $self->{local_rd_days}, 1 );
0.000000,0,0.000000,
0.000031,2,0.000015,@{ $self->{local_c} }{qw( hour minute second )}
0.000000,0,0.000000,= $self->_seconds_as_components( $self->{local_rd_secs},
0.000000,0,0.000000,$self->{utc_rd_secs}, $self->{offset_modifier} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _calc_utc_components {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,die "Cannot get UTC components before UTC RD has been calculated\n"
0.000000,0,0.000000,unless defined $self->{utc_rd_days};
0.000000,0,0.000000,
0.000000,0,0.000000,@{ $self->{utc_c} }{qw( year month day )}
0.000000,0,0.000000,= $self->_rd2ymd( $self->{utc_rd_days} );
0.000000,0,0.000000,
0.000000,0,0.000000,@{ $self->{utc_c} }{qw( hour minute second )}
0.000000,0,0.000000,= $self->_seconds_as_components( $self->{utc_rd_secs} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _utc_ymd {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_calc_utc_components unless exists $self->{utc_c}{year};
0.000000,0,0.000000,
0.000000,0,0.000000,return @{ $self->{utc_c} }{qw( year month day )};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _utc_hms {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_calc_utc_components unless exists $self->{utc_c}{hour};
0.000000,0,0.000000,
0.000000,0,0.000000,return @{ $self->{utc_c} }{qw( hour minute second )};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000021,2,0.000011,my $spec = {
0.000000,0,0.000000,epoch     => { regex => qr/^-?(?:\d+(?:\.\d*)?|\.\d+)$/ },
0.000000,0,0.000000,locale    => { type  => SCALAR | OBJECT, optional => 1 },
0.000000,0,0.000000,language  => { type  => SCALAR | OBJECT, optional => 1 },
0.000000,0,0.000000,time_zone => { type  => SCALAR | OBJECT, optional => 1 },
0.000000,0,0.000000,formatter => {
0.000000,0,0.000000,type     => SCALAR | OBJECT, can => 'format_datetime',
0.000000,0,0.000000,optional => 1
0.000000,0,0.000000,},
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub from_epoch {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p = validate( @_, $spec );
0.000000,0,0.000000,
0.000000,0,0.000000,my %args;
0.000000,0,0.000000,# Epoch may come from Time::HiRes, so it may not be an integer.
0.000000,0,0.000000,my ( $int, $dec ) = $p{epoch} =~ /^(-?\d+)?(\.\d+)?/;
0.000000,0,0.000000,$int ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,$args{nanosecond} = int( $dec * MAX_NANOSECONDS )
0.000000,0,0.000000,if $dec;
0.000000,0,0.000000,
0.000000,0,0.000000,# Note, for very large negative values this may give a
0.000000,0,0.000000,# blatantly wrong answer.
0.000000,0,0.000000,@args{qw( second minute hour day month year )}
0.000000,0,0.000000,= ( gmtime($int) )[ 0 .. 5 ];
0.000000,0,0.000000,$args{year} += 1900;
0.000000,0,0.000000,$args{month}++;
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = $class->_new( %p, %args, time_zone => 'UTC' );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->set_time_zone( $p{time_zone} ) if exists $p{time_zone};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# use scalar time in case someone's loaded Time::Piece
0.000000,0,0.000000,sub now { shift->from_epoch( epoch => ( scalar time ), @_ ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub today { shift->now(@_)->truncate( to => 'day' ) }
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000008,2,0.000004,my $spec = {
0.000000,0,0.000000,object => {
0.000000,0,0.000000,type => OBJECT,
0.000000,0,0.000000,can  => 'utc_rd_values',
0.000000,0,0.000000,},
0.000000,0,0.000000,locale    => { type => SCALAR | OBJECT, optional => 1 },
0.000000,0,0.000000,language  => { type => SCALAR | OBJECT, optional => 1 },
0.000000,0,0.000000,formatter => {
0.000000,0,0.000000,type     => SCALAR | OBJECT, can => 'format_datetime',
0.000000,0,0.000000,optional => 1
0.000000,0,0.000000,},
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub from_object {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p = validate( @_, $spec );
0.000000,0,0.000000,
0.000000,0,0.000000,my $object = delete $p{object};
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $rd_days, $rd_secs, $rd_nanosecs ) = $object->utc_rd_values;
0.000000,0,0.000000,
0.000000,0,0.000000,# A kludge because until all calendars are updated to return all
0.000000,0,0.000000,# three values, $rd_nanosecs could be undef
0.000000,0,0.000000,$rd_nanosecs ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a big hack to let _seconds_as_components operate naively
0.000000,0,0.000000,# on the given value. If the object _is_ on a leap second, we'll
0.000000,0,0.000000,# add that to the generated seconds value later.
0.000000,0,0.000000,my $leap_seconds = 0;
0.000000,0,0.000000,if (   $object->can('time_zone')
0.000000,0,0.000000,&& !$object->time_zone->is_floating
0.000000,0,0.000000,&& $rd_secs > 86399
0.000000,0,0.000000,&& $rd_secs <= $class->_day_length($rd_days) ) {
0.000000,0,0.000000,$leap_seconds = $rd_secs - 86399;
0.000000,0,0.000000,$rd_secs -= $leap_seconds;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %args;
0.000000,0,0.000000,@args{qw( year month day )} = $class->_rd2ymd($rd_days);
0.000000,0,0.000000,@args{qw( hour minute second )}
0.000000,0,0.000000,= $class->_seconds_as_components($rd_secs);
0.000000,0,0.000000,$args{nanosecond} = $rd_nanosecs;
0.000000,0,0.000000,
0.000000,0,0.000000,$args{second} += $leap_seconds;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = $class->new( %p, %args, time_zone => 'UTC' );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $object->can('time_zone') ) {
0.000000,0,0.000000,$new->set_time_zone( $object->time_zone );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$new->set_time_zone('floating');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,my $LastDayOfMonthValidate = {%$NewValidate};
0.000005,1,0.000005,foreach ( keys %$LastDayOfMonthValidate ) {
0.000029,11,0.000003,my %copy = %{ $LastDayOfMonthValidate->{$_} };
0.000000,0,0.000000,
0.000017,11,0.000002,delete $copy{default};
0.000019,11,0.000002,$copy{optional} = 1 unless $_ eq 'year' || $_ eq 'month';
0.000000,0,0.000000,
0.000034,11,0.000003,$LastDayOfMonthValidate->{$_} = \%copy;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub last_day_of_month {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p = validate( @_, $LastDayOfMonthValidate );
0.000000,0,0.000000,
0.000000,0,0.000000,my $day = $class->_month_length( $p{year}, $p{month} );
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->_new( %p, day => $day );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _month_length {
0.000000,0,0.000000,return (
0.000000,0,0.000000,$_[0]->_is_leap_year( $_[1] )
0.000000,0,0.000000,? $LeapYearMonthLengths[ $_[2] - 1 ]
0.000000,0,0.000000,: $MonthLengths[ $_[2] - 1 ]
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,my $FromDayOfYearValidate = {%$NewValidate};
0.000007,1,0.000007,foreach ( keys %$FromDayOfYearValidate ) {
0.000016,11,0.000001,next if $_ eq 'month' || $_ eq 'day';
0.000000,0,0.000000,
0.000021,9,0.000002,my %copy = %{ $FromDayOfYearValidate->{$_} };
0.000000,0,0.000000,
0.000014,9,0.000002,delete $copy{default};
0.000014,9,0.000002,$copy{optional} = 1 unless $_ eq 'year' || $_ eq 'month';
0.000000,0,0.000000,
0.000028,9,0.000003,$FromDayOfYearValidate->{$_} = \%copy;
0.000000,0,0.000000,}
0.000000,0,0.000000,$FromDayOfYearValidate->{day_of_year} = {
0.000000,0,0.000000,type      => SCALAR,
0.000000,0,0.000000,callbacks => {
0.000000,0,0.000000,'is between 1 and 366' => sub { $_[0] >= 1 && $_[0] <= 366 }
0.000000,0,0.000000,}
0.000006,1,0.000006,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub from_day_of_year {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p = validate( @_, $FromDayOfYearValidate );
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak("$p{year} is not a leap year.\n")
0.000000,0,0.000000,if $p{day_of_year} == 366 && !$class->_is_leap_year( $p{year} );
0.000000,0,0.000000,
0.000000,0,0.000000,my $month = 1;
0.000000,0,0.000000,my $day   = delete $p{day_of_year};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $day > 31 ) {
0.000000,0,0.000000,my $length = $class->_month_length( $p{year}, $month );
0.000000,0,0.000000,
0.000000,0,0.000000,while ( $day > $length ) {
0.000000,0,0.000000,$day -= $length;
0.000000,0,0.000000,$month++;
0.000000,0,0.000000,$length = $class->_month_length( $p{year}, $month );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->_new(
0.000000,0,0.000000,%p,
0.000000,0,0.000000,month => $month,
0.000000,0,0.000000,day   => $day,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub formatter { $_[0]->{formatter} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone { bless { %{ $_[0] } }, ref $_[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub year {
0.000000,0,0.000000,Carp::carp('year() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{local_c}{year};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ce_year {
0.000000,0,0.000000,$_[0]->{local_c}{year} <= 0
0.000000,0,0.000000,? $_[0]->{local_c}{year} - 1
0.000000,0,0.000000,: $_[0]->{local_c}{year};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub era_name { $_[0]->{locale}->era_wide->[ $_[0]->_era_index() ] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub era_abbr { $_[0]->{locale}->era_abbreviated->[ $_[0]->_era_index() ] }
0.000000,0,0.000000,
0.000000,0,0.000000,# deprecated
0.000005,1,0.000005,*era = \&era_abbr;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _era_index { $_[0]->{local_c}{year} <= 0 ? 0 : 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub christian_era { $_[0]->ce_year > 0 ? 'AD' : 'BC' }
0.000000,0,0.000000,sub secular_era   { $_[0]->ce_year > 0 ? 'CE' : 'BCE' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub year_with_era           { ( abs $_[0]->ce_year ) . $_[0]->era_abbr }
0.000000,0,0.000000,sub year_with_christian_era { ( abs $_[0]->ce_year ) . $_[0]->christian_era }
0.000000,0,0.000000,sub year_with_secular_era   { ( abs $_[0]->ce_year ) . $_[0]->secular_era }
0.000000,0,0.000000,
0.000000,0,0.000000,sub month {
0.000000,0,0.000000,Carp::carp('month() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{local_c}{month};
0.000000,0,0.000000,}
0.000004,1,0.000004,*mon = \&month;
0.000000,0,0.000000,
0.000000,0,0.000000,sub month_0 { $_[0]->{local_c}{month} - 1 }
0.000003,1,0.000003,*mon_0 = \&month_0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub month_name { $_[0]->{locale}->month_format_wide->[ $_[0]->month_0() ] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub month_abbr {
0.000000,0,0.000000,$_[0]->{locale}->month_format_abbreviated->[ $_[0]->month_0() ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_month {
0.000000,0,0.000000,Carp::carp('day_of_month() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,$_[0]->{local_c}{day};
0.000000,0,0.000000,}
0.000003,1,0.000003,*day  = \&day_of_month;
0.000003,1,0.000003,*mday = \&day_of_month;
0.000000,0,0.000000,
0.007243,2,0.003622,sub weekday_of_month { use integer; ( ( $_[0]->day - 1 ) / 7 ) + 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub quarter { $_[0]->{local_c}{quarter} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub quarter_name {
0.000000,0,0.000000,$_[0]->{locale}->quarter_format_wide->[ $_[0]->quarter_0() ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quarter_abbr {
0.000000,0,0.000000,$_[0]->{locale}->quarter_format_abbreviated->[ $_[0]->quarter_0() ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quarter_0 { $_[0]->{local_c}{quarter} - 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_month_0 { $_[0]->{local_c}{day} - 1 }
0.000003,1,0.000003,*day_0  = \&day_of_month_0;
0.000003,1,0.000003,*mday_0 = \&day_of_month_0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_week { $_[0]->{local_c}{day_of_week} }
0.000003,1,0.000003,*wday = \&day_of_week;
0.000003,1,0.000003,*dow  = \&day_of_week;
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_week_0 { $_[0]->{local_c}{day_of_week} - 1 }
0.000003,1,0.000003,*wday_0 = \&day_of_week_0;
0.000003,1,0.000003,*dow_0  = \&day_of_week_0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub local_day_of_week {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $day = $self->day_of_week();
0.000000,0,0.000000,
0.000000,0,0.000000,my $local_first_day = $self->{locale}->first_day_of_week();
0.000000,0,0.000000,
0.000000,0,0.000000,my $d = ( ( 8 - $local_first_day ) + $day ) % 7;
0.000000,0,0.000000,
0.000000,0,0.000000,return $d == 0 ? 7 : $d;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_name { $_[0]->{locale}->day_format_wide->[ $_[0]->day_of_week_0() ] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_abbr {
0.000000,0,0.000000,$_[0]->{locale}->day_format_abbreviated->[ $_[0]->day_of_week_0() ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_quarter { $_[0]->{local_c}{day_of_quarter} }
0.000003,1,0.000003,*doq = \&day_of_quarter;
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_quarter_0 { $_[0]->day_of_quarter - 1 }
0.000003,1,0.000003,*doq_0 = \&day_of_quarter_0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_year { $_[0]->{local_c}{day_of_year} }
0.000003,1,0.000003,*doy = \&day_of_year;
0.000000,0,0.000000,
0.000000,0,0.000000,sub day_of_year_0 { $_[0]->{local_c}{day_of_year} - 1 }
0.000003,1,0.000003,*doy_0 = \&day_of_year_0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub am_or_pm {
0.000000,0,0.000000,$_[0]->{locale}->am_pm_abbreviated->[ $_[0]->hour() < 12 ? 0 : 1 ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ymd {
0.000000,0,0.000000,my ( $self, $sep ) = @_;
0.000000,0,0.000000,$sep = '-' unless defined $sep;
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,"%0.4d%s%0.2d%s%0.2d",
0.000000,0,0.000000,$self->year,             $sep,
0.000000,0,0.000000,$self->{local_c}{month}, $sep,
0.000000,0,0.000000,$self->{local_c}{day}
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000003,1,0.000003,*date = \&ymd;
0.000000,0,0.000000,
0.000000,0,0.000000,sub mdy {
0.000000,0,0.000000,my ( $self, $sep ) = @_;
0.000000,0,0.000000,$sep = '-' unless defined $sep;
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,"%0.2d%s%0.2d%s%0.4d",
0.000000,0,0.000000,$self->{local_c}{month}, $sep,
0.000000,0,0.000000,$self->{local_c}{day},   $sep,
0.000000,0,0.000000,$self->year
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dmy {
0.000000,0,0.000000,my ( $self, $sep ) = @_;
0.000000,0,0.000000,$sep = '-' unless defined $sep;
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,"%0.2d%s%0.2d%s%0.4d",
0.000000,0,0.000000,$self->{local_c}{day},   $sep,
0.000000,0,0.000000,$self->{local_c}{month}, $sep,
0.000000,0,0.000000,$self->year
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub hour {
0.000000,0,0.000000,Carp::carp('hour() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{local_c}{hour};
0.000000,0,0.000000,}
0.000000,0,0.000000,sub hour_1 { $_[0]->{local_c}{hour} == 0 ? 24 : $_[0]->{local_c}{hour} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub hour_12 { my $h = $_[0]->hour % 12; return $h ? $h : 12 }
0.000000,0,0.000000,sub hour_12_0 { $_[0]->hour % 12 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub minute {
0.000000,0,0.000000,Carp::carp('minute() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{local_c}{minute};
0.000000,0,0.000000,}
0.000003,1,0.000003,*min = \&minute;
0.000000,0,0.000000,
0.000000,0,0.000000,sub second {
0.000000,0,0.000000,Carp::carp('second() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{local_c}{second};
0.000000,0,0.000000,}
0.000003,1,0.000003,*sec = \&second;
0.000000,0,0.000000,
0.000000,0,0.000000,sub fractional_second { $_[0]->second + $_[0]->nanosecond / MAX_NANOSECONDS }
0.000000,0,0.000000,
0.000000,0,0.000000,sub nanosecond {
0.000000,0,0.000000,Carp::carp('nanosecond() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{rd_nanosecs};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub millisecond { floor( $_[0]->{rd_nanosecs} / 1000000 ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub microsecond { floor( $_[0]->{rd_nanosecs} / 1000 ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub leap_seconds {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if $self->{tz}->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,return DateTime->_accumulated_leap_seconds( $self->{utc_rd_days} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->iso8601 unless $self->{formatter};
0.000000,0,0.000000,return $self->{formatter}->format_datetime($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub hms {
0.000000,0,0.000000,my ( $self, $sep ) = @_;
0.000000,0,0.000000,$sep = ':' unless defined $sep;
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,"%0.2d%s%0.2d%s%0.2d",
0.000000,0,0.000000,$self->{local_c}{hour},   $sep,
0.000000,0,0.000000,$self->{local_c}{minute}, $sep,
0.000000,0,0.000000,$self->{local_c}{second}
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# don't want to override CORE::time()
0.000003,1,0.000003,*DateTime::time = \&hms;
0.000000,0,0.000000,
0.000000,0,0.000000,sub iso8601 { join 'T', $_[0]->ymd('-'), $_[0]->hms(':') }
0.000003,1,0.000003,*datetime = \&iso8601;
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_leap_year { $_[0]->_is_leap_year( $_[0]->year ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub week {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( defined $self->{local_c}{week_year} ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# This algorithm was taken from Date::Calc's DateCalc.c file
0.000000,0,0.000000,my $jan_one_dow_m1
0.000000,0,0.000000,= ( ( $self->_ymd2rd( $self->year, 1, 1 ) + 6 ) % 7 );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{local_c}{week_number}
0.000000,0,0.000000,= int( ( ( $self->day_of_year - 1 ) + $jan_one_dow_m1 ) / 7 );
0.000000,0,0.000000,$self->{local_c}{week_number}++ if $jan_one_dow_m1 < 4;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->{local_c}{week_number} == 0 ) {
0.000000,0,0.000000,$self->{local_c}{week_year} = $self->year - 1;
0.000000,0,0.000000,$self->{local_c}{week_number}
0.000000,0,0.000000,= $self->_weeks_in_year( $self->{local_c}{week_year} );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->{local_c}{week_number} == 53
0.000000,0,0.000000,&& $self->_weeks_in_year( $self->year ) == 52 ) {
0.000000,0,0.000000,$self->{local_c}{week_number} = 1;
0.000000,0,0.000000,$self->{local_c}{week_year}   = $self->year + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{local_c}{week_year} = $self->year;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return @{ $self->{local_c} }{ 'week_year', 'week_number' };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _weeks_in_year {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $year = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $dow = $self->_ymd2rd( $year, 1, 1 ) % 7;
0.000000,0,0.000000,
0.000000,0,0.000000,# Tears starting with a Thursday and leap years starting with a Wednesday
0.000000,0,0.000000,# have 53 weeks.
0.000000,0,0.000000,return ( $dow == 4 || ( $dow == 3 && $self->_is_leap_year($year) ) )
0.000000,0,0.000000,? 53
0.000000,0,0.000000,: 52;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub week_year   { ( $_[0]->week )[0] }
0.000000,0,0.000000,sub week_number { ( $_[0]->week )[1] }
0.000000,0,0.000000,
0.000000,0,0.000000,# ISO says that the first week of a year is the first week containing
0.000000,0,0.000000,# a Thursday. Extending that says that the first week of the month is
0.000000,0,0.000000,# the first week containing a Thursday. ICU agrees.
0.000000,0,0.000000,sub week_of_month {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $thu  = $self->day + 4 - $self->day_of_week;
0.000000,0,0.000000,return int( ( $thu + 6 ) / 7 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub time_zone {
0.000000,0,0.000000,Carp::carp('time_zone() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{tz};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub offset { $_[0]->{tz}->offset_for_datetime( $_[0] ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _offset_for_local_datetime {
0.000000,0,0.000000,$_[0]->{tz}->offset_for_local_datetime( $_[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_dst { $_[0]->{tz}->is_dst_for_datetime( $_[0] ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub time_zone_long_name  { $_[0]->{tz}->name }
0.000000,0,0.000000,sub time_zone_short_name { $_[0]->{tz}->short_name_for_datetime( $_[0] ) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub locale {
0.000000,0,0.000000,Carp::carp('locale() is a read-only accessor') if @_ > 1;
0.000000,0,0.000000,return $_[0]->{locale};
0.000000,0,0.000000,}
0.000003,1,0.000003,*language = \&locale;
0.000000,0,0.000000,
0.000000,0,0.000000,sub utc_rd_values {
0.000000,0,0.000000,@{ $_[0] }{ 'utc_rd_days', 'utc_rd_secs', 'rd_nanosecs' };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub local_rd_values {
0.000000,0,0.000000,@{ $_[0] }{ 'local_rd_days', 'local_rd_secs', 'rd_nanosecs' };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: no nanoseconds, no leap seconds
0.000000,0,0.000000,sub utc_rd_as_seconds {
0.000000,0,0.000000,( $_[0]->{utc_rd_days} * SECONDS_PER_DAY ) + $_[0]->{utc_rd_secs};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: no nanoseconds, no leap seconds
0.000000,0,0.000000,sub local_rd_as_seconds {
0.000000,0,0.000000,( $_[0]->{local_rd_days} * SECONDS_PER_DAY ) + $_[0]->{local_rd_secs};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# RD 1 is JD 1,721,424.5 - a simple offset
0.000000,0,0.000000,sub jd {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $jd = $self->{utc_rd_days} + 1_721_424.5;
0.000000,0,0.000000,
0.000000,0,0.000000,my $day_length = $self->_day_length( $self->{utc_rd_days} );
0.000000,0,0.000000,
0.000000,0,0.000000,return (  $jd
0.000000,0,0.000000,+ ( $self->{utc_rd_secs} / $day_length )
0.000000,0,0.000000,+ ( $self->{rd_nanosecs} / $day_length / MAX_NANOSECONDS ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mjd { $_[0]->jd - 2_400_000.5 }
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000003,1,0.000003,my %strftime_patterns = (
0.000000,0,0.000000,'a' => sub { $_[0]->day_abbr },
0.000000,0,0.000000,'A' => sub { $_[0]->day_name },
0.000000,0,0.000000,'b' => sub { $_[0]->month_abbr },
0.000000,0,0.000000,'B' => sub { $_[0]->month_name },
0.000000,0,0.000000,'c' => sub {
0.000000,0,0.000000,$_[0]->format_cldr( $_[0]->{locale}->datetime_format_default() );
0.000000,0,0.000000,},
0.000000,0,0.000000,'C' => sub { int( $_[0]->year / 100 ) },
0.000000,0,0.000000,'d' => sub { sprintf( '%02d', $_[0]->day_of_month ) },
0.000000,0,0.000000,'D' => sub { $_[0]->strftime('%m/%d/%y') },
0.000000,0,0.000000,'e' => sub { sprintf( '%2d', $_[0]->day_of_month ) },
0.000000,0,0.000000,'F' => sub { $_[0]->ymd('-') },
0.000000,0,0.000000,'g' => sub { substr( $_[0]->week_year, -2 ) },
0.000000,0,0.000000,'G' => sub { $_[0]->week_year },
0.000000,0,0.000000,'H' => sub { sprintf( '%02d', $_[0]->hour ) },
0.000000,0,0.000000,'I' => sub { sprintf( '%02d', $_[0]->hour_12 ) },
0.000000,0,0.000000,'j' => sub { sprintf( '%03d', $_[0]->day_of_year ) },
0.000000,0,0.000000,'k' => sub { sprintf( '%2d', $_[0]->hour ) },
0.000000,0,0.000000,'l' => sub { sprintf( '%2d', $_[0]->hour_12 ) },
0.000000,0,0.000000,'m' => sub { sprintf( '%02d', $_[0]->month ) },
0.000000,0,0.000000,'M' => sub { sprintf( '%02d', $_[0]->minute ) },
0.000000,0,0.000000,'n' => sub {"\n"},                     # should this be OS-sensitive?
0.000000,0,0.000000,'N' => \&_format_nanosecs,
0.000000,0,0.000000,'p' => sub { $_[0]->am_or_pm() },
0.000000,0,0.000000,'P' => sub { lc $_[0]->am_or_pm() },
0.000000,0,0.000000,'r' => sub { $_[0]->strftime('%I:%M:%S %p') },
0.000000,0,0.000000,'R' => sub { $_[0]->strftime('%H:%M') },
0.000000,0,0.000000,'s' => sub { $_[0]->epoch },
0.000000,0,0.000000,'S' => sub { sprintf( '%02d', $_[0]->second ) },
0.000000,0,0.000000,'t' => sub {"\t"},
0.000000,0,0.000000,'T' => sub { $_[0]->strftime('%H:%M:%S') },
0.000000,0,0.000000,'u' => sub { $_[0]->day_of_week },
0.000000,0,0.000000,'U' => sub {
0.000000,0,0.000000,my $sun = $_[0]->day_of_year - ( $_[0]->day_of_week + 7 ) % 7;
0.000000,0,0.000000,return sprintf( '%02d', int( ( $sun + 6 ) / 7 ) );
0.000000,0,0.000000,},
0.000000,0,0.000000,'V' => sub { sprintf( '%02d', $_[0]->week_number ) },
0.000000,0,0.000000,'w' => sub {
0.000000,0,0.000000,my $dow = $_[0]->day_of_week;
0.000000,0,0.000000,return $dow % 7;
0.000000,0,0.000000,},
0.000000,0,0.000000,'W' => sub {
0.000000,0,0.000000,my $mon = $_[0]->day_of_year - ( $_[0]->day_of_week + 6 ) % 7;
0.000000,0,0.000000,return sprintf( '%02d', int( ( $mon + 6 ) / 7 ) );
0.000000,0,0.000000,},
0.000000,0,0.000000,'x' => sub {
0.000000,0,0.000000,$_[0]->format_cldr( $_[0]->{locale}->date_format_default() );
0.000000,0,0.000000,},
0.000000,0,0.000000,'X' => sub {
0.000000,0,0.000000,$_[0]->format_cldr( $_[0]->{locale}->time_format_default() );
0.000000,0,0.000000,},
0.000000,0,0.000000,'y' => sub { sprintf( '%02d', substr( $_[0]->year, -2 ) ) },
0.000000,0,0.000000,'Y' => sub { return $_[0]->year },
0.000000,0,0.000000,'z' => sub { DateTime::TimeZone->offset_as_string( $_[0]->offset ) },
0.000000,0,0.000000,'Z' => sub { $_[0]->{tz}->short_name_for_datetime( $_[0] ) },
0.000000,0,0.000000,'%' => sub {'%'},
0.000049,1,0.000049,);
0.000000,0,0.000000,
0.000002,1,0.000002,$strftime_patterns{h} = $strftime_patterns{b};
0.000000,0,0.000000,
0.000000,0,0.000000,sub strftime {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# make a copy or caller's scalars get munged
0.000000,0,0.000000,my @patterns = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @r;
0.000000,0,0.000000,foreach my $p (@patterns) {
0.000000,0,0.000000,$p =~ s/
0.000000,0,0.000000,(?:
0.000000,0,0.000000,%\{(\w+)\}       # method name like %{day_name}
0.000000,0,0.000000,|
0.000000,0,0.000000,%([%a-zA-Z])     # single character specifier like %d
0.000000,0,0.000000,|
0.000000,0,0.000000,%(\d+)N          # special case for %N
0.000000,0,0.000000,)
0.000000,0,0.000000,/
0.000000,0,0.000000,( $1
0.000000,0,0.000000,? ( $self->can($1) ? $self->$1() : "\%{$1}" )
0.000000,0,0.000000,: $2
0.000000,0,0.000000,? ( $strftime_patterns{$2} ? $strftime_patterns{$2}->($self) : "\%$2" )
0.000000,0,0.000000,: $3
0.000000,0,0.000000,? $strftime_patterns{N}->($self, $3)
0.000000,0,0.000000,: ''  # this won't happen
0.000000,0,0.000000,)
0.000000,0,0.000000,/sgex;
0.000000,0,0.000000,
0.000000,0,0.000000,return $p unless wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,push @r, $p;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return @r;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,# It's an array because the order in which the regexes are checked
0.000000,0,0.000000,# is important. These patterns are similar to the ones Java uses,
0.000000,0,0.000000,# but not quite the same. See
0.000000,0,0.000000,# http://www.unicode.org/reports/tr35/tr35-9.html#Date_Format_Patterns.
0.000005,1,0.000005,my @patterns = (
0.000000,0,0.000000,qr/GGGGG/ =>
0.000000,0,0.000000,sub { $_[0]->{locale}->era_narrow->[ $_[0]->_era_index() ] },
0.000000,0,0.000000,qr/GGGG/   => 'era_name',
0.000000,0,0.000000,qr/G{1,3}/ => 'era_abbr',
0.000000,0,0.000000,
0.000000,0,0.000000,qr/(y{3,5})/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->year() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,# yy is a weird special case, where it must be exactly 2 digits
0.000000,0,0.000000,qr/yy/ => sub {
0.000000,0,0.000000,my $year = $_[0]->year();
0.000000,0,0.000000,my $y2 = substr( $year, -2, 2 ) if length $year > 2;
0.000000,0,0.000000,$y2 *= -1 if $year < 0;
0.000000,0,0.000000,$_[0]->_zero_padded_number( 'yy', $y2 );
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/y/    => sub { $_[0]->year() },
0.000000,0,0.000000,qr/(u+)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->year() ) },
0.000000,0,0.000000,qr/(Y+)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->week_year() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/QQQQ/ => 'quarter_name',
0.000000,0,0.000000,qr/QQQ/  => 'quarter_abbr',
0.000000,0,0.000000,qr/(QQ?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->quarter() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/qqqq/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->quarter_stand_alone_wide()
0.000000,0,0.000000,->[ $_[0]->quarter_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/qqq/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->quarter_stand_alone_abbreviated()
0.000000,0,0.000000,->[ $_[0]->quarter_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/(qq?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->quarter() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/MMMMM/ =>
0.000000,0,0.000000,sub { $_[0]->{locale}->month_format_narrow->[ $_[0]->month_0() ] }
0.000000,0,0.000000,,
0.000000,0,0.000000,qr/MMMM/  => 'month_name',
0.000000,0,0.000000,qr/MMM/   => 'month_abbr',
0.000000,0,0.000000,qr/(MM?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->month() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/LLLLL/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->month_stand_alone_narrow->[ $_[0]->month_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/LLLL/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->month_stand_alone_wide->[ $_[0]->month_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/LLL/ => sub {
0.000000,0,0.000000,$_[0]->{locale}
0.000000,0,0.000000,->month_stand_alone_abbreviated->[ $_[0]->month_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/(LL?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->month() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/(ww?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->week_number() ) },
0.000000,0,0.000000,qr/W/ => 'week_of_month',
0.000000,0,0.000000,
0.000000,0,0.000000,qr/(dd?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_month() ) },
0.000000,0,0.000000,qr/(D{1,3})/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_year() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/F/    => 'weekday_of_month',
0.000000,0,0.000000,qr/(g+)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->mjd() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/EEEEE/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->day_format_narrow->[ $_[0]->day_of_week_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/EEEE/   => 'day_name',
0.000000,0,0.000000,qr/E{1,3}/ => 'day_abbr',
0.000000,0,0.000000,
0.000000,0,0.000000,qr/eeeee/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->day_format_narrow->[ $_[0]->day_of_week_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/eeee/  => 'day_name',
0.000000,0,0.000000,qr/eee/   => 'day_abbr',
0.000000,0,0.000000,qr/(ee?)/ => sub {
0.000000,0,0.000000,$_[0]->_zero_padded_number( $1, $_[0]->local_day_of_week() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,qr/ccccc/ => sub {
0.000000,0,0.000000,$_[0]->{locale}
0.000000,0,0.000000,->day_stand_alone_narrow->[ $_[0]->day_of_week_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/cccc/ => sub {
0.000000,0,0.000000,$_[0]->{locale}->day_stand_alone_wide->[ $_[0]->day_of_week_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/ccc/ => sub {
0.000000,0,0.000000,$_[0]->{locale}
0.000000,0,0.000000,->day_stand_alone_abbreviated->[ $_[0]->day_of_week_0() ];
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/(cc?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_week() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/a/ => 'am_or_pm',
0.000000,0,0.000000,
0.000000,0,0.000000,qr/(hh?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_12() ) },
0.000000,0,0.000000,qr/(HH?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->hour() ) },
0.000000,0,0.000000,qr/(KK?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_12_0() ) },
0.000000,0,0.000000,qr/(kk?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_1() ) },
0.000000,0,0.000000,qr/(jj?)/ => sub {
0.000000,0,0.000000,my $h
0.000000,0,0.000000,= $_[0]->{locale}->prefers_24_hour_time()
0.000000,0,0.000000,? $_[0]->hour()
0.000000,0,0.000000,: $_[0]->hour_12();
0.000000,0,0.000000,$_[0]->_zero_padded_number( $1, $h );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,qr/(mm?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->minute() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/(ss?)/ =>
0.000000,0,0.000000,sub { $_[0]->_zero_padded_number( $1, $_[0]->second() ) },
0.000000,0,0.000000,
0.000000,0,0.000000,# I'm not sure this is what is wanted (notably the trailing
0.000000,0,0.000000,# and leading zeros it can produce), but once again the LDML
0.000000,0,0.000000,# spec is not all that clear.
0.000000,0,0.000000,qr/(S+)/ => sub {
0.000000,0,0.000000,my $l   = length $1;
0.000000,0,0.000000,my $val = sprintf( "%.${l}f",
0.000000,0,0.000000,$_[0]->fractional_second() - $_[0]->second() );
0.000000,0,0.000000,$val =~ s/^0\.//;
0.000000,0,0.000000,$val || 0;
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/A+/ =>
0.000000,0,0.000000,sub { ( $_[0]->{local_rd_secs} * 1000 ) + $_[0]->millisecond() },
0.000000,0,0.000000,
0.000000,0,0.000000,qr/zzzz/   => sub { $_[0]->time_zone_long_name() },
0.000000,0,0.000000,qr/z{1,3}/ => sub { $_[0]->time_zone_short_name() },
0.000000,0,0.000000,qr/ZZZZ/   => sub {
0.000000,0,0.000000,$_[0]->time_zone_short_name()
0.000000,0,0.000000,. DateTime::TimeZone->offset_as_string( $_[0]->offset() );
0.000000,0,0.000000,},
0.000000,0,0.000000,qr/Z{1,3}/ =>
0.000000,0,0.000000,sub { DateTime::TimeZone->offset_as_string( $_[0]->offset() ) },
0.000000,0,0.000000,qr/vvvv/   => sub { $_[0]->time_zone_long_name() },
0.000000,0,0.000000,qr/v{1,3}/ => sub { $_[0]->time_zone_short_name() },
0.000000,0,0.000000,qr/VVVV/   => sub { $_[0]->time_zone_long_name() },
0.000000,0,0.000000,qr/V{1,3}/ => sub { $_[0]->time_zone_short_name() },
0.000337,1,0.000337,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _zero_padded_number {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $size = length shift;
0.000000,0,0.000000,my $val  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf( "%0${size}d", $val );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _space_padded_string {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $size = length shift;
0.000000,0,0.000000,my $val  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf( "% ${size}s", $val );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_cldr {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# make a copy or caller's scalars get munged
0.000000,0,0.000000,my @patterns = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @r;
0.000000,0,0.000000,foreach my $p (@patterns) {
0.000000,0,0.000000,$p =~ s/\G
0.000000,0,0.000000,(?:
0.000000,0,0.000000,'((?:[^']|'')*)' # quote escaped bit of text
0.000000,0,0.000000,# it needs to end with one
0.000000,0,0.000000,# quote not followed by
0.000000,0,0.000000,# another
0.000000,0,0.000000,|
0.000000,0,0.000000,(([a-zA-Z])\3*)     # could be a pattern
0.000000,0,0.000000,|
0.000000,0,0.000000,(.)                 # anything else
0.000000,0,0.000000,)
0.000000,0,0.000000,/
0.000000,0,0.000000,defined $1
0.000000,0,0.000000,? $1
0.000000,0,0.000000,: defined $2
0.000000,0,0.000000,? $self->_cldr_pattern($2)
0.000000,0,0.000000,: defined $4
0.000000,0,0.000000,? $4
0.000000,0,0.000000,: undef # should never get here
0.000000,0,0.000000,/sgex;
0.000000,0,0.000000,
0.000000,0,0.000000,$p =~ s/\'\'/\'/g;
0.000000,0,0.000000,
0.000000,0,0.000000,return $p unless wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,push @r, $p;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return @r;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _cldr_pattern {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my $pattern = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,for ( my $i = 0; $i < @patterns; $i += 2 ) {
0.000000,0,0.000000,if ( $pattern =~ /$patterns[$i]/ ) {
0.000000,0,0.000000,my $sub = $patterns[ $i + 1 ];
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->$sub();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $pattern;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _format_nanosecs {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $precision = @_ ? shift : 9;
0.000000,0,0.000000,
0.000000,0,0.000000,my $divide_by = 10**( 9 - $precision );
0.000000,0,0.000000,
0.000000,0,0.000000,return sprintf(
0.000000,0,0.000000,'%0' . $precision . 'u',
0.000000,0,0.000000,floor( $self->{rd_nanosecs} / $divide_by )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub epoch {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{utc_c}{epoch}
0.000000,0,0.000000,if exists $self->{utc_c}{epoch};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{utc_c}{epoch}
0.000000,0,0.000000,= ( $self->{utc_rd_days} - 719163 ) * SECONDS_PER_DAY
0.000000,0,0.000000,+ $self->{utc_rd_secs};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub hires_epoch {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $epoch = $self->epoch;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef unless defined $epoch;
0.000000,0,0.000000,
0.000000,0,0.000000,my $nano = $self->{rd_nanosecs} / MAX_NANOSECONDS;
0.000000,0,0.000000,
0.000000,0,0.000000,return $epoch + $nano;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_finite   {1}
0.000000,0,0.000000,sub is_infinite {0}
0.000000,0,0.000000,
0.000000,0,0.000000,# added for benefit of DateTime::TimeZone
0.000000,0,0.000000,sub utc_year { $_[0]->{utc_year} }
0.000000,0,0.000000,
0.000000,0,0.000000,# returns a result that is relative to the first datetime
0.000000,0,0.000000,sub subtract_datetime {
0.000000,0,0.000000,my $dt1 = shift;
0.000000,0,0.000000,my $dt2 = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$dt2 = $dt2->clone->set_time_zone( $dt1->time_zone )
0.000000,0,0.000000,unless $dt1->time_zone eq $dt2->time_zone;
0.000000,0,0.000000,
0.000000,0,0.000000,# We only want a negative duration if $dt2 > $dt1 ($self)
0.000000,0,0.000000,my ( $bigger, $smaller, $negative ) = (
0.000000,0,0.000000,$dt1 >= $dt2
0.000000,0,0.000000,? ( $dt1, $dt2, 0 )
0.000000,0,0.000000,: ( $dt2, $dt1, 1 )
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $is_floating = $dt1->time_zone->is_floating
0.000000,0,0.000000,&& $dt2->time_zone->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,my $minute_length = 60;
0.000000,0,0.000000,unless ($is_floating) {
0.000000,0,0.000000,my ( $utc_rd_days, $utc_rd_secs ) = $smaller->utc_rd_values;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $utc_rd_secs >= 86340 && !$is_floating ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# If the smaller of the two datetimes occurs in the last
0.000000,0,0.000000,# UTC minute of the UTC day, then that minute may not be
0.000000,0,0.000000,# 60 seconds long. If we need to subtract a minute from
0.000000,0,0.000000,# the larger datetime's minutes count in order to adjust
0.000000,0,0.000000,# the seconds difference to be positive, we need to know
0.000000,0,0.000000,# how long that minute was. If one of the datetimes is
0.000000,0,0.000000,# floating, we just assume a minute is 60 seconds.
0.000000,0,0.000000,
0.000000,0,0.000000,$minute_length = $dt1->_day_length($utc_rd_days) - 86340;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a gross hack that basically figures out if the bigger of
0.000000,0,0.000000,# the two datetimes is the day of a DST change. If it's a 23 hour
0.000000,0,0.000000,# day (switching _to_ DST) then we subtract 60 minutes from the
0.000000,0,0.000000,# local time. If it's a 25 hour day then we add 60 minutes to the
0.000000,0,0.000000,# local time.
0.000000,0,0.000000,#
0.000000,0,0.000000,# This produces the most "intuitive" results, though there are
0.000000,0,0.000000,# still reversibility problems with the resultant duration.
0.000000,0,0.000000,#
0.000000,0,0.000000,# However, if the two objects are on the same (local) date, and we
0.000000,0,0.000000,# are not crossing a DST change, we don't want to invoke the hack
0.000000,0,0.000000,# - see 38local-subtract.t
0.000000,0,0.000000,my $bigger_min = $bigger->hour * 60 + $bigger->minute;
0.000000,0,0.000000,if (   $bigger->time_zone->has_dst_changes
0.000000,0,0.000000,&& $bigger->is_dst != $smaller->is_dst ) {
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger_min -= 60
0.000000,0,0.000000,
0.000000,0,0.000000,# it's a 23 hour (local) day
0.000000,0,0.000000,if (
0.000000,0,0.000000,$bigger->is_dst
0.000000,0,0.000000,&& do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,my $prev_day = eval { $bigger->clone->subtract( days => 1 ) };
0.000000,0,0.000000,$prev_day && !$prev_day->is_dst ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger_min += 60
0.000000,0,0.000000,
0.000000,0,0.000000,# it's a 25 hour (local) day
0.000000,0,0.000000,if (
0.000000,0,0.000000,!$bigger->is_dst
0.000000,0,0.000000,&& do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,my $prev_day = eval { $bigger->clone->subtract( days => 1 ) };
0.000000,0,0.000000,$prev_day && $prev_day->is_dst ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $months, $days, $minutes, $seconds, $nanoseconds )
0.000000,0,0.000000,= $dt1->_adjust_for_positive_difference(
0.000000,0,0.000000,$bigger->year * 12 + $bigger->month,
0.000000,0,0.000000,$smaller->year * 12 + $smaller->month,
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger->day, $smaller->day,
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger_min, $smaller->hour * 60 + $smaller->minute,
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger->second, $smaller->second,
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger->nanosecond, $smaller->nanosecond,
0.000000,0,0.000000,
0.000000,0,0.000000,$minute_length,
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX - using the smaller as the month length is
0.000000,0,0.000000,# somewhat arbitrary, we could also use the bigger -
0.000000,0,0.000000,# either way we have reversibility problems
0.000000,0,0.000000,$dt1->_month_length( $smaller->year, $smaller->month ),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($negative) {
0.000000,0,0.000000,for ( $months, $days, $minutes, $seconds, $nanoseconds ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Some versions of Perl can end up with -0 if we do "0 * -1"!!
0.000000,0,0.000000,$_ *= -1 if $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $dt1->duration_class->new(
0.000000,0,0.000000,months      => $months,
0.000000,0,0.000000,days        => $days,
0.000000,0,0.000000,minutes     => $minutes,
0.000000,0,0.000000,seconds     => $seconds,
0.000000,0,0.000000,nanoseconds => $nanoseconds,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _adjust_for_positive_difference {
0.000000,0,0.000000,my (
0.000000,0,0.000000,$self,
0.000000,0,0.000000,$month1, $month2,
0.000000,0,0.000000,$day1,   $day2,
0.000000,0,0.000000,$min1,   $min2,
0.000000,0,0.000000,$sec1,   $sec2,
0.000000,0,0.000000,$nano1,  $nano2,
0.000000,0,0.000000,$minute_length,
0.000000,0,0.000000,$month_length,
0.000000,0,0.000000,) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $nano1 < $nano2 ) {
0.000000,0,0.000000,$sec1--;
0.000000,0,0.000000,$nano1 += MAX_NANOSECONDS;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $sec1 < $sec2 ) {
0.000000,0,0.000000,$min1--;
0.000000,0,0.000000,$sec1 += $minute_length;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A day always has 24 * 60 minutes, though the minutes may vary in
0.000000,0,0.000000,# length.
0.000000,0,0.000000,if ( $min1 < $min2 ) {
0.000000,0,0.000000,$day1--;
0.000000,0,0.000000,$min1 += 24 * 60;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $day1 < $day2 ) {
0.000000,0,0.000000,$month1--;
0.000000,0,0.000000,$day1 += $month_length;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,$month1 - $month2,
0.000000,0,0.000000,$day1 - $day2,
0.000000,0,0.000000,$min1 - $min2,
0.000000,0,0.000000,$sec1 - $sec2,
0.000000,0,0.000000,$nano1 - $nano2,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtract_datetime_absolute {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $dt   = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $utc_rd_secs1 = $self->utc_rd_as_seconds;
0.000000,0,0.000000,$utc_rd_secs1
0.000000,0,0.000000,+= DateTime->_accumulated_leap_seconds( $self->{utc_rd_days} )
0.000000,0,0.000000,if !$self->time_zone->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,my $utc_rd_secs2 = $dt->utc_rd_as_seconds;
0.000000,0,0.000000,$utc_rd_secs2 += DateTime->_accumulated_leap_seconds( $dt->{utc_rd_days} )
0.000000,0,0.000000,if !$dt->time_zone->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,my $seconds     = $utc_rd_secs1 - $utc_rd_secs2;
0.000000,0,0.000000,my $nanoseconds = $self->nanosecond - $dt->nanosecond;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $nanoseconds < 0 ) {
0.000000,0,0.000000,$seconds--;
0.000000,0,0.000000,$nanoseconds += MAX_NANOSECONDS;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->duration_class->new(
0.000000,0,0.000000,seconds     => $seconds,
0.000000,0,0.000000,nanoseconds => $nanoseconds,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub delta_md {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $dt   = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $smaller, $bigger ) = sort $self, $dt;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $months, $days, undef, undef, undef )
0.000000,0,0.000000,= $dt->_adjust_for_positive_difference(
0.000000,0,0.000000,$bigger->year * 12 + $bigger->month,
0.000000,0,0.000000,$smaller->year * 12 + $smaller->month,
0.000000,0,0.000000,
0.000000,0,0.000000,$bigger->day, $smaller->day,
0.000000,0,0.000000,
0.000000,0,0.000000,0, 0,
0.000000,0,0.000000,
0.000000,0,0.000000,0, 0,
0.000000,0,0.000000,
0.000000,0,0.000000,0, 0,
0.000000,0,0.000000,
0.000000,0,0.000000,60,
0.000000,0,0.000000,
0.000000,0,0.000000,$smaller->_month_length( $smaller->year, $smaller->month ),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->duration_class->new(
0.000000,0,0.000000,months => $months,
0.000000,0,0.000000,days   => $days
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub delta_days {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $dt   = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $days
0.000000,0,0.000000,= abs( ( $self->local_rd_values )[0] - ( $dt->local_rd_values )[0] );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->duration_class->new( days => $days );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub delta_ms {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $dt   = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $smaller, $greater ) = sort $self, $dt;
0.000000,0,0.000000,
0.000000,0,0.000000,my $days = int( $greater->jd - $smaller->jd );
0.000000,0,0.000000,
0.000000,0,0.000000,my $dur = $greater->subtract_datetime($smaller);
0.000000,0,0.000000,
0.000000,0,0.000000,my %p;
0.000000,0,0.000000,$p{hours}   = $dur->hours + ( $days * 24 );
0.000000,0,0.000000,$p{minutes} = $dur->minutes;
0.000000,0,0.000000,$p{seconds} = $dur->seconds;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->duration_class->new(%p);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _add_overload {
0.000000,0,0.000000,my ( $dt, $dur, $reversed ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($reversed) {
0.000000,0,0.000000,( $dur, $dt ) = ( $dt, $dur );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( DateTime::Helpers::isa( $dur, 'DateTime::Duration' ) ) {
0.000000,0,0.000000,my $class     = ref $dt;
0.000000,0,0.000000,my $dt_string = overload::StrVal($dt);
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak( "Cannot add $dur to a $class object ($dt_string).\n"
0.000000,0,0.000000,. " Only a DateTime::Duration object can "
0.000000,0,0.000000,. " be added to a $class object." );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $dt->clone->add_duration($dur);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _subtract_overload {
0.000000,0,0.000000,my ( $date1, $date2, $reversed ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($reversed) {
0.000000,0,0.000000,( $date2, $date1 ) = ( $date1, $date2 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( DateTime::Helpers::isa( $date2, 'DateTime::Duration' ) ) {
0.000000,0,0.000000,my $new = $date1->clone;
0.000000,0,0.000000,$new->add_duration( $date2->inverse );
0.000000,0,0.000000,return $new;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( DateTime::Helpers::isa( $date2, 'DateTime' ) ) {
0.000000,0,0.000000,return $date1->subtract_datetime($date2);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $class     = ref $date1;
0.000000,0,0.000000,my $dt_string = overload::StrVal($date1);
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak(
0.000000,0,0.000000,"Cannot subtract $date2 from a $class object ($dt_string).\n"
0.000000,0,0.000000,. " Only a DateTime::Duration or DateTime object can "
0.000000,0,0.000000,. " be subtracted from a $class object." );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->add_duration( $self->duration_class->new(@_) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtract {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %p    = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %eom;
0.000000,0,0.000000,$eom{end_of_month} = delete $p{end_of_month}
0.000000,0,0.000000,if exists $p{end_of_month};
0.000000,0,0.000000,
0.000000,0,0.000000,my $dur = $self->duration_class->new(@_)->inverse(%eom);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->add_duration($dur);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtract_duration { return $_[0]->add_duration( $_[1]->inverse ) }
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000006,2,0.000003,my @spec = ( { isa => 'DateTime::Duration' } );
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_duration {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($dur) = validate_pos( @_, @spec );
0.000000,0,0.000000,
0.000000,0,0.000000,# simple optimization
0.000000,0,0.000000,return $self if $dur->is_zero;
0.000000,0,0.000000,
0.000000,0,0.000000,my %deltas = $dur->deltas;
0.000000,0,0.000000,
0.000000,0,0.000000,# This bit isn't quite right since DateTime::Infinite::Future -
0.000000,0,0.000000,# infinite duration should NaN
0.000000,0,0.000000,foreach my $val ( values %deltas ) {
0.000000,0,0.000000,my $inf;
0.000000,0,0.000000,if ( $val == INFINITY ) {
0.000000,0,0.000000,$inf = DateTime::Infinite::Future->new;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $val == NEG_INFINITY ) {
0.000000,0,0.000000,$inf = DateTime::Infinite::Past->new;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($inf) {
0.000000,0,0.000000,%$self = %$inf;
0.000000,0,0.000000,bless $self, ref $inf;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self if $self->is_infinite;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $deltas{days} ) {
0.000000,0,0.000000,$self->{local_rd_days} += $deltas{days};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{utc_year} += int( $deltas{days} / 365 ) + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $deltas{months} ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# For preserve mode, if it is the last day of the month, make
0.000000,0,0.000000,# it the 0th day of the following month (which then will
0.000000,0,0.000000,# normalize back to the last day of the new month).
0.000000,0,0.000000,my ( $y, $m, $d ) = (
0.000000,0,0.000000,$dur->is_preserve_mode
0.000000,0,0.000000,? $self->_rd2ymd( $self->{local_rd_days} + 1 )
0.000000,0,0.000000,: $self->_rd2ymd( $self->{local_rd_days} )
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$d -= 1 if $dur->is_preserve_mode;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( !$dur->is_wrap_mode && $d > 28 ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# find the rd for the last day of our target month
0.000000,0,0.000000,$self->{local_rd_days}
0.000000,0,0.000000,= $self->_ymd2rd( $y, $m + $deltas{months} + 1, 0 );
0.000000,0,0.000000,
0.000000,0,0.000000,# what day of the month is it? (discard year and month)
0.000000,0,0.000000,my $last_day
0.000000,0,0.000000,= ( $self->_rd2ymd( $self->{local_rd_days} ) )[2];
0.000000,0,0.000000,
0.000000,0,0.000000,# if our original day was less than the last day,
0.000000,0,0.000000,# use that instead
0.000000,0,0.000000,$self->{local_rd_days} -= $last_day - $d if $last_day > $d;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->{local_rd_days}
0.000000,0,0.000000,= $self->_ymd2rd( $y, $m + $deltas{months}, $d );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{utc_year} += int( $deltas{months} / 12 ) + 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $deltas{days} || $deltas{months} ) {
0.000000,0,0.000000,$self->_calc_utc_rd;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_offset_modifier( $self->second );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $deltas{minutes} ) {
0.000000,0,0.000000,$self->{utc_rd_secs} += $deltas{minutes} * 60;
0.000000,0,0.000000,
0.000000,0,0.000000,# This intentionally ignores leap seconds
0.000000,0,0.000000,$self->_normalize_tai_seconds( $self->{utc_rd_days},
0.000000,0,0.000000,$self->{utc_rd_secs} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $deltas{seconds} || $deltas{nanoseconds} ) {
0.000000,0,0.000000,$self->{utc_rd_secs} += $deltas{seconds};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $deltas{nanoseconds} ) {
0.000000,0,0.000000,$self->{rd_nanosecs} += $deltas{nanoseconds};
0.000000,0,0.000000,$self->_normalize_nanoseconds( $self->{utc_rd_secs},
0.000000,0,0.000000,$self->{rd_nanosecs} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_normalize_seconds;
0.000000,0,0.000000,
0.000000,0,0.000000,# This might be some big number much bigger than 60, but
0.000000,0,0.000000,# that's ok (there are tests in 19leap_second.t to confirm
0.000000,0,0.000000,# that)
0.000000,0,0.000000,$self->_handle_offset_modifier(
0.000000,0,0.000000,$self->second + $deltas{seconds} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $new = ( ref $self )->from_object(
0.000000,0,0.000000,object => $self,
0.000000,0,0.000000,locale => $self->{locale},
0.000000,0,0.000000,( $self->{formatter} ? ( formatter => $self->{formatter} ) : () ),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$new;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compare_overload {
0.000000,0,0.000000,
0.000000,0,0.000000,# note: $_[1]->compare( $_[0] ) is an error when $_[1] is not a
0.000000,0,0.000000,# DateTime (such as the INFINITY value)
0.000000,0,0.000000,return $_[2] ? -$_[0]->compare( $_[1] ) : $_[0]->compare( $_[1] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _string_compare_overload {
0.000000,0,0.000000,my ( $dt1, $dt2, $flip ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# One is a DateTime object, one isn't. Just stringify and compare.
0.000000,0,0.000000,if ( !DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
0.000000,0,0.000000,my $sign = $flip ? -1 : 1;
0.000000,0,0.000000,return $sign * ( "$dt1" cmp "$dt2" );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $meth = $dt1->can('_compare_overload');
0.000000,0,0.000000,goto $meth;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub compare {
0.000000,0,0.000000,shift->_compare( @_, 0 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub compare_ignore_floating {
0.000000,0,0.000000,shift->_compare( @_, 1 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compare {
0.000000,0,0.000000,my ( $class, $dt1, $dt2, $consistent ) = ref $_[0] ? ( undef, @_ ) : @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef unless defined $dt2;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( !ref $dt2 && ( $dt2 == INFINITY || $dt2 == NEG_INFINITY ) ) {
0.000000,0,0.000000,return $dt1->{utc_rd_days} <=> $dt2;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( DateTime::Helpers::can( $dt1, 'utc_rd_values' )
0.000000,0,0.000000,&& DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
0.000000,0,0.000000,my $dt1_string = overload::StrVal($dt1);
0.000000,0,0.000000,my $dt2_string = overload::StrVal($dt2);
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak( "A DateTime object can only be compared to"
0.000000,0,0.000000,. " another DateTime object ($dt1_string, $dt2_string)." );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (   !$consistent
0.000000,0,0.000000,&& DateTime::Helpers::can( $dt1, 'time_zone' )
0.000000,0,0.000000,&& DateTime::Helpers::can( $dt2, 'time_zone' ) ) {
0.000000,0,0.000000,my $is_floating1 = $dt1->time_zone->is_floating;
0.000000,0,0.000000,my $is_floating2 = $dt2->time_zone->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $is_floating1 && !$is_floating2 ) {
0.000000,0,0.000000,$dt1 = $dt1->clone->set_time_zone( $dt2->time_zone );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $is_floating2 && !$is_floating1 ) {
0.000000,0,0.000000,$dt2 = $dt2->clone->set_time_zone( $dt1->time_zone );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @dt1_components = $dt1->utc_rd_values;
0.000000,0,0.000000,my @dt2_components = $dt2->utc_rd_values;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $i ( 0 .. 2 ) {
0.000000,0,0.000000,return $dt1_components[$i] <=> $dt2_components[$i]
0.000000,0,0.000000,if $dt1_components[$i] != $dt2_components[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _string_equals_overload {
0.000000,0,0.000000,my ( $class, $dt1, $dt2 ) = ref $_[0] ? ( undef, @_ ) : @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( !DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
0.000000,0,0.000000,return "$dt1" eq "$dt2";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$class ||= ref $dt1;
0.000000,0,0.000000,return !$class->compare( $dt1, $dt2 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _string_not_equals_overload {
0.000000,0,0.000000,return !_string_equals_overload(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _normalize_nanoseconds {
0.001238,2,0.000619,use integer;
0.000000,0,0.000000,
0.000000,0,0.000000,# seconds, nanoseconds
0.000000,0,0.000000,if ( $_[2] < 0 ) {
0.000000,0,0.000000,my $overflow = 1 + $_[2] / MAX_NANOSECONDS;
0.000000,0,0.000000,$_[2] += $overflow * MAX_NANOSECONDS;
0.000000,0,0.000000,$_[1] -= $overflow;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $_[2] >= MAX_NANOSECONDS ) {
0.000000,0,0.000000,my $overflow = $_[2] / MAX_NANOSECONDS;
0.000000,0,0.000000,$_[2] -= $overflow * MAX_NANOSECONDS;
0.000000,0,0.000000,$_[1] += $overflow;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Many of the same parameters as new() but all of them are optional,
0.000000,0,0.000000,# and there are no defaults.
0.000000,0,0.000000,my $SetValidate = {
0.000000,0,0.000000,map {
0.000046,11,0.000004,my %copy = %{ $BasicValidate->{$_} };
0.000015,10,0.000001,delete $copy{default};
0.000014,10,0.000001,$copy{optional} = 1;
0.000016,10,0.000002,$_ => \%copy
0.000000,0,0.000000,}
0.000000,0,0.000000,keys %$BasicValidate
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub set {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %p = validate( @_, $SetValidate );
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_dt = $self->_new_from_self(%p);
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$new_dt;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_year       { $_[0]->set( year       => $_[1] ) }
0.000000,0,0.000000,sub set_month      { $_[0]->set( month      => $_[1] ) }
0.000000,0,0.000000,sub set_day        { $_[0]->set( day        => $_[1] ) }
0.000000,0,0.000000,sub set_hour       { $_[0]->set( hour       => $_[1] ) }
0.000000,0,0.000000,sub set_minute     { $_[0]->set( minute     => $_[1] ) }
0.000000,0,0.000000,sub set_second     { $_[0]->set( second     => $_[1] ) }
0.000000,0,0.000000,sub set_nanosecond { $_[0]->set( nanosecond => $_[1] ) }
0.000000,0,0.000000,sub set_locale     { $_[0]->set( locale     => $_[1] ) }
0.000000,0,0.000000,sub set_formatter  { $_[0]->set( formatter  => $_[1] ) }
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000006,2,0.000003,my %TruncateDefault = (
0.000000,0,0.000000,month      => 1,
0.000000,0,0.000000,day        => 1,
0.000000,0,0.000000,hour       => 0,
0.000000,0,0.000000,minute     => 0,
0.000000,0,0.000000,second     => 0,
0.000000,0,0.000000,nanosecond => 0,
0.000000,0,0.000000,);
0.000000,0,0.000000,my $re = join '|', 'year', 'week',
0.000005,1,0.000005,grep { $_ ne 'nanosecond' } keys %TruncateDefault;
0.000048,1,0.000048,my $spec = { to => { regex => qr/^(?:$re)$/ } };
0.000000,0,0.000000,
0.000000,0,0.000000,sub truncate {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %p = validate( @_, $spec );
0.000000,0,0.000000,
0.000000,0,0.000000,my %new;
0.000000,0,0.000000,if ( $p{to} eq 'week' ) {
0.000000,0,0.000000,my $day_diff = $self->day_of_week - 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($day_diff) {
0.000000,0,0.000000,$self->add( days => -1 * $day_diff );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->truncate( to => 'day' );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $truncate;
0.000000,0,0.000000,foreach my $f (qw( year month day hour minute second nanosecond ))
0.000000,0,0.000000,{
0.000000,0,0.000000,$new{$f} = $truncate ? $TruncateDefault{$f} : $self->$f();
0.000000,0,0.000000,
0.000000,0,0.000000,$truncate = 1 if $p{to} eq $f;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_dt = $self->_new_from_self( %new, _skip_validation => 1 );
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$new_dt;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_time_zone {
0.000000,0,0.000000,my ( $self, $tz ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $tz) {
0.000000,0,0.000000,# This is a bit of a hack but it works because time zone objects
0.000000,0,0.000000,# are singletons, and if it doesn't work all we lose is a little
0.000000,0,0.000000,# bit of speed.
0.000000,0,0.000000,return $self if $self->{tz} eq $tz;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $self if $self->{tz}->name() eq $tz;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $was_floating = $self->{tz}->is_floating;
0.000000,0,0.000000,
0.000000,0,0.000000,my $old_tz = $self->{tz};
0.000000,0,0.000000,$self->{tz} = ref $tz ? $tz : DateTime::TimeZone->new( name => $tz );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_offset_modifier( $self->second, 1 );
0.000000,0,0.000000,
0.000000,0,0.000000,my $e;
0.000000,0,0.000000,try {
0.000000,0,0.000000,# if it either was or now is floating (but not both)
0.000000,0,0.000000,if ( $self->{tz}->is_floating xor $was_floating ) {
0.000000,0,0.000000,$self->_calc_utc_rd;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( !$was_floating ) {
0.000000,0,0.000000,$self->_calc_local_rd;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,catch {
0.000000,0,0.000000,$e = $_;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# If we can't recalc the RD values then we shouldn't keep the new TZ. RT
0.000000,0,0.000000,# #83940
0.000000,0,0.000000,if ($e) {
0.000000,0,0.000000,$self->{tz} = $old_tz;
0.000000,0,0.000000,die $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_freeze {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my $cloning = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $serialized = '';
0.000000,0,0.000000,foreach my $key (
0.000000,0,0.000000,qw( utc_rd_days
0.000000,0,0.000000,utc_rd_secs
0.000000,0,0.000000,rd_nanosecs )
0.000000,0,0.000000,) {
0.000000,0,0.000000,$serialized .= "$key:$self->{$key}|";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# not used yet, but may be handy in the future.
0.000000,0,0.000000,$serialized .= 'version:' . ( $DateTime::VERSION || 'git' );
0.000000,0,0.000000,
0.000000,0,0.000000,# Formatter needs to be returned as a reference since it may be
0.000000,0,0.000000,# undef or a class name, and Storable will complain if extra
0.000000,0,0.000000,# return values aren't refs
0.000000,0,0.000000,return $serialized, $self->{locale}, $self->{tz}, \$self->{formatter};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_thaw {
0.000000,0,0.000000,my $self       = shift;
0.000000,0,0.000000,my $cloning    = shift;
0.000000,0,0.000000,my $serialized = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my %serialized = map { split /:/ } split /\|/, $serialized;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $locale, $tz, $formatter );
0.000000,0,0.000000,
0.000000,0,0.000000,# more recent code version
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,( $locale, $tz, $formatter ) = @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$tz = DateTime::TimeZone->new( name => delete $serialized{tz} );
0.000000,0,0.000000,
0.000000,0,0.000000,$locale = DateTime::Locale->load(
0.000000,0,0.000000,exists $serialized{language}
0.000000,0,0.000000,? delete $serialized{language}
0.000000,0,0.000000,: delete $serialized{locale}
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,delete $serialized{version};
0.000000,0,0.000000,
0.000000,0,0.000000,my $object = bless {
0.000000,0,0.000000,utc_vals => [
0.000000,0,0.000000,$serialized{utc_rd_days},
0.000000,0,0.000000,$serialized{utc_rd_secs},
0.000000,0,0.000000,$serialized{rd_nanosecs},
0.000000,0,0.000000,],
0.000000,0,0.000000,tz => $tz,
0.000000,0,0.000000,},
0.000000,0,0.000000,'DateTime::_Thawed';
0.000000,0,0.000000,
0.000000,0,0.000000,my %formatter = defined $$formatter ? ( formatter => $$formatter ) : ();
0.000000,0,0.000000,my $new = ( ref $self )->from_object(
0.000000,0,0.000000,object => $object,
0.000000,0,0.000000,locale => $locale,
0.000000,0,0.000000,%formatter,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$new;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package
0.000000,0,0.000000,DateTime::_Thawed;
0.000000,0,0.000000,
0.000000,0,0.000000,sub utc_rd_values { @{ $_[0]->{utc_vals} } }
0.000000,0,0.000000,
0.000000,0,0.000000,sub time_zone { $_[0]->{tz} }
0.000000,0,0.000000,
0.000061,1,0.000061,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: A date and time object
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
