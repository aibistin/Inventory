# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Meta::TypeConstraint::Class;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::TypeConstraint::Class::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Moose::Meta::TypeConstraint::Class::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000034,2,0.000017,use strict;
0.000036,2,0.000018,use warnings;
0.000038,2,0.000019,use metaclass;
0.000000,0,0.000000,
0.000041,2,0.000021,use B;
0.000034,2,0.000017,use Scalar::Util 'blessed';
0.000031,2,0.000016,use Moose::Util::TypeConstraints ();
0.000000,0,0.000000,
0.000557,2,0.000278,use base 'Moose::Meta::TypeConstraint';
0.000000,0,0.000000,
0.000014,1,0.000014,__PACKAGE__->meta->add_attribute('class' => (
0.000000,0,0.000000,reader => 'class',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,my $inliner = sub {
0.000003,2,0.000002,my $self = shift;
0.000003,2,0.000002,my $val  = shift;
0.000000,0,0.000000,
0.000042,2,0.000021,return 'Scalar::Util::blessed(' . $val . ')'
0.000000,0,0.000000,. ' && ' . $val . '->isa(' . B::perlstring($self->class) . ')';
0.000003,1,0.000003,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000003,1,0.000003,my ( $class, %args ) = @_;
0.000000,0,0.000000,
0.000005,1,0.000005,$args{parent}
0.000000,0,0.000000,= Moose::Util::TypeConstraints::find_type_constraint('Object');
0.000000,0,0.000000,
0.000002,1,0.000002,my $class_name = $args{class};
0.000004,1,0.000004,$args{constraint} = sub { $_[0]->isa($class_name) };
0.000000,0,0.000000,
0.000002,1,0.000002,$args{inlined} = $inliner;
0.000000,0,0.000000,
0.000011,1,0.000011,my $self = $class->SUPER::new( \%args );
0.000000,0,0.000000,
0.000006,1,0.000006,$self->compile_type_constraint();
0.000000,0,0.000000,
0.000008,1,0.000008,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parents {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return (
0.000000,0,0.000000,$self->parent,
0.000000,0,0.000000,map {
0.000000,0,0.000000,# FIXME find_type_constraint might find a TC named after the class but that isn't really it
0.000000,0,0.000000,# I did this anyway since it's a convention that preceded TypeConstraint::Class, and it should DWIM
0.000000,0,0.000000,# if anybody thinks this problematic please discuss on IRC.
0.000000,0,0.000000,# a possible fix is to add by attr indexing to the type registry to find types of a certain property
0.000000,0,0.000000,# regardless of their name
0.000000,0,0.000000,Moose::Util::TypeConstraints::find_type_constraint($_)
0.000000,0,0.000000,||
0.000000,0,0.000000,__PACKAGE__->new( class => $_, name => "__ANON__" )
0.000000,0,0.000000,} Class::MOP::class_of($self->class)->superclasses,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub equals {
0.000000,0,0.000000,my ( $self, $type_or_name ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
0.000000,0,0.000000,
0.000000,0,0.000000,if (!defined($other)) {
0.000000,0,0.000000,if (!ref($type_or_name)) {
0.000000,0,0.000000,return $self->class eq $type_or_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $other->isa(__PACKAGE__);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->class eq $other->class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_a_type_of {
0.000000,0,0.000000,my ($self, $type_or_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,($self->equals($type_or_name) || $self->is_subtype_of($type_or_name));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_subtype_of {
0.000000,0,0.000000,my ($self, $type_or_name_or_class ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_class);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( not defined $type ) {
0.000000,0,0.000000,if ( not ref $type_or_name_or_class ) {
0.000000,0,0.000000,# it might be a class
0.000000,0,0.000000,my $class = $self->class;
0.000000,0,0.000000,return 1 if $class ne $type_or_name_or_class
0.000000,0,0.000000,&& $class->isa( $type_or_name_or_class );
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $type->isa(__PACKAGE__) && $type->class ne $self->class) {
0.000000,0,0.000000,# if $type_or_name_or_class isn't a class, it might be the TC name of another ::Class type
0.000000,0,0.000000,# or it could also just be a type object in this branch
0.000000,0,0.000000,return $self->class->isa( $type->class );
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# the only other thing we are a subtype of is Object
0.000000,0,0.000000,$self->SUPER::is_subtype_of($type);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a bit counter-intuitive, but a child type of a Class type
0.000000,0,0.000000,# constraint is not itself a Class type constraint (it has no class
0.000000,0,0.000000,# attribute). This whole create_child_type thing needs some changing
0.000000,0,0.000000,# though, probably making MMC->new a factory or something.
0.000000,0,0.000000,sub create_child_type {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,return Moose::Meta::TypeConstraint->new(@args, parent => $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_message {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->has_message) {
0.000000,0,0.000000,return $self->SUPER::get_message(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$value = (defined $value ? overload::StrVal($value) : 'undef');
0.000000,0,0.000000,return "Validation failed for '" . $self->name . "' with value $value (not isa " . $self->class . ")";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Class/TypeConstraint parallel hierarchy
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
