# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Fatal;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Replace functions with equivalents which succeed or die
0.000000,0,0.000000,
0.000064,2,0.000032,use 5.008;  # 5.8.x needed for autodie
0.000032,2,0.000016,use Carp;
0.000030,2,0.000015,use strict;
0.000030,2,0.000015,use warnings;
0.000221,2,0.000110,use Tie::RefHash;   # To cache subroutine refs
0.000035,2,0.000017,use Config;
0.000037,2,0.000019,use Scalar::Util qw(set_prototype);
0.000000,0,0.000000,
0.000102,2,0.000051,use constant PERL510     => ( $] >= 5.010 );
0.000000,0,0.000000,
0.000037,2,0.000019,use constant LEXICAL_TAG => q{:lexical};
0.000035,2,0.000017,use constant VOID_TAG    => q{:void};
0.000034,2,0.000017,use constant INSIST_TAG  => q{!};
0.000000,0,0.000000,
0.000043,2,0.000022,use constant ERROR_NOARGS    => 'Cannot use lexical %s with no arguments';
0.000040,2,0.000020,use constant ERROR_VOID_LEX  => VOID_TAG.' cannot be used with lexical scope';
0.000041,2,0.000020,use constant ERROR_LEX_FIRST => LEXICAL_TAG.' must be used as first argument';
0.000034,2,0.000017,use constant ERROR_NO_LEX    => "no %s can only start with ".LEXICAL_TAG;
0.000033,2,0.000017,use constant ERROR_BADNAME   => "Bad subroutine name for %s: %s";
0.000033,2,0.000017,use constant ERROR_NOTSUB    => "%s is not a Perl subroutine";
0.000034,2,0.000017,use constant ERROR_NOT_BUILT => "%s is neither a builtin, nor a Perl subroutine";
0.000035,2,0.000017,use constant ERROR_NOHINTS   => "No user hints defined for %s";
0.000000,0,0.000000,
0.000034,2,0.000017,use constant ERROR_CANT_OVERRIDE => "Cannot make the non-overridable builtin %s fatal";
0.000000,0,0.000000,
0.000035,2,0.000017,use constant ERROR_NO_IPC_SYS_SIMPLE => "IPC::System::Simple required for Fatalised/autodying system()";
0.000000,0,0.000000,
0.000034,2,0.000017,use constant ERROR_IPC_SYS_SIMPLE_OLD => "IPC::System::Simple version %f required for Fatalised/autodying system().  We only have version %f";
0.000000,0,0.000000,
0.000034,2,0.000017,use constant ERROR_AUTODIE_CONFLICT => q{"no autodie '%s'" is not allowed while "use Fatal '%s'" is in effect};
0.000000,0,0.000000,
0.000033,2,0.000017,use constant ERROR_FATAL_CONFLICT => q{"use Fatal '%s'" is not allowed while "no autodie '%s'" is in effect};
0.000000,0,0.000000,
0.000037,2,0.000018,use constant ERROR_58_HINTS => q{Non-subroutine %s hints for %s are not supported under Perl 5.8.x};
0.000000,0,0.000000,
0.000000,0,0.000000,# Older versions of IPC::System::Simple don't support all the
0.000000,0,0.000000,# features we need.
0.000000,0,0.000000,
0.000917,2,0.000459,use constant MIN_IPC_SYS_SIMPLE_VER => 0.12;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg::Version
0.000000,0,0.000000,
0.000001,1,0.000001,our $Debug ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# EWOULDBLOCK values for systems that don't supply their own.
0.000000,0,0.000000,# Even though this is defined with our, that's to help our
0.000000,0,0.000000,# test code.  Please don't rely upon this variable existing in
0.000000,0,0.000000,# the future.
0.000000,0,0.000000,
0.000003,1,0.000003,our %_EWOULDBLOCK = (
0.000000,0,0.000000,MSWin32 => 33,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# the linux parisc port has separate EAGAIN and EWOULDBLOCK,
0.000000,0,0.000000,# and the kernel returns EAGAIN
0.000025,1,0.000025,my $try_EAGAIN = ($^O eq 'linux' and $Config{archname} =~ /hppa|parisc/) ? 1 : 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# We have some tags that can be passed in for use with import.
0.000000,0,0.000000,# These are all assumed to be CORE::
0.000000,0,0.000000,
0.000044,1,0.000044,my %TAGS = (
0.000000,0,0.000000,':io'      => [qw(:dbm :file :filesys :ipc :socket
0.000000,0,0.000000,read seek sysread syswrite sysseek )],
0.000000,0,0.000000,':dbm'     => [qw(dbmopen dbmclose)],
0.000000,0,0.000000,':file'    => [qw(open close flock sysopen fcntl fileno binmode
0.000000,0,0.000000,ioctl truncate)],
0.000000,0,0.000000,':filesys' => [qw(opendir closedir chdir link unlink rename mkdir
0.000000,0,0.000000,symlink rmdir readlink umask chmod chown utime)],
0.000000,0,0.000000,':ipc'     => [qw(:msg :semaphore :shm pipe kill)],
0.000000,0,0.000000,':msg'     => [qw(msgctl msgget msgrcv msgsnd)],
0.000000,0,0.000000,':threads' => [qw(fork)],
0.000000,0,0.000000,':semaphore'=>[qw(semctl semget semop)],
0.000000,0,0.000000,':shm'     => [qw(shmctl shmget shmread)],
0.000000,0,0.000000,':system'  => [qw(system exec)],
0.000000,0,0.000000,
0.000000,0,0.000000,# Can we use qw(getpeername getsockname)? What do they do on failure?
0.000000,0,0.000000,# TODO - Can socket return false?
0.000000,0,0.000000,':socket'  => [qw(accept bind connect getsockopt listen recv send
0.000000,0,0.000000,setsockopt shutdown socketpair)],
0.000000,0,0.000000,
0.000000,0,0.000000,# Our defaults don't include system(), because it depends upon
0.000000,0,0.000000,# an optional module, and it breaks the exotic form.
0.000000,0,0.000000,#
0.000000,0,0.000000,# This *may* change in the future.  I'd love IPC::System::Simple
0.000000,0,0.000000,# to be a dependency rather than a recommendation, and hence for
0.000000,0,0.000000,# system() to be autodying by default.
0.000000,0,0.000000,
0.000000,0,0.000000,':default' => [qw(:io :threads)],
0.000000,0,0.000000,
0.000000,0,0.000000,# Everything in v2.07 and brefore. This was :default less chmod and chown
0.000000,0,0.000000,':v207'    => [qw(:threads :dbm :socket read seek sysread
0.000000,0,0.000000,syswrite sysseek open close flock sysopen fcntl fileno
0.000000,0,0.000000,binmode ioctl truncate opendir closedir chdir link unlink
0.000000,0,0.000000,rename mkdir symlink rmdir readlink umask
0.000000,0,0.000000,:msg :semaphore :shm pipe)],
0.000000,0,0.000000,
0.000000,0,0.000000,# Chmod was added in 2.13
0.000000,0,0.000000,':v213'    => [qw(:v207 chmod)],
0.000000,0,0.000000,
0.000000,0,0.000000,# chown, utime, kill were added in 2.14
0.000000,0,0.000000,':v214'    => [qw(:v213 chown utime kill)],
0.000000,0,0.000000,
0.000000,0,0.000000,# Version specific tags.  These allow someone to specify
0.000000,0,0.000000,# use autodie qw(:1.994) and know exactly what they'll get.
0.000000,0,0.000000,
0.000000,0,0.000000,':1.994' => [qw(:v207)],
0.000000,0,0.000000,':1.995' => [qw(:v207)],
0.000000,0,0.000000,':1.996' => [qw(:v207)],
0.000000,0,0.000000,':1.997' => [qw(:v207)],
0.000000,0,0.000000,':1.998' => [qw(:v207)],
0.000000,0,0.000000,':1.999' => [qw(:v207)],
0.000000,0,0.000000,':1.999_01' => [qw(:v207)],
0.000000,0,0.000000,':2.00'  => [qw(:v207)],
0.000000,0,0.000000,':2.01'  => [qw(:v207)],
0.000000,0,0.000000,':2.02'  => [qw(:v207)],
0.000000,0,0.000000,':2.03'  => [qw(:v207)],
0.000000,0,0.000000,':2.04'  => [qw(:v207)],
0.000000,0,0.000000,':2.05'  => [qw(:v207)],
0.000000,0,0.000000,':2.06'  => [qw(:v207)],
0.000000,0,0.000000,':2.06_01' => [qw(:v207)],
0.000000,0,0.000000,':2.07'  => [qw(:v207)],     # Last release without chmod
0.000000,0,0.000000,':2.08'  => [qw(:v213)],
0.000000,0,0.000000,':2.09'  => [qw(:v213)],
0.000000,0,0.000000,':2.10'  => [qw(:v213)],
0.000000,0,0.000000,':2.11'  => [qw(:v213)],
0.000000,0,0.000000,':2.12'  => [qw(:v213)],
0.000000,0,0.000000,':2.13'  => [qw(:v213)],
0.000000,0,0.000000,':2.14'  => [qw(:default)],
0.000000,0,0.000000,':2.15'  => [qw(:default)],
0.000000,0,0.000000,':2.16'  => [qw(:default)],
0.000000,0,0.000000,':2.17'  => [qw(:default)],
0.000000,0,0.000000,':2.18'  => [qw(:default)],
0.000000,0,0.000000,':2.19'  => [qw(:default)],
0.000000,0,0.000000,':2.20'  => [qw(:default)],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# chmod was only introduced in 2.07
0.000000,0,0.000000,# chown was only introduced in 2.14
0.000000,0,0.000000,
0.000009,1,0.000009,$TAGS{':all'}  = [ keys %TAGS ];
0.000000,0,0.000000,
0.000000,0,0.000000,# This hash contains subroutines for which we should
0.000000,0,0.000000,# subroutine() // die() rather than subroutine() || die()
0.000000,0,0.000000,
0.000002,1,0.000002,my %Use_defined_or;
0.000000,0,0.000000,
0.000000,0,0.000000,# CORE::open returns undef on failure.  It can legitimately return
0.000000,0,0.000000,# 0 on success, eg: open(my $fh, '-|') || exec(...);
0.000000,0,0.000000,
0.000006,1,0.000006,@Use_defined_or{qw(
0.000000,0,0.000000,CORE::fork
0.000000,0,0.000000,CORE::recv
0.000000,0,0.000000,CORE::send
0.000000,0,0.000000,CORE::open
0.000000,0,0.000000,CORE::fileno
0.000000,0,0.000000,CORE::read
0.000000,0,0.000000,CORE::readlink
0.000000,0,0.000000,CORE::sysread
0.000000,0,0.000000,CORE::syswrite
0.000000,0,0.000000,CORE::sysseek
0.000000,0,0.000000,CORE::umask
0.000000,0,0.000000,)} = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Some functions can return true because they changed *some* things, but
0.000000,0,0.000000,# not all of them.  This is a list of offending functions, and how many
0.000000,0,0.000000,# items to subtract from @_ to determine the "success" value they return.
0.000000,0,0.000000,
0.000003,1,0.000003,my %Returns_num_things_changed = (
0.000000,0,0.000000,'CORE::chmod'  => 1,
0.000000,0,0.000000,'CORE::chown'  => 2,
0.000000,0,0.000000,'CORE::kill'   => 1,  # TODO: Could this return anything on negative args?
0.000000,0,0.000000,'CORE::unlink' => 0,
0.000000,0,0.000000,'CORE::utime'  => 2,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Optional actions to take on the return value before returning it.
0.000000,0,0.000000,
0.000003,1,0.000003,my %Retval_action = (
0.000000,0,0.000000,"CORE::open"        => q{
0.000000,0,0.000000,
0.000000,0,0.000000,# apply the open pragma from our caller
0.000000,0,0.000000,if( defined $retval ) {
0.000000,0,0.000000,# Get the caller's hint hash
0.000000,0,0.000000,my $hints = (caller 0)[10];
0.000000,0,0.000000,
0.000000,0,0.000000,# Decide if we're reading or writing and apply the appropriate encoding
0.000000,0,0.000000,# These keys are undocumented.
0.000000,0,0.000000,# Match what PerlIO_context_layers() does.  Read gets the read layer,
0.000000,0,0.000000,# everything else gets the write layer.
0.000000,0,0.000000,my $encoding = $_[1] =~ /^\+?>/ ? $hints->{"open>"} : $hints->{"open<"};
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply the encoding, if any.
0.000000,0,0.000000,if( $encoding ) {
0.000000,0,0.000000,binmode $_[0], $encoding;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,},
0.000000,0,0.000000,"CORE::sysopen"     => q{
0.000000,0,0.000000,
0.000000,0,0.000000,# apply the open pragma from our caller
0.000000,0,0.000000,if( defined $retval ) {
0.000000,0,0.000000,# Get the caller's hint hash
0.000000,0,0.000000,my $hints = (caller 0)[10];
0.000000,0,0.000000,
0.000000,0,0.000000,require Fcntl;
0.000000,0,0.000000,
0.000000,0,0.000000,# Decide if we're reading or writing and apply the appropriate encoding.
0.000000,0,0.000000,# Match what PerlIO_context_layers() does.  Read gets the read layer,
0.000000,0,0.000000,# everything else gets the write layer.
0.000000,0,0.000000,my $open_read_only = !($_[2] ^ Fcntl::O_RDONLY());
0.000000,0,0.000000,my $encoding = $open_read_only ? $hints->{"open<"} : $hints->{"open>"};
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply the encoding, if any.
0.000000,0,0.000000,if( $encoding ) {
0.000000,0,0.000000,binmode $_[0], $encoding;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,my %reusable_builtins;
0.000000,0,0.000000,
0.000000,0,0.000000,# "Wait!" I hear you cry, "truncate() and chdir() are not reuseable! They can
0.000000,0,0.000000,# take file and directory handles, which are package depedent."
0.000000,0,0.000000,#
0.000000,0,0.000000,# You would be correct, except that prototype() returns signatures which don't
0.000000,0,0.000000,# allow for passing of globs, and nobody's complained about that. You can
0.000000,0,0.000000,# still use \*FILEHANDLE, but that results in a reference coming through,
0.000000,0,0.000000,# and it's already pointing to the filehandle in the caller's packge, so
0.000000,0,0.000000,# it's all okay.
0.000000,0,0.000000,
0.000009,1,0.000009,@reusable_builtins{qw(
0.000000,0,0.000000,CORE::fork
0.000000,0,0.000000,CORE::kill
0.000000,0,0.000000,CORE::truncate
0.000000,0,0.000000,CORE::chdir
0.000000,0,0.000000,CORE::link
0.000000,0,0.000000,CORE::unlink
0.000000,0,0.000000,CORE::rename
0.000000,0,0.000000,CORE::mkdir
0.000000,0,0.000000,CORE::symlink
0.000000,0,0.000000,CORE::rmdir
0.000000,0,0.000000,CORE::readlink
0.000000,0,0.000000,CORE::umask
0.000000,0,0.000000,CORE::chmod
0.000000,0,0.000000,CORE::chown
0.000000,0,0.000000,CORE::utime
0.000000,0,0.000000,CORE::msgctl
0.000000,0,0.000000,CORE::msgget
0.000000,0,0.000000,CORE::msgrcv
0.000000,0,0.000000,CORE::msgsnd
0.000000,0,0.000000,CORE::semctl
0.000000,0,0.000000,CORE::semget
0.000000,0,0.000000,CORE::semop
0.000000,0,0.000000,CORE::shmctl
0.000000,0,0.000000,CORE::shmget
0.000000,0,0.000000,CORE::shmread
0.000000,0,0.000000,)} = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Cached_fatalised_sub caches the various versions of our
0.000000,0,0.000000,# fatalised subs as they're produced.  This means we don't
0.000000,0,0.000000,# have to build our own replacement of CORE::open and friends
0.000000,0,0.000000,# for every single package that wants to use them.
0.000000,0,0.000000,
0.000002,1,0.000002,my %Cached_fatalised_sub = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Every time we're called with package scope, we record the subroutine
0.000000,0,0.000000,# (including package or CORE::) in %Package_Fatal.  This allows us
0.000000,0,0.000000,# to detect illegal combinations of autodie and Fatal, and makes sure
0.000000,0,0.000000,# we don't accidently make a Fatal function autodying (which isn't
0.000000,0,0.000000,# very useful).
0.000000,0,0.000000,
0.000002,1,0.000002,my %Package_Fatal = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# The first time we're called with a user-sub, we cache it here.
0.000000,0,0.000000,# In the case of a "no autodie ..." we put back the cached copy.
0.000000,0,0.000000,
0.000001,1,0.000001,my %Original_user_sub = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Is_fatalised_sub simply records a big map of fatalised subroutine
0.000000,0,0.000000,# refs.  It means we can avoid repeating work, or fatalising something
0.000000,0,0.000000,# we've already processed.
0.000000,0,0.000000,
0.000002,1,0.000002,my  %Is_fatalised_sub = ();
0.000009,1,0.000009,tie %Is_fatalised_sub, 'Tie::RefHash';
0.000000,0,0.000000,
0.000000,0,0.000000,# Our trampoline cache allows us to cache trampolines which are used to
0.000000,0,0.000000,# bounce leaked wrapped core subroutines to their actual core counterparts.
0.000000,0,0.000000,
0.000001,1,0.000001,my %Trampoline_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,# We use our package in a few hash-keys.  Having it in a scalar is
0.000000,0,0.000000,# convenient.  The "guard $PACKAGE" string is used as a key when
0.000000,0,0.000000,# setting up lexical guards.
0.000000,0,0.000000,
0.000002,1,0.000002,my $PACKAGE       = __PACKAGE__;
0.000002,1,0.000002,my $PACKAGE_GUARD = "guard $PACKAGE";
0.000002,1,0.000002,my $NO_PACKAGE    = "no $PACKAGE";      # Used to detect 'no autodie'
0.000000,0,0.000000,
0.000000,0,0.000000,# Here's where all the magic happens when someone write 'use Fatal'
0.000000,0,0.000000,# or 'use autodie'.
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000004,2,0.000002,my $class        = shift(@_);
0.000004,2,0.000002,my @original_args = @_;
0.000003,2,0.000002,my $void         = 0;
0.000003,2,0.000001,my $lexical      = 0;
0.000003,2,0.000001,my $insist_hints = 0;
0.000000,0,0.000000,
0.000005,2,0.000002,my ($pkg, $filename) = caller();
0.000000,0,0.000000,
0.000003,2,0.000002,@_ or return;   # 'use Fatal' is a no-op.
0.000000,0,0.000000,
0.000000,0,0.000000,# If we see the :lexical flag, then _all_ arguments are
0.000000,0,0.000000,# changed lexically
0.000000,0,0.000000,
0.000007,2,0.000003,if ($_[0] eq LEXICAL_TAG) {
0.000003,2,0.000001,$lexical = 1;
0.000003,2,0.000002,shift @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# If we see no arguments and :lexical, we assume they
0.000000,0,0.000000,# wanted ':default'.
0.000000,0,0.000000,
0.000004,2,0.000002,if (@_ == 0) {
0.000000,0,0.000000,push(@_, ':default');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Don't allow :lexical with :void, it's needlessly confusing.
0.000005,2,0.000003,if ( grep { $_ eq VOID_TAG } @_ ) {
0.000000,0,0.000000,croak(ERROR_VOID_LEX);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,2,0.000002,if ( grep { $_ eq LEXICAL_TAG } @_ ) {
0.000000,0,0.000000,# If we see the lexical tag as the non-first argument, complain.
0.000000,0,0.000000,croak(ERROR_LEX_FIRST);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,2,0.000002,my @fatalise_these =  @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Thiese subs will get unloaded at the end of lexical scope.
0.000003,2,0.000002,my %unload_later;
0.000000,0,0.000000,
0.000000,0,0.000000,# Use _translate_import_args to expand tags for us.  It will
0.000000,0,0.000000,# pass-through unknown tags (i.e. we have to manually handle
0.000000,0,0.000000,# VOID_TAG).
0.000000,0,0.000000,#
0.000000,0,0.000000,# TODO: Consider how to handle stuff like:
0.000000,0,0.000000,#   use autodie qw(:defaults ! :io);
0.000000,0,0.000000,#   use Fatal qw(:defaults :void :io);
0.000000,0,0.000000,#
0.000000,0,0.000000,# The ! and :void is currently not applied to anything in the
0.000000,0,0.000000,# example above since duplicates are filtered out.  This has been
0.000000,0,0.000000,# autodie's behaviour for quite a while, but it might make sense
0.000000,0,0.000000,# to change it so "!" or ":void" applies to stuff after they
0.000000,0,0.000000,# appear (even if they are all duplicates).
0.000027,2,0.000014,for my $func ($class->_translate_import_args(@fatalise_these)) {
0.000000,0,0.000000,
0.000504,106,0.000005,if ($func eq VOID_TAG) {
0.000000,0,0.000000,
0.000000,0,0.000000,# When we see :void, set the void flag.
0.000000,0,0.000000,$void = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ($func eq INSIST_TAG) {
0.000000,0,0.000000,
0.000000,0,0.000000,$insist_hints = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Otherwise, fatalise it.
0.000000,0,0.000000,
0.000000,0,0.000000,# Check to see if there's an insist flag at the front.
0.000000,0,0.000000,# If so, remove it, and insist we have hints for this sub.
0.000144,106,0.000001,my $insist_this;
0.000000,0,0.000000,
0.000655,106,0.000006,if ($func =~ s/^!//) {
0.000000,0,0.000000,$insist_this = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We're going to make a subroutine fatalistic.
0.000000,0,0.000000,# However if we're being invoked with 'use Fatal qw(x)'
0.000000,0,0.000000,# and we've already been called with 'no autodie qw(x)'
0.000000,0,0.000000,# in the same scope, we consider this to be an error.
0.000000,0,0.000000,# Mixing Fatal and autodie effects was considered to be
0.000000,0,0.000000,# needlessly confusing on p5p.
0.000000,0,0.000000,
0.000164,106,0.000002,my $sub = $func;
0.000678,106,0.000006,$sub = "${pkg}::$sub" unless $sub =~ /::/;
0.000000,0,0.000000,
0.000000,0,0.000000,# If we're being called as Fatal, and we've previously
0.000000,0,0.000000,# had a 'no X' in scope for the subroutine, then complain
0.000000,0,0.000000,# bitterly.
0.000000,0,0.000000,
0.000153,106,0.000001,if (! $lexical and $^H{$NO_PACKAGE}{$sub}) {
0.000000,0,0.000000,croak(sprintf(ERROR_FATAL_CONFLICT, $func, $func));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We're not being used in a confusing way, so make
0.000000,0,0.000000,# the sub fatal.  Note that _make_fatal returns the
0.000000,0,0.000000,# old (original) version of the sub, or undef for
0.000000,0,0.000000,# built-ins.
0.000000,0,0.000000,
0.000613,106,0.000006,my $sub_ref = $class->_make_fatal(
0.000000,0,0.000000,$func, $pkg, $void, $lexical, $filename,
0.000000,0,0.000000,( $insist_this || $insist_hints )
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000218,106,0.000002,$Original_user_sub{$sub} ||= $sub_ref;
0.000000,0,0.000000,
0.000000,0,0.000000,# If we're making lexical changes, we need to arrange
0.000000,0,0.000000,# for them to be cleaned at the end of our scope, so
0.000000,0,0.000000,# record them here.
0.000000,0,0.000000,
0.000234,106,0.000002,$unload_later{$func} = $sub_ref if $lexical;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,2,0.000003,if ($lexical) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Dark magic to have autodie work under 5.8
0.000000,0,0.000000,# Copied from namespace::clean, that copied it from
0.000000,0,0.000000,# autobox, that found it on an ancient scroll written
0.000000,0,0.000000,# in blood.
0.000000,0,0.000000,
0.000000,0,0.000000,# This magic bit causes %^H to be lexically scoped.
0.000000,0,0.000000,
0.000005,2,0.000003,$^H |= 0x020000;
0.000000,0,0.000000,
0.000000,0,0.000000,# Our package guard gets invoked when we leave our lexical
0.000000,0,0.000000,# scope.
0.000000,0,0.000000,
0.000000,0,0.000000,push(@ { $^H{$PACKAGE_GUARD} }, autodie::Scope::Guard->new(sub {
0.000032,2,0.000016,$class->_install_subs($pkg, \%unload_later);
0.000028,2,0.000014,}));
0.000000,0,0.000000,
0.000000,0,0.000000,# To allow others to determine when autodie was in scope,
0.000000,0,0.000000,# and with what arguments, we also set a %^H hint which
0.000000,0,0.000000,# is how we were called.
0.000000,0,0.000000,
0.000000,0,0.000000,# This feature should be considered EXPERIMENTAL, and
0.000000,0,0.000000,# may change without notice.  Please e-mail pjf@cpan.org
0.000000,0,0.000000,# if you're actually using it.
0.000000,0,0.000000,
0.000010,2,0.000005,$^H{autodie} = "$PACKAGE @original_args";
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,2,0.000008,return;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The code here is originally lifted from namespace::clean,
0.000000,0,0.000000,# by Robert "phaylon" Sedlacek.
0.000000,0,0.000000,#
0.000000,0,0.000000,# It's been redesigned after feedback from ikegami on perlmonks.
0.000000,0,0.000000,# See http://perlmonks.org/?node_id=693338 .  Ikegami rocks.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Given a package, and hash of (subname => subref) pairs,
0.000000,0,0.000000,# we install the given subroutines into the package.  If
0.000000,0,0.000000,# a subref is undef, the subroutine is removed.  Otherwise
0.000000,0,0.000000,# it replaces any existing subs which were already there.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_subs {
0.000191,108,0.000002,my ($class, $pkg, $subs_to_reinstate) = @_;
0.000000,0,0.000000,
0.000185,108,0.000002,my $pkg_sym = "${pkg}::";
0.000000,0,0.000000,
0.000000,0,0.000000,# It does not hurt to do this in a predictable order, and might help debugging.
0.001090,108,0.000010,foreach my $sub_name (sort keys %$subs_to_reinstate) {
0.000356,212,0.000002,my $sub_ref= $subs_to_reinstate->{$sub_name};
0.000000,0,0.000000,
0.000346,212,0.000002,my $full_path = $pkg_sym.$sub_name;
0.000000,0,0.000000,
0.000000,0,0.000000,# Copy symbols across to temp area.
0.000000,0,0.000000,
0.000048,2,0.000024,no strict 'refs';   ## no critic
0.000000,0,0.000000,
0.000641,212,0.000003,local *__tmp = *{ $full_path };
0.000000,0,0.000000,
0.000000,0,0.000000,# Nuke the old glob.
0.001203,426,0.000003,{ no strict; delete $pkg_sym->{$sub_name}; }    ## no critic
0.000000,0,0.000000,
0.000000,0,0.000000,# Copy innocent bystanders back.  Note that we lose
0.000000,0,0.000000,# formats; it seems that Perl versions up to 5.10.0
0.000000,0,0.000000,# have a bug which causes copying formats to end up in
0.000000,0,0.000000,# the scalar slot.  Thanks to Ben Morrow for spotting this.
0.000000,0,0.000000,
0.001638,212,0.000008,foreach my $slot (qw( SCALAR ARRAY HASH IO ) ) {
0.001357,848,0.000002,next unless defined *__tmp{ $slot };
0.000901,212,0.000004,*{ $full_path } = *__tmp{ $slot };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Put back the old sub (if there was one).
0.000000,0,0.000000,
0.000945,212,0.000004,if ($sub_ref) {
0.000000,0,0.000000,
0.002437,2,0.001218,no strict;  ## no critic
0.000236,106,0.000002,*{ $full_path } = $sub_ref;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000591,108,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Calling "no Fatal" must start with ":lexical"
0.000000,0,0.000000,if ($_[0] ne LEXICAL_TAG) {
0.000000,0,0.000000,croak(sprintf(ERROR_NO_LEX,$class));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,shift @_;   # Remove :lexical
0.000000,0,0.000000,
0.000000,0,0.000000,my $pkg = (caller)[0];
0.000000,0,0.000000,
0.000000,0,0.000000,# If we've been called with arguments, then the developer
0.000000,0,0.000000,# has explicitly stated 'no autodie qw(blah)',
0.000000,0,0.000000,# in which case, we disable Fatalistic behaviour for 'blah'.
0.000000,0,0.000000,
0.000000,0,0.000000,my @unimport_these = @_ ? @_ : ':all';
0.000000,0,0.000000,
0.000000,0,0.000000,for my $symbol ($class->_translate_import_args(@unimport_these)) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = $symbol;
0.000000,0,0.000000,$sub = "${pkg}::$sub" unless $sub =~ /::/;
0.000000,0,0.000000,
0.000000,0,0.000000,# If 'blah' was already enabled with Fatal (which has package
0.000000,0,0.000000,# scope) then, this is considered an error.
0.000000,0,0.000000,
0.000000,0,0.000000,if (exists $Package_Fatal{$sub}) {
0.000000,0,0.000000,croak(sprintf(ERROR_AUTODIE_CONFLICT,$symbol,$symbol));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Record 'no autodie qw($sub)' as being in effect.
0.000000,0,0.000000,# This is to catch conflicting semantics elsewhere
0.000000,0,0.000000,# (eg, mixing Fatal with no autodie)
0.000000,0,0.000000,
0.000000,0,0.000000,$^H{$NO_PACKAGE}{$sub} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $original_sub = $Original_user_sub{$sub}) {
0.000000,0,0.000000,# Hey, we've got an original one of these, put it back.
0.000000,0,0.000000,$class->_install_subs($pkg, { $symbol => $original_sub });
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We don't have an original copy of the sub, on the assumption
0.000000,0,0.000000,# it's core (or doesn't exist), we'll just nuke it.
0.000000,0,0.000000,
0.000000,0,0.000000,$class->_install_subs($pkg,{ $symbol => undef });
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _translate_import_args {
0.000004,2,0.000002,my ($class, @args) = @_;
0.000003,2,0.000001,my @result;
0.000006,2,0.000003,for my $a (@args){
0.000013,2,0.000006,if (exists $TAGS{$a}) {
0.000015,2,0.000007,my $expanded = $class->_expand_tag($a);
0.000000,0,0.000000,# Strip "CORE::" from all elements in the list as import and
0.000000,0,0.000000,# unimport does not handle the "CORE::" prefix too well.
0.000000,0,0.000000,#
0.000000,0,0.000000,# NB: we use substr as it is faster than s/^CORE::// and
0.000000,0,0.000000,# it does not change the elements.
0.000045,2,0.000023,push @result, map { substr($_, 6) } @{$expanded};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,#pass through
0.000000,0,0.000000,push @result, $a;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# If @args < 2, then we have no duplicates (because _expand_tag
0.000000,0,0.000000,# does not have duplicates and if it is not a tag, it is just a
0.000000,0,0.000000,# single value).  We optimize for this because it is a fairly
0.000000,0,0.000000,# common case (e.g. use autodie; or use autodie qw(:all); both
0.000000,0,0.000000,# trigger this).
0.000029,2,0.000014,return @result if @args < 2;
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,# Yes, this is basically List::MoreUtils's uniq/distinct, but
0.000000,0,0.000000,# List::MoreUtils is not in the Perl core and autodie is
0.000000,0,0.000000,return grep { !$seen{$_}++ } @result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# NB: Perl::Critic's dump-autodie-tag-contents depends upon this
0.000000,0,0.000000,# continuing to work.
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000005,2,0.000002,my %tag_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,# Expand a given tag (e.g. ":default") into a listref containing
0.000000,0,0.000000,# all sub names covered by that tag.  Each sub is returned as
0.000000,0,0.000000,# "CORE::<name>" (i.e. "CORE::open" rather than "open").
0.000000,0,0.000000,#
0.000000,0,0.000000,# NB: the listref must not be modified.
0.000000,0,0.000000,sub _expand_tag {
0.000021,12,0.000002,my ($class, $tag) = @_;
0.000000,0,0.000000,
0.000025,12,0.000002,if (my $cached = $tag_cache{$tag}) {
0.000000,0,0.000000,return $cached;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,11,0.000001,if (not exists $TAGS{$tag}) {
0.000000,0,0.000000,croak "Invalid exception class $tag";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000030,11,0.000003,my @to_process = @{$TAGS{$tag}};
0.000000,0,0.000000,
0.000000,0,0.000000,# If the tag is basically an alias of another tag (like e.g. ":2.11"),
0.000000,0,0.000000,# then just share the resulting reference with the original content (so
0.000000,0,0.000000,# we only pay for an extra reference for the alias memory-wise).
0.000017,11,0.000002,if (@to_process == 1 && substr($to_process[0], 0, 1) eq ':') {
0.000000,0,0.000000,# We could do this for "non-tags" as well, but that only occurs
0.000000,0,0.000000,# once at the time of writing (":threads" => ["fork"]), so
0.000000,0,0.000000,# probably not worth it.
0.000000,0,0.000000,my $expanded = $class->_expand_tag($to_process[0]);
0.000000,0,0.000000,$tag_cache{$tag} = $expanded;
0.000000,0,0.000000,return $expanded;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,11,0.000002,my %seen = ();
0.000016,11,0.000001,my @taglist = ();
0.000000,0,0.000000,
0.000032,11,0.000003,for my $item (@to_process) {
0.000000,0,0.000000,# substr is more efficient than m/^:/ for stuff like this,
0.000000,0,0.000000,# at the price of being a bit more verbose/low-level.
0.000280,63,0.000004,if (substr($item, 0, 1) eq ':') {
0.000000,0,0.000000,# Use recursion here to ensure we expand a tag at most once.
0.000000,0,0.000000,#
0.000000,0,0.000000,# TODO: Improve handling of :all so we don't expand
0.000000,0,0.000000,# all those aliases (e.g :2.00..:2.07 are all aliases
0.000000,0,0.000000,# of v2.07).
0.000000,0,0.000000,
0.000055,10,0.000006,my $expanded = $class->_expand_tag($item);
0.000082,10,0.000008,push @taglist, grep { !$seen{$_}++ } @{$expanded};
0.000000,0,0.000000,} else {
0.000080,53,0.000002,my $subname = "CORE::$item";
0.000114,53,0.000002,push @taglist, $subname
0.000000,0,0.000000,unless $seen{$subname}++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000020,11,0.000002,$tag_cache{$tag} = \@taglist;
0.000000,0,0.000000,
0.000074,11,0.000007,return \@taglist;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This code is from the original Fatal.  It scares me.
0.000000,0,0.000000,# It is 100% compatible with the 5.10.0 Fatal module, right down
0.000000,0,0.000000,# to the scary 'XXXX' comment.  ;)
0.000000,0,0.000000,
0.000000,0,0.000000,sub fill_protos {
0.000137,81,0.000002,my $proto = shift;
0.000166,81,0.000002,my ($n, $isref, @out, @out1, $seen_semi) = -1;
0.000558,81,0.000007,if ($proto =~ m{^\s* (?: [;] \s*)? \@}x) {
0.000000,0,0.000000,# prototype is entirely slurp - special case that does not
0.000000,0,0.000000,# require any handling.
0.000000,0,0.000000,return ([0, '@_']);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001901,76,0.000025,while ($proto =~ /\S/) {
0.000315,217,0.000001,$n++;
0.000326,217,0.000002,push(@out1,[$n,@out]) if $seen_semi;
0.001242,217,0.000006,push(@out, $1 . "{\$_[$n]}"), next if $proto =~ s/^\s*\\([\@%\$\&])//;
0.001467,207,0.000007,push(@out, "\$_[$n]"),        next if $proto =~ s/^\s*([_*\$&])//;
0.000125,21,0.000006,push(@out, "\@_[$n..\$#_]"),  last if $proto =~ s/^\s*(;\s*)?\@//;
0.000132,19,0.000007,$seen_semi = 1, $n--,         next if $proto =~ s/^\s*;//; # XXXX ????
0.000000,0,0.000000,die "Internal error: Unknown prototype letters: \"$proto\"";
0.000000,0,0.000000,}
0.000222,76,0.000003,push(@out1,[$n+1,@out]);
0.000407,76,0.000005,return @out1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a backwards compatible version of _write_invocation.  It's
0.000000,0,0.000000,# recommended you don't use it.
0.000000,0,0.000000,
0.000000,0,0.000000,sub write_invocation {
0.000000,0,0.000000,my ($core, $call, $name, $void, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return Fatal->_write_invocation(
0.000000,0,0.000000,$core, $call, $name, $void,
0.000000,0,0.000000,0,      # Lexical flag
0.000000,0,0.000000,undef,  # Sub, unused in legacy mode
0.000000,0,0.000000,undef,  # Subref, unused in legacy mode.
0.000000,0,0.000000,@args
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This version of _write_invocation is used internally.  It's not
0.000000,0,0.000000,# recommended you call it from external code, as the interface WILL
0.000000,0,0.000000,# change in the future.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _write_invocation {
0.000000,0,0.000000,
0.000192,81,0.000002,my ($class, $core, $call, $name, $void, $lexical, $sub, $sref, @argvs) = @_;
0.000000,0,0.000000,
0.000142,81,0.000002,if (@argvs == 1) {        # No optional arguments
0.000000,0,0.000000,
0.000152,62,0.000002,my @argv = @{$argvs[0]};
0.000096,62,0.000002,shift @argv;
0.000000,0,0.000000,
0.000560,62,0.000009,return $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000029,19,0.000002,my $else = "\t";
0.000027,19,0.000001,my (@out, @argv, $n);
0.000058,19,0.000003,while (@argvs) {
0.000116,42,0.000003,@argv = @{shift @argvs};
0.000064,42,0.000002,$n = shift @argv;
0.000000,0,0.000000,
0.000076,42,0.000002,my $condition = "\@_ == $n";
0.000000,0,0.000000,
0.000278,42,0.000007,if (@argv and $argv[-1] =~ /[#@]_/) {
0.000000,0,0.000000,# This argv ends with '@' in the prototype, so it matches
0.000000,0,0.000000,# any number of args >= the number of expressions in the
0.000000,0,0.000000,# argv.
0.000000,0,0.000000,$condition = "\@_ >= $n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000091,42,0.000002,push @out, "${else}if ($condition) {\n";
0.000000,0,0.000000,
0.000060,42,0.000001,$else = "\t} els";
0.000000,0,0.000000,
0.000312,42,0.000007,push @out, $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
0.000000,0,0.000000,}
0.000047,19,0.000002,push @out, qq[
0.000000,0,0.000000,}
0.000000,0,0.000000,die "Internal error: $name(\@_): Do not expect to get ", scalar(\@_), " arguments";
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000174,19,0.000009,return join '', @out;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a slim interface to ensure backward compatibility with
0.000000,0,0.000000,# anyone doing very foolish things with old versions of Fatal.
0.000000,0,0.000000,
0.000000,0,0.000000,sub one_invocation {
0.000000,0,0.000000,my ($core, $call, $name, $void, @argv) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return Fatal->_one_invocation(
0.000000,0,0.000000,$core, $call, $name, $void,
0.000000,0,0.000000,undef,   # Sub.  Unused in back-compat mode.
0.000000,0,0.000000,1,       # Back-compat flag
0.000000,0,0.000000,undef,   # Subref, unused in back-compat mode.
0.000000,0,0.000000,@argv
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is the internal interface that generates code.
0.000000,0,0.000000,# NOTE: This interface WILL change in the future.  Please do not
0.000000,0,0.000000,# call this subroutine directly.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: Whatever's calling this code has already looked up hints.  Pass
0.000000,0,0.000000,# them in, rather than look them up a second time.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _one_invocation {
0.000262,104,0.000003,my ($class, $core, $call, $name, $void, $sub, $back_compat, $sref, @argv) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# If someone is calling us directly (a child class perhaps?) then
0.000000,0,0.000000,# they could try to mix void without enabling backwards
0.000000,0,0.000000,# compatibility.  We just don't support this at all, so we gripe
0.000000,0,0.000000,# about it rather than doing something unwise.
0.000000,0,0.000000,
0.000146,104,0.000001,if ($void and not $back_compat) {
0.000000,0,0.000000,Carp::confess("Internal error: :void mode not supported with $class");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# @argv only contains the results of the in-built prototype
0.000000,0,0.000000,# function, and is therefore safe to interpolate in the
0.000000,0,0.000000,# code generators below.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - The following clobbers context, but that's what the
0.000000,0,0.000000,#        old Fatal did.  Do we care?
0.000000,0,0.000000,
0.000149,104,0.000001,if ($back_compat) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Use Fatal qw(system) will never be supported.  It generated
0.000000,0,0.000000,# a compile-time error with legacy Fatal, and there's no reason
0.000000,0,0.000000,# to support it when autodie does a better job.
0.000000,0,0.000000,
0.000000,0,0.000000,if ($call eq 'CORE::system') {
0.000000,0,0.000000,return q{
0.000000,0,0.000000,croak("UNIMPLEMENTED: use Fatal qw(system) not supported.");
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,local $" = ', ';
0.000000,0,0.000000,
0.000000,0,0.000000,if ($void) {
0.000000,0,0.000000,return qq/return (defined wantarray)?$call(@argv):
0.000000,0,0.000000,$call(@argv) || Carp::croak("Can't $name(\@_)/ .
0.000000,0,0.000000,($core ? ': $!' : ', \$! is \"$!\"') . '")'
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return qq{return $call(@argv) || Carp::croak("Can't $name(\@_)} .
0.000000,0,0.000000,($core ? ': $!' : ', \$! is \"$!\"') . '")';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The name of our original function is:
0.000000,0,0.000000,#   $call if the function is CORE
0.000000,0,0.000000,#   $sub if our function is non-CORE
0.000000,0,0.000000,
0.000000,0,0.000000,# The reason for this is that $call is what we're actually
0.000000,0,0.000000,# calling.  For our core functions, this is always
0.000000,0,0.000000,# CORE::something.  However for user-defined subs, we're about to
0.000000,0,0.000000,# replace whatever it is that we're calling; as such, we actually
0.000000,0,0.000000,# calling a subroutine ref.
0.000000,0,0.000000,
0.000156,104,0.000002,my $human_sub_name = $core ? $call : $sub;
0.000000,0,0.000000,
0.000000,0,0.000000,# Should we be testing to see if our result is defined, or
0.000000,0,0.000000,# just true?
0.000000,0,0.000000,
0.000141,104,0.000001,my $use_defined_or;
0.000000,0,0.000000,
0.000139,104,0.000001,my $hints;      # All user-sub hints, including list hints.
0.000000,0,0.000000,
0.000186,104,0.000002,if ( $core ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Core hints are built into autodie.
0.000000,0,0.000000,
0.000000,0,0.000000,$use_defined_or = exists ( $Use_defined_or{$call} );
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# User sub hints are looked up using autodie::hints,
0.000000,0,0.000000,# since users may wish to add their own hints.
0.000000,0,0.000000,
0.000000,0,0.000000,require autodie::hints;
0.000000,0,0.000000,
0.000000,0,0.000000,$hints = autodie::hints->get_hints_for( $sref );
0.000000,0,0.000000,
0.000000,0,0.000000,# We'll look up the sub's fullname.  This means we
0.000000,0,0.000000,# get better reports of where it came from in our
0.000000,0,0.000000,# error messages, rather than what imported it.
0.000000,0,0.000000,
0.000000,0,0.000000,$human_sub_name = autodie::hints->sub_fullname( $sref );
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Checks for special core subs.
0.000000,0,0.000000,
0.000154,104,0.000001,if ($call eq 'CORE::system') {
0.000000,0,0.000000,
0.000000,0,0.000000,# Leverage IPC::System::Simple if we're making an autodying
0.000000,0,0.000000,# system.
0.000000,0,0.000000,
0.000000,0,0.000000,local $" = ", ";
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to stash $@ into $E, rather than using
0.000000,0,0.000000,# local $@ for the whole sub.  If we don't then
0.000000,0,0.000000,# any exceptions from internal errors in autodie/Fatal
0.000000,0,0.000000,# will mysteriously disappear before propagating
0.000000,0,0.000000,# upwards.
0.000000,0,0.000000,
0.000000,0,0.000000,return qq{
0.000000,0,0.000000,my \$retval;
0.000000,0,0.000000,my \$E;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,local \$@;
0.000000,0,0.000000,
0.000000,0,0.000000,eval {
0.000000,0,0.000000,\$retval = IPC::System::Simple::system(@argv);
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,\$E = \$@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (\$E) {
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - This can't be overridden in child
0.000000,0,0.000000,# classes!
0.000000,0,0.000000,
0.000000,0,0.000000,die autodie::exception::system->new(
0.000000,0,0.000000,function => q{CORE::system}, args => [ @argv ],
0.000000,0,0.000000,message => "\$E", errno => \$!,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \$retval;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000180,104,0.000002,local $" = ', ';
0.000000,0,0.000000,
0.000000,0,0.000000,# If we're going to throw an exception, here's the code to use.
0.000284,104,0.000003,my $die = qq{
0.000000,0,0.000000,die $class->throw(
0.000000,0,0.000000,function => q{$human_sub_name}, args => [ @argv ],
0.000000,0,0.000000,pragma => q{$class}, errno => \$!,
0.000000,0,0.000000,context => \$context, return => \$retval,
0.000000,0,0.000000,eval_error => \$@
0.000000,0,0.000000,)
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000146,104,0.000001,if ($call eq 'CORE::flock') {
0.000000,0,0.000000,
0.000000,0,0.000000,# flock needs special treatment.  When it fails with
0.000000,0,0.000000,# LOCK_UN and EWOULDBLOCK, then it's not really fatal, it just
0.000000,0,0.000000,# means we couldn't get the lock right now.
0.000000,0,0.000000,
0.000168,2,0.000084,require POSIX;      # For POSIX::EWOULDBLOCK
0.000000,0,0.000000,
0.000003,2,0.000002,local $@;   # Don't blat anyone else's $@.
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure that our vendor supports EWOULDBLOCK.  If they
0.000000,0,0.000000,# don't (eg, Windows), then we use known values for its
0.000000,0,0.000000,# equivalent on other systems.
0.000000,0,0.000000,
0.000026,4,0.000007,my $EWOULDBLOCK = eval { POSIX::EWOULDBLOCK(); }
0.000000,0,0.000000,|| $_EWOULDBLOCK{$^O}
0.000000,0,0.000000,|| _autocroak("Internal error - can't overload flock - EWOULDBLOCK not defined on this system.");
0.000003,2,0.000002,my $EAGAIN = $EWOULDBLOCK;
0.000003,2,0.000002,if ($try_EAGAIN) {
0.000000,0,0.000000,$EAGAIN = eval { POSIX::EAGAIN(); }
0.000000,0,0.000000,|| _autocroak("Internal error - can't overload flock - EAGAIN not defined on this system.");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,2,0.000002,require Fcntl;      # For Fcntl::LOCK_NB
0.000000,0,0.000000,
0.000028,2,0.000014,return qq{
0.000000,0,0.000000,
0.000000,0,0.000000,my \$context = wantarray() ? "list" : "scalar";
0.000000,0,0.000000,
0.000000,0,0.000000,# Try to flock.  If successful, return it immediately.
0.000000,0,0.000000,
0.000000,0,0.000000,my \$retval = $call(@argv);
0.000000,0,0.000000,return \$retval if \$retval;
0.000000,0,0.000000,
0.000000,0,0.000000,# If we failed, but we're using LOCK_NB and
0.000000,0,0.000000,# returned EWOULDBLOCK, it's not a real error.
0.000000,0,0.000000,
0.000000,0,0.000000,if (\$_[1] & Fcntl::LOCK_NB() and
0.000000,0,0.000000,(\$! == $EWOULDBLOCK or
0.000000,0,0.000000,($try_EAGAIN and \$! == $EAGAIN ))) {
0.000000,0,0.000000,return \$retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Otherwise, we failed.  Die noisily.
0.000000,0,0.000000,
0.000000,0,0.000000,$die;
0.000000,0,0.000000,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000191,102,0.000002,if (exists $Returns_num_things_changed{$call}) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Some things return the number of things changed (like
0.000000,0,0.000000,# chown, kill, chmod, etc). We only consider these successful
0.000000,0,0.000000,# if *all* the things are changed.
0.000000,0,0.000000,
0.000000,0,0.000000,return qq[
0.000000,0,0.000000,my \$num_things = \@_ - $Returns_num_things_changed{$call};
0.000000,0,0.000000,my \$retval = $call(@argv);
0.000000,0,0.000000,
0.000000,0,0.000000,if (\$retval != \$num_things) {
0.000000,0,0.000000,
0.000000,0,0.000000,# We need \$context to throw an exception.
0.000000,0,0.000000,# It's *always* set to scalar, because that's how
0.000000,0,0.000000,# autodie calls chown() above.
0.000000,0,0.000000,
0.000000,0,0.000000,my \$context = "scalar";
0.000000,0,0.000000,$die;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \$retval;
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# AFAIK everything that can be given an unopned filehandle
0.000000,0,0.000000,# will fail if it tries to use it, so we don't really need
0.000000,0,0.000000,# the 'unopened' warning class here.  Especially since they
0.000000,0,0.000000,# then report the wrong line number.
0.000000,0,0.000000,
0.000000,0,0.000000,# Other warnings are disabled because they produce excessive
0.000000,0,0.000000,# complaints from smart-match hints under 5.10.1.
0.000000,0,0.000000,
0.000215,97,0.000002,my $code = qq[
0.000000,0,0.000000,no warnings qw(unopened uninitialized numeric);
0.000000,0,0.000000,no if \$\] >= 5.017011, warnings => "experimental::smartmatch";
0.000000,0,0.000000,
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,my \@results = $call(@argv);
0.000000,0,0.000000,my \$retval  = \\\@results;
0.000000,0,0.000000,my \$context = "list";
0.000000,0,0.000000,
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000167,97,0.000002,my $retval_action = $Retval_action{$call} || '';
0.000000,0,0.000000,
0.000282,97,0.000003,if ( $hints and ( ref($hints->{list} ) || "" ) eq 'CODE' ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# NB: Subroutine hints are passed as a full list.
0.000000,0,0.000000,# This differs from the 5.10.0 smart-match behaviour,
0.000000,0,0.000000,# but means that context unaware subroutines can use
0.000000,0,0.000000,# the same hints in both list and scalar context.
0.000000,0,0.000000,
0.000000,0,0.000000,$code .= qq{
0.000000,0,0.000000,if ( \$hints->{list}->(\@results) ) { $die };
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( PERL510 and $hints ) {
0.000000,0,0.000000,$code .= qq{
0.000000,0,0.000000,if ( \@results ~~ \$hints->{list} ) { $die };
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $hints ) {
0.000000,0,0.000000,croak sprintf(ERROR_58_HINTS, 'list', $sub);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000190,97,0.000002,$code .= qq{
0.000000,0,0.000000,# An empty list, or a single undef is failure
0.000000,0,0.000000,if (! \@results or (\@results == 1 and ! defined \$results[0])) {
0.000000,0,0.000000,$die;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Tidy up the end of our wantarray call.
0.000000,0,0.000000,
0.000142,97,0.000001,$code .= qq[
0.000000,0,0.000000,return \@results;
0.000000,0,0.000000,}
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Otherwise, we're in scalar context.
0.000000,0,0.000000,# We're never in a void context, since we have to look
0.000000,0,0.000000,# at the result.
0.000000,0,0.000000,
0.000197,97,0.000002,$code .= qq{
0.000000,0,0.000000,my \$retval  = $call(@argv);
0.000000,0,0.000000,my \$context = "scalar";
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000139,97,0.000001,if ( $hints and ( ref($hints->{scalar} ) || "" ) eq 'CODE' ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# We always call code refs directly, since that always
0.000000,0,0.000000,# works in 5.8.x, and always works in 5.10.1
0.000000,0,0.000000,
0.000000,0,0.000000,return $code .= qq{
0.000000,0,0.000000,if ( \$hints->{scalar}->(\$retval) ) { $die };
0.000000,0,0.000000,$retval_action
0.000000,0,0.000000,return \$retval;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (PERL510 and $hints) {
0.000000,0,0.000000,return $code . qq{
0.000000,0,0.000000,
0.000000,0,0.000000,if ( \$retval ~~ \$hints->{scalar} ) { $die };
0.000000,0,0.000000,$retval_action
0.000000,0,0.000000,return \$retval;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $hints ) {
0.000000,0,0.000000,croak sprintf(ERROR_58_HINTS, 'scalar', $sub);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000730,97,0.000008,return $code .
0.000000,0,0.000000,( $use_defined_or ? qq{
0.000000,0,0.000000,
0.000000,0,0.000000,$die if not defined \$retval;
0.000000,0,0.000000,$retval_action
0.000000,0,0.000000,return \$retval;
0.000000,0,0.000000,
0.000000,0,0.000000,} : qq{
0.000000,0,0.000000,
0.000000,0,0.000000,$retval_action
0.000000,0,0.000000,return \$retval || $die;
0.000000,0,0.000000,
0.000000,0,0.000000,} ) ;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This returns the old copy of the sub, so we can
0.000000,0,0.000000,# put it back at end of scope.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO : Check to make sure prototypes are restored correctly.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: Taking a huge list of arguments is awful.  Rewriting to
0.000000,0,0.000000,#       take a hash would be lovely.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - BACKCOMPAT - This is not yet compatible with 5.10.0
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_fatal {
0.000206,106,0.000002,my($class, $sub, $pkg, $void, $lexical, $filename, $insist) = @_;
0.000148,106,0.000001,my($name, $code, $sref, $real_proto, $proto, $core, $call, $hints);
0.000154,106,0.000001,my $ini = $sub;
0.000000,0,0.000000,
0.000669,106,0.000006,$sub = "${pkg}::$sub" unless $sub =~ /::/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Figure if we're using lexical or package semantics and
0.000000,0,0.000000,# twiddle the appropriate bits.
0.000000,0,0.000000,
0.000148,106,0.000001,if (not $lexical) {
0.000000,0,0.000000,$Package_Fatal{$sub} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO - We *should* be able to do skipping, since we know when
0.000000,0,0.000000,# we've lexicalised / unlexicalised a subroutine.
0.000000,0,0.000000,
0.000154,106,0.000001,$name = $sub;
0.000827,106,0.000008,$name =~ s/.*::// or $name =~ s/^&//;
0.000000,0,0.000000,
0.000151,106,0.000001,warn  "# _make_fatal: sub=$sub pkg=$pkg name=$name void=$void\n" if $Debug;
0.000687,106,0.000006,croak(sprintf(ERROR_BADNAME, $class, $name)) unless $name =~ /^\w+$/;
0.000000,0,0.000000,
0.000584,106,0.000006,if (defined(&$sub)) {   # user subroutine
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: Previously we would localise $@ at this point, so
0.000000,0,0.000000,# the following calls to eval {} wouldn't interfere with anything
0.000000,0,0.000000,# that's already in $@.  Unfortunately, it would also stop
0.000000,0,0.000000,# any of our croaks from triggering(!), which is even worse.
0.000000,0,0.000000,
0.000000,0,0.000000,# This could be something that we've fatalised that
0.000000,0,0.000000,# was in core.
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $Package_Fatal{$sub} and do { local $@; eval { prototype "CORE::$name" } } ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Something we previously made Fatal that was core.
0.000000,0,0.000000,# This is safe to replace with an autodying to core
0.000000,0,0.000000,# version.
0.000000,0,0.000000,
0.000000,0,0.000000,$core  = 1;
0.000000,0,0.000000,$call  = "CORE::$name";
0.000000,0,0.000000,$proto = prototype $call;
0.000000,0,0.000000,
0.000000,0,0.000000,# We return our $sref from this subroutine later
0.000000,0,0.000000,# on, indicating this subroutine should be placed
0.000000,0,0.000000,# back when we're finished.
0.000000,0,0.000000,
0.000000,0,0.000000,$sref = \&$sub;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,# If this is something we've already fatalised or played with,
0.000000,0,0.000000,# then look-up the name of the original sub for the rest of
0.000000,0,0.000000,# our processing.
0.000000,0,0.000000,
0.000000,0,0.000000,$sub = $Is_fatalised_sub{\&$sub} || $sub;
0.000000,0,0.000000,
0.000000,0,0.000000,# A regular user sub, or a user sub wrapping a
0.000000,0,0.000000,# core sub.
0.000000,0,0.000000,
0.000000,0,0.000000,$sref = \&$sub;
0.000000,0,0.000000,$proto = prototype $sref;
0.000000,0,0.000000,$call = '&$sref';
0.000000,0,0.000000,require autodie::hints;
0.000000,0,0.000000,
0.000000,0,0.000000,$hints = autodie::hints->get_hints_for( $sref );
0.000000,0,0.000000,
0.000000,0,0.000000,# If we've insisted on hints, but don't have them, then
0.000000,0,0.000000,# bail out!
0.000000,0,0.000000,
0.000000,0,0.000000,if ($insist and not $hints) {
0.000000,0,0.000000,croak(sprintf(ERROR_NOHINTS, $name));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Otherwise, use the default hints if we don't have
0.000000,0,0.000000,# any.
0.000000,0,0.000000,
0.000000,0,0.000000,$hints ||= autodie::hints::DEFAULT_HINTS();
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ($sub eq $ini && $sub !~ /^CORE::GLOBAL::/) {
0.000000,0,0.000000,# Stray user subroutine
0.000000,0,0.000000,croak(sprintf(ERROR_NOTSUB,$sub));
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ($name eq 'system') {
0.000000,0,0.000000,
0.000000,0,0.000000,# If we're fatalising system, then we need to load
0.000000,0,0.000000,# helper code.
0.000000,0,0.000000,
0.000000,0,0.000000,# The business with $E is to avoid clobbering our caller's
0.000000,0,0.000000,# $@, and to avoid $@ being localised when we croak.
0.000000,0,0.000000,
0.000000,0,0.000000,my $E;
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,
0.000000,0,0.000000,eval {
0.000000,0,0.000000,require IPC::System::Simple; # Only load it if we need it.
0.000000,0,0.000000,require autodie::exception::system;
0.000000,0,0.000000,};
0.000000,0,0.000000,$E = $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($E) { croak ERROR_NO_IPC_SYS_SIMPLE; }
0.000000,0,0.000000,
0.000000,0,0.000000,# Make sure we're using a recent version of ISS that actually
0.000000,0,0.000000,# support fatalised system.
0.000000,0,0.000000,if ($IPC::System::Simple::VERSION < MIN_IPC_SYS_SIMPLE_VER) {
0.000000,0,0.000000,croak sprintf(
0.000000,0,0.000000,ERROR_IPC_SYS_SIMPLE_OLD, MIN_IPC_SYS_SIMPLE_VER,
0.000000,0,0.000000,$IPC::System::Simple::VERSION
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$call = 'CORE::system';
0.000000,0,0.000000,$name = 'system';
0.000000,0,0.000000,$core = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ($name eq 'exec') {
0.000000,0,0.000000,# Exec doesn't have a prototype.  We don't care.  This
0.000000,0,0.000000,# breaks the exotic form with lexical scope, and gives
0.000000,0,0.000000,# the regular form a "do or die" behavior as expected.
0.000000,0,0.000000,
0.000000,0,0.000000,$call = 'CORE::exec';
0.000000,0,0.000000,$name = 'exec';
0.000000,0,0.000000,$core = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {            # CORE subroutine
0.000146,106,0.000001,my $E;
0.000000,0,0.000000,{
0.000450,212,0.000002,local $@;
0.001085,212,0.000005,$proto = eval { prototype "CORE::$name" };
0.000190,106,0.000002,$E = $@;
0.000000,0,0.000000,}
0.000149,106,0.000001,croak(sprintf(ERROR_NOT_BUILT,$name)) if $E;
0.000148,106,0.000001,croak(sprintf(ERROR_CANT_OVERRIDE,$name)) if not defined $proto;
0.000150,106,0.000001,$core = 1;
0.000171,106,0.000002,$call = "CORE::$name";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000161,106,0.000002,my $true_name = $core ? $call : $sub;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: This caching works, but I don't like using $void and
0.000000,0,0.000000,# $lexical as keys.  In particular, I suspect our code may end up
0.000000,0,0.000000,# wrapping already wrapped code when autodie and Fatal are used
0.000000,0,0.000000,# together.
0.000000,0,0.000000,
0.000000,0,0.000000,# NB: We must use '$sub' (the name plus package) and not
0.000000,0,0.000000,# just '$name' (the short name) here.  Failing to do so
0.000000,0,0.000000,# results code that's in the wrong package, and hence has
0.000000,0,0.000000,# access to the wrong package filehandles.
0.000000,0,0.000000,
0.000372,106,0.000004,if (my $subref = $Cached_fatalised_sub{$class}{$sub}{$void}{$lexical}) {
0.000000,0,0.000000,$class->_install_subs($pkg, { $name => $subref });
0.000000,0,0.000000,return $sref;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If our subroutine is reusable (ie, not package depdendent),
0.000000,0,0.000000,# then check to see if we've got a cached copy, and use that.
0.000000,0,0.000000,# See RT #46984. (Thanks to Niels Thykier for being awesome!)
0.000000,0,0.000000,
0.000254,106,0.000002,if ($core && exists $reusable_builtins{$call}) {
0.000000,0,0.000000,# For non-lexical subs, we can just use this cache directly
0.000000,0,0.000000,# - for lexical variants, we need a leak guard as well.
0.000099,50,0.000002,$code = $reusable_builtins{$call}{$lexical};
0.000074,50,0.000001,if (!$lexical && defined($code)) {
0.000000,0,0.000000,$class->_install_subs($pkg, { $name => $code });
0.000000,0,0.000000,return $sref;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000188,106,0.000002,if (defined $proto) {
0.000000,0,0.000000,$real_proto = " ($proto)";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$real_proto = '';
0.000000,0,0.000000,$proto = '@';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000264,106,0.000002,if (!defined($code)) {
0.000000,0,0.000000,# No code available, generate it now.
0.000455,81,0.000006,my @protos = fill_protos($proto);
0.000000,0,0.000000,
0.000167,81,0.000002,$code = qq[
0.000000,0,0.000000,sub$real_proto {
0.000000,0,0.000000,local(\$", \$!) = (', ', 0);    # TODO - Why do we do this?
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000000,0,0.000000,# Don't have perl whine if exec fails, since we'll be handling
0.000000,0,0.000000,# the exception now.
0.000119,81,0.000001,$code .= "no warnings qw(exec);\n" if $call eq "CORE::exec";
0.000000,0,0.000000,
0.000610,81,0.000008,$code .= $class->_write_invocation($core, $call, $name, $void, $lexical,
0.000000,0,0.000000,$sub, $sref, @protos);
0.000148,81,0.000002,$code .= "}\n";
0.000113,81,0.000001,warn $code if $Debug;
0.000000,0,0.000000,
0.000000,0,0.000000,# I thought that changing package was a monumental waste of
0.000000,0,0.000000,# time for CORE subs, since they'll always be the same.  However
0.000000,0,0.000000,# that's not the case, since they may refer to package-based
0.000000,0,0.000000,# filehandles (eg, with open).
0.000000,0,0.000000,#
0.000000,0,0.000000,# The %reusable_builtins hash defines ones we can aggressively
0.000000,0,0.000000,# cache as they never depend upon package-based symbols.
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.001216,83,0.000015,no strict 'refs'; ## no critic # to avoid: Can't use string (...) as a symbol ref ...
0.000000,0,0.000000,
0.000120,81,0.000001,my $E;
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000336,162,0.000002,local $@;
0.000259,81,0.000003,if (!exists($reusable_builtins{$call})) {
0.023985,56,0.000428,$code = eval("package $pkg; require Carp; $code");  ## no critic
0.000000,0,0.000000,} else {
0.007402,25,0.000296,$code = eval("require Carp; $code");  ## no critic
0.000080,25,0.000003,if (exists $reusable_builtins{$call}) {
0.000000,0,0.000000,# cache it so we don't recompile this part again
0.000000,0,0.000000,$reusable_builtins{$call}{$lexical} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000147,81,0.000002,$E = $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000130,81,0.000002,if (not $code) {
0.000000,0,0.000000,croak("Internal error in autodie/Fatal processing $true_name: $E");
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now we need to wrap our fatalised sub inside an itty bitty
0.000000,0,0.000000,# closure, which can detect if we've leaked into another file.
0.000000,0,0.000000,# Luckily, we only need to do this for lexical (autodie)
0.000000,0,0.000000,# subs.  Fatal subs can leak all they want, it's considered
0.000000,0,0.000000,# a "feature" (or at least backwards compatible).
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: Cache our leak guards!
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: This is pretty hairy code.  A lot more tests would
0.000000,0,0.000000,# be really nice for this.
0.000000,0,0.000000,
0.000145,106,0.000001,my $leak_guard;
0.000000,0,0.000000,
0.000584,106,0.000006,if ($lexical) {
0.000000,0,0.000000,$leak_guard = _make_leak_guard($filename, $code, $sref, $call,
0.000000,0,0.000000,$pkg, $proto, $real_proto);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000156,106,0.000001,my $installed_sub = $leak_guard || $code;
0.000000,0,0.000000,
0.000732,106,0.000007,$class->_install_subs($pkg, { $name => $installed_sub });
0.000000,0,0.000000,
0.000281,106,0.000003,$Cached_fatalised_sub{$class}{$sub}{$void}{$lexical} = $installed_sub;
0.000000,0,0.000000,
0.000000,0,0.000000,# Cache that we've now overridden this sub.  If we get called
0.000000,0,0.000000,# again, we may need to find that find subroutine again (eg, for hints).
0.000000,0,0.000000,
0.000875,106,0.000008,$Is_fatalised_sub{$installed_sub} = $sref;
0.000000,0,0.000000,
0.000567,106,0.000005,return $sref;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This subroutine exists primarily so that child classes can override
0.000000,0,0.000000,# it to point to their own exception class.  Doing this is significantly
0.000000,0,0.000000,# less complex than overriding throw()
0.000000,0,0.000000,
0.000000,0,0.000000,sub exception_class { return "autodie::exception" };
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000004,2,0.000002,my %exception_class_for;
0.000002,1,0.000002,my %class_loaded;
0.000000,0,0.000000,
0.000000,0,0.000000,sub throw {
0.000000,0,0.000000,my ($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Find our exception class if we need it.
0.000000,0,0.000000,my $exception_class =
0.000000,0,0.000000,$exception_class_for{$class} ||= $class->exception_class;
0.000000,0,0.000000,
0.000000,0,0.000000,if (not $class_loaded{$exception_class}) {
0.000000,0,0.000000,if ($exception_class =~ /[^\w:']/) {
0.000000,0,0.000000,confess "Bad exception class '$exception_class'.\nThe '$class->exception_class' method wants to use $exception_class\nfor exceptions, but it contains characters which are not word-characters or colons.";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Alas, Perl does turn barewords into modules unless they're
0.000000,0,0.000000,# actually barewords.  As such, we're left doing a string eval
0.000000,0,0.000000,# to make sure we load our file correctly.
0.000000,0,0.000000,
0.000000,0,0.000000,my $E;
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;   # We can't clobber $@, it's wrong!
0.000000,0,0.000000,my $pm_file = $exception_class . ".pm";
0.000000,0,0.000000,$pm_file =~ s{ (?: :: | ' ) }{/}gx;
0.000000,0,0.000000,eval { require $pm_file };
0.000000,0,0.000000,$E = $@;    # Save $E despite ending our local.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We need quotes around $@ to make sure it's stringified
0.000000,0,0.000000,# while still in scope.  Without them, we run the risk of
0.000000,0,0.000000,# $@ having been cleared by us exiting the local() block.
0.000000,0,0.000000,
0.000000,0,0.000000,confess "Failed to load '$exception_class'.\nThis may be a typo in the '$class->exception_class' method,\nor the '$exception_class' module may not exist.\n\n $E" if $E;
0.000000,0,0.000000,
0.000000,0,0.000000,$class_loaded{$exception_class}++;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $exception_class->new(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Creates and returns a leak guard (with prototype if needed).
0.000000,0,0.000000,sub _make_leak_guard {
0.000253,106,0.000002,my ($filename, $wrapped_sub, $orig_sub, $call, $pkg, $proto, $real_proto) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# The leak guard is rather lengthly (in fact it makes up the most
0.000000,0,0.000000,# of _make_leak_guard).  It is possible to split it into a large
0.000000,0,0.000000,# "generic" part and a small wrapper with call-specific
0.000000,0,0.000000,# information.  This was done in v2.19 and profiling suggested
0.000000,0,0.000000,# that we ended up using a substantial amount of runtime in "goto"
0.000000,0,0.000000,# between the leak guard(s) and the final sub.  Therefore, the two
0.000000,0,0.000000,# parts were merged into one to reduce the runtime overhead.
0.000000,0,0.000000,
0.000000,0,0.000000,my $leak_guard = sub {
0.000000,0,0.000000,my $caller_level = 0;
0.000000,0,0.000000,my $caller;
0.000000,0,0.000000,
0.000000,0,0.000000,while ( ($caller = (caller $caller_level)[1]) =~ m{^\(eval \d+\)$} ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# If our filename is actually an eval, and we
0.000000,0,0.000000,# reach it, then go to our autodying code immediatately.
0.000000,0,0.000000,
0.000000,0,0.000000,last if ($caller eq $filename);
0.000000,0,0.000000,$caller_level++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We're now out of the eval stack.
0.000000,0,0.000000,
0.000000,0,0.000000,if ($caller eq $filename) {
0.000000,0,0.000000,# No leak, call the wrapper.  NB: In this case, it doesn't
0.000000,0,0.000000,# matter if it is a CORE sub or not.
0.000000,0,0.000000,goto $wrapped_sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We leaked, time to call the original function.
0.000000,0,0.000000,# - for non-core functions that will be $orig_sub
0.000000,0,0.000000,goto $orig_sub if defined($orig_sub);
0.000000,0,0.000000,
0.000000,0,0.000000,# We are wrapping a CORE sub
0.000000,0,0.000000,
0.000000,0,0.000000,# If we've cached a trampoline, then use it.
0.000000,0,0.000000,my $trampoline_sub = $Trampoline_cache{$pkg}{$call};
0.000000,0,0.000000,
0.000000,0,0.000000,if (not $trampoline_sub) {
0.000000,0,0.000000,# If we don't have a trampoline, we need to build it.
0.000000,0,0.000000,#
0.000000,0,0.000000,# We only generate trampolines when we need them, and
0.000000,0,0.000000,# we can cache them by subroutine + package.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: Consider caching on reusable_builtins status as well.
0.000000,0,0.000000,
0.000000,0,0.000000,$trampoline_sub = _make_core_trampoline($call, $pkg, $proto);
0.000000,0,0.000000,
0.000000,0,0.000000,# Let's cache that, so we don't have to do it again.
0.000000,0,0.000000,$Trampoline_cache{$pkg}{$call} = $trampoline_sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Bounce to our trampoline, which takes us to our core sub.
0.000000,0,0.000000,goto \&$trampoline_sub;
0.000366,106,0.000003,};  # <-- end of leak guard
0.000000,0,0.000000,
0.000000,0,0.000000,# If there is a prototype on the original sub, copy it to the leak
0.000000,0,0.000000,# guard.
0.000898,106,0.000008,if ($real_proto ne '') {
0.000000,0,0.000000,# The "\&" may appear to be redundant but set_prototype
0.000000,0,0.000000,# croaks when it is removed.
0.000000,0,0.000000,set_prototype(\&$leak_guard, $proto);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000521,106,0.000005,return $leak_guard;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Create a trampoline for calling a core sub.  Essentially, a tiny sub
0.000000,0,0.000000,# that figures out how we should be calling our core sub, puts in the
0.000000,0,0.000000,# arguments in the right way, and bounces our control over to it.
0.000000,0,0.000000,#
0.000000,0,0.000000,# If we could use `goto &` on core builtins, we wouldn't need this.
0.000000,0,0.000000,sub _make_core_trampoline {
0.000000,0,0.000000,my ($call, $pkg, $proto_str) = @_;
0.000000,0,0.000000,my $trampoline_code = 'sub {';
0.000000,0,0.000000,my $trampoline_sub;
0.000000,0,0.000000,my @protos = fill_protos($proto_str);
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: It may be possible to combine this with write_invocation().
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $proto (@protos) {
0.000000,0,0.000000,local $" = ", ";    # So @args is formatted correctly.
0.000000,0,0.000000,my ($count, @args) = @$proto;
0.000000,0,0.000000,if (@args && $args[-1] =~ m/[@#]_/) {
0.000000,0,0.000000,$trampoline_code .= qq/
0.000000,0,0.000000,if (\@_ >= $count) {
0.000000,0,0.000000,return $call(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,/;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$trampoline_code .= qq<
0.000000,0,0.000000,if (\@_ == $count) {
0.000000,0,0.000000,return $call(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,>;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$trampoline_code .= qq< Carp::croak("Internal error in Fatal/autodie.  Leak-guard failure"); } >;
0.000000,0,0.000000,my $E;
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,$trampoline_sub = eval "package $pkg;\n $trampoline_code"; ## no critic
0.000000,0,0.000000,$E = $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,die "Internal error in Fatal/autodie: Leak-guard installation failure: $E"
0.000000,0,0.000000,if $E;
0.000000,0,0.000000,
0.000000,0,0.000000,return $trampoline_sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# For some reason, dying while replacing our subs doesn't
0.000000,0,0.000000,# kill our calling program.  It simply stops the loading of
0.000000,0,0.000000,# autodie and keeps going with everything else.  The _autocroak
0.000000,0,0.000000,# sub allows us to die with a vengeance.  It should *only* ever be
0.000000,0,0.000000,# used for serious internal errors, since the results of it can't
0.000000,0,0.000000,# be captured.
0.000000,0,0.000000,
0.000000,0,0.000000,sub _autocroak {
0.000000,0,0.000000,warn Carp::longmess(@_);
0.000000,0,0.000000,exit(255);  # Ugh!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package autodie::Scope::Guard;
0.000000,0,0.000000,
0.000000,0,0.000000,# This code schedules the cleanup of subroutines at the end of
0.000000,0,0.000000,# scope.  It's directly inspired by chocolateboy's excellent
0.000000,0,0.000000,# Scope::Guard module.
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000004,2,0.000002,my ($class, $handler) = @_;
0.000000,0,0.000000,
0.000014,2,0.000007,return bless $handler, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000004,2,0.000002,my ($self) = @_;
0.000000,0,0.000000,
0.000031,2,0.000015,$self->();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000028,1,0.000028,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
