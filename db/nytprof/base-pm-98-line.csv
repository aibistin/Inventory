# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package base;
0.000000,0,0.000000,
0.000034,2,0.000017,use strict 'vars';
0.000771,2,0.000385,use vars qw($VERSION);
0.000002,1,0.000002,$VERSION = '2.18';
0.000019,1,0.000019,$VERSION = eval $VERSION;
0.000000,0,0.000000,
0.000000,0,0.000000,# constant.pm is slow
0.000000,0,0.000000,sub SUCCESS () { 1 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub PUBLIC     () { 2**0  }
0.000000,0,0.000000,sub PRIVATE    () { 2**1  }
0.000000,0,0.000000,sub INHERITED  () { 2**2  }
0.000000,0,0.000000,sub PROTECTED  () { 2**3  }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000002,1,0.000002,my $Fattr = \%fields::attr;
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_fields {
0.000143,82,0.000002,my($base) = shift;
0.000211,82,0.000003,my $fglob = ${"$base\::"}{FIELDS};
0.000487,82,0.000006,return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_attr {
0.000133,82,0.000002,my($proto) = shift;
0.000137,82,0.000002,my($class) = ref $proto || $proto;
0.000414,82,0.000005,return exists $Fattr->{$class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_attr {
0.000000,0,0.000000,$Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};
0.000000,0,0.000000,return $Fattr->{$_[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,if ($] < 5.009) {
0.000000,0,0.000000,*get_fields = sub {
0.000000,0,0.000000,# Shut up a possible typo warning.
0.000000,0,0.000000,() = \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,my $f = \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,
0.000000,0,0.000000,# should be centralized in fields? perhaps
0.000000,0,0.000000,# fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
0.000000,0,0.000000,# is used here anyway, it doesn't matter.
0.000000,0,0.000000,bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');
0.000000,0,0.000000,
0.000000,0,0.000000,return $f;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*get_fields = sub {
0.000000,0,0.000000,# Shut up a possible typo warning.
0.000000,0,0.000000,() = \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,return \%{$_[0].'::FIELDS'};
0.000000,0,0.000000,}
0.000004,1,0.000004,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000123,70,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000115,70,0.000002,return SUCCESS unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# List of base classes from which we will inherit %FIELDS.
0.000100,70,0.000001,my $fields_base;
0.000000,0,0.000000,
0.000131,70,0.000002,my $inheritor = caller(0);
0.000000,0,0.000000,
0.000102,70,0.000001,my @bases;
0.000231,70,0.000003,foreach my $base (@_) {
0.000128,82,0.000002,if ( $inheritor eq $base ) {
0.000000,0,0.000000,warn "Class '$inheritor' tried to inherit from itself\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001326,82,0.000016,next if grep $_->isa($base), ($inheritor, @bases);
0.000000,0,0.000000,
0.000000,0,0.000000,# Following blocks help isolate $SIG{__DIE__} changes
0.000000,0,0.000000,{
0.000346,164,0.000002,my $sigdie;
0.000000,0,0.000000,{
0.000517,164,0.000003,local $SIG{__DIE__};
0.003253,82,0.000040,eval "require $base";
0.000000,0,0.000000,# Only ignore "Can't locate" errors from our eval require.
0.000000,0,0.000000,# Other fatal errors (syntax etc) must be reported.
0.000121,82,0.000001,die if $@ && $@ !~ /^Can't locate .*? at \(eval /;
0.000301,82,0.000004,unless (%{"$base\::"}) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,local $" = " ";
0.000000,0,0.000000,Carp::croak(<<ERROR);
0.000000,0,0.000000,Base class package "$base" is empty.
0.000000,0,0.000000,(Perhaps you need to 'use' the module which defines that package first,
0.000000,0,0.000000,or make that module available in \@INC (\@INC contains: @INC).
0.000000,0,0.000000,ERROR
0.000000,0,0.000000,}
0.000344,82,0.000004,$sigdie = $SIG{__DIE__} || undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,# Make sure a global $SIG{__DIE__} makes it out of the localization.
0.000130,82,0.000002,$SIG{__DIE__} = $sigdie if defined $sigdie;
0.000000,0,0.000000,}
0.000153,82,0.000002,push @bases, $base;
0.000000,0,0.000000,
0.000924,82,0.000011,if ( has_fields($base) || has_attr($base) ) {
0.000000,0,0.000000,# No multiple fields inheritance *suck*
0.000000,0,0.000000,if ($fields_base) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("Can't multiply inherit fields");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$fields_base = $base;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# Save this until the end so it's all or nothing if the above loop croaks.
0.000816,70,0.000012,push @{"$inheritor\::ISA"}, @bases;
0.000000,0,0.000000,
0.000537,70,0.000008,if( defined $fields_base ) {
0.000000,0,0.000000,inherit_fields($inheritor, $fields_base);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub inherit_fields {
0.000000,0,0.000000,my($derived, $base) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return SUCCESS unless $base;
0.000000,0,0.000000,
0.000000,0,0.000000,my $battr = get_attr($base);
0.000000,0,0.000000,my $dattr = get_attr($derived);
0.000000,0,0.000000,my $dfields = get_fields($derived);
0.000000,0,0.000000,my $bfields = get_fields($base);
0.000000,0,0.000000,
0.000000,0,0.000000,$dattr->[0] = @$battr;
0.000000,0,0.000000,
0.000000,0,0.000000,if( keys %$dfields ) {
0.000000,0,0.000000,warn <<"END";
0.000000,0,0.000000,$derived is inheriting from $base but already has its own fields!
0.000000,0,0.000000,This will cause problems.  Be sure you use base BEFORE declaring fields.
0.000000,0,0.000000,END
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Iterate through the base's fields adding all the non-private
0.000000,0,0.000000,# ones to the derived class.  Hang on to the original attribute
0.000000,0,0.000000,# (Public, Private, etc...) and add Inherited.
0.000000,0,0.000000,# This is all too complicated to do efficiently with add_fields().
0.000000,0,0.000000,while (my($k,$v) = each %$bfields) {
0.000000,0,0.000000,my $fno;
0.000000,0,0.000000,if ($fno = $dfields->{$k} and $fno != $v) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak ("Inherited fields can't override existing fields");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( $battr->[$v] & PRIVATE ) {
0.000000,0,0.000000,$dattr->[$v] = PRIVATE | INHERITED;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$dattr->[$v] = INHERITED | $battr->[$v];
0.000000,0,0.000000,$dfields->{$k} = $v;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $idx (1..$#{$battr}) {
0.000000,0,0.000000,next if defined $dattr->[$idx];
0.000000,0,0.000000,$dattr->[$idx] = $battr->[$idx] & INHERITED;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
