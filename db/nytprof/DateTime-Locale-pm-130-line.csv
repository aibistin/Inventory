# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package DateTime::Locale;
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000031,2,0.000015,use warnings;
0.000000,0,0.000000,
0.000053,2,0.000026,use 5.006;
0.000000,0,0.000000,
0.000000,0,0.000000,# Loading this here isn't necessary, but it makes it easier to catch
0.000000,0,0.000000,# syntax errors when testing.
0.000111,2,0.000056,use DateTime::Locale::Base;
0.000242,2,0.000121,use DateTime::Locale::Catalog;
0.000532,2,0.000266,use Params::Validate qw( validate validate_pos SCALAR );
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.45';
0.000000,0,0.000000,
0.000001,1,0.000001,my %Class;
0.000001,1,0.000001,my %DataForID;
0.000001,1,0.000001,my %NameToID;
0.000001,1,0.000001,my %NativeNameToID;
0.000001,1,0.000001,my %AliasToID;
0.000001,1,0.000001,my %IDToExtra;
0.000000,0,0.000000,
0.000001,1,0.000001,my %LoadCache;
0.000000,0,0.000000,
0.000000,0,0.000000,sub register {
0.000002,1,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000002,1,0.000002,%LoadCache = ();
0.000000,0,0.000000,
0.003152,1,0.003152,if ( ref $_[0] ) {
0.000000,0,0.000000,$class->_register(%$_) foreach @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$class->_register(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _register {
0.000717,466,0.000002,my $class = shift;
0.000000,0,0.000000,
0.018951,466,0.000041,my %p = validate(
0.000000,0,0.000000,@_, {
0.000000,0,0.000000,id => { type => SCALAR },
0.000000,0,0.000000,
0.000000,0,0.000000,en_language  => { type => SCALAR },
0.000000,0,0.000000,en_script    => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,en_territory => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,en_variant   => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,
0.000000,0,0.000000,native_language  => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,native_script    => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,native_territory => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,native_variant   => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,
0.000000,0,0.000000,class   => { type => SCALAR, optional => 1 },
0.000000,0,0.000000,replace => { type => SCALAR, default  => 0 },
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000792,466,0.000002,my $id = $p{id};
0.000000,0,0.000000,
0.003015,466,0.000006,die "'\@' or '=' are not allowed in locale ids"
0.000000,0,0.000000,if $id =~ /[\@=]/;
0.000000,0,0.000000,
0.000964,466,0.000002,die
0.000000,0,0.000000,"You cannot replace an existing locale ('$id') unless you also specify the 'replace' parameter as true\n"
0.000000,0,0.000000,if !delete $p{replace} && exists $DataForID{$id};
0.000000,0,0.000000,
0.000741,466,0.000002,$p{native_language} = $p{en_language}
0.000000,0,0.000000,unless exists $p{native_language};
0.000000,0,0.000000,
0.000640,466,0.000001,my @en_pieces;
0.000614,466,0.000001,my @native_pieces;
0.001458,466,0.000003,foreach my $p (qw( language script territory variant )) {
0.003381,1864,0.000002,push @en_pieces,     $p{"en_$p"}     if exists $p{"en_$p"};
0.014108,1864,0.000008,push @native_pieces, $p{"native_$p"} if exists $p{"native_$p"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000945,466,0.000002,$p{en_complete_name}     = join ' ', @en_pieces;
0.000853,466,0.000002,$p{native_complete_name} = join ' ', @native_pieces;
0.000000,0,0.000000,
0.000923,466,0.000002,$DataForID{$id} = \%p;
0.000000,0,0.000000,
0.000921,466,0.000002,$NameToID{ $p{en_complete_name} }           = $id;
0.000928,466,0.000002,$NativeNameToID{ $p{native_complete_name} } = $id;
0.000000,0,0.000000,
0.002956,466,0.000006,$Class{$id} = $p{class} if defined exists $p{class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _registered_id {
0.000579,422,0.000001,shift;
0.005065,422,0.000012,my ($id) = validate_pos( @_, { type => SCALAR } );
0.000000,0,0.000000,
0.000645,422,0.000002,return 1 if $AliasToID{$id};
0.009213,422,0.000022,return 1 if $DataForID{$id};
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_aliases {
0.000002,1,0.000002,shift;
0.000000,0,0.000000,
0.000002,1,0.000002,%LoadCache = ();
0.000000,0,0.000000,
0.000119,1,0.000119,my $aliases = ref $_[0] ? $_[0] : {@_};
0.000000,0,0.000000,
0.001516,1,0.001516,while ( my ( $alias, $id ) = each %$aliases ) {
0.002119,422,0.000005,die
0.000000,0,0.000000,"Unregistered locale '$id' cannot be used as an alias target for $alias"
0.000000,0,0.000000,unless __PACKAGE__->_registered_id($id);
0.000000,0,0.000000,
0.000621,422,0.000001,die "Can't alias an id to itself"
0.000000,0,0.000000,if $alias eq $id;
0.000000,0,0.000000,
0.000000,0,0.000000,# check for overwrite?
0.000000,0,0.000000,
0.000871,422,0.000002,my %seen = ( $alias => 1, $id => 1 );
0.000615,422,0.000001,my $copy = $id;
0.001259,422,0.000003,while ( $copy = $AliasToID{$copy} ) {
0.000000,0,0.000000,die "Creating an alias from $alias to $id would create a loop.\n"
0.000000,0,0.000000,if $seen{$copy};
0.000000,0,0.000000,
0.000000,0,0.000000,$seen{$copy} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000923,422,0.000002,$AliasToID{$alias} = $id;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_alias {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,
0.000000,0,0.000000,%LoadCache = ();
0.000000,0,0.000000,
0.000000,0,0.000000,my ($alias) = validate_pos( @_, { type => SCALAR } );
0.000000,0,0.000000,
0.000000,0,0.000000,return delete $AliasToID{$alias};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000026,1,0.000026,__PACKAGE__->register( DateTime::Locale::Catalog->Locales() );
0.000019,1,0.000019,__PACKAGE__->add_aliases( DateTime::Locale::Catalog->Aliases() );
0.000789,1,0.000789,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ids   { wantarray ? keys %DataForID : [ keys %DataForID ] }
0.000000,0,0.000000,sub names { wantarray ? keys %NameToID  : [ keys %NameToID ] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub native_names {
0.000000,0,0.000000,wantarray ? keys %NativeNameToID : [ keys %NativeNameToID ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# These are hardcoded for backwards comaptibility with the
0.000000,0,0.000000,# DateTime::Language code.
0.000012,1,0.000012,my %OldAliases = (
0.000000,0,0.000000,'Afar'      => 'aa',
0.000000,0,0.000000,'Amharic'   => 'am_ET',
0.000000,0,0.000000,'Austrian'  => 'de_AT',
0.000000,0,0.000000,'Brazilian' => 'pt_BR',
0.000000,0,0.000000,'Czech'     => 'cs_CZ',
0.000000,0,0.000000,'Danish'    => 'da_DK',
0.000000,0,0.000000,'Dutch'     => 'nl_NL',
0.000000,0,0.000000,'English'   => 'en_US',
0.000000,0,0.000000,'French'    => 'fr_FR',
0.000000,0,0.000000,
0.000000,0,0.000000,#      'Gedeo'             => undef, # XXX
0.000000,0,0.000000,'German'            => 'de_DE',
0.000000,0,0.000000,'Italian'           => 'it_IT',
0.000000,0,0.000000,'Norwegian'         => 'no_NO',
0.000000,0,0.000000,'Oromo'             => 'om_ET',    # Maybe om_KE or plain om ?
0.000000,0,0.000000,'Portugese'         => 'pt_PT',
0.000000,0,0.000000,'Sidama'            => 'sid',
0.000000,0,0.000000,'Somali'            => 'so_SO',
0.000000,0,0.000000,'Spanish'           => 'es_ES',
0.000000,0,0.000000,'Swedish'           => 'sv_SE',
0.000000,0,0.000000,'Tigre'             => 'tig',
0.000000,0,0.000000,'TigrinyaEthiopian' => 'ti_ET',
0.000000,0,0.000000,'TigrinyaEritrean'  => 'ti_ER',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub load {
0.000003,2,0.000002,my $class = shift;
0.000034,2,0.000017,my ($name) = validate_pos( @_, { type => SCALAR } );
0.000000,0,0.000000,
0.000000,0,0.000000,# Support RFC 3066 language tags, which use '-' instead of '_'.
0.000004,2,0.000002,$name =~ tr/-/_/;
0.000000,0,0.000000,
0.000003,2,0.000002,my $key = $name;
0.000000,0,0.000000,
0.000009,2,0.000005,return $LoadCache{$key} if exists $LoadCache{$key};
0.000000,0,0.000000,
0.000000,0,0.000000,# Custom class registered by user
0.000003,1,0.000003,if ( $Class{$name} ) {
0.000000,0,0.000000,return $LoadCache{$key}
0.000000,0,0.000000,= $class->_load_class_from_id( $name, $Class{$name} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# special case for backwards compatibility with DT::Language
0.000002,1,0.000002,$name = $OldAliases{$name} if exists $OldAliases{$name};
0.000000,0,0.000000,
0.000013,1,0.000013,if ( exists $DataForID{$name} || exists $AliasToID{$name} ) {
0.000000,0,0.000000,return $LoadCache{$key} = $class->_load_class_from_id($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $h ( \%NameToID, \%NativeNameToID ) {
0.000000,0,0.000000,return $LoadCache{$key} = $class->_load_class_from_id( $h->{$name} )
0.000000,0,0.000000,if exists $h->{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( my $id = $class->_guess_id($name) ) {
0.000000,0,0.000000,return $LoadCache{$key} = $class->_load_class_from_id($id);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "Invalid locale name or id: $name\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _guess_id {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $name  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Strip off charset for LC_* ids : en_GB.UTF-8 etc
0.000000,0,0.000000,$name =~ s/\..*$//;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $language, $script, $territory, $variant ) = _parse_id($name);
0.000000,0,0.000000,
0.000000,0,0.000000,my @guesses;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $script ) {
0.000000,0,0.000000,my $guess = join '_', lc $language, ucfirst lc $script;
0.000000,0,0.000000,
0.000000,0,0.000000,push @guesses, $guess;
0.000000,0,0.000000,
0.000000,0,0.000000,$guess .= '_' . uc $territory if defined $territory;
0.000000,0,0.000000,
0.000000,0,0.000000,# version with script comes first
0.000000,0,0.000000,unshift @guesses, $guess;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $variant ) {
0.000000,0,0.000000,push @guesses, join '_', lc $language, uc $territory, uc $variant;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $territory ) {
0.000000,0,0.000000,push @guesses, join '_', lc $language, uc $territory;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @guesses, lc $language;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $id (@guesses) {
0.000000,0,0.000000,return $id
0.000000,0,0.000000,if exists $DataForID{$id} || exists $AliasToID{$id};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parse_id {
0.000000,0,0.000000,$_[0] =~ /([a-z]+)               # id
0.000000,0,0.000000,(?: _([A-Z][a-z]+) )?  # script - Title Case - optional
0.000000,0,0.000000,(?: _([A-Z]+) )?       # territory - ALL CAPS - optional
0.000000,0,0.000000,(?: _([A-Z]+) )?       # variant - ALL CAPS - optional
0.000000,0,0.000000,/x;
0.000000,0,0.000000,
0.000000,0,0.000000,return $1, $2, $3, $4;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_class_from_id {
0.000002,1,0.000002,my $class      = shift;
0.000002,1,0.000002,my $id         = shift;
0.000001,1,0.000001,my $real_class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# We want the first alias for which there is data, even if it has
0.000000,0,0.000000,# no corresponding .pm file.  There may be multiple levels of
0.000000,0,0.000000,# alias to go through.
0.000002,1,0.000002,my $data_id = $id;
0.000004,1,0.000004,while ( exists $AliasToID{$data_id} && !exists $DataForID{$data_id} ) {
0.000000,0,0.000000,$data_id = $AliasToID{$data_id};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,$real_class ||= "DateTime::Locale::$data_id";
0.000000,0,0.000000,
0.000015,1,0.000015,unless ( $real_class->can('new') ) {
0.000124,1,0.000124,eval "require $real_class";
0.000000,0,0.000000,
0.000001,1,0.000001,die $@ if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $locale = $real_class->new(
0.000015,1,0.000015,%{ $DataForID{$data_id} },
0.000000,0,0.000000,id => $id,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,return $locale if $DateTime::Locale::InGenerator;
0.000000,0,0.000000,
0.000014,1,0.000014,if ( $locale->can('cldr_version') ) {
0.000005,1,0.000005,my $object_version  = $locale->cldr_version();
0.000007,1,0.000007,my $catalog_version = DateTime::Locale::Catalog->CLDRVersion();
0.000000,0,0.000000,
0.000002,1,0.000002,if ( $object_version ne $catalog_version ) {
0.000000,0,0.000000,warn
0.000000,0,0.000000,"Loaded $real_class, which is from an older version ($object_version)"
0.000000,0,0.000000,. "of the CLDR database than this installation of"
0.000000,0,0.000000,. "DateTime::Locale ($catalog_version).\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,return $locale;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
