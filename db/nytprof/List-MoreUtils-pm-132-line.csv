# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package List::MoreUtils;
0.000000,0,0.000000,
0.000051,2,0.000025,use 5.00503;
0.000031,2,0.000016,use strict;
0.000027,2,0.000013,use Exporter   ();
0.000030,2,0.000015,use DynaLoader ();
0.000000,0,0.000000,
0.000117,2,0.000059,use vars qw{ $VERSION @ISA @EXPORT_OK %EXPORT_TAGS };
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,$VERSION   = '0.33';
0.000000,0,0.000000,# $VERSION   = eval $VERSION;
0.000008,1,0.000008,@ISA       = qw{ Exporter DynaLoader };
0.000006,1,0.000006,@EXPORT_OK = qw{
0.000000,0,0.000000,any all none notall true false
0.000000,0,0.000000,firstidx first_index lastidx last_index
0.000000,0,0.000000,insert_after insert_after_string
0.000000,0,0.000000,apply indexes
0.000000,0,0.000000,after after_incl before before_incl
0.000000,0,0.000000,firstval first_value lastval last_value
0.000000,0,0.000000,each_array each_arrayref
0.000000,0,0.000000,pairwise natatime
0.000000,0,0.000000,mesh zip uniq distinct
0.000000,0,0.000000,minmax part
0.000000,0,0.000000,};
0.000002,1,0.000002,%EXPORT_TAGS = (
0.000000,0,0.000000,all => \@EXPORT_OK,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Load the XS at compile-time so that redefinition warnings will be
0.000000,0,0.000000,# thrown correctly if the XS versions of part or indexes loaded
0.000011,1,0.000011,eval {
0.000000,0,0.000000,# PERL_DL_NONLAZY must be false, or any errors in loading will just
0.000000,0,0.000000,# cause the perl code to be tested
0.000005,1,0.000005,local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
0.000000,0,0.000000,
0.000018,1,0.000018,bootstrap List::MoreUtils $VERSION;
0.000002,1,0.000002,1;
0.000000,0,0.000000,
0.000000,0,0.000000,} unless $ENV{LIST_MOREUTILS_PP};
0.000196,1,0.000196,}
0.000000,0,0.000000,
0.000002,1,0.000002,eval <<'END_PERL' unless defined &any;
0.000000,0,0.000000,
0.000000,0,0.000000,# Use pure scalar boolean return values for compatibility with XS
0.000000,0,0.000000,use constant YES => ! 0;
0.000000,0,0.000000,use constant NO  => ! 1;
0.000000,0,0.000000,
0.000000,0,0.000000,sub any (&@) {
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,return YES if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return NO;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub all (&@) {
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,return NO unless $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return YES;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub none (&@) {
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,return NO if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return YES;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub notall (&@) {
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,return YES unless $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return NO;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub true (&@) {
0.000000,0,0.000000,my $f     = shift;
0.000000,0,0.000000,my $count = 0;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,$count++ if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return $count;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub false (&@) {
0.000000,0,0.000000,my $f     = shift;
0.000000,0,0.000000,my $count = 0;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,$count++ unless $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return $count;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub firstidx (&@) {
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach my $i ( 0 .. $#_ ) {
0.000000,0,0.000000,local *_ = \$_[$i];
0.000000,0,0.000000,return $i if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lastidx (&@) {
0.000000,0,0.000000,my $f = shift;
0.000000,0,0.000000,foreach my $i ( reverse 0 .. $#_ ) {
0.000000,0,0.000000,local *_ = \$_[$i];
0.000000,0,0.000000,return $i if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub insert_after (&$\@) {
0.000000,0,0.000000,my ($f, $val, $list) = @_;
0.000000,0,0.000000,my $c = -1;
0.000000,0,0.000000,local *_;
0.000000,0,0.000000,foreach my $i ( 0 .. $#$list ) {
0.000000,0,0.000000,$_ = $list->[$i];
0.000000,0,0.000000,$c = $i, last if $f->();
0.000000,0,0.000000,}
0.000000,0,0.000000,@$list = (
0.000000,0,0.000000,@{$list}[ 0 .. $c ],
0.000000,0,0.000000,$val,
0.000000,0,0.000000,@{$list}[ $c + 1 .. $#$list ],
0.000000,0,0.000000,) and return 1 if $c != -1;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub insert_after_string ($$\@) {
0.000000,0,0.000000,my ($string, $val, $list) = @_;
0.000000,0,0.000000,my $c = -1;
0.000000,0,0.000000,foreach my $i ( 0 .. $#$list ) {
0.000000,0,0.000000,local $^W = 0;
0.000000,0,0.000000,$c = $i, last if $string eq $list->[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,@$list = (
0.000000,0,0.000000,@{$list}[ 0 .. $c ],
0.000000,0,0.000000,$val,
0.000000,0,0.000000,@{$list}[ $c + 1 .. $#$list ],
0.000000,0,0.000000,) and return 1 if $c != -1;
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply (&@) {
0.000000,0,0.000000,my $action = shift;
0.000000,0,0.000000,&$action foreach my @values = @_;
0.000000,0,0.000000,wantarray ? @values : $values[-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $started;
0.000000,0,0.000000,my $lag;
0.000000,0,0.000000,grep $started ||= do {
0.000000,0,0.000000,my $x = $lag;
0.000000,0,0.000000,$lag = $test->();
0.000000,0,0.000000,$x
0.000000,0,0.000000,}, @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after_incl (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $started;
0.000000,0,0.000000,grep $started ||= $test->(), @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $more = 1;
0.000000,0,0.000000,grep $more &&= ! $test->(), @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before_incl (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $more = 1;
0.000000,0,0.000000,my $lag  = 1;
0.000000,0,0.000000,grep $more &&= do {
0.000000,0,0.000000,my $x = $lag;
0.000000,0,0.000000,$lag = ! $test->();
0.000000,0,0.000000,$x
0.000000,0,0.000000,}, @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub indexes (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,grep {
0.000000,0,0.000000,local *_ = \$_[$_];
0.000000,0,0.000000,$test->()
0.000000,0,0.000000,} 0 .. $#_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub lastval (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,my $ix;
0.000000,0,0.000000,for ( $ix = $#_; $ix >= 0; $ix-- ) {
0.000000,0,0.000000,local *_ = \$_[$ix];
0.000000,0,0.000000,my $testval = $test->();
0.000000,0,0.000000,
0.000000,0,0.000000,# Simulate $_ as alias
0.000000,0,0.000000,$_[$ix] = $_;
0.000000,0,0.000000,return $_ if $testval;
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub firstval (&@) {
0.000000,0,0.000000,my $test = shift;
0.000000,0,0.000000,foreach ( @_ ) {
0.000000,0,0.000000,return $_ if $test->();
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub pairwise (&\@\@) {
0.000000,0,0.000000,my $op = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Symbols for caller's input arrays
0.000000,0,0.000000,use vars qw{ @A @B };
0.000000,0,0.000000,local ( *A, *B ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Localise $a, $b
0.000000,0,0.000000,my ( $caller_a, $caller_b ) = do {
0.000000,0,0.000000,my $pkg = caller();
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,\*{$pkg.'::a'}, \*{$pkg.'::b'};
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# Loop iteration limit
0.000000,0,0.000000,my $limit = $#A > $#B? $#A : $#B;
0.000000,0,0.000000,
0.000000,0,0.000000,# This map expression is also the return value
0.000000,0,0.000000,local( *$caller_a, *$caller_b );
0.000000,0,0.000000,map {
0.000000,0,0.000000,# Assign to $a, $b as refs to caller's array elements
0.000000,0,0.000000,( *$caller_a, *$caller_b ) = \( $A[$_], $B[$_] );
0.000000,0,0.000000,
0.000000,0,0.000000,# Perform the transformation
0.000000,0,0.000000,$op->();
0.000000,0,0.000000,}  0 .. $limit;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
0.000000,0,0.000000,return each_arrayref(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub each_arrayref {
0.000000,0,0.000000,my @list  = @_; # The list of references to the arrays
0.000000,0,0.000000,my $index = 0;  # Which one the caller will get next
0.000000,0,0.000000,my $max   = 0;  # Number of elements in longest array
0.000000,0,0.000000,
0.000000,0,0.000000,# Get the length of the longest input array
0.000000,0,0.000000,foreach ( @list ) {
0.000000,0,0.000000,unless ( ref $_ eq 'ARRAY' ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("each_arrayref: argument is not an array reference\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,$max = @$_ if @$_ > $max;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Return the iterator as a closure wrt the above variables.
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,if ( @_ ) {
0.000000,0,0.000000,my $method = shift;
0.000000,0,0.000000,unless ( $method eq 'index' ) {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak("each_array: unknown argument '$method' passed to iterator.");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Return current (last fetched) index
0.000000,0,0.000000,return undef if $index == 0  ||  $index > $max;
0.000000,0,0.000000,return $index - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# No more elements to return
0.000000,0,0.000000,return if $index >= $max;
0.000000,0,0.000000,my $i = $index++;
0.000000,0,0.000000,
0.000000,0,0.000000,# Return ith elements
0.000000,0,0.000000,return map $_->[$i], @list; 
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub natatime ($@) {
0.000000,0,0.000000,my $n    = shift;
0.000000,0,0.000000,my @list = @_;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,return splice @list, 0, $n;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {
0.000000,0,0.000000,my $max = -1;
0.000000,0,0.000000,$max < $#$_ && ( $max = $#$_ ) foreach @_;
0.000000,0,0.000000,map {
0.000000,0,0.000000,my $ix = $_;
0.000000,0,0.000000,map $_->[$ix], @_;
0.000000,0,0.000000,} 0 .. $max; 
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub uniq (@) {
0.000000,0,0.000000,my %seen = ();
0.000000,0,0.000000,grep { not $seen{$_}++ } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub minmax (@) {
0.000000,0,0.000000,return unless @_;
0.000000,0,0.000000,my $min = my $max = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,for ( my $i = 1; $i < @_; $i += 2 ) {
0.000000,0,0.000000,if ( $_[$i-1] <= $_[$i] ) {
0.000000,0,0.000000,$min = $_[$i-1] if $min > $_[$i-1];
0.000000,0,0.000000,$max = $_[$i]   if $max < $_[$i];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$min = $_[$i]   if $min > $_[$i];
0.000000,0,0.000000,$max = $_[$i-1] if $max < $_[$i-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @_ & 1 ) {
0.000000,0,0.000000,my $i = $#_;
0.000000,0,0.000000,if ($_[$i-1] <= $_[$i]) {
0.000000,0,0.000000,$min = $_[$i-1] if $min > $_[$i-1];
0.000000,0,0.000000,$max = $_[$i]   if $max < $_[$i];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$min = $_[$i]   if $min > $_[$i];
0.000000,0,0.000000,$max = $_[$i-1] if $max < $_[$i-1];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($min, $max);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub part (&@) {
0.000000,0,0.000000,my ($code, @list) = @_;
0.000000,0,0.000000,my @parts;
0.000000,0,0.000000,push @{ $parts[ $code->($_) ] }, $_  foreach @list;
0.000000,0,0.000000,return @parts;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _XScompiled {
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,END_PERL
0.000001,1,0.000001,die $@ if $@;
0.000000,0,0.000000,
0.000000,0,0.000000,# Function aliases
0.000003,1,0.000003,*first_index = \&firstidx;
0.000002,1,0.000002,*last_index  = \&lastidx;
0.000002,1,0.000002,*first_value = \&firstval;
0.000002,1,0.000002,*last_value  = \&lastval;
0.000002,1,0.000002,*zip         = \&mesh;
0.000001,1,0.000001,*distinct    = \&uniq;
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
