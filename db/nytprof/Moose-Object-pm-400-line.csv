# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Object;
0.000000,0,0.000000,BEGIN {
0.000051,1,0.000051,$Moose::Object::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Moose::Object::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000058,2,0.000029,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000027,2,0.000013,use Carp ();
0.000027,2,0.000014,use Devel::GlobalDestruction ();
0.000031,2,0.000015,use MRO::Compat ();
0.000026,2,0.000013,use Scalar::Util ();
0.000039,2,0.000019,use Try::Tiny ();
0.000000,0,0.000000,
0.000042,2,0.000021,use if ( not our $__mx_is_compiled ), 'Moose::Meta::Class';
0.000347,2,0.000174,use if ( not our $__mx_is_compiled ), metaclass => 'Moose::Meta::Class';
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $real_class = Scalar::Util::blessed($class) || $class;
0.000000,0,0.000000,
0.000000,0,0.000000,my $params = $real_class->BUILDARGS(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,return Class::MOP::Class->initialize($real_class)->new_object($params);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub BUILDARGS {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,if ( scalar @_ == 1 ) {
0.000000,0,0.000000,unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
0.000000,0,0.000000,Class::MOP::class_of($class)->throw_error(
0.000000,0,0.000000,"Single parameters to new() must be a HASH ref",
0.000000,0,0.000000,data => $_[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,return { %{ $_[0] } };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( @_ % 2 ) {
0.000000,0,0.000000,Carp::carp(
0.000000,0,0.000000,"The new() method for $class expects a hash reference or a key/value list."
0.000000,0,0.000000,. " You passed an odd number of arguments" );
0.000000,0,0.000000,return { @_, undef };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return {@_};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub BUILDALL {
0.000000,0,0.000000,# NOTE: we ask Perl if we even
0.000000,0,0.000000,# need to do this first, to avoid
0.000000,0,0.000000,# extra meta level calls
0.000000,0,0.000000,return unless $_[0]->can('BUILD');
0.000000,0,0.000000,my ($self, $params) = @_;
0.000000,0,0.000000,foreach my $method (reverse Class::MOP::class_of($self)->find_all_methods_by_name('BUILD')) {
0.000000,0,0.000000,$method->{code}->execute($self, $params);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DEMOLISHALL {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($in_global_destruction) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: we ask Perl if we even
0.000000,0,0.000000,# need to do this first, to avoid
0.000000,0,0.000000,# extra meta level calls
0.000000,0,0.000000,return unless $self->can('DEMOLISH');
0.000000,0,0.000000,
0.000000,0,0.000000,my @isa;
0.000000,0,0.000000,if ( my $meta = Class::MOP::class_of($self ) ) {
0.000000,0,0.000000,@isa = $meta->linearized_isa;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# We cannot count on being able to retrieve a previously made
0.000000,0,0.000000,# metaclass, _or_ being able to make a new one during global
0.000000,0,0.000000,# destruction. However, we should still be able to use mro at
0.000000,0,0.000000,# that time (at least tests suggest so ;)
0.000000,0,0.000000,my $class_name = ref $self;
0.000000,0,0.000000,@isa = @{ mro::get_linear_isa($class_name) }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $class (@isa) {
0.000184,2,0.000092,no strict 'refs';
0.000000,0,0.000000,my $demolish = *{"${class}::DEMOLISH"}{CODE};
0.000000,0,0.000000,$self->$demolish($in_global_destruction)
0.000000,0,0.000000,if defined $demolish;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $?;
0.000000,0,0.000000,
0.000000,0,0.000000,Try::Tiny::try {
0.000000,0,0.000000,$self->DEMOLISHALL(Devel::GlobalDestruction::in_global_destruction);
0.000000,0,0.000000,}
0.000000,0,0.000000,Try::Tiny::catch {
0.000000,0,0.000000,die $_;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# support for UNIVERSAL::DOES ...
0.000000,0,0.000000,BEGIN {
0.000012,1,0.000012,my $does = UNIVERSAL->can("DOES") ? "SUPER::DOES" : "isa";
0.000063,1,0.000063,eval 'sub DOES {
0.000000,0,0.000000,my ( $self, $class_or_role_name ) = @_;
0.000000,0,0.000000,return $self->'.$does.'($class_or_role_name)
0.000000,0,0.000000,|| $self->does($class_or_role_name);
0.000000,0,0.000000,}';
0.000121,1,0.000121,}
0.000000,0,0.000000,
0.000000,0,0.000000,# new does() methods will be created
0.000000,0,0.000000,# as appropriate see Moose::Meta::Role
0.000000,0,0.000000,sub does {
0.000000,0,0.000000,my ($self, $role_name) = @_;
0.000000,0,0.000000,my $class = Scalar::Util::blessed($self) || $self;
0.000000,0,0.000000,my $meta = Class::MOP::Class->initialize($class);
0.000000,0,0.000000,(defined $role_name)
0.000000,0,0.000000,|| $meta->throw_error("You must supply a role name to does()");
0.000000,0,0.000000,return 1 if $meta->can('does_role') && $meta->does_role($role_name);
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,local $Data::Dumper::Maxdepth = shift if @_;
0.000000,0,0.000000,Data::Dumper::Dumper $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: The base object for Moose
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
