# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Meta::TypeConstraint::Role;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::TypeConstraint::Role::AUTHORITY = 'cpan:STEVAN';
0.000033,1,0.000033,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::TypeConstraint::Role::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000032,2,0.000016,use warnings;
0.000037,2,0.000019,use metaclass;
0.000000,0,0.000000,
0.000035,2,0.000018,use B;
0.000034,2,0.000017,use Scalar::Util 'blessed';
0.000030,2,0.000015,use Moose::Util::TypeConstraints ();
0.000000,0,0.000000,
0.000559,2,0.000280,use base 'Moose::Meta::TypeConstraint';
0.000000,0,0.000000,
0.000014,1,0.000014,__PACKAGE__->meta->add_attribute('role' => (
0.000000,0,0.000000,reader => 'role',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,my $inliner = sub {
0.000007,4,0.000002,my $self = shift;
0.000008,4,0.000002,my $val  = shift;
0.000000,0,0.000000,
0.000080,4,0.000020,return 'Moose::Util::does_role('
0.000000,0,0.000000,. $val . ', '
0.000000,0,0.000000,. B::perlstring($self->role)
0.000000,0,0.000000,. ')';
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000003,1,0.000003,my ( $class, %args ) = @_;
0.000000,0,0.000000,
0.000006,1,0.000006,$args{parent} = Moose::Util::TypeConstraints::find_type_constraint('Object');
0.000000,0,0.000000,
0.000002,1,0.000002,my $role_name = $args{role};
0.000004,1,0.000004,$args{constraint} = sub { Moose::Util::does_role( $_[0], $role_name ) };
0.000000,0,0.000000,
0.000002,1,0.000002,$args{inlined} = $inliner;
0.000000,0,0.000000,
0.000011,1,0.000011,my $self = $class->SUPER::new( \%args );
0.000000,0,0.000000,
0.000007,1,0.000007,$self->_create_hand_optimized_type_constraint;
0.000005,1,0.000005,$self->compile_type_constraint();
0.000000,0,0.000000,
0.000007,1,0.000007,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create_hand_optimized_type_constraint {
0.000002,1,0.000002,my $self = shift;
0.000005,1,0.000005,my $role = $self->role;
0.000000,0,0.000000,$self->hand_optimized_type_constraint(
0.000000,0,0.000000,sub { Moose::Util::does_role($_[0], $role) }
0.000015,1,0.000015,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parents {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return (
0.000000,0,0.000000,$self->parent,
0.000000,0,0.000000,map {
0.000000,0,0.000000,# FIXME find_type_constraint might find a TC named after the role but that isn't really it
0.000000,0,0.000000,# I did this anyway since it's a convention that preceded TypeConstraint::Role, and it should DWIM
0.000000,0,0.000000,# if anybody thinks this problematic please discuss on IRC.
0.000000,0,0.000000,# a possible fix is to add by attr indexing to the type registry to find types of a certain property
0.000000,0,0.000000,# regardless of their name
0.000000,0,0.000000,Moose::Util::TypeConstraints::find_type_constraint($_)
0.000000,0,0.000000,||
0.000000,0,0.000000,__PACKAGE__->new( role => $_, name => "__ANON__" )
0.000000,0,0.000000,} @{ Class::MOP::class_of($self->role)->get_roles },
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub equals {
0.000000,0,0.000000,my ( $self, $type_or_name ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
0.000000,0,0.000000,
0.000000,0,0.000000,return unless defined $other;
0.000000,0,0.000000,return unless $other->isa(__PACKAGE__);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->role eq $other->role;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_a_type_of {
0.000000,0,0.000000,my ($self, $type_or_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name);
0.000000,0,0.000000,
0.000000,0,0.000000,($self->equals($type) || $self->is_subtype_of($type_or_name));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_subtype_of {
0.000000,0,0.000000,my ($self, $type_or_name_or_role ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( not ref $type_or_name_or_role ) {
0.000000,0,0.000000,# it might be a role
0.000000,0,0.000000,my $class = Class::MOP::class_of($self->role);
0.000000,0,0.000000,return 1 if defined($class) && $class->does_role( $type_or_name_or_role );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name_or_role);
0.000000,0,0.000000,
0.000000,0,0.000000,return unless defined $type;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $type->isa(__PACKAGE__) ) {
0.000000,0,0.000000,# if $type_or_name_or_role isn't a role, it might be the TC name of another ::Role type
0.000000,0,0.000000,# or it could also just be a type object in this branch
0.000000,0,0.000000,my $class = Class::MOP::class_of($self->role);
0.000000,0,0.000000,return defined($class) && $class->does_role( $type->role );
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# the only other thing we are a subtype of is Object
0.000000,0,0.000000,$self->SUPER::is_subtype_of($type);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_child_type {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,return Moose::Meta::TypeConstraint->new(@args, parent => $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Role/TypeConstraint parallel hierarchy
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
