# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# -*- buffer-read-only: t -*-
0.000000,0,0.000000,# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
0.000000,0,0.000000,# This file is built by regen/warnings.pl.
0.000000,0,0.000000,# Any changes made here will be lost!
0.000000,0,0.000000,
0.000000,0,0.000000,package warnings;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.18';
0.000000,0,0.000000,
0.000000,0,0.000000,# Verify that we're called correctly so that warnings will work.
0.000000,0,0.000000,# see also strict.pm.
0.000039,1,0.000039,unless ( __FILE__ =~ /(^|[\/\\])\Q${\__PACKAGE__}\E\.pmc?$/ ) {
0.000000,0,0.000000,my (undef, $f, $l) = caller;
0.000000,0,0.000000,die("Incorrect use of pragma '${\__PACKAGE__}' at $f line $l.\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,warnings - Perl pragma to control optional warnings
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use warnings;
0.000000,0,0.000000,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,use warnings "all";
0.000000,0,0.000000,no warnings "all";
0.000000,0,0.000000,
0.000000,0,0.000000,use warnings::register;
0.000000,0,0.000000,if (warnings::enabled()) {
0.000000,0,0.000000,warnings::warn("some warning");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (warnings::enabled("void")) {
0.000000,0,0.000000,warnings::warn("void", "some warning");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (warnings::enabled($object)) {
0.000000,0,0.000000,warnings::warn($object, "some warning");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,warnings::warnif("some warning");
0.000000,0,0.000000,warnings::warnif("void", "some warning");
0.000000,0,0.000000,warnings::warnif($object, "some warning");
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,The C<warnings> pragma is a replacement for the command line flag C<-w>,
0.000000,0,0.000000,but the pragma is limited to the enclosing block, while the flag is global.
0.000000,0,0.000000,See L<perllexwarn> for more information and the list of built-in warning
0.000000,0,0.000000,categories.
0.000000,0,0.000000,
0.000000,0,0.000000,If no import list is supplied, all possible warnings are either enabled
0.000000,0,0.000000,or disabled.
0.000000,0,0.000000,
0.000000,0,0.000000,A number of functions are provided to assist module authors.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item use warnings::register
0.000000,0,0.000000,
0.000000,0,0.000000,Creates a new warnings category with the same name as the package where
0.000000,0,0.000000,the call to the pragma is used.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::enabled()
0.000000,0,0.000000,
0.000000,0,0.000000,Use the warnings category with the same name as the current package.
0.000000,0,0.000000,
0.000000,0,0.000000,Return TRUE if that warnings category is enabled in the calling module.
0.000000,0,0.000000,Otherwise returns FALSE.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::enabled($category)
0.000000,0,0.000000,
0.000000,0,0.000000,Return TRUE if the warnings category, C<$category>, is enabled in the
0.000000,0,0.000000,calling module.
0.000000,0,0.000000,Otherwise returns FALSE.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::enabled($object)
0.000000,0,0.000000,
0.000000,0,0.000000,Use the name of the class for the object reference, C<$object>, as the
0.000000,0,0.000000,warnings category.
0.000000,0,0.000000,
0.000000,0,0.000000,Return TRUE if that warnings category is enabled in the first scope
0.000000,0,0.000000,where the object is used.
0.000000,0,0.000000,Otherwise returns FALSE.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::fatal_enabled()
0.000000,0,0.000000,
0.000000,0,0.000000,Return TRUE if the warnings category with the same name as the current
0.000000,0,0.000000,package has been set to FATAL in the calling module.
0.000000,0,0.000000,Otherwise returns FALSE.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::fatal_enabled($category)
0.000000,0,0.000000,
0.000000,0,0.000000,Return TRUE if the warnings category C<$category> has been set to FATAL in
0.000000,0,0.000000,the calling module.
0.000000,0,0.000000,Otherwise returns FALSE.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::fatal_enabled($object)
0.000000,0,0.000000,
0.000000,0,0.000000,Use the name of the class for the object reference, C<$object>, as the
0.000000,0,0.000000,warnings category.
0.000000,0,0.000000,
0.000000,0,0.000000,Return TRUE if that warnings category has been set to FATAL in the first
0.000000,0,0.000000,scope where the object is used.
0.000000,0,0.000000,Otherwise returns FALSE.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::warn($message)
0.000000,0,0.000000,
0.000000,0,0.000000,Print C<$message> to STDERR.
0.000000,0,0.000000,
0.000000,0,0.000000,Use the warnings category with the same name as the current package.
0.000000,0,0.000000,
0.000000,0,0.000000,If that warnings category has been set to "FATAL" in the calling module
0.000000,0,0.000000,then die. Otherwise return.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::warn($category, $message)
0.000000,0,0.000000,
0.000000,0,0.000000,Print C<$message> to STDERR.
0.000000,0,0.000000,
0.000000,0,0.000000,If the warnings category, C<$category>, has been set to "FATAL" in the
0.000000,0,0.000000,calling module then die. Otherwise return.
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::warn($object, $message)
0.000000,0,0.000000,
0.000000,0,0.000000,Print C<$message> to STDERR.
0.000000,0,0.000000,
0.000000,0,0.000000,Use the name of the class for the object reference, C<$object>, as the
0.000000,0,0.000000,warnings category.
0.000000,0,0.000000,
0.000000,0,0.000000,If that warnings category has been set to "FATAL" in the scope where C<$object>
0.000000,0,0.000000,is first used then die. Otherwise return.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::warnif($message)
0.000000,0,0.000000,
0.000000,0,0.000000,Equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,if (warnings::enabled())
0.000000,0,0.000000,{ warnings::warn($message) }
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::warnif($category, $message)
0.000000,0,0.000000,
0.000000,0,0.000000,Equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,if (warnings::enabled($category))
0.000000,0,0.000000,{ warnings::warn($category, $message) }
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::warnif($object, $message)
0.000000,0,0.000000,
0.000000,0,0.000000,Equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,if (warnings::enabled($object))
0.000000,0,0.000000,{ warnings::warn($object, $message) }
0.000000,0,0.000000,
0.000000,0,0.000000,=item warnings::register_categories(@names)
0.000000,0,0.000000,
0.000000,0,0.000000,This registers warning categories for the given names and is primarily for
0.000000,0,0.000000,use by the warnings::register pragma, for which see L<perllexwarn>.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlmodlib/Pragmatic Modules> and L<perllexwarn>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000043,1,0.000043,our %Offsets = (
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.008
0.000000,0,0.000000,
0.000000,0,0.000000,'all'		=> 0,
0.000000,0,0.000000,'closure'		=> 2,
0.000000,0,0.000000,'deprecated'	=> 4,
0.000000,0,0.000000,'exiting'		=> 6,
0.000000,0,0.000000,'glob'		=> 8,
0.000000,0,0.000000,'io'		=> 10,
0.000000,0,0.000000,'closed'		=> 12,
0.000000,0,0.000000,'exec'		=> 14,
0.000000,0,0.000000,'layer'		=> 16,
0.000000,0,0.000000,'newline'		=> 18,
0.000000,0,0.000000,'pipe'		=> 20,
0.000000,0,0.000000,'unopened'		=> 22,
0.000000,0,0.000000,'misc'		=> 24,
0.000000,0,0.000000,'numeric'		=> 26,
0.000000,0,0.000000,'once'		=> 28,
0.000000,0,0.000000,'overflow'		=> 30,
0.000000,0,0.000000,'pack'		=> 32,
0.000000,0,0.000000,'portable'		=> 34,
0.000000,0,0.000000,'recursion'		=> 36,
0.000000,0,0.000000,'redefine'		=> 38,
0.000000,0,0.000000,'regexp'		=> 40,
0.000000,0,0.000000,'severe'		=> 42,
0.000000,0,0.000000,'debugging'		=> 44,
0.000000,0,0.000000,'inplace'		=> 46,
0.000000,0,0.000000,'internal'		=> 48,
0.000000,0,0.000000,'malloc'		=> 50,
0.000000,0,0.000000,'signal'		=> 52,
0.000000,0,0.000000,'substr'		=> 54,
0.000000,0,0.000000,'syntax'		=> 56,
0.000000,0,0.000000,'ambiguous'		=> 58,
0.000000,0,0.000000,'bareword'		=> 60,
0.000000,0,0.000000,'digit'		=> 62,
0.000000,0,0.000000,'parenthesis'	=> 64,
0.000000,0,0.000000,'precedence'	=> 66,
0.000000,0,0.000000,'printf'		=> 68,
0.000000,0,0.000000,'prototype'		=> 70,
0.000000,0,0.000000,'qw'		=> 72,
0.000000,0,0.000000,'reserved'		=> 74,
0.000000,0,0.000000,'semicolon'		=> 76,
0.000000,0,0.000000,'taint'		=> 78,
0.000000,0,0.000000,'threads'		=> 80,
0.000000,0,0.000000,'uninitialized'	=> 82,
0.000000,0,0.000000,'unpack'		=> 84,
0.000000,0,0.000000,'untie'		=> 86,
0.000000,0,0.000000,'utf8'		=> 88,
0.000000,0,0.000000,'void'		=> 90,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.011
0.000000,0,0.000000,
0.000000,0,0.000000,'imprecision'	=> 92,
0.000000,0,0.000000,'illegalproto'	=> 94,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.013
0.000000,0,0.000000,
0.000000,0,0.000000,'non_unicode'	=> 96,
0.000000,0,0.000000,'nonchar'		=> 98,
0.000000,0,0.000000,'surrogate'		=> 100,
0.000000,0,0.000000,
0.000000,0,0.000000,# Warnings Categories added in Perl 5.017
0.000000,0,0.000000,
0.000000,0,0.000000,'experimental'	=> 102,
0.000000,0,0.000000,'experimental::lexical_subs'=> 104,
0.000000,0,0.000000,'experimental::lexical_topic'=> 106,
0.000000,0,0.000000,'experimental::regex_sets'=> 108,
0.000000,0,0.000000,'experimental::smartmatch'=> 110,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000017,1,0.000017,our %Bits = (
0.000000,0,0.000000,'all'		=> "\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55", # [0..55]
0.000000,0,0.000000,'ambiguous'		=> "\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00", # [29]
0.000000,0,0.000000,'bareword'		=> "\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00", # [30]
0.000000,0,0.000000,'closed'		=> "\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [6]
0.000000,0,0.000000,'closure'		=> "\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [1]
0.000000,0,0.000000,'debugging'		=> "\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00", # [22]
0.000000,0,0.000000,'deprecated'	=> "\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [2]
0.000000,0,0.000000,'digit'		=> "\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00", # [31]
0.000000,0,0.000000,'exec'		=> "\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [7]
0.000000,0,0.000000,'exiting'		=> "\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [3]
0.000000,0,0.000000,'experimental'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x55", # [51..55]
0.000000,0,0.000000,'experimental::lexical_subs'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01", # [52]
0.000000,0,0.000000,'experimental::lexical_topic'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04", # [53]
0.000000,0,0.000000,'experimental::regex_sets'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10", # [54]
0.000000,0,0.000000,'experimental::smartmatch'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40", # [55]
0.000000,0,0.000000,'glob'		=> "\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [4]
0.000000,0,0.000000,'illegalproto'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00", # [47]
0.000000,0,0.000000,'imprecision'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00", # [46]
0.000000,0,0.000000,'inplace'		=> "\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00", # [23]
0.000000,0,0.000000,'internal'		=> "\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00", # [24]
0.000000,0,0.000000,'io'		=> "\x00\x54\x55\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [5..11]
0.000000,0,0.000000,'layer'		=> "\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [8]
0.000000,0,0.000000,'malloc'		=> "\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00", # [25]
0.000000,0,0.000000,'misc'		=> "\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [12]
0.000000,0,0.000000,'newline'		=> "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [9]
0.000000,0,0.000000,'non_unicode'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00", # [48]
0.000000,0,0.000000,'nonchar'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00", # [49]
0.000000,0,0.000000,'numeric'		=> "\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [13]
0.000000,0,0.000000,'once'		=> "\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [14]
0.000000,0,0.000000,'overflow'		=> "\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [15]
0.000000,0,0.000000,'pack'		=> "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [16]
0.000000,0,0.000000,'parenthesis'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00", # [32]
0.000000,0,0.000000,'pipe'		=> "\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [10]
0.000000,0,0.000000,'portable'		=> "\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [17]
0.000000,0,0.000000,'precedence'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00", # [33]
0.000000,0,0.000000,'printf'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00", # [34]
0.000000,0,0.000000,'prototype'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00", # [35]
0.000000,0,0.000000,'qw'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00", # [36]
0.000000,0,0.000000,'recursion'		=> "\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [18]
0.000000,0,0.000000,'redefine'		=> "\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [19]
0.000000,0,0.000000,'regexp'		=> "\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00", # [20]
0.000000,0,0.000000,'reserved'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00", # [37]
0.000000,0,0.000000,'semicolon'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00", # [38]
0.000000,0,0.000000,'severe'		=> "\x00\x00\x00\x00\x00\x54\x05\x00\x00\x00\x00\x00\x00\x00", # [21..25]
0.000000,0,0.000000,'signal'		=> "\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00", # [26]
0.000000,0,0.000000,'substr'		=> "\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00", # [27]
0.000000,0,0.000000,'surrogate'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00", # [50]
0.000000,0,0.000000,'syntax'		=> "\x00\x00\x00\x00\x00\x00\x00\x55\x55\x15\x00\x40\x00\x00", # [28..38,47]
0.000000,0,0.000000,'taint'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00", # [39]
0.000000,0,0.000000,'threads'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00", # [40]
0.000000,0,0.000000,'uninitialized'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00", # [41]
0.000000,0,0.000000,'unopened'		=> "\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [11]
0.000000,0,0.000000,'unpack'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00", # [42]
0.000000,0,0.000000,'untie'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00", # [43]
0.000000,0,0.000000,'utf8'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x15\x00", # [44,48..50]
0.000000,0,0.000000,'void'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00", # [45]
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000020,1,0.000020,our %DeadBits = (
0.000000,0,0.000000,'all'		=> "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa", # [0..55]
0.000000,0,0.000000,'ambiguous'		=> "\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00", # [29]
0.000000,0,0.000000,'bareword'		=> "\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00", # [30]
0.000000,0,0.000000,'closed'		=> "\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [6]
0.000000,0,0.000000,'closure'		=> "\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [1]
0.000000,0,0.000000,'debugging'		=> "\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00", # [22]
0.000000,0,0.000000,'deprecated'	=> "\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [2]
0.000000,0,0.000000,'digit'		=> "\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00", # [31]
0.000000,0,0.000000,'exec'		=> "\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [7]
0.000000,0,0.000000,'exiting'		=> "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [3]
0.000000,0,0.000000,'experimental'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\xaa", # [51..55]
0.000000,0,0.000000,'experimental::lexical_subs'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02", # [52]
0.000000,0,0.000000,'experimental::lexical_topic'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08", # [53]
0.000000,0,0.000000,'experimental::regex_sets'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20", # [54]
0.000000,0,0.000000,'experimental::smartmatch'=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80", # [55]
0.000000,0,0.000000,'glob'		=> "\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [4]
0.000000,0,0.000000,'illegalproto'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00", # [47]
0.000000,0,0.000000,'imprecision'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00", # [46]
0.000000,0,0.000000,'inplace'		=> "\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00", # [23]
0.000000,0,0.000000,'internal'		=> "\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00", # [24]
0.000000,0,0.000000,'io'		=> "\x00\xa8\xaa\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [5..11]
0.000000,0,0.000000,'layer'		=> "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [8]
0.000000,0,0.000000,'malloc'		=> "\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00", # [25]
0.000000,0,0.000000,'misc'		=> "\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [12]
0.000000,0,0.000000,'newline'		=> "\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [9]
0.000000,0,0.000000,'non_unicode'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00", # [48]
0.000000,0,0.000000,'nonchar'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00", # [49]
0.000000,0,0.000000,'numeric'		=> "\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [13]
0.000000,0,0.000000,'once'		=> "\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [14]
0.000000,0,0.000000,'overflow'		=> "\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [15]
0.000000,0,0.000000,'pack'		=> "\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [16]
0.000000,0,0.000000,'parenthesis'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00", # [32]
0.000000,0,0.000000,'pipe'		=> "\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [10]
0.000000,0,0.000000,'portable'		=> "\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [17]
0.000000,0,0.000000,'precedence'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00", # [33]
0.000000,0,0.000000,'printf'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00", # [34]
0.000000,0,0.000000,'prototype'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00", # [35]
0.000000,0,0.000000,'qw'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00", # [36]
0.000000,0,0.000000,'recursion'		=> "\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [18]
0.000000,0,0.000000,'redefine'		=> "\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [19]
0.000000,0,0.000000,'regexp'		=> "\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00", # [20]
0.000000,0,0.000000,'reserved'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00", # [37]
0.000000,0,0.000000,'semicolon'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00", # [38]
0.000000,0,0.000000,'severe'		=> "\x00\x00\x00\x00\x00\xa8\x0a\x00\x00\x00\x00\x00\x00\x00", # [21..25]
0.000000,0,0.000000,'signal'		=> "\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00", # [26]
0.000000,0,0.000000,'substr'		=> "\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00", # [27]
0.000000,0,0.000000,'surrogate'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00", # [50]
0.000000,0,0.000000,'syntax'		=> "\x00\x00\x00\x00\x00\x00\x00\xaa\xaa\x2a\x00\x80\x00\x00", # [28..38,47]
0.000000,0,0.000000,'taint'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00", # [39]
0.000000,0,0.000000,'threads'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00", # [40]
0.000000,0,0.000000,'uninitialized'	=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00", # [41]
0.000000,0,0.000000,'unopened'		=> "\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", # [11]
0.000000,0,0.000000,'unpack'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00", # [42]
0.000000,0,0.000000,'untie'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00", # [43]
0.000000,0,0.000000,'utf8'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x2a\x00", # [44,48..50]
0.000000,0,0.000000,'void'		=> "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00", # [45]
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,$NONE     = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
0.000004,1,0.000004,$DEFAULT  = "\x10\x01\x00\x00\x00\x50\x04\x00\x00\x00\x00\x00\x00\x55", # [2,52..55,4,22,23,25]
0.000000,0,0.000000,$LAST_BIT = 112 ;
0.000001,1,0.000001,$BYTES    = 14 ;
0.000000,0,0.000000,
0.000012,2,0.000006,$All = "" ; vec($All, $Offsets{'all'}, 2) = 3 ;
0.000000,0,0.000000,
0.000000,0,0.000000,sub Croaker
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp; # this initializes %CarpInternal
0.000000,0,0.000000,local $Carp::CarpInternal{'warnings'};
0.000000,0,0.000000,delete $Carp::CarpInternal{'warnings'};
0.000000,0,0.000000,Carp::croak(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _bits {
0.000004,2,0.000002,my $mask = shift ;
0.000003,2,0.000001,my $catmask ;
0.000003,2,0.000001,my $fatal = 0 ;
0.000003,2,0.000001,my $no_fatal = 0 ;
0.000000,0,0.000000,
0.000007,2,0.000004,foreach my $word ( @_ ) {
0.000022,4,0.000005,if ($word eq 'FATAL') {
0.000003,2,0.000001,$fatal = 1;
0.000003,2,0.000002,$no_fatal = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($word eq 'NONFATAL') {
0.000000,0,0.000000,$fatal = 0;
0.000000,0,0.000000,$no_fatal = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($catmask = $Bits{$word}) {
0.000003,2,0.000002,$mask |= $catmask ;
0.000005,2,0.000002,$mask |= $DeadBits{$word} if $fatal ;
0.000003,2,0.000001,$mask &= ~($DeadBits{$word}|$All) if $no_fatal ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ Croaker("Unknown warnings category '$word'")}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,2,0.000006,return $mask ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bits
0.000000,0,0.000000,{
0.000000,0,0.000000,# called from B::Deparse.pm
0.000000,0,0.000000,push @_, 'all' unless @_ ;
0.000000,0,0.000000,return _bits(undef, @_) ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import 
0.000000,0,0.000000,{
0.000235,163,0.000001,shift;
0.000000,0,0.000000,
0.000473,163,0.000003,my $mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT) ;
0.000000,0,0.000000,
0.000388,163,0.000002,if (vec($mask, $Offsets{'all'}, 1)) {
0.000015,8,0.000002,$mask |= $Bits{'all'} ;
0.000015,8,0.000002,$mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Empty @_ is equivalent to @_ = 'all' ;
0.001458,163,0.000009,${^WARNING_BITS} = @_ ? _bits($mask, @_) : $mask | $Bits{all} ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport 
0.000000,0,0.000000,{
0.000326,225,0.000001,shift;
0.000000,0,0.000000,
0.000314,225,0.000001,my $catmask ;
0.000621,225,0.000003,my $mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT) ;
0.000000,0,0.000000,
0.000637,225,0.000003,if (vec($mask, $Offsets{'all'}, 1)) {
0.000219,124,0.000002,$mask |= $Bits{'all'} ;
0.000232,124,0.000002,$mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000333,225,0.000001,push @_, 'all' unless @_;
0.000000,0,0.000000,
0.000741,225,0.000003,foreach my $word ( @_ ) {
0.001890,421,0.000004,if ($word eq 'FATAL') {
0.000000,0,0.000000,next; 
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($catmask = $Bits{$word}) {
0.000000,0,0.000000,$mask &= ~($catmask | $DeadBits{$word} | $All);
0.000000,0,0.000000,}
0.000000,0,0.000000,else
0.000000,0,0.000000,{ Croaker("Unknown warnings category '$word'")}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001756,225,0.000008,${^WARNING_BITS} = $mask ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,2,0.000003,my %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub MESSAGE () { 4 };
0.000000,0,0.000000,sub FATAL () { 2 };
0.000000,0,0.000000,sub NORMAL () { 1 };
0.000000,0,0.000000,
0.000000,0,0.000000,sub __chk
0.000000,0,0.000000,{
0.000007,5,0.000001,my $category ;
0.000007,5,0.000001,my $offset ;
0.000008,5,0.000002,my $isobj = 0 ;
0.000008,5,0.000002,my $wanted = shift;
0.000008,5,0.000002,my $has_message = $wanted & MESSAGE;
0.000000,0,0.000000,
0.000008,5,0.000002,unless (@_ == 1 || @_ == ($has_message ? 2 : 0)) {
0.000000,0,0.000000,my $sub = (caller 1)[3];
0.000000,0,0.000000,my $syntax = $has_message ? "[category,] 'message'" : '[category]';
0.000000,0,0.000000,Croaker("Usage: $sub($syntax)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,5,0.000001,my $message = pop if $has_message;
0.000000,0,0.000000,
0.000015,5,0.000003,if (@_) {
0.000000,0,0.000000,# check the category supplied.
0.000008,5,0.000002,$category = shift ;
0.000009,5,0.000002,if (my $type = ref $category) {
0.000000,0,0.000000,Croaker("not an object")
0.000000,0,0.000000,if exists $builtin_type{$type};
0.000000,0,0.000000,$category = $type;
0.000000,0,0.000000,$isobj = 1 ;
0.000000,0,0.000000,}
0.000010,5,0.000002,$offset = $Offsets{$category};
0.000008,5,0.000002,Croaker("Unknown warnings category '$category'")
0.000000,0,0.000000,unless defined $offset;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$category = (caller(1))[0] ;
0.000000,0,0.000000,$offset = $Offsets{$category};
0.000000,0,0.000000,Croaker("package '$category' not registered for warnings")
0.000000,0,0.000000,unless defined $offset ;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,5,0.000001,my $i;
0.000000,0,0.000000,
0.000014,5,0.000003,if ($isobj) {
0.000000,0,0.000000,my $pkg;
0.000000,0,0.000000,$i = 2;
0.000000,0,0.000000,while (do { { package DB; $pkg = (caller($i++))[0] } } ) {
0.000000,0,0.000000,last unless @DB::args && $DB::args[0] =~ /^$category=/ ;
0.000000,0,0.000000,}
0.000000,0,0.000000,$i -= 2 ;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000027,5,0.000005,$i = _error_loc(); # see where Carp will allocate the error
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Default to 0 if caller returns nothing.  Default to $DEFAULT if it
0.000000,0,0.000000,# explicitly returns undef.
0.000026,5,0.000005,my(@callers_bitmask) = (caller($i))[9] ;
0.000010,5,0.000002,my $callers_bitmask =
0.000000,0,0.000000,@callers_bitmask ? $callers_bitmask[0] // $DEFAULT : 0 ;
0.000000,0,0.000000,
0.000007,5,0.000001,my @results;
0.000024,5,0.000005,foreach my $type (FATAL, NORMAL) {
0.000015,10,0.000002,next unless $wanted & $type;
0.000000,0,0.000000,
0.000022,5,0.000004,push @results, (vec($callers_bitmask, $offset + $type - 1, 1) ||
0.000000,0,0.000000,vec($callers_bitmask, $Offsets{'all'} + $type - 1, 1));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# &enabled and &fatal_enabled
0.000030,5,0.000006,return $results[0] unless $has_message;
0.000000,0,0.000000,
0.000000,0,0.000000,# &warnif, and the category is neither enabled as warning nor as fatal
0.000000,0,0.000000,return if $wanted == (NORMAL | FATAL | MESSAGE)
0.000000,0,0.000000,&& !($results[0] || $results[1]);
0.000000,0,0.000000,
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak($message) if $results[0];
0.000000,0,0.000000,# will always get here for &warn. will only get here for &warnif if the
0.000000,0,0.000000,# category is enabled
0.000000,0,0.000000,Carp::carp($message);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _mkMask
0.000000,0,0.000000,{
0.000013,8,0.000002,my ($bit) = @_;
0.000012,8,0.000002,my $mask = "";
0.000000,0,0.000000,
0.000021,8,0.000003,vec($mask, $bit, 1) = 1;
0.000051,8,0.000006,return $mask;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub register_categories
0.000000,0,0.000000,{
0.000008,4,0.000002,my @names = @_;
0.000000,0,0.000000,
0.000028,4,0.000007,for my $name (@names) {
0.000022,4,0.000006,if (! defined $Bits{$name}) {
0.000024,4,0.000006,$Bits{$name}     = _mkMask($LAST_BIT);
0.000010,4,0.000003,vec($Bits{'all'}, $LAST_BIT, 1) = 1;
0.000009,4,0.000002,$Offsets{$name}  = $LAST_BIT ++;
0.000049,4,0.000012,foreach my $k (keys %Bits) {
0.000742,234,0.000003,vec($Bits{$k}, $LAST_BIT, 1) = 0;
0.000000,0,0.000000,}
0.000023,4,0.000006,$DeadBits{$name} = _mkMask($LAST_BIT);
0.000010,4,0.000003,vec($DeadBits{'all'}, $LAST_BIT++, 1) = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _error_loc {
0.000009,5,0.000002,require Carp;
0.000046,5,0.000009,goto &Carp::short_error_loc; # don't introduce another stack frame
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub enabled
0.000000,0,0.000000,{
0.000047,5,0.000009,return __chk(NORMAL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fatal_enabled
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(FATAL, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warn
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(FATAL | MESSAGE, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warnif
0.000000,0,0.000000,{
0.000000,0,0.000000,return __chk(NORMAL | FATAL | MESSAGE, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# These are not part of any public interface, so we can delete them to save
0.000000,0,0.000000,# space.
0.000005,1,0.000005,delete @warnings::{qw(NORMAL FATAL MESSAGE)};
0.000000,0,0.000000,
0.000029,1,0.000029,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ex: set ro:
