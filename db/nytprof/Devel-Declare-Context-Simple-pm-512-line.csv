# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Devel::Declare::Context::Simple;
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000033,2,0.000016,use warnings;
0.000155,2,0.000078,use Devel::Declare ();
0.000118,2,0.000059,use B::Hooks::EndOfScope;
0.001383,2,0.000691,use Carp qw/confess/;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.006014';
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000003,2,0.000002,my $class = shift;
0.000016,2,0.000008,bless {@_}, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub init {
0.000024,17,0.000001,my $self = shift;
0.000061,17,0.000004,@{$self}{ qw(Declarator Offset WarningOnRedefined) } = @_;
0.000092,17,0.000005,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub offset {
0.000388,266,0.000001,my $self = shift;
0.001356,266,0.000005,return $self->{Offset}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inc_offset {
0.000125,85,0.000001,my $self = shift;
0.000425,85,0.000005,$self->{Offset} += shift;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub declarator {
0.000048,34,0.000001,my $self = shift;
0.000185,34,0.000005,return $self->{Declarator}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub warning_on_redefine {
0.000024,17,0.000001,my $self = shift;
0.000109,17,0.000006,return $self->{WarningOnRedefined}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub skip_declarator {
0.000026,17,0.000002,my $self = shift;
0.000086,17,0.000005,my $decl = $self->declarator;
0.000188,17,0.000011,my $len = Devel::Declare::toke_scan_word($self->offset, 0);
0.000024,17,0.000001,confess "Couldn't find declarator '$decl'"
0.000000,0,0.000000,unless $len;
0.000000,0,0.000000,
0.000087,17,0.000005,my $linestr = $self->get_linestr;
0.000092,17,0.000005,my $name = substr($linestr, $self->offset, $len);
0.000026,17,0.000002,confess "Expected declarator '$decl', got '${name}'"
0.000000,0,0.000000,unless $name eq $decl;
0.000000,0,0.000000,
0.000150,17,0.000009,$self->inc_offset($len);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub skipspace {
0.000094,68,0.000001,my $self = shift;
0.008670,68,0.000128,$self->inc_offset(Devel::Declare::toke_skipspace($self->offset));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_linestr {
0.000117,82,0.000001,my $self = shift;
0.000522,82,0.000006,my $line = Devel::Declare::get_linestr();
0.000404,82,0.000005,return $line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_linestr {
0.000077,48,0.000002,my $self = shift;
0.000079,48,0.000002,my ($line) = @_;
0.000461,48,0.000010,Devel::Declare::set_linestr($line);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_name {
0.000033,17,0.000002,my $self = shift;
0.000085,17,0.000005,$self->skipspace;
0.000174,17,0.000010,if (my $len = Devel::Declare::toke_scan_word( $self->offset, 1 )) {
0.000084,17,0.000005,my $linestr = $self->get_linestr();
0.000091,17,0.000005,my $name = substr( $linestr, $self->offset, $len );
0.000088,17,0.000005,substr( $linestr, $self->offset, $len ) = '';
0.000089,17,0.000005,$self->set_linestr($linestr);
0.000092,17,0.000005,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_ident {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,if (my $len = Devel::Declare::toke_scan_ident( $self->offset )) {
0.000000,0,0.000000,my $linestr = $self->get_linestr();
0.000000,0,0.000000,my $ident = substr( $linestr, $self->offset, $len );
0.000000,0,0.000000,substr( $linestr, $self->offset, $len ) = '';
0.000000,0,0.000000,$self->set_linestr($linestr);
0.000000,0,0.000000,return $ident;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_proto {
0.000025,17,0.000001,my $self = shift;
0.000078,17,0.000005,$self->skipspace;
0.000000,0,0.000000,
0.000085,17,0.000005,my $linestr = $self->get_linestr();
0.000090,17,0.000005,if (substr($linestr, $self->offset, 1) eq '(') {
0.000180,14,0.000013,my $length = Devel::Declare::toke_scan_str($self->offset);
0.000094,14,0.000007,my $proto = Devel::Declare::get_lex_stuff();
0.000088,14,0.000006,Devel::Declare::clear_lex_stuff();
0.000070,14,0.000005,$linestr = $self->get_linestr();
0.000000,0,0.000000,
0.000074,14,0.000005,substr($linestr, $self->offset,
0.000000,0,0.000000,defined($length) ? $length : length($linestr)) = '';
0.000076,14,0.000005,$self->set_linestr($linestr);
0.000000,0,0.000000,
0.000074,14,0.000005,return $proto;
0.000000,0,0.000000,}
0.000016,3,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_names_and_args {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,
0.000000,0,0.000000,my @args;
0.000000,0,0.000000,
0.000000,0,0.000000,my $linestr = $self->get_linestr;
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq '(') {
0.000000,0,0.000000,# We had a leading paren, so we will now expect comma separated
0.000000,0,0.000000,# arguments
0.000000,0,0.000000,substr($linestr, $self->offset, 1) = '';
0.000000,0,0.000000,$self->set_linestr($linestr);
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,
0.000000,0,0.000000,# At this point we expect to have a comma-separated list of
0.000000,0,0.000000,# barewords with optional protos afterward, so loop until we
0.000000,0,0.000000,# run out of comma-separated values
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,# Get the bareword
0.000000,0,0.000000,my $thing = $self->strip_name;
0.000000,0,0.000000,# If there's no bareword here, bail
0.000000,0,0.000000,confess "failed to parse bareword. found ${linestr}"
0.000000,0,0.000000,unless defined $thing;
0.000000,0,0.000000,
0.000000,0,0.000000,$linestr = $self->get_linestr;
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq '(') {
0.000000,0,0.000000,# This one had a proto, pull it out
0.000000,0,0.000000,push(@args, [ $thing, $self->strip_proto ]);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# This had no proto, so store it with an undef
0.000000,0,0.000000,push(@args, [ $thing, undef ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,$linestr = $self->get_linestr;
0.000000,0,0.000000,
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq ',') {
0.000000,0,0.000000,# We found a comma, strip it out and set things up for
0.000000,0,0.000000,# another iteration
0.000000,0,0.000000,substr($linestr, $self->offset, 1) = '';
0.000000,0,0.000000,$self->set_linestr($linestr);
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# No comma, get outta here
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# look for the final closing paren of the list
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq ')') {
0.000000,0,0.000000,substr($linestr, $self->offset, 1) = '';
0.000000,0,0.000000,$self->set_linestr($linestr);
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# fail if it isn't there
0.000000,0,0.000000,confess "couldn't find closing paren for argument. found ${linestr}"
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# No parens, so expect a single arg
0.000000,0,0.000000,my $thing = $self->strip_name;
0.000000,0,0.000000,# If there's no bareword here, bail
0.000000,0,0.000000,confess "failed to parse bareword. found ${linestr}"
0.000000,0,0.000000,unless defined $thing;
0.000000,0,0.000000,$linestr = $self->get_linestr;
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq '(') {
0.000000,0,0.000000,# This one had a proto, pull it out
0.000000,0,0.000000,push(@args, [ $thing, $self->strip_proto ]);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# This had no proto, so store it with an undef
0.000000,0,0.000000,push(@args, [ $thing, undef ]);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@args;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_attrs {
0.000024,17,0.000001,my $self = shift;
0.000077,17,0.000005,$self->skipspace;
0.000000,0,0.000000,
0.000136,17,0.000008,my $linestr = Devel::Declare::get_linestr;
0.000025,17,0.000001,my $attrs   = '';
0.000000,0,0.000000,
0.000089,17,0.000005,if (substr($linestr, $self->offset, 1) eq ':') {
0.000000,0,0.000000,while (substr($linestr, $self->offset, 1) ne '{') {
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq ':') {
0.000000,0,0.000000,substr($linestr, $self->offset, 1) = '';
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,
0.000000,0,0.000000,$attrs .= ':';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->skipspace;
0.000000,0,0.000000,$linestr = Devel::Declare::get_linestr();
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $len = Devel::Declare::toke_scan_word($self->offset, 0)) {
0.000000,0,0.000000,my $name = substr($linestr, $self->offset, $len);
0.000000,0,0.000000,substr($linestr, $self->offset, $len) = '';
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,
0.000000,0,0.000000,$attrs .= " ${name}";
0.000000,0,0.000000,
0.000000,0,0.000000,if (substr($linestr, $self->offset, 1) eq '(') {
0.000000,0,0.000000,my $length = Devel::Declare::toke_scan_str($self->offset);
0.000000,0,0.000000,my $arg    = Devel::Declare::get_lex_stuff();
0.000000,0,0.000000,Devel::Declare::clear_lex_stuff();
0.000000,0,0.000000,$linestr = Devel::Declare::get_linestr();
0.000000,0,0.000000,substr($linestr, $self->offset, $length) = '';
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,
0.000000,0,0.000000,$attrs .= "(${arg})";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$linestr = Devel::Declare::get_linestr();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000086,17,0.000005,return $attrs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_curstash_name {
0.000338,34,0.000010,return Devel::Declare::get_curstash_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shadow {
0.000026,17,0.000002,my $self = shift;
0.000081,17,0.000005,my $pack = $self->get_curstash_name;
0.000209,17,0.000012,Devel::Declare::shadow_sub( $pack . '::' . $self->declarator, $_[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inject_if_block {
0.000025,17,0.000001,my $self   = shift;
0.000026,17,0.000002,my $inject = shift;
0.000025,17,0.000001,my $before = shift || '';
0.000000,0,0.000000,
0.000078,17,0.000005,$self->skipspace;
0.000000,0,0.000000,
0.000087,17,0.000005,my $linestr = $self->get_linestr;
0.000089,17,0.000005,if (substr($linestr, $self->offset, 1) eq '{') {
0.000097,17,0.000006,substr($linestr, $self->offset + 1, 0) = $inject;
0.000087,17,0.000005,substr($linestr, $self->offset, 0) = $before;
0.000082,17,0.000005,$self->set_linestr($linestr);
0.000082,17,0.000005,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub scope_injector_call {
0.000025,17,0.000001,my $self = shift;
0.000026,17,0.000002,my $inject = shift || '';
0.000105,17,0.000006,return ' BEGIN { ' . ref($self) . "->inject_scope('${inject}') }; ";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inject_scope {
0.000029,17,0.000002,my $class = shift;
0.000025,17,0.000001,my $inject = shift;
0.000000,0,0.000000,on_scope_end {
0.000148,17,0.000009,my $linestr = Devel::Declare::get_linestr;
0.000025,17,0.000001,return unless defined $linestr;
0.000123,17,0.000007,my $offset  = Devel::Declare::get_linestr_offset;
0.000037,17,0.000002,substr( $linestr, $offset, 0 ) = ';' . $inject;
0.000211,17,0.000012,Devel::Declare::set_linestr($linestr);
0.000214,17,0.000013,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,# vi:sw=2 ts=2
