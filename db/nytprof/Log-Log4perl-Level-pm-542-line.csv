# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,###############r###################################
0.000000,0,0.000000,package Log::Log4perl::Level;
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000053,2,0.000027,use 5.006;
0.000032,2,0.000016,use strict;
0.000031,2,0.000015,use warnings;
0.000037,2,0.000018,use Carp;
0.000000,0,0.000000,
0.000000,0,0.000000,# log4j, for whatever reason, puts 0 as all and MAXINT as OFF.
0.000000,0,0.000000,# this seems less optimal, as more logging would imply a higher
0.000000,0,0.000000,# level. But oh well. Probably some brokenness that has persisted. :)
0.000037,2,0.000019,use constant ALL_INT   => 0;
0.000034,2,0.000017,use constant TRACE_INT =>  5000;
0.000034,2,0.000017,use constant DEBUG_INT => 10000;
0.000034,2,0.000017,use constant INFO_INT  => 20000;
0.000037,2,0.000019,use constant WARN_INT  => 30000;
0.000033,2,0.000017,use constant ERROR_INT => 40000;
0.000039,2,0.000019,use constant FATAL_INT => 50000;
0.000036,2,0.000018,use constant OFF_INT   => (2 ** 31) - 1;
0.000000,0,0.000000,
0.000038,2,0.000019,no strict qw(refs);
0.000810,2,0.000405,use vars qw(%PRIORITY %LEVELS %SYSLOG %L4P_TO_LD);
0.000000,0,0.000000,
0.000002,1,0.000002,%PRIORITY = (); # unless (%PRIORITY);
0.000002,1,0.000002,%LEVELS = () unless (%LEVELS);
0.000002,1,0.000002,%SYSLOG = () unless (%SYSLOG);
0.000002,1,0.000002,%L4P_TO_LD = () unless (%L4P_TO_LD);
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_priority {
0.000013,8,0.000002,my ($prio, $intval, $syslog, $log_dispatch_level) = @_;
0.000012,8,0.000002,$prio = uc($prio); # just in case;
0.000000,0,0.000000,
0.000017,8,0.000002,$PRIORITY{$prio}    = $intval;
0.000017,8,0.000002,$LEVELS{$intval}    = $prio;
0.000000,0,0.000000,
0.000000,0,0.000000,# Set up the mapping between Log4perl integer levels and 
0.000000,0,0.000000,# Log::Dispatch levels
0.000000,0,0.000000,# Note: Log::Dispatch uses the following levels:
0.000000,0,0.000000,# 0 debug
0.000000,0,0.000000,# 1 info
0.000000,0,0.000000,# 2 notice
0.000000,0,0.000000,# 3 warning
0.000000,0,0.000000,# 4 error
0.000000,0,0.000000,# 5 critical
0.000000,0,0.000000,# 6 alert
0.000000,0,0.000000,# 7 emergency
0.000000,0,0.000000,
0.000000,0,0.000000,# The equivalent Log::Dispatch level is optional, set it to 
0.000000,0,0.000000,# the highest value (7=emerg) if it's not provided.
0.000011,8,0.000001,$log_dispatch_level = 7 unless defined $log_dispatch_level;
0.000000,0,0.000000,
0.000012,8,0.000002,$L4P_TO_LD{$prio}  = $log_dispatch_level;
0.000000,0,0.000000,
0.000050,8,0.000006,$SYSLOG{$prio}      = $syslog if defined($syslog);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# create the basic priorities
0.000005,1,0.000005,add_priority("OFF",   OFF_INT,   -1, 7);
0.000005,1,0.000005,add_priority("FATAL", FATAL_INT,  0, 7);
0.000005,1,0.000005,add_priority("ERROR", ERROR_INT,  3, 4);
0.000005,1,0.000005,add_priority("WARN",  WARN_INT,   4, 3);
0.000005,1,0.000005,add_priority("INFO",  INFO_INT,   6, 1);
0.000005,1,0.000005,add_priority("DEBUG", DEBUG_INT,  7, 0);
0.000004,1,0.000004,add_priority("TRACE", TRACE_INT,  8, 0);
0.000005,1,0.000005,add_priority("ALL",   ALL_INT,    8, 0);
0.000000,0,0.000000,
0.000000,0,0.000000,# we often sort numerically, so a helper func for readability
0.000000,0,0.000000,sub numerically {$a <=> $b}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,###########################################
0.000016,8,0.000002,my($class, $namespace) = @_;
0.000000,0,0.000000,
0.000024,8,0.000003,if(defined $namespace) {
0.000000,0,0.000000,# Export $OFF, $FATAL, $ERROR etc. to
0.000000,0,0.000000,# the given namespace
0.000000,0,0.000000,$namespace .= "::" unless $namespace =~ /::$/;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Export $OFF, $FATAL, $ERROR etc. to
0.000000,0,0.000000,# the caller's namespace
0.000019,8,0.000002,$namespace = caller(0) . "::";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000083,8,0.000010,for my $key (keys %PRIORITY) {
0.000097,64,0.000002,my $name  = "$namespace$key";
0.000101,64,0.000002,my $value = $PRIORITY{$key};
0.000204,64,0.000003,*{"$name"} = \$value;
0.000103,64,0.000002,my $nameint = "$namespace${key}_INT";
0.000106,64,0.000002,my $func = uc($key) . "_INT";
0.000269,64,0.000004,*{"$nameint"} = \&$func;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub new { 
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# We don't need any of this class nonsense
0.000000,0,0.000000,# in Perl, because we won't allow subclassing
0.000000,0,0.000000,# from this. We're optimizing for raw speed.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub to_priority {
0.000000,0,0.000000,# changes a level name string to a priority numeric
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($string) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $PRIORITY{$string}) {
0.000000,0,0.000000,return $PRIORITY{$string};
0.000000,0,0.000000,}else{
0.000000,0,0.000000,croak "level '$string' is not a valid error level (".join ('|', keys %PRIORITY),')';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub to_level {
0.000000,0,0.000000,# changes a priority numeric constant to a level name string 
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($priority) = @_;
0.000000,0,0.000000,if (exists $LEVELS{$priority}) {
0.000000,0,0.000000,return $LEVELS{$priority}
0.000000,0,0.000000,}else {
0.000000,0,0.000000,croak("priority '$priority' is not a valid error level number (",
0.000000,0,0.000000,join("|", sort numerically keys %LEVELS), "
0.000000,0,0.000000,)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub to_LogDispatch_string {
0.000000,0,0.000000,# translates into strings that Log::Dispatch recognizes
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($priority) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,confess "do what? no priority?" unless defined $priority;
0.000000,0,0.000000,
0.000000,0,0.000000,my $string;
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $LEVELS{$priority}) {
0.000000,0,0.000000,$string = $LEVELS{$priority};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Log::Dispatch idiosyncrasies
0.000000,0,0.000000,if($priority == $PRIORITY{WARN}) {
0.000000,0,0.000000,$string = "WARNING";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($priority == $PRIORITY{FATAL}) {
0.000000,0,0.000000,$string = "EMERGENCY";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###################################################
0.000000,0,0.000000,sub is_valid {
0.000000,0,0.000000,###################################################
0.000002,1,0.000002,my $q = shift;
0.000000,0,0.000000,
0.000011,1,0.000011,if ($q =~ /[A-Z]/) {
0.000000,0,0.000000,return exists $PRIORITY{$q};
0.000000,0,0.000000,}else{
0.000009,1,0.000009,return $LEVELS{$q};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_higher_level {
0.000000,0,0.000000,my ($old_priority, $delta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$delta ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_priority = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach (1..$delta){
0.000000,0,0.000000,#so the list is TRACE, DEBUG, INFO, WARN, ERROR, FATAL
0.000000,0,0.000000,# but remember, the numbers go in reverse order!
0.000000,0,0.000000,foreach my $p (sort numerically keys %LEVELS){
0.000000,0,0.000000,if ($p > $old_priority) {
0.000000,0,0.000000,$new_priority = $p;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$old_priority = $new_priority;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $new_priority;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_lower_level {
0.000000,0,0.000000,my ($old_priority, $delta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$delta ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_priority = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach (1..$delta){
0.000000,0,0.000000,#so the list is FATAL, ERROR, WARN, INFO, DEBUG, TRACE
0.000000,0,0.000000,# but remember, the numbers go in reverse order!
0.000000,0,0.000000,foreach my $p (reverse sort numerically keys %LEVELS){
0.000000,0,0.000000,if ($p < $old_priority) {
0.000000,0,0.000000,$new_priority = $p;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$old_priority = $new_priority;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $new_priority;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub isGreaterOrEqual {
0.000105,64,0.000002,my $lval = shift;
0.000091,64,0.000001,my $rval = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# in theory, we should check if the above really ARE valid levels.
0.000000,0,0.000000,# but we just use numeric comparison, since they aren't really classes.
0.000000,0,0.000000,
0.000000,0,0.000000,# oh, yeah, and 'cuz level ints go from 0 .. N with 0 being highest,
0.000000,0,0.000000,# these are reversed.
0.000325,64,0.000005,return $lval <= $rval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,######################################################################
0.000000,0,0.000000,# 
0.000000,0,0.000000,# since the integer representation of levels is reversed from what
0.000000,0,0.000000,# we normally want, we don't want to use < and >... instead, we
0.000000,0,0.000000,# want to use this comparison function
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
