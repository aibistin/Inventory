# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# -*- buffer-read-only: t -*-
0.000000,0,0.000000,# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
0.000000,0,0.000000,# This file is built by regen/feature.pl.
0.000000,0,0.000000,# Any changes made here will be lost!
0.000000,0,0.000000,
0.000000,0,0.000000,package feature;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.32';
0.000000,0,0.000000,
0.000007,1,0.000007,our %feature = (
0.000000,0,0.000000,fc              => 'feature_fc',
0.000000,0,0.000000,say             => 'feature_say',
0.000000,0,0.000000,state           => 'feature_state',
0.000000,0,0.000000,switch          => 'feature_switch',
0.000000,0,0.000000,evalbytes       => 'feature_evalbytes',
0.000000,0,0.000000,array_base      => 'feature_arybase',
0.000000,0,0.000000,current_sub     => 'feature___SUB__',
0.000000,0,0.000000,lexical_subs    => 'feature_lexsubs',
0.000000,0,0.000000,unicode_eval    => 'feature_unieval',
0.000000,0,0.000000,unicode_strings => 'feature_unicode',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000007,1,0.000007,our %feature_bundle = (
0.000000,0,0.000000,"5.10"    => [qw(array_base say state switch)],
0.000000,0,0.000000,"5.11"    => [qw(array_base say state switch unicode_strings)],
0.000000,0,0.000000,"5.15"    => [qw(current_sub evalbytes fc say state switch unicode_eval unicode_strings)],
0.000000,0,0.000000,"all"     => [qw(array_base current_sub evalbytes fc lexical_subs say state switch unicode_eval unicode_strings)],
0.000000,0,0.000000,"default" => [qw(array_base)],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,$feature_bundle{"5.12"} = $feature_bundle{"5.11"};
0.000002,1,0.000002,$feature_bundle{"5.13"} = $feature_bundle{"5.11"};
0.000002,1,0.000002,$feature_bundle{"5.14"} = $feature_bundle{"5.11"};
0.000001,1,0.000001,$feature_bundle{"5.16"} = $feature_bundle{"5.15"};
0.000001,1,0.000001,$feature_bundle{"5.17"} = $feature_bundle{"5.15"};
0.000002,1,0.000002,$feature_bundle{"5.18"} = $feature_bundle{"5.15"};
0.000002,1,0.000002,$feature_bundle{"5.9.5"} = $feature_bundle{"5.10"};
0.000000,0,0.000000,
0.000002,1,0.000002,our $hint_shift   = 26;
0.000001,1,0.000001,our $hint_mask    = 0x1c000000;
0.000003,1,0.000003,our @hint_bundles = qw( default 5.10 5.11 5.15 );
0.000000,0,0.000000,
0.000000,0,0.000000,# This gets set (for now) in $^H as well as in %^H,
0.000000,0,0.000000,# for runtime speed of the uc/lc/ucfirst/lcfirst functions.
0.000000,0,0.000000,# See HINT_UNI_8_BIT in perl.h.
0.000001,1,0.000001,our $hint_uni8bit = 0x00000800;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO:
0.000000,0,0.000000,# - think about versioned features (use feature switch => 2)
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,feature - Perl pragma to enable new features
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use feature qw(say switch);
0.000000,0,0.000000,given ($foo) {
0.000000,0,0.000000,when (1)          { say "\$foo == 1" }
0.000000,0,0.000000,when ([2,3])      { say "\$foo == 2 || \$foo == 3" }
0.000000,0,0.000000,when (/^a[bc]d$/) { say "\$foo eq 'abd' || \$foo eq 'acd'" }
0.000000,0,0.000000,when ($_ > 100)   { say "\$foo > 100" }
0.000000,0,0.000000,default           { say "None of the above" }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,use feature ':5.10'; # loads all features available in perl 5.10
0.000000,0,0.000000,
0.000000,0,0.000000,use v5.10;           # implicitly loads :5.10 feature bundle
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,It is usually impossible to add new syntax to Perl without breaking
0.000000,0,0.000000,some existing programs.  This pragma provides a way to minimize that
0.000000,0,0.000000,risk. New syntactic constructs, or new semantic meanings to older
0.000000,0,0.000000,constructs, can be enabled by C<use feature 'foo'>, and will be parsed
0.000000,0,0.000000,only when the appropriate feature pragma is in scope.  (Nevertheless, the
0.000000,0,0.000000,C<CORE::> prefix provides access to all Perl keywords, regardless of this
0.000000,0,0.000000,pragma.)
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Lexical effect
0.000000,0,0.000000,
0.000000,0,0.000000,Like other pragmas (C<use strict>, for example), features have a lexical
0.000000,0,0.000000,effect.  C<use feature qw(foo)> will only make the feature "foo" available
0.000000,0,0.000000,from that point to the end of the enclosing block.
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,use feature 'say';
0.000000,0,0.000000,say "say is available here";
0.000000,0,0.000000,}
0.000000,0,0.000000,print "But not here.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 C<no feature>
0.000000,0,0.000000,
0.000000,0,0.000000,Features can also be turned off by using C<no feature "foo">.  This too
0.000000,0,0.000000,has lexical effect.
0.000000,0,0.000000,
0.000000,0,0.000000,use feature 'say';
0.000000,0,0.000000,say "say is available here";
0.000000,0,0.000000,{
0.000000,0,0.000000,no feature 'say';
0.000000,0,0.000000,print "But not here.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,say "Yet it is here.";
0.000000,0,0.000000,
0.000000,0,0.000000,C<no feature> with no features specified will reset to the default group.  To
0.000000,0,0.000000,disable I<all> features (an unusual request!) use C<no feature ':all'>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AVAILABLE FEATURES
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'say' feature
0.000000,0,0.000000,
0.000000,0,0.000000,C<use feature 'say'> tells the compiler to enable the Perl 6 style
0.000000,0,0.000000,C<say> function.
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlfunc/say> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available starting with Perl 5.10.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'state' feature
0.000000,0,0.000000,
0.000000,0,0.000000,C<use feature 'state'> tells the compiler to enable C<state>
0.000000,0,0.000000,variables.
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlsub/"Persistent Private Variables"> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available starting with Perl 5.10.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'switch' feature
0.000000,0,0.000000,
0.000000,0,0.000000,C<use feature 'switch'> tells the compiler to enable the Perl 6
0.000000,0,0.000000,given/when construct.
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlsyn/"Switch Statements"> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available starting with Perl 5.10.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'unicode_strings' feature
0.000000,0,0.000000,
0.000000,0,0.000000,C<use feature 'unicode_strings'> tells the compiler to use Unicode semantics
0.000000,0,0.000000,in all string operations executed within its scope (unless they are also
0.000000,0,0.000000,within the scope of either C<use locale> or C<use bytes>).  The same applies
0.000000,0,0.000000,to all regular expressions compiled within the scope, even if executed outside
0.000000,0,0.000000,it.  It does not change the internal representation of strings, but only how
0.000000,0,0.000000,they are interpreted.
0.000000,0,0.000000,
0.000000,0,0.000000,C<no feature 'unicode_strings'> tells the compiler to use the traditional
0.000000,0,0.000000,Perl semantics wherein the native character set semantics is used unless it is
0.000000,0,0.000000,clear to Perl that Unicode is desired.  This can lead to some surprises
0.000000,0,0.000000,when the behavior suddenly changes.  (See
0.000000,0,0.000000,L<perlunicode/The "Unicode Bug"> for details.)  For this reason, if you are
0.000000,0,0.000000,potentially using Unicode in your program, the
0.000000,0,0.000000,C<use feature 'unicode_strings'> subpragma is B<strongly> recommended.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available starting with Perl 5.12; was almost fully
0.000000,0,0.000000,implemented in Perl 5.14; and extended in Perl 5.16 to cover C<quotemeta>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'unicode_eval' and 'evalbytes' features
0.000000,0,0.000000,
0.000000,0,0.000000,Under the C<unicode_eval> feature, Perl's C<eval> function, when passed a
0.000000,0,0.000000,string, will evaluate it as a string of characters, ignoring any
0.000000,0,0.000000,C<use utf8> declarations.  C<use utf8> exists to declare the encoding of
0.000000,0,0.000000,the script, which only makes sense for a stream of bytes, not a string of
0.000000,0,0.000000,characters.  Source filters are forbidden, as they also really only make
0.000000,0,0.000000,sense on strings of bytes.  Any attempt to activate a source filter will
0.000000,0,0.000000,result in an error.
0.000000,0,0.000000,
0.000000,0,0.000000,The C<evalbytes> feature enables the C<evalbytes> keyword, which evaluates
0.000000,0,0.000000,the argument passed to it as a string of bytes.  It dies if the string
0.000000,0,0.000000,contains any characters outside the 8-bit range.  Source filters work
0.000000,0,0.000000,within C<evalbytes>: they apply to the contents of the string being
0.000000,0,0.000000,evaluated.
0.000000,0,0.000000,
0.000000,0,0.000000,Together, these two features are intended to replace the historical C<eval>
0.000000,0,0.000000,function, which has (at least) two bugs in it, that cannot easily be fixed
0.000000,0,0.000000,without breaking existing programs:
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,C<eval> behaves differently depending on the internal encoding of the
0.000000,0,0.000000,string, sometimes treating its argument as a string of bytes, and sometimes
0.000000,0,0.000000,as a string of characters.
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,Source filters activated within C<eval> leak out into whichever I<file>
0.000000,0,0.000000,scope is currently being compiled.  To give an example with the CPAN module
0.000000,0,0.000000,L<Semi::Semicolons>:
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN { eval "use Semi::Semicolons;  # not filtered here " }
0.000000,0,0.000000,# filtered here!
0.000000,0,0.000000,
0.000000,0,0.000000,C<evalbytes> fixes that to work the way one would expect:
0.000000,0,0.000000,
0.000000,0,0.000000,use feature "evalbytes";
0.000000,0,0.000000,BEGIN { evalbytes "use Semi::Semicolons;  # filtered " }
0.000000,0,0.000000,# not filtered
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,These two features are available starting with Perl 5.16.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'current_sub' feature
0.000000,0,0.000000,
0.000000,0,0.000000,This provides the C<__SUB__> token that returns a reference to the current
0.000000,0,0.000000,subroutine or C<undef> outside of a subroutine.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available starting with Perl 5.16.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'array_base' feature
0.000000,0,0.000000,
0.000000,0,0.000000,This feature supports the legacy C<$[> variable.  See L<perlvar/$[> and
0.000000,0,0.000000,L<arybase>.  It is on by default but disabled under C<use v5.16> (see
0.000000,0,0.000000,L</IMPLICIT LOADING>, below).
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available under this name starting with Perl 5.16.  In
0.000000,0,0.000000,previous versions, it was simply on all the time, and this pragma knew
0.000000,0,0.000000,nothing about it.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'fc' feature
0.000000,0,0.000000,
0.000000,0,0.000000,C<use feature 'fc'> tells the compiler to enable the C<fc> function,
0.000000,0,0.000000,which implements Unicode casefolding.
0.000000,0,0.000000,
0.000000,0,0.000000,See L<perlfunc/fc> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available from Perl 5.16 onwards.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The 'lexical_subs' feature
0.000000,0,0.000000,
0.000000,0,0.000000,B<WARNING>: This feature is still experimental and the implementation may
0.000000,0,0.000000,change in future versions of Perl.  For this reason, Perl will
0.000000,0,0.000000,warn when you use the feature, unless you have explicitly disabled the
0.000000,0,0.000000,warning:
0.000000,0,0.000000,
0.000000,0,0.000000,no warnings "experimental::lexical_subs";
0.000000,0,0.000000,
0.000000,0,0.000000,This enables declaration of subroutines via C<my sub foo>, C<state sub foo>
0.000000,0,0.000000,and C<our sub foo> syntax.  See L<perlsub/Lexical Subroutines> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,This feature is available from Perl 5.18 onwards.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FEATURE BUNDLES
0.000000,0,0.000000,
0.000000,0,0.000000,It's possible to load multiple features together, using
0.000000,0,0.000000,a I<feature bundle>.  The name of a feature bundle is prefixed with
0.000000,0,0.000000,a colon, to distinguish it from an actual feature.
0.000000,0,0.000000,
0.000000,0,0.000000,use feature ":5.10";
0.000000,0,0.000000,
0.000000,0,0.000000,The following feature bundles are available:
0.000000,0,0.000000,
0.000000,0,0.000000,bundle    features included
0.000000,0,0.000000,--------- -----------------
0.000000,0,0.000000,:default  array_base
0.000000,0,0.000000,
0.000000,0,0.000000,:5.10     say state switch array_base
0.000000,0,0.000000,
0.000000,0,0.000000,:5.12     say state switch unicode_strings array_base
0.000000,0,0.000000,
0.000000,0,0.000000,:5.14     say state switch unicode_strings array_base
0.000000,0,0.000000,
0.000000,0,0.000000,:5.16     say state switch unicode_strings
0.000000,0,0.000000,unicode_eval evalbytes current_sub fc
0.000000,0,0.000000,
0.000000,0,0.000000,:5.18     say state switch unicode_strings
0.000000,0,0.000000,unicode_eval evalbytes current_sub fc
0.000000,0,0.000000,
0.000000,0,0.000000,The C<:default> bundle represents the feature set that is enabled before
0.000000,0,0.000000,any C<use feature> or C<no feature> declaration.
0.000000,0,0.000000,
0.000000,0,0.000000,Specifying sub-versions such as the C<0> in C<5.14.0> in feature bundles has
0.000000,0,0.000000,no effect.  Feature bundles are guaranteed to be the same for all sub-versions.
0.000000,0,0.000000,
0.000000,0,0.000000,use feature ":5.14.0";    # same as ":5.14"
0.000000,0,0.000000,use feature ":5.14.1";    # same as ":5.14"
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 IMPLICIT LOADING
0.000000,0,0.000000,
0.000000,0,0.000000,Instead of loading feature bundles by name, it is easier to let Perl do
0.000000,0,0.000000,implicit loading of a feature bundle for you.
0.000000,0,0.000000,
0.000000,0,0.000000,There are two ways to load the C<feature> pragma implicitly:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,By using the C<-E> switch on the Perl command-line instead of C<-e>.
0.000000,0,0.000000,That will enable the feature bundle for that version of Perl in the
0.000000,0,0.000000,main compilation unit (that is, the one-liner that follows C<-E>).
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,By explicitly requiring a minimum Perl version number for your program, with
0.000000,0,0.000000,the C<use VERSION> construct.  That is,
0.000000,0,0.000000,
0.000000,0,0.000000,use v5.10.0;
0.000000,0,0.000000,
0.000000,0,0.000000,will do an implicit
0.000000,0,0.000000,
0.000000,0,0.000000,no feature ':all';
0.000000,0,0.000000,use feature ':5.10';
0.000000,0,0.000000,
0.000000,0,0.000000,and so on.  Note how the trailing sub-version
0.000000,0,0.000000,is automatically stripped from the
0.000000,0,0.000000,version.
0.000000,0,0.000000,
0.000000,0,0.000000,But to avoid portability warnings (see L<perlfunc/use>), you may prefer:
0.000000,0,0.000000,
0.000000,0,0.000000,use 5.010;
0.000000,0,0.000000,
0.000000,0,0.000000,with the same effect.
0.000000,0,0.000000,
0.000000,0,0.000000,If the required version is older than Perl 5.10, the ":default" feature
0.000000,0,0.000000,bundle is automatically loaded instead.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000007,4,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000007,4,0.000002,if (!@_) {
0.000000,0,0.000000,croak("No features specified");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000038,4,0.000009,__common(1, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# A bare C<no feature> should reset to the default bundle
0.000000,0,0.000000,if (!@_) {
0.000000,0,0.000000,$^H &= ~($hint_uni8bit|$hint_mask);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,__common(0, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub __common {
0.000006,4,0.000002,my $import = shift;
0.000008,4,0.000002,my $bundle_number = $^H & $hint_mask;
0.000010,4,0.000003,my $features = $bundle_number != $hint_mask
0.000000,0,0.000000,&& $feature_bundle{$hint_bundles[$bundle_number >> $hint_shift]};
0.000009,4,0.000002,if ($features) {
0.000000,0,0.000000,# Features are enabled implicitly via bundle hints.
0.000000,0,0.000000,# Delete any keys that may be left over from last time.
0.000032,2,0.000016,delete @^H{ values(%feature) };
0.000004,2,0.000002,$^H |= $hint_mask;
0.000007,2,0.000004,for (@$features) {
0.000006,2,0.000003,$^H{$feature{$_}} = 1;
0.000007,2,0.000004,$^H |= $hint_uni8bit if $_ eq 'unicode_strings';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000034,4,0.000008,while (@_) {
0.000023,15,0.000002,my $name = shift;
0.000027,15,0.000002,if (substr($name, 0, 1) eq ":") {
0.000004,2,0.000002,my $v = substr($name, 1);
0.000004,2,0.000002,if (!exists $feature_bundle{$v}) {
0.000000,0,0.000000,$v =~ s/^([0-9]+)\.([0-9]+).[0-9]+$/$1.$2/;
0.000000,0,0.000000,if (!exists $feature_bundle{$v}) {
0.000000,0,0.000000,unknown_feature_bundle(substr($name, 1));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000007,2,0.000004,unshift @_, @{$feature_bundle{$v}};
0.000004,2,0.000002,next;
0.000000,0,0.000000,}
0.000035,13,0.000003,if (!exists $feature{$name}) {
0.000000,0,0.000000,unknown_feature($name);
0.000000,0,0.000000,}
0.000057,13,0.000004,if ($import) {
0.000035,13,0.000003,$^H{$feature{$name}} = 1;
0.000022,13,0.000002,$^H |= $hint_uni8bit if $name eq 'unicode_strings';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,delete $^H{$feature{$name}};
0.000000,0,0.000000,$^H &= ~ $hint_uni8bit if $name eq 'unicode_strings';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unknown_feature {
0.000000,0,0.000000,my $feature = shift;
0.000000,0,0.000000,croak(sprintf('Feature "%s" is not supported by Perl %vd',
0.000000,0,0.000000,$feature, $^V));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unknown_feature_bundle {
0.000000,0,0.000000,my $feature = shift;
0.000000,0,0.000000,croak(sprintf('Feature bundle "%s" is not supported by Perl %vd',
0.000000,0,0.000000,$feature, $^V));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,Carp::croak(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,1,0.000011,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ex: set ro:
