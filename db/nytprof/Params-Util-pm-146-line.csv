# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Params::Util;
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Params::Util - Simple, compact and correct param-checking functions
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,# Import some functions
0.000000,0,0.000000,use Params::Util qw{_SCALAR _HASH _INSTANCE};
0.000000,0,0.000000,
0.000000,0,0.000000,# If you are lazy, or need a lot of them...
0.000000,0,0.000000,use Params::Util ':ALL';
0.000000,0,0.000000,
0.000000,0,0.000000,sub foo {
0.000000,0,0.000000,my $object  = _INSTANCE(shift, 'Foo') or return undef;
0.000000,0,0.000000,my $image   = _SCALAR(shift)          or return undef;
0.000000,0,0.000000,my $options = _HASH(shift)            or return undef;
0.000000,0,0.000000,# etc...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,C<Params::Util> provides a basic set of importable functions that makes
0.000000,0,0.000000,checking parameters a hell of a lot easier
0.000000,0,0.000000,
0.000000,0,0.000000,While they can be (and are) used in other contexts, the main point
0.000000,0,0.000000,behind this module is that the functions B<both> Do What You Mean,
0.000000,0,0.000000,and Do The Right Thing, so they are most useful when you are getting
0.000000,0,0.000000,params passed into your code from someone and/or somewhere else
0.000000,0,0.000000,and you can't really trust the quality.
0.000000,0,0.000000,
0.000000,0,0.000000,Thus, C<Params::Util> is of most use at the edges of your API, where
0.000000,0,0.000000,params and data are coming in from outside your code.
0.000000,0,0.000000,
0.000000,0,0.000000,The functions provided by C<Params::Util> check in the most strictly
0.000000,0,0.000000,correct manner known, are documented as thoroughly as possible so their
0.000000,0,0.000000,exact behaviour is clear, and heavily tested so make sure they are not
0.000000,0,0.000000,fooled by weird data and Really Bad Things.
0.000000,0,0.000000,
0.000000,0,0.000000,To use, simply load the module providing the functions you want to use
0.000000,0,0.000000,as arguments (as shown in the SYNOPSIS).
0.000000,0,0.000000,
0.000000,0,0.000000,To aid in maintainability, C<Params::Util> will B<never> export by
0.000000,0,0.000000,default.
0.000000,0,0.000000,
0.000000,0,0.000000,You must explicitly name the functions you want to export, or use the
0.000000,0,0.000000,C<:ALL> param to just have it export everything (although this is not
0.000000,0,0.000000,recommended if you have any _FOO functions yourself with which future
0.000000,0,0.000000,additions to C<Params::Util> may clash)
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000059,2,0.000029,use 5.00503;
0.000053,2,0.000026,use strict;
0.000002,1,0.000002,require overload;
0.000002,1,0.000002,require Exporter;
0.000001,1,0.000001,require Scalar::Util;
0.000002,1,0.000002,require DynaLoader;
0.000000,0,0.000000,
0.000671,2,0.000335,use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
0.000000,0,0.000000,
0.000002,1,0.000002,$VERSION   = '1.07';
0.000008,1,0.000008,@ISA       = qw{
0.000000,0,0.000000,Exporter
0.000000,0,0.000000,DynaLoader
0.000000,0,0.000000,};
0.000005,1,0.000005,@EXPORT_OK = qw{
0.000000,0,0.000000,_STRING     _IDENTIFIER
0.000000,0,0.000000,_CLASS      _CLASSISA   _SUBCLASS  _DRIVER  _CLASSDOES
0.000000,0,0.000000,_NUMBER     _POSINT     _NONNEGINT
0.000000,0,0.000000,_SCALAR     _SCALAR0
0.000000,0,0.000000,_ARRAY      _ARRAY0     _ARRAYLIKE
0.000000,0,0.000000,_HASH       _HASH0      _HASHLIKE
0.000000,0,0.000000,_CODE       _CODELIKE
0.000000,0,0.000000,_INVOCANT   _REGEX      _INSTANCE  _INSTANCEDOES
0.000000,0,0.000000,_SET        _SET0
0.000000,0,0.000000,_HANDLE
0.000000,0,0.000000,};
0.000003,1,0.000003,%EXPORT_TAGS = ( ALL => \@EXPORT_OK );
0.000000,0,0.000000,
0.000004,1,0.000004,eval {
0.000002,1,0.000002,local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
0.000011,1,0.000011,bootstrap Params::Util $VERSION;
0.000002,1,0.000002,1;
0.000000,0,0.000000,} unless $ENV{PERL_PARAMS_UTIL_PP};
0.000000,0,0.000000,
0.000000,0,0.000000,# Use a private pure-perl copy of looks_like_number if the version of
0.000000,0,0.000000,# Scalar::Util is old (for whatever reason).
0.000023,1,0.000023,my $SU = eval "$Scalar::Util::VERSION" || 0;
0.000009,1,0.000009,if ( $SU >= 1.18 ) { 
0.000000,0,0.000000,Scalar::Util->import('looks_like_number');
0.000000,0,0.000000,} else {
0.000000,0,0.000000,eval <<'END_PERL';
0.000000,0,0.000000,sub looks_like_number {
0.000000,0,0.000000,local $_ = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# checks from perlfaq4
0.000000,0,0.000000,return 0 if !defined($_);
0.000000,0,0.000000,if (ref($_)) {
0.000000,0,0.000000,return overload::Overloaded($_) ? defined(0 + $_) : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
0.000000,0,0.000000,return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
0.000000,0,0.000000,return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
0.000000,0,0.000000,
0.000000,0,0.000000,0;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,# Param Checking Functions
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _STRING $string
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_STRING> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a normal non-false string of non-zero length.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that this will NOT do anything magic to deal with the special
0.000000,0,0.000000,C<'0'> false negative case, but will return it.
0.000000,0,0.000000,
0.000000,0,0.000000,# '0' not considered valid data
0.000000,0,0.000000,my $name = _STRING(shift) or die "Bad name";
0.000000,0,0.000000,
0.000000,0,0.000000,# '0' is considered valid data
0.000000,0,0.000000,my $string = _STRING($_[0]) ? shift : die "Bad string";
0.000000,0,0.000000,
0.000000,0,0.000000,Please also note that this function expects a normal string. It does
0.000000,0,0.000000,not support overloading or other magic techniques to get a string.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the string as a conveince if it is a valid string, or
0.000000,0,0.000000,C<undef> if not.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,eval <<'END_PERL' unless defined &_STRING;
0.000000,0,0.000000,sub _STRING ($) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _IDENTIFIER $string
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_IDENTIFIER> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a string that is a valid Perl identifier.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the string as a convenience if it is a valid identifier, or
0.000000,0,0.000000,C<undef> if not.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000071,1,0.000071,eval <<'END_PERL' unless defined &_IDENTIFIER;
0.000000,0,0.000000,sub _IDENTIFIER ($) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _CLASS $string
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_CLASS> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a string that is a valid Perl class.
0.000000,0,0.000000,
0.000000,0,0.000000,This function only checks that the format is valid, not that the
0.000000,0,0.000000,class is actually loaded. It also assumes "normalised" form, and does
0.000000,0,0.000000,not accept class names such as C<::Foo> or C<D'Oh>.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the string as a convenience if it is a valid class name, or
0.000000,0,0.000000,C<undef> if not.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000064,1,0.000064,eval <<'END_PERL' unless defined &_CLASS;
0.000000,0,0.000000,sub _CLASS ($) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _CLASSISA $string, $class
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_CLASSISA> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a string that is a particularly class, or a subclass of it.
0.000000,0,0.000000,
0.000000,0,0.000000,This function checks that the format is valid and calls the -E<gt>isa
0.000000,0,0.000000,method on the class name. It does not check that the class is actually
0.000000,0,0.000000,loaded.
0.000000,0,0.000000,
0.000000,0,0.000000,It also assumes "normalised" form, and does
0.000000,0,0.000000,not accept class names such as C<::Foo> or C<D'Oh>.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the string as a convenience if it is a valid class name, or
0.000000,0,0.000000,C<undef> if not.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000073,1,0.000073,eval <<'END_PERL' unless defined &_CLASSISA;
0.000000,0,0.000000,sub _CLASSISA ($$) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _CLASSDOES $string, $role
0.000000,0,0.000000,
0.000000,0,0.000000,This routine behaves exactly like C<L</_CLASSISA>>, but checks with C<< ->DOES
0.000000,0,0.000000,>> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
0.000000,0,0.000000,5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
0.000000,0,0.000000,implemented.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000068,1,0.000068,eval <<'END_PERL' unless defined &_CLASSDOES;
0.000000,0,0.000000,sub _CLASSDOES ($$) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->DOES($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _SUBCLASS $string, $class
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_SUBCLASS> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a string that is a subclass of a specified class.
0.000000,0,0.000000,
0.000000,0,0.000000,This function checks that the format is valid and calls the -E<gt>isa
0.000000,0,0.000000,method on the class name. It does not check that the class is actually
0.000000,0,0.000000,loaded.
0.000000,0,0.000000,
0.000000,0,0.000000,It also assumes "normalised" form, and does
0.000000,0,0.000000,not accept class names such as C<::Foo> or C<D'Oh>.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the string as a convenience if it is a valid class name, or
0.000000,0,0.000000,C<undef> if not.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000076,1,0.000076,eval <<'END_PERL' unless defined &_SUBCLASS;
0.000000,0,0.000000,sub _SUBCLASS ($$) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _NUMBER $scalar
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_NUMBER> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a number. That is, it is defined and perl thinks it's a number.
0.000000,0,0.000000,
0.000000,0,0.000000,This function is basically a Params::Util-style wrapper around the
0.000000,0,0.000000,L<Scalar::Util> C<looks_like_number> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the value as a convience, or C<undef> if the value is not a
0.000000,0,0.000000,number.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,eval <<'END_PERL' unless defined &_NUMBER;
0.000000,0,0.000000,sub _NUMBER ($) {
0.000000,0,0.000000,( defined $_[0] and ! ref $_[0] and looks_like_number($_[0]) )
0.000000,0,0.000000,? $_[0]
0.000000,0,0.000000,: undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _POSINT $integer
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_POSINT> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a positive integer (of any length).
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the value as a convience, or C<undef> if the value is not a
0.000000,0,0.000000,positive integer.
0.000000,0,0.000000,
0.000000,0,0.000000,The name itself is derived from the XML schema constraint of the same
0.000000,0,0.000000,name.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000057,1,0.000057,eval <<'END_PERL' unless defined &_POSINT;
0.000000,0,0.000000,sub _POSINT ($) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _NONNEGINT $integer
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_NONNEGINT> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to test to see if a value is
0.000000,0,0.000000,a non-negative integer (of any length). That is, a positive integer,
0.000000,0,0.000000,or zero.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the value as a convience, or C<undef> if the value is not a
0.000000,0,0.000000,non-negative integer.
0.000000,0,0.000000,
0.000000,0,0.000000,As with other tests that may return false values, care should be taken
0.000000,0,0.000000,to test via "defined" in boolean validy contexts.
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( defined _NONNEGINT($value) ) {
0.000000,0,0.000000,die "Invalid value";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,The name itself is derived from the XML schema constraint of the same
0.000000,0,0.000000,name.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000059,1,0.000059,eval <<'END_PERL' unless defined &_NONNEGINT;
0.000000,0,0.000000,sub _NONNEGINT ($) {
0.000000,0,0.000000,(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _SCALAR \$scalar
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_SCALAR> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<SCALAR> reference, with content of non-zero length.
0.000000,0,0.000000,
0.000000,0,0.000000,For a version that allows zero length C<SCALAR> references, see
0.000000,0,0.000000,the C<_SCALAR0> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<SCALAR> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not a C<SCALAR> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,eval <<'END_PERL' unless defined &_SCALAR;
0.000000,0,0.000000,sub _SCALAR ($) {
0.000000,0,0.000000,(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _SCALAR0 \$scalar
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_SCALAR0> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<SCALAR0> reference, allowing content of zero-length.
0.000000,0,0.000000,
0.000000,0,0.000000,For a simpler "give me some content" version that requires non-zero
0.000000,0,0.000000,length, C<_SCALAR> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<SCALAR> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not a C<SCALAR> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_SCALAR0;
0.000000,0,0.000000,sub _SCALAR0 ($) {
0.000000,0,0.000000,ref $_[0] eq 'SCALAR' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _ARRAY $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_ARRAY> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<ARRAY> reference containing B<at least> one element of any kind.
0.000000,0,0.000000,
0.000000,0,0.000000,For a more basic form that allows zero length ARRAY references, see
0.000000,0,0.000000,the C<_ARRAY0> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<ARRAY> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not an C<ARRAY> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_ARRAY;
0.000000,0,0.000000,sub _ARRAY ($) {
0.000000,0,0.000000,(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _ARRAY0 $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_ARRAY0> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<ARRAY> reference, allowing C<ARRAY> references that contain no
0.000000,0,0.000000,elements.
0.000000,0,0.000000,
0.000000,0,0.000000,For a more basic "An array of something" form that also requires at
0.000000,0,0.000000,least one element, see the C<_ARRAY> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<ARRAY> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not an C<ARRAY> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_ARRAY0;
0.000000,0,0.000000,sub _ARRAY0 ($) {
0.000000,0,0.000000,ref $_[0] eq 'ARRAY' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _ARRAYLIKE $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
0.000000,0,0.000000,array dereferencing.  If it can, the value is returned.  If it cannot,
0.000000,0,0.000000,C<_ARRAYLIKE> returns C<undef>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_ARRAYLIKE;
0.000000,0,0.000000,sub _ARRAYLIKE {
0.000000,0,0.000000,(defined $_[0] and ref $_[0] and (
0.000000,0,0.000000,(Scalar::Util::reftype($_[0]) eq 'ARRAY')
0.000000,0,0.000000,or
0.000000,0,0.000000,overload::Method($_[0], '@{}')
0.000000,0,0.000000,)) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _HASH $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_HASH> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<HASH> reference with at least one entry.
0.000000,0,0.000000,
0.000000,0,0.000000,For a version of this function that allows the C<HASH> to be empty,
0.000000,0,0.000000,see the C<_HASH0> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<HASH> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not an C<HASH> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_HASH;
0.000000,0,0.000000,sub _HASH ($) {
0.000000,0,0.000000,(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _HASH0 $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_HASH0> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<HASH> reference, regardless of the C<HASH> content.
0.000000,0,0.000000,
0.000000,0,0.000000,For a simpler "A hash of something" version that requires at least one
0.000000,0,0.000000,element, see the C<_HASH> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<HASH> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not an C<HASH> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_HASH0;
0.000000,0,0.000000,sub _HASH0 ($) {
0.000000,0,0.000000,ref $_[0] eq 'HASH' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _HASHLIKE $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_HASHLIKE> function tests whether a given scalar value can respond to
0.000000,0,0.000000,hash dereferencing.  If it can, the value is returned.  If it cannot,
0.000000,0,0.000000,C<_HASHLIKE> returns C<undef>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_HASHLIKE;
0.000000,0,0.000000,sub _HASHLIKE {
0.000000,0,0.000000,(defined $_[0] and ref $_[0] and (
0.000000,0,0.000000,(Scalar::Util::reftype($_[0]) eq 'HASH')
0.000000,0,0.000000,or
0.000000,0,0.000000,overload::Method($_[0], '%{}')
0.000000,0,0.000000,)) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _CODE $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_CODE> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a raw and unblessed
0.000000,0,0.000000,C<CODE> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<CODE> reference itself as a convenience, or C<undef>
0.000000,0,0.000000,if the value provided is not an C<CODE> reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_CODE;
0.000000,0,0.000000,sub _CODE ($) {
0.000000,0,0.000000,ref $_[0] eq 'CODE' ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _CODELIKE $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
0.000000,0,0.000000,which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
0.000000,0,0.000000,also includes things that act like them, such as blessed objects that
0.000000,0,0.000000,overload C<'&{}'>.
0.000000,0,0.000000,
0.000000,0,0.000000,Please note that in the case of objects overloaded with '&{}', you will
0.000000,0,0.000000,almost always end up also testing it in 'bool' context at some stage.
0.000000,0,0.000000,
0.000000,0,0.000000,For example:
0.000000,0,0.000000,
0.000000,0,0.000000,sub foo {
0.000000,0,0.000000,my $code1 = _CODELIKE(shift) or die "No code param provided";
0.000000,0,0.000000,my $code2 = _CODELIKE(shift);
0.000000,0,0.000000,if ( $code2 ) {
0.000000,0,0.000000,print "Got optional second code param";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,As such, you will most likely always want to make sure your class has
0.000000,0,0.000000,at least the following to allow it to evaluate to true in boolean
0.000000,0,0.000000,context.
0.000000,0,0.000000,
0.000000,0,0.000000,# Always evaluate to true in boolean context
0.000000,0,0.000000,use overload 'bool' => sub () { 1 };
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the callable value as a convenience, or C<undef> if the
0.000000,0,0.000000,value provided is not callable.
0.000000,0,0.000000,
0.000000,0,0.000000,Note - This function was formerly known as _CALLABLE but has been renamed
0.000000,0,0.000000,for greater symmetry with the other _XXXXLIKE functions.
0.000000,0,0.000000,
0.000000,0,0.000000,The use of _CALLABLE has been deprecated. It will continue to work, but
0.000000,0,0.000000,with a warning, until end-2006, then will be removed.
0.000000,0,0.000000,
0.000000,0,0.000000,I apologise for any inconvenience caused.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000001,1,0.000001,eval <<'END_PERL' unless defined &_CODELIKE;
0.000000,0,0.000000,sub _CODELIKE($) {
0.000000,0,0.000000,(
0.000000,0,0.000000,(Scalar::Util::reftype($_[0])||'') eq 'CODE'
0.000000,0,0.000000,or
0.000000,0,0.000000,Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
0.000000,0,0.000000,)
0.000000,0,0.000000,? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _INVOCANT $value
0.000000,0,0.000000,
0.000000,0,0.000000,This routine tests whether the given value is a valid method invocant.
0.000000,0,0.000000,This can be either an instance of an object, or a class name.
0.000000,0,0.000000,
0.000000,0,0.000000,If so, the value itself is returned.  Otherwise, C<_INVOCANT>
0.000000,0,0.000000,returns C<undef>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000051,1,0.000051,eval <<'END_PERL' unless defined &_INVOCANT;
0.000000,0,0.000000,sub _INVOCANT($) {
0.000000,0,0.000000,(defined $_[0] and
0.000000,0,0.000000,(defined Scalar::Util::blessed($_[0])
0.000000,0,0.000000,or      
0.000000,0,0.000000,# We used to check for stash definedness, but any class-like name is a
0.000000,0,0.000000,# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
0.000000,0,0.000000,Params::Util::_CLASS($_[0]))
0.000000,0,0.000000,) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _INSTANCE $object, $class
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_INSTANCE> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for an object of a particular class
0.000000,0,0.000000,in a strictly correct manner.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the object itself as a convenience, or C<undef> if the value
0.000000,0,0.000000,provided is not an object of that type.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,eval <<'END_PERL' unless defined &_INSTANCE;
0.000000,0,0.000000,sub _INSTANCE ($$) {
0.000000,0,0.000000,(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _INSTANCEDOES $object, $role
0.000000,0,0.000000,
0.000000,0,0.000000,This routine behaves exactly like C<L</_INSTANCE>>, but checks with C<< ->DOES
0.000000,0,0.000000,>> rather than C<< ->isa >>.  This is probably only a good idea to use on Perl
0.000000,0,0.000000,5.10 or later, when L<UNIVERSAL::DOES|UNIVERSAL::DOES/DOES> has been
0.000000,0,0.000000,implemented.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000046,1,0.000046,eval <<'END_PERL' unless defined &_INSTANCEDOES;
0.000000,0,0.000000,sub _INSTANCEDOES ($$) {
0.000000,0,0.000000,(Scalar::Util::blessed($_[0]) and $_[0]->DOES($_[1])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _REGEX $value
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_REGEX> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a regular expression.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the value itself as a convenience, or C<undef> if the value
0.000000,0,0.000000,provided is not a regular expression.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,eval <<'END_PERL' unless defined &_REGEX;
0.000000,0,0.000000,sub _REGEX ($) {
0.000000,0,0.000000,(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _SET \@array, $class
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_SET> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for set of at least one object of
0.000000,0,0.000000,a particular class in a strictly correct manner.
0.000000,0,0.000000,
0.000000,0,0.000000,The set is provided as a reference to an C<ARRAY> of objects of the
0.000000,0,0.000000,class provided.
0.000000,0,0.000000,
0.000000,0,0.000000,For an alternative function that allows zero-length sets, see the
0.000000,0,0.000000,C<_SET0> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
0.000000,0,0.000000,the value provided is not a set of that class.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000061,1,0.000061,eval <<'END_PERL' unless defined &_SET;
0.000000,0,0.000000,sub _SET ($$) {
0.000000,0,0.000000,my $set = shift;
0.000000,0,0.000000,_ARRAY($set) or return undef;
0.000000,0,0.000000,foreach my $item ( @$set ) {
0.000000,0,0.000000,_INSTANCE($item,$_[0]) or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,$set;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _SET0 \@array, $class
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_SET0> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test for a set of objects of a
0.000000,0,0.000000,particular class in a strictly correct manner, allowing for zero objects.
0.000000,0,0.000000,
0.000000,0,0.000000,The set is provided as a reference to an C<ARRAY> of objects of the
0.000000,0,0.000000,class provided.
0.000000,0,0.000000,
0.000000,0,0.000000,For an alternative function that requires at least one object, see the
0.000000,0,0.000000,C<_SET> function.
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
0.000000,0,0.000000,the value provided is not a set of that class.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000058,1,0.000058,eval <<'END_PERL' unless defined &_SET0;
0.000000,0,0.000000,sub _SET0 ($$) {
0.000000,0,0.000000,my $set = shift;
0.000000,0,0.000000,_ARRAY0($set) or return undef;
0.000000,0,0.000000,foreach my $item ( @$set ) {
0.000000,0,0.000000,_INSTANCE($item,$_[0]) or return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,$set;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _HANDLE
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_HANDLE> function is intended to be imported into your package,
0.000000,0,0.000000,and provides a convenient way to test whether or not a single scalar
0.000000,0,0.000000,value is a file handle.
0.000000,0,0.000000,
0.000000,0,0.000000,Unfortunately, in Perl the definition of a file handle can be a little
0.000000,0,0.000000,bit fuzzy, so this function is likely to be somewhat imperfect (at first
0.000000,0,0.000000,anyway).
0.000000,0,0.000000,
0.000000,0,0.000000,That said, it is implement as well or better than the other file handle
0.000000,0,0.000000,detectors in existance (and we stole from the best of them).
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,# We're doing this longhand for now. Once everything is perfect,
0.000000,0,0.000000,# we'll compress this into something that compiles more efficiently.
0.000000,0,0.000000,# Further, testing file handles is not something that is generally
0.000000,0,0.000000,# done millions of times, so doing it slowly is not a big speed hit.
0.000120,1,0.000120,eval <<'END_PERL' unless defined &_HANDLE;
0.000000,0,0.000000,sub _HANDLE {
0.000000,0,0.000000,my $it = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# It has to be defined, of course
0.000000,0,0.000000,unless ( defined $it ) {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Normal globs are considered to be file handles
0.000000,0,0.000000,if ( ref $it eq 'GLOB' ) {
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for a normal tied filehandle
0.000000,0,0.000000,# Side Note: 5.5.4's tied() and can() doesn't like getting undef
0.000000,0,0.000000,if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# There are no other non-object handles that we support
0.000000,0,0.000000,unless ( Scalar::Util::blessed($it) ) {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for a common base classes for conventional IO::Handle object
0.000000,0,0.000000,if ( $it->isa('IO::Handle') ) {
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for tied file handles using Tie::Handle
0.000000,0,0.000000,if ( $it->isa('Tie::Handle') ) {
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# IO::Scalar is not a proper seekable, but it is valid is a
0.000000,0,0.000000,# regular file handle
0.000000,0,0.000000,if ( $it->isa('IO::Scalar') ) {
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Yet another special case for IO::String, which refuses (for now
0.000000,0,0.000000,# anyway) to become a subclass of IO::Handle.
0.000000,0,0.000000,if ( $it->isa('IO::String') ) {
0.000000,0,0.000000,return $it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is not any sort of object we know about
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 _DRIVER $string
0.000000,0,0.000000,
0.000000,0,0.000000,sub foo {
0.000000,0,0.000000,my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,The C<_DRIVER> function is intended to be imported into your
0.000000,0,0.000000,package, and provides a convenient way to load and validate
0.000000,0,0.000000,a driver class.
0.000000,0,0.000000,
0.000000,0,0.000000,The most common pattern when taking a driver class as a parameter
0.000000,0,0.000000,is to check that the name is a class (i.e. check against _CLASS)
0.000000,0,0.000000,and then to load the class (if it exists) and then ensure that
0.000000,0,0.000000,the class returns true for the isa method on some base driver name.
0.000000,0,0.000000,
0.000000,0,0.000000,Return the value as a convenience, or C<undef> if the value is not
0.000000,0,0.000000,a class name, the module does not exist, the module does not load,
0.000000,0,0.000000,or the class fails the isa test.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000070,1,0.000070,eval <<'END_PERL' unless defined &_DRIVER;
0.000000,0,0.000000,sub _DRIVER ($$) {
0.000000,0,0.000000,(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,END_PERL
0.000000,0,0.000000,
0.000020,1,0.000020,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=pod
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 TO DO
0.000000,0,0.000000,
0.000000,0,0.000000,- Add _CAN to help resolve the UNIVERSAL::can debacle
0.000000,0,0.000000,
0.000000,0,0.000000,- Would be even nicer if someone would demonstrate how the hell to
0.000000,0,0.000000,build a Module::Install dist of the ::Util dual Perl/XS type. :/
0.000000,0,0.000000,
0.000000,0,0.000000,- Implement an assertion-like version of this module, that dies on
0.000000,0,0.000000,error.
0.000000,0,0.000000,
0.000000,0,0.000000,- Implement a Test:: version of this module, for use in testing
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,Bugs should be reported via the CPAN bug tracker at
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
0.000000,0,0.000000,
0.000000,0,0.000000,For other issues, contact the author.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Adam Kennedy E<lt>adamk@cpan.orgE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Params::Validate>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2005 - 2012 Adam Kennedy.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute
0.000000,0,0.000000,it and/or modify it under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,The full text of the license can be found in the
0.000000,0,0.000000,LICENSE file included with this module.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
