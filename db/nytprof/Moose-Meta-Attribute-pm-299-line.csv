# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Meta::Attribute;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::Attribute::AUTHORITY = 'cpan:STEVAN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::Attribute::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000037,2,0.000019,use warnings;
0.000000,0,0.000000,
0.000221,2,0.000110,use B ();
0.000039,2,0.000019,use Class::Load qw(is_class_loaded load_class);
0.000036,2,0.000018,use Scalar::Util 'blessed', 'weaken';
0.000035,2,0.000018,use List::MoreUtils 'any';
0.000034,2,0.000017,use Try::Tiny;
0.000029,2,0.000014,use overload     ();
0.000000,0,0.000000,
0.000034,2,0.000017,use Moose::Deprecated;
0.000119,2,0.000060,use Moose::Meta::Method::Accessor;
0.000110,2,0.000055,use Moose::Meta::Method::Delegation;
0.000029,2,0.000014,use Moose::Util ();
0.000123,2,0.000062,use Moose::Util::TypeConstraints ();
0.000037,2,0.000018,use Class::MOP::MiniTrait;
0.000000,0,0.000000,
0.005227,2,0.002613,use base 'Class::MOP::Attribute', 'Moose::Meta::Mixin::AttributeCore';
0.000000,0,0.000000,
0.000006,1,0.000006,Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
0.000000,0,0.000000,
0.000018,1,0.000018,__PACKAGE__->meta->add_attribute('traits' => (
0.000000,0,0.000000,reader    => 'applied_traits',
0.000000,0,0.000000,predicate => 'has_applied_traits',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,# we need to have a ->does method in here to
0.000000,0,0.000000,# more easily support traits, and the introspection
0.000000,0,0.000000,# of those traits. We extend the does check to look
0.000000,0,0.000000,# for metatrait aliases.
0.000000,0,0.000000,sub does {
0.000000,0,0.000000,my ($self, $role_name) = @_;
0.000000,0,0.000000,my $name = try {
0.000000,0,0.000000,Moose::Util::resolve_metatrait_alias(Attribute => $role_name)
0.000000,0,0.000000,};
0.000000,0,0.000000,return 0 if !defined($name); # failed to load class
0.000000,0,0.000000,return $self->Moose::Object::does($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _error_thrower {
0.000038,25,0.000002,my $self = shift;
0.000048,25,0.000002,require Moose::Meta::Class;
0.000266,25,0.000011,( ref $self && $self->associated_class ) || "Moose::Meta::Class";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub throw_error {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $inv = $self->_error_thrower;
0.000000,0,0.000000,unshift @_, "message" if @_ % 2 == 1;
0.000000,0,0.000000,unshift @_, attr => $self if ref $self;
0.000000,0,0.000000,unshift @_, $inv;
0.000000,0,0.000000,my $handler = $inv->can("throw_error"); # to avoid incrementing depth by 1
0.000000,0,0.000000,goto $handler;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_throw_error {
0.000050,25,0.000002,my ( $self, $msg, $args ) = @_;
0.000000,0,0.000000,
0.000129,25,0.000005,my $inv = $self->_error_thrower;
0.000000,0,0.000000,# XXX ugh
0.000192,25,0.000008,$inv = 'Moose::Meta::Class' unless $inv->can('_inline_throw_error');
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX ugh ugh UGH
0.000199,25,0.000008,my $class = $self->associated_class;
0.000073,25,0.000003,if ($class) {
0.000321,25,0.000013,my $class_name = B::perlstring($class->name);
0.000295,25,0.000012,my $attr_name = B::perlstring($self->name);
0.000076,25,0.000003,$args = 'attr => Class::MOP::class_of(' . $class_name . ')'
0.000000,0,0.000000,. '->find_attribute_by_name(' . $attr_name . '), '
0.000000,0,0.000000,. (defined $args ? $args : '');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000223,25,0.000009,return $inv->_inline_throw_error($msg, $args)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000029,9,0.000003,my ($class, $name, %options) = @_;
0.000056,9,0.000006,$class->_process_options($name, \%options) unless $options{__hack_no_process_options}; # used from clone()... YECHKKK FIXME ICKY YUCK GROSS
0.000000,0,0.000000,
0.000018,9,0.000002,delete $options{__hack_no_process_options};
0.000000,0,0.000000,
0.000000,0,0.000000,my %attrs =
0.000000,0,0.000000,( map { $_ => 1 }
0.001698,252,0.000007,grep { defined }
0.000690,9,0.000077,map { $_->init_arg() }
0.000000,0,0.000000,$class->meta()->get_all_attributes()
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000094,9,0.000010,my @bad = sort grep { ! $attrs{$_} }  keys %options;
0.000000,0,0.000000,
0.000015,9,0.000002,if (@bad)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $s = @bad > 1 ? 's' : '';
0.000000,0,0.000000,my $list = join "', '", @bad;
0.000000,0,0.000000,
0.000000,0,0.000000,my $package = $options{definition_context}{package};
0.000000,0,0.000000,my $context = $options{definition_context}{context}
0.000000,0,0.000000,|| 'attribute constructor';
0.000000,0,0.000000,my $type = $options{definition_context}{type} || 'class';
0.000000,0,0.000000,
0.000000,0,0.000000,my $location = '';
0.000000,0,0.000000,if (defined($package)) {
0.000000,0,0.000000,$location = " in ";
0.000000,0,0.000000,$location .= "$type " if $type;
0.000000,0,0.000000,$location .= $package;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::cluck "Found unknown argument$s '$list' in the $context for '$name'$location";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000126,9,0.000014,return $class->SUPER::new($name, %options);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub interpolate_class_and_new {
0.000028,8,0.000004,my ($class, $name, %args) = @_;
0.000000,0,0.000000,
0.000051,8,0.000006,my ( $new_class, @traits ) = $class->interpolate_class(\%args);
0.000000,0,0.000000,
0.000090,8,0.000011,$new_class->new($name, %args, ( scalar(@traits) ? ( traits => \@traits ) : () ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub interpolate_class {
0.000015,8,0.000002,my ($class, $options) = @_;
0.000000,0,0.000000,
0.000013,8,0.000002,$class = ref($class) || $class;
0.000000,0,0.000000,
0.000016,8,0.000002,if ( my $metaclass_name = delete $options->{metaclass} ) {
0.000000,0,0.000000,my $new_class = Moose::Util::resolve_metaclass_alias( Attribute => $metaclass_name );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $class ne $new_class ) {
0.000000,0,0.000000,if ( $new_class->can("interpolate_class") ) {
0.000000,0,0.000000,return $new_class->interpolate_class($options);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$class = $new_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,8,0.000002,my @traits;
0.000000,0,0.000000,
0.000015,8,0.000002,if (my $traits = $options->{traits}) {
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,my $has_foreign_options = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,while ($i < @$traits) {
0.000000,0,0.000000,my $trait = $traits->[$i++];
0.000000,0,0.000000,next if ref($trait); # options to a trait we discarded
0.000000,0,0.000000,
0.000000,0,0.000000,$trait = Moose::Util::resolve_metatrait_alias(Attribute => $trait)
0.000000,0,0.000000,|| $trait;
0.000000,0,0.000000,
0.000000,0,0.000000,next if $class->does($trait);
0.000000,0,0.000000,
0.000000,0,0.000000,push @traits, $trait;
0.000000,0,0.000000,
0.000000,0,0.000000,# are there options?
0.000000,0,0.000000,if ($traits->[$i] && ref($traits->[$i])) {
0.000000,0,0.000000,$has_foreign_options = 1
0.000000,0,0.000000,if any { $_ ne '-alias' && $_ ne '-excludes' } keys %{ $traits->[$i] };
0.000000,0,0.000000,
0.000000,0,0.000000,push @traits, $traits->[$i++];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (@traits) {
0.000000,0,0.000000,my %options = (
0.000000,0,0.000000,superclasses => [ $class ],
0.000000,0,0.000000,roles        => [ @traits ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($has_foreign_options) {
0.000000,0,0.000000,$options{weaken} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$options{cache} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $anon_class = Moose::Meta::Class->create_anon_class(%options);
0.000000,0,0.000000,$class = $anon_class->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000054,8,0.000007,return ( wantarray ? ( $class, @traits ) : $class );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# ...
0.000000,0,0.000000,
0.000000,0,0.000000,# method-generating options shouldn't be overridden
0.000000,0,0.000000,sub illegal_options_for_inheritance {
0.000000,0,0.000000,qw(reader writer accessor clearer predicate)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE/TODO
0.000000,0,0.000000,# This method *must* be able to handle
0.000000,0,0.000000,# Class::MOP::Attribute instances as
0.000000,0,0.000000,# well. Yes, I know that is wrong, but
0.000000,0,0.000000,# apparently we didn't realize it was
0.000000,0,0.000000,# doing that and now we have some code
0.000000,0,0.000000,# which is dependent on it. The real
0.000000,0,0.000000,# solution of course is to push this
0.000000,0,0.000000,# feature back up into Class::MOP::Attribute
0.000000,0,0.000000,# but I not right now, I am too lazy.
0.000000,0,0.000000,# However if you are reading this and
0.000000,0,0.000000,# looking for something to do,.. please
0.000000,0,0.000000,# be my guest.
0.000000,0,0.000000,# - stevan
0.000000,0,0.000000,sub clone_and_inherit_options {
0.000000,0,0.000000,my ($self, %options) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we may want to extends a Class::MOP::Attribute
0.000000,0,0.000000,# in which case we need to be able to use the
0.000000,0,0.000000,# core set of legal options that have always
0.000000,0,0.000000,# been here. But we allows Moose::Meta::Attribute
0.000000,0,0.000000,# instances to changes them.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,my @illegal_options = $self->can('illegal_options_for_inheritance')
0.000000,0,0.000000,? $self->illegal_options_for_inheritance
0.000000,0,0.000000,: ();
0.000000,0,0.000000,
0.000000,0,0.000000,my @found_illegal_options = grep { exists $options{$_} && exists $self->{$_} ? $_ : undef } @illegal_options;
0.000000,0,0.000000,(scalar @found_illegal_options == 0)
0.000000,0,0.000000,|| $self->throw_error("Illegal inherited options => (" . (join ', ' => @found_illegal_options) . ")", data => \%options);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_process_isa_option( $self->name, \%options );
0.000000,0,0.000000,$self->_process_does_option( $self->name, \%options );
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# this doesn't apply to Class::MOP::Attributes,
0.000000,0,0.000000,# so we can ignore it for them.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,if ($self->can('interpolate_class')) {
0.000000,0,0.000000,( $options{metaclass}, my @traits ) = $self->interpolate_class(\%options);
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,my @all_traits = grep { $seen{$_}++ } @{ $self->applied_traits || [] }, @traits;
0.000000,0,0.000000,$options{traits} = \@all_traits if @all_traits;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This method can be called on a CMOP::Attribute object, so we need to
0.000000,0,0.000000,# make sure we can call this method.
0.000000,0,0.000000,$self->_process_lazy_build_option( $self->name, \%options )
0.000000,0,0.000000,if $self->can('_process_lazy_build_option');
0.000000,0,0.000000,
0.000000,0,0.000000,$self->clone(%options);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ( $self, %params ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = delete $params{metaclass} || ref $self;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( @init, @non_init );
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attr ( grep { $_->has_value($self) } Class::MOP::class_of($self)->get_all_attributes ) {
0.000000,0,0.000000,push @{ $attr->has_init_arg ? \@init : \@non_init }, $attr;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %new_params = ( ( map { $_->init_arg => $_->get_value($self) } @init ), %params );
0.000000,0,0.000000,
0.000000,0,0.000000,my $name = delete $new_params{name};
0.000000,0,0.000000,
0.000000,0,0.000000,my $clone = $class->new($name, %new_params, __hack_no_process_options => 1 );
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attr ( @non_init ) {
0.000000,0,0.000000,$attr->set_value($clone, $attr->get_value($self));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $clone;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_options {
0.000017,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000054,9,0.000006,$class->_process_is_option( $name, $options );
0.000055,9,0.000006,$class->_process_isa_option( $name, $options );
0.000052,9,0.000006,$class->_process_does_option( $name, $options );
0.000051,9,0.000006,$class->_process_coerce_option( $name, $options );
0.000049,9,0.000005,$class->_process_trigger_option( $name, $options );
0.000054,9,0.000006,$class->_process_auto_deref_option( $name, $options );
0.000049,9,0.000005,$class->_process_lazy_build_option( $name, $options );
0.000049,9,0.000005,$class->_process_lazy_option( $name, $options );
0.000086,9,0.000010,$class->_process_required_option( $name, $options );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_is_option {
0.000016,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000020,9,0.000002,return unless $options->{is};
0.000000,0,0.000000,
0.000000,0,0.000000,### -------------------------
0.000000,0,0.000000,## is => ro, writer => _foo    # turns into (reader => foo, writer => _foo) as before
0.000000,0,0.000000,## is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
0.000000,0,0.000000,## is => rw, accessor => _foo  # turns into (accessor => _foo)
0.000000,0,0.000000,## is => ro, accessor => _foo  # error, accesor is rw
0.000000,0,0.000000,### -------------------------
0.000000,0,0.000000,
0.000063,8,0.000008,if ( $options->{is} eq 'ro' ) {
0.000015,8,0.000002,$class->throw_error(
0.000000,0,0.000000,"Cannot define an accessor name on a read-only attribute, accessors are read/write",
0.000000,0,0.000000,data => $options )
0.000000,0,0.000000,if exists $options->{accessor};
0.000018,8,0.000002,$options->{reader} ||= $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $options->{is} eq 'rw' ) {
0.000000,0,0.000000,if ( $options->{writer} ) {
0.000000,0,0.000000,$options->{reader} ||= $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$options->{accessor} ||= $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $options->{is} eq 'bare' ) {
0.000000,0,0.000000,return;
0.000000,0,0.000000,# do nothing, but don't complain (later) about missing methods
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$class->throw_error( "I do not understand this option (is => "
0.000000,0,0.000000,. $options->{is}
0.000000,0,0.000000,. ") on attribute ($name)", data => $options->{is} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_isa_option {
0.000016,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000022,9,0.000002,return unless exists $options->{isa};
0.000000,0,0.000000,
0.000013,8,0.000002,if ( exists $options->{does} ) {
0.000000,0,0.000000,if ( try { $options->{isa}->can('does') } ) {
0.000000,0,0.000000,( $options->{isa}->does( $options->{does} ) )
0.000000,0,0.000000,|| $class->throw_error(
0.000000,0,0.000000,"Cannot have an isa option and a does option if the isa does not do the does on attribute ($name)",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$class->throw_error(
0.000000,0,0.000000,"Cannot have an isa option which cannot ->does() on attribute ($name)",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# allow for anon-subtypes here ...
0.000000,0,0.000000,#
0.000000,0,0.000000,# Checking for Specio explicitly is completely revolting. At some point
0.000000,0,0.000000,# this needs to be refactored so that Moose core defines a standard type
0.000000,0,0.000000,# API that all types must implement. Unfortunately, the current core API
0.000000,0,0.000000,# is _not_ the right API, so we probably need to A) come up with the new
0.000000,0,0.000000,# API (Specio is a good start); B) refactor the core types to implement
0.000000,0,0.000000,# that API; C) do duck type checking on type objects.
0.000140,8,0.000017,if ( blessed( $options->{isa} )
0.000000,0,0.000000,&& $options->{isa}->isa('Moose::Meta::TypeConstraint') ) {
0.000000,0,0.000000,$options->{type_constraint} = $options->{isa};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (
0.000000,0,0.000000,blessed( $options->{isa} )
0.000000,0,0.000000,&& Moose::Util::does_role(
0.000000,0,0.000000,$options->{isa}, 'Specio::Constraint::Role::Interface'
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$options->{type_constraint} = $options->{isa};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000051,6,0.000008,$options->{type_constraint}
0.000000,0,0.000000,= Moose::Util::TypeConstraints::find_or_create_isa_type_constraint(
0.000000,0,0.000000,$options->{isa},
0.000000,0,0.000000,{ package_defined_in => $options->{definition_context}->{package} }
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_does_option {
0.000017,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000055,9,0.000006,return unless exists $options->{does} && ! exists $options->{isa};
0.000000,0,0.000000,
0.000000,0,0.000000,# allow for anon-subtypes here ...
0.000000,0,0.000000,if ( blessed( $options->{does} )
0.000000,0,0.000000,&& $options->{does}->isa('Moose::Meta::TypeConstraint') ) {
0.000000,0,0.000000,$options->{type_constraint} = $options->{does};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$options->{type_constraint}
0.000000,0,0.000000,= Moose::Util::TypeConstraints::find_or_create_does_type_constraint(
0.000000,0,0.000000,$options->{does},
0.000000,0,0.000000,{ package_defined_in => $options->{definition_context}->{package} }
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_coerce_option {
0.000017,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000048,9,0.000005,return unless $options->{coerce};
0.000000,0,0.000000,
0.000000,0,0.000000,( exists $options->{type_constraint} )
0.000000,0,0.000000,|| $class->throw_error(
0.000000,0,0.000000,"You cannot have coercion without specifying a type constraint on attribute ($name)",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,
0.000000,0,0.000000,$class->throw_error(
0.000000,0,0.000000,"You cannot have a weak reference to a coerced value on attribute ($name)",
0.000000,0,0.000000,data => $options )
0.000000,0,0.000000,if $options->{weak_ref};
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $options->{type_constraint}->has_coercion ) {
0.000000,0,0.000000,my $type = $options->{type_constraint}->name;
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Deprecated::deprecated(
0.000000,0,0.000000,feature => 'coerce without coercion',
0.000000,0,0.000000,message =>
0.000000,0,0.000000,"You cannot coerce an attribute ($name) unless its type ($type) has a coercion"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_trigger_option {
0.000018,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000051,9,0.000006,return unless exists $options->{trigger};
0.000000,0,0.000000,
0.000000,0,0.000000,( 'CODE' eq ref $options->{trigger} )
0.000000,0,0.000000,|| $class->throw_error("Trigger must be a CODE ref on attribute ($name)", data => $options->{trigger});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_auto_deref_option {
0.000016,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000049,9,0.000005,return unless $options->{auto_deref};
0.000000,0,0.000000,
0.000000,0,0.000000,( exists $options->{type_constraint} )
0.000000,0,0.000000,|| $class->throw_error(
0.000000,0,0.000000,"You cannot auto-dereference without specifying a type constraint on attribute ($name)",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,
0.000000,0,0.000000,( $options->{type_constraint}->is_a_type_of('ArrayRef')
0.000000,0,0.000000,|| $options->{type_constraint}->is_a_type_of('HashRef') )
0.000000,0,0.000000,|| $class->throw_error(
0.000000,0,0.000000,"You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute ($name)",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_lazy_build_option {
0.000016,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000048,9,0.000005,return unless $options->{lazy_build};
0.000000,0,0.000000,
0.000000,0,0.000000,$class->throw_error(
0.000000,0,0.000000,"You can not use lazy_build and default for the same attribute ($name)",
0.000000,0,0.000000,data => $options )
0.000000,0,0.000000,if exists $options->{default};
0.000000,0,0.000000,
0.000000,0,0.000000,$options->{lazy} = 1;
0.000000,0,0.000000,$options->{builder} ||= "_build_${name}";
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $name =~ /^_/ ) {
0.000000,0,0.000000,$options->{clearer}   ||= "_clear${name}";
0.000000,0,0.000000,$options->{predicate} ||= "_has${name}";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$options->{clearer}   ||= "clear_${name}";
0.000000,0,0.000000,$options->{predicate} ||= "has_${name}";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_lazy_option {
0.000016,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000041,9,0.000005,return unless $options->{lazy};
0.000000,0,0.000000,
0.000011,2,0.000005,( exists $options->{default} || defined $options->{builder} )
0.000000,0,0.000000,|| $class->throw_error(
0.000000,0,0.000000,"You cannot have a lazy attribute ($name) without specifying a default value for it",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_required_option {
0.000017,9,0.000002,my ( $class, $name, $options ) = @_;
0.000000,0,0.000000,
0.000048,9,0.000005,if (
0.000000,0,0.000000,$options->{required}
0.000000,0,0.000000,&& !(
0.000000,0,0.000000,( !exists $options->{init_arg} || defined $options->{init_arg} )
0.000000,0,0.000000,|| exists $options->{default}
0.000000,0,0.000000,|| defined $options->{builder}
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$class->throw_error(
0.000000,0,0.000000,"You cannot have a required attribute ($name) without a default, builder, or an init_arg",
0.000000,0,0.000000,data => $options );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub initialize_instance_slot {
0.000000,0,0.000000,my ($self, $meta_instance, $instance, $params) = @_;
0.000000,0,0.000000,my $init_arg = $self->init_arg();
0.000000,0,0.000000,# try to fetch the init arg from the %params ...
0.000000,0,0.000000,
0.000000,0,0.000000,my $val;
0.000000,0,0.000000,my $value_is_set;
0.000000,0,0.000000,if ( defined($init_arg) and exists $params->{$init_arg}) {
0.000000,0,0.000000,$val = $params->{$init_arg};
0.000000,0,0.000000,$value_is_set = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# skip it if it's lazy
0.000000,0,0.000000,return if $self->is_lazy;
0.000000,0,0.000000,# and die if it's required and doesn't have a default value
0.000000,0,0.000000,$self->throw_error("Attribute (" . $self->name . ") is required", object => $instance, data => $params)
0.000000,0,0.000000,if $self->is_required && !$self->has_default && !$self->has_builder;
0.000000,0,0.000000,
0.000000,0,0.000000,# if nothing was in the %params, we can use the
0.000000,0,0.000000,# attribute's default value (if it has one)
0.000000,0,0.000000,if ($self->has_default) {
0.000000,0,0.000000,$val = $self->default($instance);
0.000000,0,0.000000,$value_is_set = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->has_builder) {
0.000000,0,0.000000,$val = $self->_call_builder($instance);
0.000000,0,0.000000,$value_is_set = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $value_is_set;
0.000000,0,0.000000,
0.000000,0,0.000000,$val = $self->_coerce_and_verify( $val, $instance );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->set_initial_value($instance, $val);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref $val && $self->is_weak_ref ) {
0.000000,0,0.000000,$self->_weaken_value($instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _call_builder {
0.000000,0,0.000000,my ( $self, $instance ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $builder = $self->builder();
0.000000,0,0.000000,
0.000000,0,0.000000,return $instance->$builder()
0.000000,0,0.000000,if $instance->can( $self->builder );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->throw_error(  blessed($instance)
0.000000,0,0.000000,. " does not support builder method '"
0.000000,0,0.000000,. $self->builder
0.000000,0,0.000000,. "' for attribute '"
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. "'",
0.000000,0,0.000000,object => $instance,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Slot management
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_initializer_writer_callback {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($meta_instance, $instance, $slot_name) = @_;
0.000000,0,0.000000,my $old_callback = $self->SUPER::_make_initializer_writer_callback(@_);
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,$old_callback->($self->_coerce_and_verify($_[0], $instance));
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_value {
0.000000,0,0.000000,my ($self, $instance, @args) = @_;
0.000000,0,0.000000,my $value = $args[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my $attr_name = quotemeta($self->name);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_required and not @args) {
0.000000,0,0.000000,$self->throw_error("Attribute ($attr_name) is required", object => $instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$value = $self->_coerce_and_verify( $value, $instance );
0.000000,0,0.000000,
0.000000,0,0.000000,my @old;
0.000000,0,0.000000,if ( $self->has_trigger && $self->has_value($instance) ) {
0.000000,0,0.000000,@old = $self->get_value($instance, 'for trigger');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::set_value($instance, $value);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref $value && $self->is_weak_ref ) {
0.000000,0,0.000000,$self->_weaken_value($instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->has_trigger) {
0.000000,0,0.000000,$self->trigger->($instance, $value, @old);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_set_value {
0.000021,14,0.000001,my $self = shift;
0.000028,14,0.000002,my ($instance, $value, $tc, $coercion, $message, $for_constructor) = @_;
0.000000,0,0.000000,
0.000021,14,0.000002,my $old     = '@old';
0.000020,14,0.000001,my $copy    = '$val';
0.000020,14,0.000001,$tc       ||= '$type_constraint';
0.000019,14,0.000001,$coercion ||= '$type_coercion';
0.000019,14,0.000001,$message  ||= '$type_message';
0.000000,0,0.000000,
0.000019,14,0.000001,my @code;
0.000069,14,0.000005,if ($self->_writer_value_needs_copy) {
0.000000,0,0.000000,push @code, $self->_inline_copy_value($value, $copy);
0.000000,0,0.000000,$value = $copy;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# constructors already handle required checks
0.000029,14,0.000002,push @code, $self->_inline_check_required
0.000000,0,0.000000,unless $for_constructor;
0.000000,0,0.000000,
0.000092,14,0.000007,push @code, $self->_inline_tc_code($value, $tc, $coercion, $message);
0.000000,0,0.000000,
0.000000,0,0.000000,# constructors do triggers all at once at the end
0.000029,14,0.000002,push @code, $self->_inline_get_old_value_for_trigger($instance, $old)
0.000000,0,0.000000,unless $for_constructor;
0.000000,0,0.000000,
0.000144,14,0.000010,push @code, (
0.000000,0,0.000000,$self->SUPER::_inline_set_value($instance, $value),
0.000000,0,0.000000,$self->_inline_weaken_value($instance, $value),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# constructors do triggers all at once at the end
0.000029,14,0.000002,push @code, $self->_inline_trigger($instance, $value, $old)
0.000000,0,0.000000,unless $for_constructor;
0.000000,0,0.000000,
0.000110,14,0.000008,return @code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _writer_value_needs_copy {
0.000020,14,0.000001,my $self = shift;
0.000123,14,0.000009,return $self->should_coerce;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_copy_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($value, $copy) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return 'my ' . $copy . ' = ' . $value . ';'
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check_required {
0.000003,2,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000024,2,0.000012,return unless $self->is_required;
0.000000,0,0.000000,
0.000000,0,0.000000,my $attr_name = quotemeta($self->name);
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,'if (@_ < 2) {',
0.000000,0,0.000000,$self->_inline_throw_error(
0.000000,0,0.000000,'"Attribute (' . $attr_name . ') is required"'
0.000000,0,0.000000,) . ';',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_tc_code {
0.000021,14,0.000001,my $self = shift;
0.000027,14,0.000002,my ($value, $tc, $coercion, $message, $is_lazy) = @_;
0.000000,0,0.000000,return (
0.000166,14,0.000012,$self->_inline_check_coercion(
0.000000,0,0.000000,$value, $tc, $coercion, $is_lazy,
0.000000,0,0.000000,),
0.000000,0,0.000000,$self->_inline_check_constraint(
0.000000,0,0.000000,$value, $tc, $message, $is_lazy,
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check_coercion {
0.000032,16,0.000002,my $self = shift;
0.000028,16,0.000002,my ($value, $tc, $coercion) = @_;
0.000000,0,0.000000,
0.000145,16,0.000009,return unless $self->should_coerce && $self->type_constraint->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->type_constraint->can_be_inlined ) {
0.000000,0,0.000000,return (
0.000000,0,0.000000,'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
0.000000,0,0.000000,$value . ' = ' . $coercion . '->(' . $value . ');',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return (
0.000000,0,0.000000,'if (!' . $tc . '->(' . $value . ')) {',
0.000000,0,0.000000,$value . ' = ' . $coercion . '->(' . $value . ');',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check_constraint {
0.000025,16,0.000002,my $self = shift;
0.000029,16,0.000002,my ($value, $tc, $message) = @_;
0.000000,0,0.000000,
0.000087,16,0.000005,return unless $self->has_type_constraint;
0.000000,0,0.000000,
0.000103,14,0.000007,my $attr_name = quotemeta($self->name);
0.000000,0,0.000000,
0.000380,14,0.000027,if ( $self->type_constraint->can_be_inlined ) {
0.000000,0,0.000000,return (
0.000000,0,0.000000,'if (! (' . $self->type_constraint->_inline_check($value) . ')) {',
0.000000,0,0.000000,$self->_inline_throw_error(
0.000000,0,0.000000,'"Attribute (' . $attr_name . ') does not pass the type '
0.000000,0,0.000000,. 'constraint because: " . '
0.000000,0,0.000000,. 'do { local $_ = ' . $value . '; '
0.000000,0,0.000000,. $message . '->(' . $value . ')'
0.000000,0,0.000000,. '}',
0.000000,0,0.000000,'data => ' . $value
0.000000,0,0.000000,) . ';',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return (
0.000000,0,0.000000,'if (!' . $tc . '->(' . $value . ')) {',
0.000000,0,0.000000,$self->_inline_throw_error(
0.000000,0,0.000000,'"Attribute (' . $attr_name . ') does not pass the type '
0.000000,0,0.000000,. 'constraint because: " . '
0.000000,0,0.000000,. 'do { local $_ = ' . $value . '; '
0.000000,0,0.000000,. $message . '->(' . $value . ')'
0.000000,0,0.000000,. '}',
0.000000,0,0.000000,'data => ' . $value
0.000000,0,0.000000,) . ';',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_get_old_value_for_trigger {
0.000003,2,0.000002,my $self = shift;
0.000004,2,0.000002,my ($instance, $old) = @_;
0.000000,0,0.000000,
0.000019,2,0.000009,return unless $self->has_trigger;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,'my ' . $old . ' = ' . $self->_inline_instance_has($instance),
0.000000,0,0.000000,'? ' . $self->_inline_instance_get($instance),
0.000000,0,0.000000,': ();',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_weaken_value {
0.000024,16,0.000002,my $self = shift;
0.000027,16,0.000002,my ($instance, $value) = @_;
0.000000,0,0.000000,
0.000144,16,0.000009,return unless $self->is_weak_ref;
0.000000,0,0.000000,
0.000023,2,0.000012,my $mi = $self->associated_class->get_meta_instance;
0.000000,0,0.000000,return (
0.000034,2,0.000017,$mi->inline_weaken_slot_value($instance, $self->name),
0.000000,0,0.000000,'if ref ' . $value . ';',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_trigger {
0.000003,2,0.000001,my $self = shift;
0.000004,2,0.000002,my ($instance, $value, $old) = @_;
0.000000,0,0.000000,
0.000017,2,0.000009,return unless $self->has_trigger;
0.000000,0,0.000000,
0.000000,0,0.000000,return '$trigger->(' . $instance . ', ' . $value . ', ' . $old . ');';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_environment {
0.000023,14,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000025,14,0.000002,my $env = { };
0.000000,0,0.000000,
0.000089,14,0.000006,$env->{'$trigger'} = \($self->trigger)
0.000000,0,0.000000,if $self->has_trigger;
0.000125,14,0.000009,$env->{'$attr_default'} = \($self->default)
0.000000,0,0.000000,if $self->has_default;
0.000000,0,0.000000,
0.000115,14,0.000008,if ($self->has_type_constraint) {
0.000070,12,0.000006,my $tc_obj = $self->type_constraint;
0.000000,0,0.000000,
0.000068,12,0.000006,$env->{'$type_constraint'} = \(
0.000000,0,0.000000,$tc_obj->_compiled_type_constraint
0.000000,0,0.000000,) unless $tc_obj->can_be_inlined;
0.000000,0,0.000000,# these two could probably get inlined versions too
0.000079,12,0.000007,$env->{'$type_coercion'} = \(
0.000000,0,0.000000,$tc_obj->coercion->_compiled_type_coercion
0.000000,0,0.000000,) if $tc_obj->has_coercion;
0.000123,12,0.000010,$env->{'$type_message'} = \(
0.000000,0,0.000000,$tc_obj->has_message ? $tc_obj->message : $tc_obj->_default_message
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000103,12,0.000009,$env = { %$env, %{ $tc_obj->inline_environment } };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX ugh, fix these
0.000081,14,0.000006,$env->{'$attr'} = \$self
0.000000,0,0.000000,if $self->has_initializer && $self->is_lazy;
0.000000,0,0.000000,# pretty sure this is only going to be closed over if you use a custom
0.000000,0,0.000000,# error class at this point, but we should still get rid of this
0.000000,0,0.000000,# at some point
0.000107,14,0.000008,$env->{'$meta'} = \($self->associated_class);
0.000000,0,0.000000,
0.000075,14,0.000005,return $env;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _weaken_value {
0.000000,0,0.000000,my ( $self, $instance ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta_instance = Class::MOP::Class->initialize( blessed($instance) )
0.000000,0,0.000000,->get_meta_instance;
0.000000,0,0.000000,
0.000000,0,0.000000,$meta_instance->weaken_slot_value( $instance, $self->name );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_value {
0.000000,0,0.000000,my ($self, $instance, $for_trigger) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_lazy) {
0.000000,0,0.000000,unless ($self->has_value($instance)) {
0.000000,0,0.000000,my $value;
0.000000,0,0.000000,if ($self->has_default) {
0.000000,0,0.000000,$value = $self->default($instance);
0.000000,0,0.000000,} elsif ( $self->has_builder ) {
0.000000,0,0.000000,$value = $self->_call_builder($instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$value = $self->_coerce_and_verify( $value, $instance );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->set_initial_value($instance, $value);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ref $value && $self->is_weak_ref ) {
0.000000,0,0.000000,$self->_weaken_value($instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->should_auto_deref && ! $for_trigger ) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $type_constraint = $self->type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type_constraint->is_a_type_of('ArrayRef')) {
0.000000,0,0.000000,my $rv = $self->SUPER::get_value($instance);
0.000000,0,0.000000,return unless defined $rv;
0.000000,0,0.000000,return wantarray ? @{ $rv } : $rv;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type_constraint->is_a_type_of('HashRef')) {
0.000000,0,0.000000,my $rv = $self->SUPER::get_value($instance);
0.000000,0,0.000000,return unless defined $rv;
0.000000,0,0.000000,return wantarray ? %{ $rv } : $rv;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->throw_error("Can not auto de-reference the type constraint '" . $type_constraint->name . "'", object => $instance, type_constraint => $type_constraint);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->SUPER::get_value($instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_get_value {
0.000016,10,0.000002,my $self = shift;
0.000018,10,0.000002,my ($instance, $tc, $coercion, $message) = @_;
0.000000,0,0.000000,
0.000062,10,0.000006,my $slot_access = $self->_inline_instance_get($instance);
0.000016,10,0.000002,$tc           ||= '$type_constraint';
0.000015,10,0.000002,$coercion     ||= '$type_coercion';
0.000015,10,0.000002,$message      ||= '$type_message';
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000135,10,0.000013,$self->_inline_check_lazy($instance, $tc, $coercion, $message),
0.000000,0,0.000000,$self->_inline_return_auto_deref($slot_access),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check_lazy {
0.000015,10,0.000002,my $self = shift;
0.000021,10,0.000002,my ($instance, $tc, $coercion, $message) = @_;
0.000000,0,0.000000,
0.000098,10,0.000010,return unless $self->is_lazy;
0.000000,0,0.000000,
0.000013,2,0.000007,my $slot_exists = $self->_inline_instance_has($instance);
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000025,2,0.000012,'if (!' . $slot_exists . ') {',
0.000000,0,0.000000,$self->_inline_init_from_default($instance, '$default', $tc, $coercion, $message, 'lazy'),
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_init_from_default {
0.000003,2,0.000002,my $self = shift;
0.000005,2,0.000002,my ($instance, $default, $tc, $coercion, $message, $for_lazy) = @_;
0.000000,0,0.000000,
0.000021,2,0.000011,if (!($self->has_default || $self->has_builder)) {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,'You cannot have a lazy attribute '
0.000000,0,0.000000,. '(' . $self->name . ') '
0.000000,0,0.000000,. 'without specifying a default value for it',
0.000000,0,0.000000,attr => $self,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000069,2,0.000035,$self->_inline_generate_default($instance, $default),
0.000000,0,0.000000,# intentionally not using _inline_tc_code, since that can be overridden
0.000000,0,0.000000,# to do things like possibly only do member tc checks, which isn't
0.000000,0,0.000000,# appropriate for checking the result of a default
0.000000,0,0.000000,$self->has_type_constraint
0.000000,0,0.000000,? ($self->_inline_check_coercion($default, $tc, $coercion, $for_lazy),
0.000000,0,0.000000,$self->_inline_check_constraint($default, $tc, $message, $for_lazy))
0.000000,0,0.000000,: (),
0.000000,0,0.000000,$self->_inline_init_slot($instance, $default),
0.000000,0,0.000000,$self->_inline_weaken_value($instance, $default),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_generate_default {
0.000003,2,0.000001,my $self = shift;
0.000004,2,0.000002,my ($instance, $default) = @_;
0.000000,0,0.000000,
0.000014,2,0.000007,if ($self->has_default) {
0.000002,1,0.000002,my $source = 'my ' . $default . ' = $attr_default';
0.000006,1,0.000006,$source .= '->(' . $instance . ')'
0.000000,0,0.000000,if $self->is_default_a_coderef;
0.000008,1,0.000008,return $source . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($self->has_builder) {
0.000023,1,0.000023,my $builder = B::perlstring($self->builder);
0.000009,1,0.000009,my $builder_str = quotemeta($self->builder);
0.000008,1,0.000008,my $attr_name_str = quotemeta($self->name);
0.000000,0,0.000000,return (
0.000016,1,0.000016,'my ' . $default . ';',
0.000000,0,0.000000,'if (my $builder = ' . $instance . '->can(' . $builder . ')) {',
0.000000,0,0.000000,$default . ' = ' . $instance . '->$builder;',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,'else {',
0.000000,0,0.000000,'my $class = ref(' . $instance . ') || ' . $instance . ';',
0.000000,0,0.000000,$self->_inline_throw_error(
0.000000,0,0.000000,'"$class does not support builder method '
0.000000,0,0.000000,. '\'' . $builder_str . '\' for attribute '
0.000000,0,0.000000,. '\'' . $attr_name_str . '\'"'
0.000000,0,0.000000,) . ';',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,"Can't generate a default for " . $self->name
0.000000,0,0.000000,. " since no default or builder was specified"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_init_slot {
0.000003,2,0.000002,my $self = shift;
0.000004,2,0.000002,my ($inv, $value) = @_;
0.000000,0,0.000000,
0.000010,2,0.000005,if ($self->has_initializer) {
0.000000,0,0.000000,return '$attr->set_initial_value(' . $inv . ', ' . $value . ');';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000026,2,0.000013,return $self->_inline_instance_set($inv, $value) . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_return_auto_deref {
0.000017,10,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000094,10,0.000009,return 'return ' . $self->_auto_deref(@_) . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _auto_deref {
0.000015,10,0.000002,my $self = shift;
0.000017,10,0.000002,my ($ref_value) = @_;
0.000000,0,0.000000,
0.000104,10,0.000010,return $ref_value unless $self->should_auto_deref;
0.000000,0,0.000000,
0.000000,0,0.000000,my $type_constraint = $self->type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sigil;
0.000000,0,0.000000,if ($type_constraint->is_a_type_of('ArrayRef')) {
0.000000,0,0.000000,$sigil = '@';
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($type_constraint->is_a_type_of('HashRef')) {
0.000000,0,0.000000,$sigil = '%';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,'Can not auto de-reference the type constraint \''
0.000000,0,0.000000,. $type_constraint->name
0.000000,0,0.000000,. '\'',
0.000000,0,0.000000,type_constraint => $type_constraint,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 'wantarray '
0.000000,0,0.000000,. '? ' . $sigil . '{ (' . $ref_value . ') || return } '
0.000000,0,0.000000,. ': (' . $ref_value . ')';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## installing accessors
0.000000,0,0.000000,
0.000073,14,0.000005,sub accessor_metaclass { 'Moose::Meta::Method::Accessor' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_accessors {
0.000015,10,0.000002,my $self = shift;
0.000059,10,0.000006,$self->SUPER::install_accessors(@_);
0.000068,10,0.000007,$self->install_delegation if $self->has_handles;
0.000049,10,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_associated_methods {
0.000014,8,0.000002,my $self = shift;
0.000097,8,0.000012,unless (
0.000000,0,0.000000,@{ $self->associated_methods }
0.000000,0,0.000000,|| ($self->_is_metadata || '') eq 'bare'
0.000000,0,0.000000,) {
0.000000,0,0.000000,Carp::cluck(
0.000000,0,0.000000,'Attribute (' . $self->name . ') of class '
0.000000,0,0.000000,. $self->associated_class->name
0.000000,0,0.000000,. ' has no associated methods'
0.000000,0,0.000000,. ' (did you mean to provide an "is" argument?)'
0.000000,0,0.000000,. "\n"
0.000000,0,0.000000,)
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_accessors {
0.000022,14,0.000002,my $self = shift;
0.000029,14,0.000002,my ($type, $accessor, $generate_as_inline_methods) = @_;
0.000000,0,0.000000,
0.000036,14,0.000003,$accessor = ( keys %$accessor )[0] if ( ref($accessor) || '' ) eq 'HASH';
0.000152,14,0.000011,my $method = $self->associated_class->get_method($accessor);
0.000000,0,0.000000,
0.000042,14,0.000003,if (   $method
0.000000,0,0.000000,&& $method->isa('Class::MOP::Method::Accessor')
0.000000,0,0.000000,&& $method->associated_attribute->name ne $self->name ) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $other_attr_name = $method->associated_attribute->name;
0.000000,0,0.000000,my $name            = $self->name;
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::cluck(
0.000000,0,0.000000,"You are overwriting an accessor ($accessor) for the $other_attr_name attribute"
0.000000,0,0.000000,. " with a new accessor method for the $name attribute" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000043,14,0.000003,if (
0.000000,0,0.000000,$method
0.000000,0,0.000000,&& !$method->is_stub
0.000000,0,0.000000,&& !$method->isa('Class::MOP::Method::Accessor')
0.000000,0,0.000000,&& (  !$self->definition_context
0.000000,0,0.000000,|| $method->package_name eq $self->definition_context->{package} )
0.000000,0,0.000000,) {
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::cluck(
0.000000,0,0.000000,"You are overwriting a locally defined method ($accessor) with "
0.000000,0,0.000000,. "an accessor" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000285,14,0.000020,if (  !$self->associated_class->has_method($accessor)
0.000000,0,0.000000,&& $self->associated_class->has_package_symbol( '&' . $accessor ) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::cluck(
0.000000,0,0.000000,"You are overwriting a locally defined function ($accessor) with "
0.000000,0,0.000000,. "an accessor" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000150,14,0.000011,$self->SUPER::_process_accessors(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_accessors {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->SUPER::remove_accessors(@_);
0.000000,0,0.000000,$self->remove_delegation if $self->has_handles;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_delegation {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# Here we canonicalize the 'handles' option
0.000000,0,0.000000,# this will sort out any details and always
0.000000,0,0.000000,# return an hash of methods which we want
0.000000,0,0.000000,# to delagate to, see that method for details
0.000000,0,0.000000,my %handles = $self->_canonicalize_handles;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# install the delegation ...
0.000000,0,0.000000,my $associated_class = $self->associated_class;
0.000000,0,0.000000,foreach my $handle (sort keys %handles) {
0.000000,0,0.000000,my $method_to_call = $handles{$handle};
0.000000,0,0.000000,my $class_name = $associated_class->name;
0.000000,0,0.000000,my $name = "${class_name}::${handle}";
0.000000,0,0.000000,
0.000000,0,0.000000,if ( my $method = $associated_class->get_method($handle) ) {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,"You cannot overwrite a locally defined method ($handle) with a delegation",
0.000000,0,0.000000,method_name => $handle
0.000000,0,0.000000,) unless $method->is_stub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# handles is not allowed to delegate
0.000000,0,0.000000,# any of these methods, as they will
0.000000,0,0.000000,# override the ones in your class, which
0.000000,0,0.000000,# is almost certainly not what you want.
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME warn when $handle was explicitly specified, but not if the source is a regex or something
0.000000,0,0.000000,#cluck("Not delegating method '$handle' because it is a core method") and
0.000000,0,0.000000,next if $class_name->isa("Moose::Object") and $handle =~ /^BUILD|DEMOLISH$/ || Moose::Object->can($handle);
0.000000,0,0.000000,
0.000000,0,0.000000,my $method = $self->_make_delegation_method($handle, $method_to_call);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->associated_class->add_method($method->name, $method);
0.000000,0,0.000000,$self->associate_method($method);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_delegation {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %handles = $self->_canonicalize_handles;
0.000000,0,0.000000,my $associated_class = $self->associated_class;
0.000000,0,0.000000,foreach my $handle (keys %handles) {
0.000000,0,0.000000,next unless any { $handle eq $_ }
0.000000,0,0.000000,map { $_->name }
0.000000,0,0.000000,@{ $self->associated_methods };
0.000000,0,0.000000,$self->associated_class->remove_method($handle);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# private methods to help delegation ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub _canonicalize_handles {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my $handles = $self->handles;
0.000000,0,0.000000,if (my $handle_type = ref($handles)) {
0.000000,0,0.000000,if ($handle_type eq 'HASH') {
0.000000,0,0.000000,return %{$handles};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($handle_type eq 'ARRAY') {
0.000000,0,0.000000,return map { $_ => $_ } @{$handles};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($handle_type eq 'Regexp') {
0.000000,0,0.000000,($self->has_type_constraint)
0.000000,0,0.000000,|| $self->throw_error("Cannot delegate methods based on a Regexp without a type constraint (isa)", data => $handles);
0.000000,0,0.000000,return map  { ($_ => $_) }
0.000000,0,0.000000,grep { /$handles/ } $self->_get_delegate_method_list;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($handle_type eq 'CODE') {
0.000000,0,0.000000,return $handles->($self, $self->_find_delegate_metaclass);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::DuckType')) {
0.000000,0,0.000000,return map { $_ => $_ } @{ $handles->methods };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (blessed($handles) && $handles->isa('Moose::Meta::TypeConstraint::Role')) {
0.000000,0,0.000000,$handles = $handles->role;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->throw_error("Unable to canonicalize the 'handles' option with $handles", data => $handles);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,load_class($handles);
0.000000,0,0.000000,my $role_meta = Class::MOP::class_of($handles);
0.000000,0,0.000000,
0.000000,0,0.000000,(blessed $role_meta && $role_meta->isa('Moose::Meta::Role'))
0.000000,0,0.000000,|| $self->throw_error("Unable to canonicalize the 'handles' option with $handles because its metaclass is not a Moose::Meta::Role", data => $handles);
0.000000,0,0.000000,
0.000000,0,0.000000,return map { $_ => $_ }
0.000000,0,0.000000,map { $_->name }
0.000000,0,0.000000,grep { !$_->isa('Class::MOP::Method::Meta') } (
0.000000,0,0.000000,$role_meta->_get_local_methods,
0.000000,0,0.000000,$role_meta->get_required_method_list,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_delegate_method_list {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $meta = $self->_find_delegate_metaclass;
0.000000,0,0.000000,if ($meta->isa('Class::MOP::Class')) {
0.000000,0,0.000000,return map  { $_->name }  # NOTE: !never! delegate &meta
0.000000,0,0.000000,grep { $_->package_name ne 'Moose::Object' && !$_->isa('Class::MOP::Method::Meta') }
0.000000,0,0.000000,$meta->get_all_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($meta->isa('Moose::Meta::Role')) {
0.000000,0,0.000000,return $meta->get_method_list;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->throw_error("Unable to recognize the delegate metaclass '$meta'", data => $meta);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _find_delegate_metaclass {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if (my $class = $self->_isa_metadata) {
0.000000,0,0.000000,unless ( is_class_loaded($class) ) {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'The %s attribute is trying to delegate to a class which has not been loaded - %s',
0.000000,0,0.000000,$self->name, $class
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,# we might be dealing with a non-Moose class,
0.000000,0,0.000000,# and need to make our own metaclass. if there's
0.000000,0,0.000000,# already a metaclass, it will be returned
0.000000,0,0.000000,return Class::MOP::Class->initialize($class);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (my $role = $self->_does_metadata) {
0.000000,0,0.000000,unless ( is_class_loaded($class) ) {
0.000000,0,0.000000,$self->throw_error(
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,'The %s attribute is trying to delegate to a role which has not been loaded - %s',
0.000000,0,0.000000,$self->name, $role
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return Class::MOP::class_of($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->throw_error("Cannot find delegate metaclass for attribute " . $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub delegation_metaclass { 'Moose::Meta::Method::Delegation' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_delegation_method {
0.000000,0,0.000000,my ( $self, $handle_name, $method_to_call ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @curried_arguments;
0.000000,0,0.000000,
0.000000,0,0.000000,($method_to_call, @curried_arguments) = @$method_to_call
0.000000,0,0.000000,if 'ARRAY' eq ref($method_to_call);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->delegation_metaclass->new(
0.000000,0,0.000000,name               => $handle_name,
0.000000,0,0.000000,package_name       => $self->associated_class->name,
0.000000,0,0.000000,attribute          => $self,
0.000000,0,0.000000,delegate_to_method => $method_to_call,
0.000000,0,0.000000,curried_arguments  => \@curried_arguments,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _coerce_and_verify {
0.000000,0,0.000000,my $self     = shift;
0.000000,0,0.000000,my $val      = shift;
0.000000,0,0.000000,my $instance = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $val unless $self->has_type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,$val = $self->type_constraint->coerce($val)
0.000000,0,0.000000,if $self->should_coerce && $self->type_constraint->has_coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->verify_against_type_constraint($val, instance => $instance);
0.000000,0,0.000000,
0.000000,0,0.000000,return $val;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub verify_against_type_constraint {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $val  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if !$self->has_type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,my $type_constraint = $self->type_constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,$type_constraint->check($val)
0.000000,0,0.000000,|| $self->throw_error("Attribute ("
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. ") does not pass the type constraint because: "
0.000000,0,0.000000,. $type_constraint->get_message($val), data => $val, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Meta::Attribute::Custom::Moose;
0.000000,0,0.000000,BEGIN {
0.000011,1,0.000011,$Moose::Meta::Attribute::Custom::Moose::AUTHORITY = 'cpan:STEVAN';
0.000064,1,0.000064,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Moose::Meta::Attribute::Custom::Moose::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,sub register_implementation { 'Moose::Meta::Attribute' }
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: The Moose attribute metaclass
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
