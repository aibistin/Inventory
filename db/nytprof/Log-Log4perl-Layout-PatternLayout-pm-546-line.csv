# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,package Log::Log4perl::Layout::PatternLayout;
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000053,2,0.000026,use 5.006;
0.000033,2,0.000016,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000034,2,0.000017,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000035,2,0.000017,use Carp;
0.000030,2,0.000015,use Log::Log4perl;
0.000033,2,0.000017,use Log::Log4perl::Util;
0.000033,2,0.000017,use Log::Log4perl::Level;
0.000118,2,0.000059,use Log::Log4perl::DateFormat;
0.000102,2,0.000051,use Log::Log4perl::NDC;
0.000100,2,0.000050,use Log::Log4perl::MDC;
0.000105,2,0.000052,use Log::Log4perl::Util::TimeTracker;
0.000032,2,0.000016,use File::Spec;
0.000300,2,0.000150,use File::Basename;
0.000000,0,0.000000,
0.000002,1,0.000002,our $TIME_HIRES_AVAILABLE_WARNED = 0;
0.000001,1,0.000001,our $HOSTNAME;
0.000002,1,0.000002,our %GLOBAL_USER_DEFINED_CSPECS = ();
0.000000,0,0.000000,
0.000002,1,0.000002,our $CSPECS = 'cCdFHIlLmMnpPrRtTxX%';
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# Check if we've got Sys::Hostname. If not, just punt.
0.000002,1,0.000002,$HOSTNAME = "unknown.host";
0.000011,1,0.000011,if(Log::Log4perl::Util::module_available("Sys::Hostname")) {
0.000002,1,0.000002,require Sys::Hostname;
0.000006,1,0.000006,$HOSTNAME = Sys::Hostname::hostname();
0.000000,0,0.000000,}
0.000029,1,0.000029,}
0.000000,0,0.000000,
0.000039,2,0.000019,use base qw(Log::Log4perl::Layout);
0.000000,0,0.000000,
0.002075,2,0.001037,no strict qw(refs);
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,##################################################
0.000004,2,0.000002,my $class = shift;
0.000003,2,0.000002,$class = ref ($class) || $class;
0.000000,0,0.000000,
0.000005,2,0.000002,my $options       = ref $_[0] eq "HASH" ? shift : {};
0.000004,2,0.000002,my $layout_string = @_ ? shift : '%m%n';
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = {
0.000000,0,0.000000,format                => undef,
0.000000,0,0.000000,info_needed           => {},
0.000000,0,0.000000,stack                 => [],
0.000000,0,0.000000,CSPECS                => $CSPECS,
0.000000,0,0.000000,dontCollapseArrayRefs => $options->{dontCollapseArrayRefs}{value},
0.000000,0,0.000000,last_time             => undef,
0.000000,0,0.000000,undef_column_value    => 
0.000000,0,0.000000,(exists $options->{ undef_column_value } 
0.000000,0,0.000000,? $options->{ undef_column_value } 
0.000019,2,0.000010,: "[undef]"),
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000021,2,0.000010,$self->{timer} = Log::Log4perl::Util::TimeTracker->new(
0.000000,0,0.000000,time_function => $options->{time_function}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000005,2,0.000002,if(exists $options->{ConversionPattern}->{value}) {
0.000000,0,0.000000,$layout_string = $options->{ConversionPattern}->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,2,0.000003,if(exists $options->{message_chomp_before_newline}) {
0.000000,0,0.000000,$self->{message_chomp_before_newline} = 
0.000000,0,0.000000,$options->{message_chomp_before_newline}->{value};
0.000000,0,0.000000,} else {
0.000004,2,0.000002,$self->{message_chomp_before_newline} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,2,0.000002,bless $self, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,#add the global user-defined cspecs
0.000009,2,0.000005,foreach my $f (keys %GLOBAL_USER_DEFINED_CSPECS){
0.000000,0,0.000000,#add it to the list of letters
0.000000,0,0.000000,$self->{CSPECS} .= $f;
0.000000,0,0.000000,#for globals, the coderef is already evaled, 
0.000000,0,0.000000,$self->{USER_DEFINED_CSPECS}{$f} = $GLOBAL_USER_DEFINED_CSPECS{$f};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#add the user-defined cspecs local to this appender
0.000008,2,0.000004,foreach my $f (keys %{$options->{cspec}}){
0.000000,0,0.000000,$self->add_layout_cspec($f, $options->{cspec}{$f}{value});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# non-portable line breaks
0.000021,2,0.000011,$layout_string =~ s/\\n/\n/g;
0.000013,2,0.000007,$layout_string =~ s/\\r/\r/g;
0.000000,0,0.000000,
0.000012,2,0.000006,$self->define($layout_string);
0.000000,0,0.000000,
0.000016,2,0.000008,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub define {
0.000000,0,0.000000,##################################################
0.000004,2,0.000002,my($self, $format) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# If the message contains a %m followed by a newline,
0.000000,0,0.000000,# make a note of that so that we can cut a superfluous 
0.000000,0,0.000000,# \n off the message later on
0.000024,2,0.000012,if($self->{message_chomp_before_newline} and $format =~ /%m%n/) {
0.000000,0,0.000000,$self->{message_chompable} = 1;
0.000000,0,0.000000,} else {
0.000002,1,0.000002,$self->{message_chompable} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Parse the format
0.000107,2,0.000054,$format =~ s/%(-?\d*(?:\.\d+)?) 
0.000022,4,0.000006,([$self->{CSPECS}])
0.000000,0,0.000000,(?:{(.*?)})*/
0.000000,0,0.000000,rep($self, $1, $2, $3);
0.000000,0,0.000000,/gex;
0.000000,0,0.000000,
0.000014,2,0.000007,$self->{printformat} = $format;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub rep {
0.000000,0,0.000000,##################################################
0.000013,4,0.000003,my($self, $num, $op, $curlies) = @_;
0.000000,0,0.000000,
0.000007,4,0.000002,return "%%" if $op eq "%";
0.000000,0,0.000000,
0.000000,0,0.000000,# If it's a %d{...} construct, initialize a simple date
0.000000,0,0.000000,# format formatter, so that we can quickly render later on.
0.000000,0,0.000000,# If it's just %d, assume %d{yyyy/MM/dd HH:mm:ss}
0.000005,4,0.000001,my $sdf;
0.000007,4,0.000002,if($op eq "d") {
0.000000,0,0.000000,if(defined $curlies) {
0.000000,0,0.000000,$sdf = Log::Log4perl::DateFormat->new($curlies);
0.000000,0,0.000000,} else {
0.000009,1,0.000009,$sdf = Log::Log4perl::DateFormat->new("yyyy/MM/dd HH:mm:ss");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,4,0.000003,push @{$self->{stack}}, [$op, $sdf || $curlies];
0.000000,0,0.000000,
0.000009,4,0.000002,$self->{info_needed}->{$op}++;
0.000000,0,0.000000,
0.000025,4,0.000006,return "%${num}s";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub render {
0.000000,0,0.000000,##################################################
0.000005,2,0.000003,my($self, $message, $category, $priority, $caller_level) = @_;
0.000000,0,0.000000,
0.000003,2,0.000002,$caller_level = 0 unless defined  $caller_level;
0.000000,0,0.000000,
0.000004,2,0.000002,my %info    = ();
0.000000,0,0.000000,
0.000006,2,0.000003,$info{m}    = $message;
0.000000,0,0.000000,# See 'define'
0.000006,2,0.000003,chomp $info{m} if $self->{message_chompable};
0.000000,0,0.000000,
0.000003,2,0.000002,my @results = ();
0.000000,0,0.000000,
0.000012,2,0.000006,my $caller_offset = Log::Log4perl::caller_depth_offset( $caller_level );
0.000000,0,0.000000,
0.000009,2,0.000004,if($self->{info_needed}->{L} or
0.000000,0,0.000000,$self->{info_needed}->{F} or
0.000000,0,0.000000,$self->{info_needed}->{C} or
0.000000,0,0.000000,$self->{info_needed}->{l} or
0.000000,0,0.000000,$self->{info_needed}->{M} or
0.000000,0,0.000000,$self->{info_needed}->{T} or
0.000000,0,0.000000,0
0.000000,0,0.000000,) {
0.000000,0,0.000000,
0.000000,0,0.000000,my ($package, $filename, $line, 
0.000000,0,0.000000,$subroutine, $hasargs,
0.000000,0,0.000000,$wantarray, $evaltext, $is_require, 
0.000000,0,0.000000,$hints, $bitmask) = caller($caller_offset);
0.000000,0,0.000000,
0.000000,0,0.000000,# If caller() choked because of a whacko caller level,
0.000000,0,0.000000,# correct undefined values to '[undef]' in order to prevent 
0.000000,0,0.000000,# warning messages when interpolating later
0.000000,0,0.000000,unless(defined $bitmask) {
0.000000,0,0.000000,for($package, 
0.000000,0,0.000000,$filename, $line,
0.000000,0,0.000000,$subroutine, $hasargs,
0.000000,0,0.000000,$wantarray, $evaltext, $is_require,
0.000000,0,0.000000,$hints, $bitmask) {
0.000000,0,0.000000,$_ = '[undef]' unless defined $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$info{L} = $line;
0.000000,0,0.000000,$info{F} = $filename;
0.000000,0,0.000000,$info{C} = $package;
0.000000,0,0.000000,
0.000000,0,0.000000,if($self->{info_needed}->{M} or
0.000000,0,0.000000,$self->{info_needed}->{l} or
0.000000,0,0.000000,0) {
0.000000,0,0.000000,# To obtain the name of the subroutine which triggered the 
0.000000,0,0.000000,# logger, we need to go one additional level up.
0.000000,0,0.000000,my $levels_up = 1; 
0.000000,0,0.000000,{
0.000000,0,0.000000,my @callinfo = caller($caller_offset+$levels_up);
0.000000,0,0.000000,
0.000000,0,0.000000,if(_INTERNAL_DEBUG) {
0.000000,0,0.000000,callinfo_dump( $caller_offset, \@callinfo );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$subroutine = $callinfo[3];
0.000000,0,0.000000,# If we're inside an eval, go up one level further.
0.000000,0,0.000000,if(defined $subroutine and
0.000000,0,0.000000,$subroutine eq "(eval)") {
0.000000,0,0.000000,print "Inside an eval, one up\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$levels_up++;
0.000000,0,0.000000,redo;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$subroutine = "main::" unless $subroutine;
0.000000,0,0.000000,print "Subroutine is '$subroutine'\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$info{M} = $subroutine;
0.000000,0,0.000000,$info{l} = "$subroutine $filename ($line)";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,2,0.000002,$info{X} = "[No curlies defined]";
0.000004,2,0.000002,$info{x} = Log::Log4perl::NDC->get() if $self->{info_needed}->{x};
0.000004,2,0.000002,$info{c} = $category;
0.000004,2,0.000002,$info{d} = 1; # Dummy value, corrected later
0.000004,2,0.000002,$info{n} = "\n";
0.000004,2,0.000002,$info{p} = $priority;
0.000008,2,0.000004,$info{P} = $$;
0.000005,2,0.000003,$info{H} = $HOSTNAME;
0.000000,0,0.000000,
0.000003,2,0.000002,my $current_time;
0.000000,0,0.000000,
0.000020,2,0.000010,if($self->{info_needed}->{r} or $self->{info_needed}->{R}) {
0.000000,0,0.000000,if(!$TIME_HIRES_AVAILABLE_WARNED++ and 
0.000000,0,0.000000,!$self->{timer}->hires_available()) {
0.000000,0,0.000000,warn "Requested %r/%R pattern without installed Time::HiRes\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$current_time = [$self->{timer}->gettimeofday()];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,2,0.000002,if($self->{info_needed}->{r}) {
0.000000,0,0.000000,$info{r} = $self->{timer}->milliseconds( $current_time );
0.000000,0,0.000000,}
0.000004,2,0.000002,if($self->{info_needed}->{R}) {
0.000000,0,0.000000,$info{R} = $self->{timer}->delta_milliseconds( $current_time );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Stack trace wanted?
0.000003,2,0.000002,if($self->{info_needed}->{T}) {
0.000000,0,0.000000,local $Carp::CarpLevel =
0.000000,0,0.000000,$Carp::CarpLevel + $caller_offset;
0.000000,0,0.000000,my $mess = Carp::longmess(); 
0.000000,0,0.000000,chomp($mess);
0.000000,0,0.000000,# $mess =~ s/(?:\A\s*at.*\n|^\s*Log::Log4perl.*\n|^\s*)//mg;
0.000000,0,0.000000,$mess =~ s/(?:\A\s*at.*\n|^\s*)//mg;
0.000000,0,0.000000,$mess =~ s/\n/, /g;
0.000000,0,0.000000,$info{T} = $mess;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# As long as they're not implemented yet ..
0.000005,2,0.000002,$info{t} = "N/A";
0.000000,0,0.000000,
0.000000,0,0.000000,# Iterate over all info fields on the stack
0.000009,2,0.000004,for my $e (@{$self->{stack}}) {
0.000013,6,0.000002,my($op, $curlies) = @$e;
0.000000,0,0.000000,
0.000008,6,0.000001,my $result;
0.000000,0,0.000000,
0.000022,6,0.000004,if(exists $self->{USER_DEFINED_CSPECS}->{$op}) {
0.000000,0,0.000000,next unless $self->{info_needed}->{$op};
0.000000,0,0.000000,$self->{curlies} = $curlies;
0.000000,0,0.000000,$result = $self->{USER_DEFINED_CSPECS}->{$op}->($self, 
0.000000,0,0.000000,$message, $category, $priority, 
0.000000,0,0.000000,$caller_offset+1);
0.000000,0,0.000000,} elsif(exists $info{$op}) {
0.000010,6,0.000002,$result = $info{$op};
0.000025,6,0.000004,if($curlies) {
0.000000,0,0.000000,$result = $self->curly_action($op, $curlies, $info{$op});
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# just for %d
0.000006,4,0.000002,if($op eq 'd') {
0.000000,0,0.000000,$result = $info{$op}->format($self->{timer}->gettimeofday());
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,warn "Format %'$op' not implemented (yet)";
0.000000,0,0.000000,$result = "FORMAT-ERROR";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,6,0.000001,$result = $self->{undef_column_value} unless defined $result;
0.000020,6,0.000003,push @results, $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# dbi appender needs that
0.000004,2,0.000002,if( scalar @results == 1 and
0.000000,0,0.000000,!defined $results[0] ) {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000021,2,0.000010,return (sprintf $self->{printformat}, @results);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub curly_action {
0.000000,0,0.000000,##################################################
0.000005,2,0.000002,my($self, $ops, $curlies, $data) = @_;
0.000000,0,0.000000,
0.000027,2,0.000014,if($ops eq "c") {
0.000000,0,0.000000,$data = shrink_category($data, $curlies);
0.000000,0,0.000000,} elsif($ops eq "C") {
0.000000,0,0.000000,$data = shrink_category($data, $curlies);
0.000000,0,0.000000,} elsif($ops eq "X") {
0.000000,0,0.000000,$data = Log::Log4perl::MDC->get($curlies);
0.000000,0,0.000000,} elsif($ops eq "d") {
0.000000,0,0.000000,$data = $curlies->format( $self->{timer}->gettimeofday() );
0.000000,0,0.000000,} elsif($ops eq "M") {
0.000000,0,0.000000,$data = shrink_category($data, $curlies);
0.000000,0,0.000000,} elsif($ops eq "m") {
0.000000,0,0.000000,if($curlies eq "chomp") {
0.000000,0,0.000000,chomp $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif($ops eq "F") {
0.000000,0,0.000000,my @parts = File::Spec->splitdir($data);
0.000000,0,0.000000,# Limit it to max curlies entries
0.000000,0,0.000000,if(@parts > $curlies) {
0.000000,0,0.000000,splice @parts, 0, @parts - $curlies;
0.000000,0,0.000000,}
0.000000,0,0.000000,$data = File::Spec->catfile(@parts);
0.000000,0,0.000000,} elsif($ops eq "p") {
0.000000,0,0.000000,$data = substr $data, 0, $curlies;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,2,0.000006,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub shrink_category {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($category, $len) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @components = split /\.|::/, $category;
0.000000,0,0.000000,
0.000000,0,0.000000,if(@components > $len) {
0.000000,0,0.000000,splice @components, 0, @components - $len;
0.000000,0,0.000000,$category = join '.', @components;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,return $category;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub add_global_cspec {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# This is a Class method.
0.000000,0,0.000000,# Accepts a coderef or text
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000000,0,0.000000,unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE) {
0.000000,0,0.000000,die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " .
0.000000,0,0.000000,"prohibits user defined cspecs";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ($letter, $perlcode) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Illegal value '$letter' in call to add_global_cspec()"
0.000000,0,0.000000,unless ($letter =~ /^[a-zA-Z]$/);
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Missing argument for perlcode for 'cspec.$letter' ".
0.000000,0,0.000000,"in call to add_global_cspec()"
0.000000,0,0.000000,unless $perlcode;
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Please don't redefine built-in cspecs [$CSPECS]\n".
0.000000,0,0.000000,"like you do for \"cspec.$letter\"\n "
0.000000,0,0.000000,if ($CSPECS =~/$letter/);
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $perlcode eq 'CODE') {
0.000000,0,0.000000,$GLOBAL_USER_DEFINED_CSPECS{$letter} = $perlcode;
0.000000,0,0.000000,
0.000000,0,0.000000,}elsif (! ref $perlcode){
0.000000,0,0.000000,
0.000000,0,0.000000,$GLOBAL_USER_DEFINED_CSPECS{$letter} = 
0.000000,0,0.000000,Log::Log4perl::Config::compile_if_perl($perlcode);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,die qq{Compilation failed for your perl code for }.
0.000000,0,0.000000,qq{"log4j.PatternLayout.cspec.$letter":\n}.
0.000000,0,0.000000,qq{This is the error message: \t$@\n}.
0.000000,0,0.000000,qq{This is the code that failed: \n$perlcode\n};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,croak "eval'ing your perlcode for 'log4j.PatternLayout.cspec.$letter' ".
0.000000,0,0.000000,"doesn't return a coderef \n".
0.000000,0,0.000000,"Here is the perl code: \n\t$perlcode\n "
0.000000,0,0.000000,unless (ref $GLOBAL_USER_DEFINED_CSPECS{$letter} eq 'CODE');
0.000000,0,0.000000,
0.000000,0,0.000000,}else{
0.000000,0,0.000000,croak "I don't know how to handle perlcode=$perlcode ".
0.000000,0,0.000000,"for 'cspec.$letter' in call to add_global_cspec()";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub add_layout_cspec {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# object method
0.000000,0,0.000000,# adds a cspec just for this layout
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self, $letter, $perlcode) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,unless($Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE) {
0.000000,0,0.000000,die "\$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE setting " .
0.000000,0,0.000000,"prohibits user defined cspecs";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Illegal value '$letter' in call to add_layout_cspec()"
0.000000,0,0.000000,unless ($letter =~ /^[a-zA-Z]$/);
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Missing argument for perlcode for 'cspec.$letter' ".
0.000000,0,0.000000,"in call to add_layout_cspec()"
0.000000,0,0.000000,unless $perlcode;
0.000000,0,0.000000,
0.000000,0,0.000000,croak "Please don't redefine built-in cspecs [$CSPECS] \n".
0.000000,0,0.000000,"like you do for 'cspec.$letter'"
0.000000,0,0.000000,if ($CSPECS =~/$letter/);
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $perlcode eq 'CODE') {
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{USER_DEFINED_CSPECS}{$letter} = $perlcode;
0.000000,0,0.000000,
0.000000,0,0.000000,}elsif (! ref $perlcode){
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{USER_DEFINED_CSPECS}{$letter} =
0.000000,0,0.000000,Log::Log4perl::Config::compile_if_perl($perlcode);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($@) {
0.000000,0,0.000000,die qq{Compilation failed for your perl code for }.
0.000000,0,0.000000,qq{"cspec.$letter":\n}.
0.000000,0,0.000000,qq{This is the error message: \t$@\n}.
0.000000,0,0.000000,qq{This is the code that failed: \n$perlcode\n};
0.000000,0,0.000000,}
0.000000,0,0.000000,croak "eval'ing your perlcode for 'cspec.$letter' ".
0.000000,0,0.000000,"doesn't return a coderef \n".
0.000000,0,0.000000,"Here is the perl code: \n\t$perlcode\n "
0.000000,0,0.000000,unless (ref $self->{USER_DEFINED_CSPECS}{$letter} eq 'CODE');
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,}else{
0.000000,0,0.000000,croak "I don't know how to handle perlcode=$perlcode ".
0.000000,0,0.000000,"for 'cspec.$letter' in call to add_layout_cspec()";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{CSPECS} .= $letter;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub callinfo_dump {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($level, $info) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @called_by = caller(0);
0.000000,0,0.000000,
0.000000,0,0.000000,# Just for internal debugging
0.000000,0,0.000000,$called_by[1] = basename $called_by[1];
0.000000,0,0.000000,print "caller($level) at $called_by[1]-$called_by[2] returned ";
0.000000,0,0.000000,
0.000000,0,0.000000,my @by_idx;
0.000000,0,0.000000,
0.000000,0,0.000000,# $info->[1] = basename $info->[1] if defined $info->[1];
0.000000,0,0.000000,
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,for my $field (qw(package filename line subroutine hasargs
0.000000,0,0.000000,wantarray evaltext is_require hints bitmask)) {
0.000000,0,0.000000,$by_idx[$i] = $field;
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$i = 0;
0.000000,0,0.000000,for my $value (@$info) {
0.000000,0,0.000000,my $field = $by_idx[ $i ];
0.000000,0,0.000000,print "$field=", 
0.000000,0,0.000000,(defined $info->[$i] ? $info->[$i] : "[undef]"),
0.000000,0,0.000000," ";
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
