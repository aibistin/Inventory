# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Exporter;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Exporter::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Exporter::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000047,2,0.000023,use warnings;
0.000000,0,0.000000,
0.000032,2,0.000016,use Class::Load qw(is_class_loaded);
0.000224,2,0.000112,use Class::MOP;
0.000038,2,0.000019,use List::MoreUtils qw( first_index uniq );
0.000139,2,0.000070,use Moose::Util::MetaRole;
0.000037,2,0.000019,use Scalar::Util qw(reftype);
0.000123,3,0.000041,use Sub::Exporter 0.980;
0.000435,2,0.000218,use Sub::Name qw(subname);
0.000000,0,0.000000,
0.000001,1,0.000001,my %EXPORT_SPEC;
0.000000,0,0.000000,
0.000000,0,0.000000,sub setup_import_methods {
0.000007,2,0.000004,my ( $class, %args ) = @_;
0.000000,0,0.000000,
0.000005,2,0.000003,$args{exporting_package} ||= caller();
0.000000,0,0.000000,
0.000027,2,0.000014,$class->build_import_methods(
0.000000,0,0.000000,%args,
0.000000,0,0.000000,install => [qw(import unimport init_meta)]
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A reminder to intrepid Moose hackers
0.000000,0,0.000000,# there may be more than one level of exporter
0.000000,0,0.000000,# don't make doy cry. -- perigrin
0.000000,0,0.000000,
0.000000,0,0.000000,sub build_import_methods {
0.000007,2,0.000003,my ( $class, %args ) = @_;
0.000000,0,0.000000,
0.000004,2,0.000002,my $exporting_package = $args{exporting_package} ||= caller();
0.000000,0,0.000000,
0.000064,8,0.000008,my $meta_lookup = $args{meta_lookup} || sub { Class::MOP::class_of(shift) };
0.000000,0,0.000000,
0.000004,2,0.000002,$EXPORT_SPEC{$exporting_package} = \%args;
0.000000,0,0.000000,
0.000014,2,0.000007,my @exports_from = $class->_follow_also($exporting_package);
0.000000,0,0.000000,
0.000004,2,0.000002,my $export_recorder = {};
0.000003,2,0.000001,my $is_reexport     = {};
0.000000,0,0.000000,
0.000018,2,0.000009,my $exports = $class->_make_sub_exporter_params(
0.000000,0,0.000000,[ $exporting_package, @exports_from ],
0.000000,0,0.000000,$export_recorder,
0.000000,0,0.000000,$is_reexport,
0.000000,0,0.000000,$args{meta_lookup}, # so that we don't pass through the default
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000014,2,0.000007,my $exporter = $class->_make_exporter(
0.000000,0,0.000000,$exports,
0.000000,0,0.000000,$is_reexport,
0.000000,0,0.000000,$meta_lookup,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,2,0.000002,my %methods;
0.000015,2,0.000008,$methods{import} = $class->_make_import_sub(
0.000000,0,0.000000,$exporting_package,
0.000000,0,0.000000,$exporter,
0.000000,0,0.000000,\@exports_from,
0.000000,0,0.000000,$is_reexport,
0.000000,0,0.000000,$meta_lookup,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000014,2,0.000007,$methods{unimport} = $class->_make_unimport_sub(
0.000000,0,0.000000,$exporting_package,
0.000000,0,0.000000,$exports,
0.000000,0,0.000000,$export_recorder,
0.000000,0,0.000000,$is_reexport,
0.000000,0,0.000000,$meta_lookup,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000014,2,0.000007,$methods{init_meta} = $class->_make_init_meta(
0.000000,0,0.000000,$exporting_package,
0.000000,0,0.000000,\%args,
0.000000,0,0.000000,$meta_lookup,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000014,2,0.000007,my $package = Class::MOP::Package->initialize($exporting_package);
0.000011,2,0.000006,for my $to_install ( @{ $args{install} || [] } ) {
0.000011,6,0.000002,my $symbol = '&' . $to_install;
0.000000,0,0.000000,next
0.000029,6,0.000005,unless $methods{$to_install}
0.000000,0,0.000000,&& !$package->has_package_symbol($symbol);
0.000029,4,0.000007,$package->add_package_symbol( $symbol, $methods{$to_install} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000015,2,0.000008,return ( $methods{import}, $methods{unimport}, $methods{init_meta} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_exporter {
0.000004,2,0.000002,my ($class, $exports, $is_reexport, $meta_lookup) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return Sub::Exporter::build_exporter(
0.000000,0,0.000000,{
0.000000,0,0.000000,exports   => $exports,
0.000000,0,0.000000,groups    => { default => [':all'] },
0.000000,0,0.000000,installer => sub {
0.000005,3,0.000002,my ($arg, $to_export) = @_;
0.000017,3,0.000006,my $meta = $meta_lookup->($arg->{into});
0.000000,0,0.000000,
0.000014,3,0.000005,goto &Sub::Exporter::default_installer unless $meta;
0.000000,0,0.000000,
0.000000,0,0.000000,# don't overwrite existing symbols with our magically flagged
0.000000,0,0.000000,# version of it if we would install the same sub that's already
0.000000,0,0.000000,# in the importer
0.000000,0,0.000000,
0.000003,2,0.000001,my @filtered_to_export;
0.000003,2,0.000002,my %installed;
0.000105,2,0.000053,for (my $i = 0; $i < @{ $to_export }; $i += 2) {
0.000055,31,0.000002,my ($as, $cv) = @{ $to_export }[$i, $i + 1];
0.000000,0,0.000000,
0.000177,31,0.000006,next if !ref($as)
0.000000,0,0.000000,&& $meta->has_package_symbol('&' . $as)
0.000000,0,0.000000,&& $meta->get_package_symbol('&' . $as) == $cv;
0.000000,0,0.000000,
0.000058,31,0.000002,push @filtered_to_export, $as, $cv;
0.000067,31,0.000002,$installed{$as} = 1 unless ref $as;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,2,0.000006,Sub::Exporter::default_installer($arg, \@filtered_to_export);
0.000000,0,0.000000,
0.000022,2,0.000011,for my $name ( keys %{$is_reexport} ) {
0.000036,2,0.000018,no strict 'refs';
0.000870,2,0.000435,no warnings 'once';
0.000003,2,0.000002,next unless exists $installed{$name};
0.000029,2,0.000015,_flag_as_reexport( \*{ join q{::}, $arg->{into}, $name } );
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,}
0.000037,2,0.000018,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _follow_also {
0.000003,2,0.000002,my $class             = shift;
0.000003,2,0.000002,my $exporting_package = shift;
0.000000,0,0.000000,
0.000012,2,0.000006,_die_if_cycle_found_in_also_list_for_package($exporting_package);
0.000000,0,0.000000,
0.000041,2,0.000021,return uniq( _follow_also_real($exporting_package) );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _follow_also_real {
0.000003,2,0.000002,my $exporting_package = shift;
0.000010,2,0.000005,my @also              = _also_list_for_package($exporting_package);
0.000000,0,0.000000,
0.000012,2,0.000006,return map { $_, _follow_also_real($_) } @also;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _also_list_for_package {
0.000006,4,0.000001,my $package = shift;
0.000000,0,0.000000,
0.000007,4,0.000002,if ( !exists $EXPORT_SPEC{$package} ) {
0.000000,0,0.000000,my $loaded = is_class_loaded($package);
0.000000,0,0.000000,
0.000000,0,0.000000,die "Package in also ($package) does not seem to "
0.000000,0,0.000000,. "use Moose::Exporter"
0.000000,0,0.000000,. ( $loaded ? "" : " (is it loaded?)" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,4,0.000002,my $also = $EXPORT_SPEC{$package}{also};
0.000000,0,0.000000,
0.000027,4,0.000007,return unless defined $also;
0.000000,0,0.000000,
0.000000,0,0.000000,return ref $also ? @$also : $also;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this is no Tarjan algorithm, but for the list sizes expected,
0.000000,0,0.000000,# brute force will probably be fine (and more maintainable)
0.000000,0,0.000000,sub _die_if_cycle_found_in_also_list_for_package {
0.000003,2,0.000002,my $package = shift;
0.000030,2,0.000015,_die_if_also_list_cycles_back_to_existing_stack(
0.000000,0,0.000000,[ _also_list_for_package($package) ],
0.000000,0,0.000000,[$package],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _die_if_also_list_cycles_back_to_existing_stack {
0.000004,2,0.000002,my ( $also_list, $existing_stack ) = @_;
0.000000,0,0.000000,
0.000013,2,0.000007,return unless @$also_list && @$existing_stack;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $also_member (@$also_list) {
0.000000,0,0.000000,for my $stack_member (@$existing_stack) {
0.000000,0,0.000000,next unless $also_member eq $stack_member;
0.000000,0,0.000000,
0.000000,0,0.000000,die
0.000000,0,0.000000,"Circular reference in 'also' parameter to Moose::Exporter between "
0.000000,0,0.000000,. join(
0.000000,0,0.000000,', ',
0.000000,0,0.000000,@$existing_stack
0.000000,0,0.000000,) . " and $also_member";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,_die_if_also_list_cycles_back_to_existing_stack(
0.000000,0,0.000000,[ _also_list_for_package($also_member) ],
0.000000,0,0.000000,[ $also_member, @$existing_stack ],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parse_trait_aliases {
0.000003,2,0.000002,my $class   = shift;
0.000004,2,0.000002,my ($package, $aliases) = @_;
0.000000,0,0.000000,
0.000003,2,0.000001,my @ret;
0.000007,2,0.000003,for my $alias (@$aliases) {
0.000000,0,0.000000,my $name;
0.000000,0,0.000000,if (ref($alias)) {
0.000000,0,0.000000,reftype($alias) eq 'ARRAY'
0.000000,0,0.000000,or Moose->throw_error(reftype($alias) . " references are not "
0.000000,0,0.000000,. "valid arguments to the 'trait_aliases' "
0.000000,0,0.000000,. "option");
0.000000,0,0.000000,
0.000000,0,0.000000,($alias, $name) = @$alias;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,($name = $alias) =~ s/.*:://;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @ret, subname "${package}::${name}" => sub () { $alias };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,2,0.000007,return @ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_sub_exporter_params {
0.000004,2,0.000002,my $class                = shift;
0.000002,2,0.000001,my $packages             = shift;
0.000003,2,0.000002,my $export_recorder      = shift;
0.000003,2,0.000002,my $is_reexport          = shift;
0.000004,2,0.000002,my $meta_lookup_override = shift;
0.000000,0,0.000000,
0.000003,2,0.000001,my %exports;
0.000003,2,0.000001,my $current_meta_lookup;
0.000000,0,0.000000,
0.000008,2,0.000004,for my $package ( @{$packages} ) {
0.000004,2,0.000002,my $args = $EXPORT_SPEC{$package}
0.000000,0,0.000000,or die "The $package package does not use Moose::Exporter\n";
0.000000,0,0.000000,
0.000004,2,0.000002,$current_meta_lookup = $meta_lookup_override || $args->{meta_lookup};
0.000003,2,0.000001,$meta_lookup_override = $current_meta_lookup;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta_lookup = $current_meta_lookup
0.000087,10,0.000009,|| sub { Class::MOP::class_of(shift) };
0.000000,0,0.000000,
0.000007,2,0.000004,for my $name ( @{ $args->{with_meta} } ) {
0.000043,8,0.000005,my $sub = $class->_sub_from_package( $package, $name )
0.000000,0,0.000000,or next;
0.000000,0,0.000000,
0.000014,8,0.000002,my $fq_name = $package . '::' . $name;
0.000000,0,0.000000,
0.000062,8,0.000008,$exports{$name} = $class->_make_wrapped_sub_with_meta(
0.000000,0,0.000000,$fq_name,
0.000000,0,0.000000,$sub,
0.000000,0,0.000000,$export_recorder,
0.000000,0,0.000000,$meta_lookup,
0.000000,0,0.000000,) unless exists $exports{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,2,0.000004,for my $name ( @{ $args->{with_caller} } ) {
0.000000,0,0.000000,my $sub = $class->_sub_from_package( $package, $name )
0.000000,0,0.000000,or next;
0.000000,0,0.000000,
0.000000,0,0.000000,my $fq_name = $package . '::' . $name;
0.000000,0,0.000000,
0.000000,0,0.000000,$exports{$name} = $class->_make_wrapped_sub(
0.000000,0,0.000000,$fq_name,
0.000000,0,0.000000,$sub,
0.000000,0,0.000000,$export_recorder,
0.000000,0,0.000000,) unless exists $exports{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,2,0.000007,my @extra_exports = $class->_parse_trait_aliases(
0.000000,0,0.000000,$package, $args->{trait_aliases},
0.000000,0,0.000000,);
0.000013,2,0.000007,for my $name ( @{ $args->{as_is} }, @extra_exports ) {
0.000032,23,0.000001,my ( $sub, $coderef_name );
0.000000,0,0.000000,
0.000076,23,0.000003,if ( ref $name ) {
0.000003,2,0.000001,$sub = $name;
0.000000,0,0.000000,
0.000003,2,0.000001,my $coderef_pkg;
0.000018,2,0.000009,( $coderef_pkg, $coderef_name )
0.000000,0,0.000000,= Class::MOP::get_code_info($name);
0.000000,0,0.000000,
0.000005,2,0.000002,if ( $coderef_pkg ne $package ) {
0.000000,0,0.000000,$is_reexport->{$coderef_name} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000110,21,0.000005,$sub = $class->_sub_from_package( $package, $name )
0.000000,0,0.000000,or next;
0.000000,0,0.000000,
0.000033,21,0.000002,$coderef_name = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000056,23,0.000002,$export_recorder->{$sub} = 1;
0.000000,0,0.000000,
0.000217,42,0.000005,$exports{$coderef_name} = sub { $sub }
0.000107,23,0.000005,unless exists $exports{$coderef_name};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,2,0.000008,return \%exports;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _sub_from_package {
0.000043,29,0.000001,my $sclass  = shift;
0.000041,29,0.000001,my $package = shift;
0.000041,29,0.000001,my $name    = shift;
0.000000,0,0.000000,
0.000083,29,0.000003,my $sub = do {
0.001602,2,0.000801,no strict 'refs';
0.000074,29,0.000003,\&{ $package . '::' . $name };
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000156,29,0.000005,return $sub if defined &$sub;
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::cluck "Trying to export undefined sub ${package}::${name}";
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,our $CALLER;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_wrapped_sub {
0.000000,0,0.000000,my $self            = shift;
0.000000,0,0.000000,my $fq_name         = shift;
0.000000,0,0.000000,my $sub             = shift;
0.000000,0,0.000000,my $export_recorder = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to set the package at import time, so that when
0.000000,0,0.000000,# package Foo imports has(), we capture "Foo" as the
0.000000,0,0.000000,# package. This lets other packages call Foo::has() and get
0.000000,0,0.000000,# the right package. This is done for backwards compatibility
0.000000,0,0.000000,# with existing production code, not because this is a good
0.000000,0,0.000000,# idea ;)
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $caller = $CALLER;
0.000000,0,0.000000,
0.000000,0,0.000000,my $wrapper = $self->_curry_wrapper( $sub, $fq_name, $caller );
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = subname( $fq_name => $wrapper );
0.000000,0,0.000000,
0.000000,0,0.000000,$export_recorder->{$sub} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,return $sub;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_wrapped_sub_with_meta {
0.000013,8,0.000002,my $self            = shift;
0.000012,8,0.000002,my $fq_name         = shift;
0.000011,8,0.000001,my $sub             = shift;
0.000011,8,0.000001,my $export_recorder = shift;
0.000011,8,0.000001,my $meta_lookup     = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000012,8,0.000002,my $caller = $CALLER;
0.000000,0,0.000000,
0.000044,8,0.000005,my $wrapper = $self->_late_curry_wrapper(
0.000000,0,0.000000,$sub, $fq_name,
0.000000,0,0.000000,$meta_lookup => $caller
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000073,8,0.000009,my $sub = subname( $fq_name => $wrapper );
0.000000,0,0.000000,
0.000019,8,0.000002,$export_recorder->{$sub} = 1;
0.000000,0,0.000000,
0.000049,8,0.000006,return $sub;
0.000058,8,0.000007,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _curry_wrapper {
0.000000,0,0.000000,my $class   = shift;
0.000000,0,0.000000,my $sub     = shift;
0.000000,0,0.000000,my $fq_name = shift;
0.000000,0,0.000000,my @extra   = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $wrapper = sub { $sub->( @extra, @_ ) };
0.000000,0,0.000000,if ( my $proto = prototype $sub ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX - Perl's prototype sucks. Use & to make set_prototype
0.000000,0,0.000000,# ignore the fact that we're passing "private variables"
0.000000,0,0.000000,&Scalar::Util::set_prototype( $wrapper, $proto );
0.000000,0,0.000000,}
0.000000,0,0.000000,return $wrapper;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _late_curry_wrapper {
0.000012,8,0.000002,my $class   = shift;
0.000012,8,0.000001,my $sub     = shift;
0.000012,8,0.000002,my $fq_name = shift;
0.000011,8,0.000001,my $extra   = shift;
0.000015,8,0.000002,my @ex_args = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $wrapper = sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# resolve curried arguments at runtime via this closure
0.000052,8,0.000007,my @curry = ( $extra->(@ex_args) );
0.000095,8,0.000012,return $sub->( @curry, @_ );
0.000026,8,0.000003,};
0.000000,0,0.000000,
0.000012,8,0.000002,if ( my $proto = prototype $sub ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX - Perl's prototype sucks. Use & to make set_prototype
0.000000,0,0.000000,# ignore the fact that we're passing "private variables"
0.000000,0,0.000000,&Scalar::Util::set_prototype( $wrapper, $proto );
0.000000,0,0.000000,}
0.000048,8,0.000006,return $wrapper;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_import_sub {
0.000003,2,0.000002,shift;
0.000003,2,0.000002,my $exporting_package = shift;
0.000003,2,0.000002,my $exporter          = shift;
0.000003,2,0.000002,my $exports_from      = shift;
0.000003,2,0.000002,my $is_reexport       = shift;
0.000005,2,0.000003,my $meta_lookup       = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,
0.000000,0,0.000000,# I think we could use Sub::Exporter's collector feature
0.000000,0,0.000000,# to do this, but that would be rather gross, since that
0.000000,0,0.000000,# feature isn't really designed to return a value to the
0.000000,0,0.000000,# caller of the exporter sub.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Also, this makes sure we preserve backwards compat for
0.000000,0,0.000000,# _get_caller, so it always sees the arguments in the
0.000000,0,0.000000,# expected order.
0.000004,3,0.000001,my $traits;
0.000023,3,0.000008,( $traits, @_ ) = _strip_traits(@_);
0.000000,0,0.000000,
0.000005,3,0.000002,my $metaclass;
0.000020,3,0.000007,( $metaclass, @_ ) = _strip_metaclass(@_);
0.000005,3,0.000002,$metaclass
0.000000,0,0.000000,= Moose::Util::resolve_metaclass_alias( 'Class' => $metaclass )
0.000000,0,0.000000,if defined $metaclass && length $metaclass;
0.000000,0,0.000000,
0.000005,3,0.000002,my $meta_name;
0.000022,3,0.000007,( $meta_name, @_ ) = _strip_meta_name(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,# Normally we could look at $_[0], but in some weird cases
0.000000,0,0.000000,# (involving goto &Moose::import), $_[0] ends as something
0.000000,0,0.000000,# else (like Squirrel).
0.000005,3,0.000002,my $class = $exporting_package;
0.000000,0,0.000000,
0.000019,3,0.000006,$CALLER = _get_caller(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,# this works because both pragmas set $^H (see perldoc
0.000000,0,0.000000,# perlvar) which affects the current compilation -
0.000000,0,0.000000,# i.e. the file who use'd us - which is why we don't need
0.000000,0,0.000000,# to do anything special to make it affect that file
0.000000,0,0.000000,# rather than this one (which is already compiled)
0.000000,0,0.000000,
0.000020,3,0.000007,strict->import;
0.000019,3,0.000006,warnings->import;
0.000000,0,0.000000,
0.000005,3,0.000002,my $did_init_meta;
0.000059,6,0.000010,for my $c ( grep { $_->can('init_meta') } $class, @{$exports_from} ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# init_meta can apply a role, which when loaded uses
0.000000,0,0.000000,# Moose::Exporter, which in turn sets $CALLER, so we need
0.000000,0,0.000000,# to protect against that.
0.000002,1,0.000002,local $CALLER = $CALLER;
0.000006,1,0.000006,$c->init_meta(
0.000000,0,0.000000,for_class => $CALLER,
0.000000,0,0.000000,metaclass => $metaclass,
0.000000,0,0.000000,meta_name => $meta_name,
0.000000,0,0.000000,);
0.000004,1,0.000004,$did_init_meta = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# The metaroles will use Moose::Role, which in turn uses
0.000000,0,0.000000,# Moose::Exporter, which in turn sets $CALLER, so we need
0.000000,0,0.000000,# to protect against that.
0.000015,6,0.000002,local $CALLER = $CALLER;
0.000020,3,0.000007,_apply_metaroles(
0.000000,0,0.000000,$CALLER,
0.000000,0,0.000000,[$class, @$exports_from],
0.000000,0,0.000000,$meta_lookup
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,3,0.000002,if ( $did_init_meta && @{$traits} ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# The traits will use Moose::Role, which in turn uses
0.000000,0,0.000000,# Moose::Exporter, which in turn sets $CALLER, so we need
0.000000,0,0.000000,# to protect against that.
0.000000,0,0.000000,local $CALLER = $CALLER;
0.000000,0,0.000000,_apply_meta_traits( $CALLER, $traits, $meta_lookup );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( @{$traits} ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error(
0.000000,0,0.000000,"Cannot provide traits when $class does not have an init_meta() method"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,3,0.000002,my ( undef, @args ) = @_;
0.000005,3,0.000002,my $extra = shift @args if ref $args[0] eq 'HASH';
0.000000,0,0.000000,
0.000005,3,0.000002,$extra ||= {};
0.000010,3,0.000003,if ( !$extra->{into} ) {
0.000006,3,0.000002,$extra->{into_level} ||= 0;
0.000005,3,0.000002,$extra->{into_level}++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000050,3,0.000017,$class->$exporter( $extra, @args );
0.000020,2,0.000010,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _strip_traits {
0.000076,6,0.000013,my $idx = first_index { ( $_ || '' ) eq '-traits' } @_;
0.000000,0,0.000000,
0.000025,3,0.000008,return ( [], @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $traits = $_[ $idx + 1 ];
0.000000,0,0.000000,
0.000000,0,0.000000,splice @_, $idx, 2;
0.000000,0,0.000000,
0.000000,0,0.000000,$traits = [$traits] unless ref $traits;
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $traits, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _strip_metaclass {
0.000038,6,0.000006,my $idx = first_index { ( $_ || '' ) eq '-metaclass' } @_;
0.000000,0,0.000000,
0.000020,3,0.000007,return ( undef, @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $metaclass = $_[ $idx + 1 ];
0.000000,0,0.000000,
0.000000,0,0.000000,splice @_, $idx, 2;
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $metaclass, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _strip_meta_name {
0.000036,6,0.000006,my $idx = first_index { ( $_ || '' ) eq '-meta_name' } @_;
0.000000,0,0.000000,
0.000020,3,0.000007,return ( 'meta', @_ ) unless $idx >= 0 && $#_ >= $idx + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta_name = $_[ $idx + 1 ];
0.000000,0,0.000000,
0.000000,0,0.000000,splice @_, $idx, 2;
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $meta_name, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _apply_metaroles {
0.000006,3,0.000002,my ($class, $exports_from, $meta_lookup) = @_;
0.000000,0,0.000000,
0.000017,3,0.000006,my $metaroles = _collect_metaroles($exports_from);
0.000005,3,0.000002,my $base_class_roles = delete $metaroles->{base_class_roles};
0.000000,0,0.000000,
0.000019,3,0.000006,my $meta = $meta_lookup->($class);
0.000000,0,0.000000,# for instance, Moose.pm uses Moose::Util::TypeConstraints
0.000010,3,0.000003,return unless $meta;
0.000000,0,0.000000,
0.000004,2,0.000002,Moose::Util::MetaRole::apply_metaroles(
0.000000,0,0.000000,for => $meta,
0.000000,0,0.000000,%$metaroles,
0.000000,0,0.000000,) if keys %$metaroles;
0.000000,0,0.000000,
0.000027,2,0.000013,Moose::Util::MetaRole::apply_base_class_roles(
0.000000,0,0.000000,for   => $meta,
0.000000,0,0.000000,roles => $base_class_roles,
0.000000,0,0.000000,) if $meta->isa('Class::MOP::Class')
0.000000,0,0.000000,&& $base_class_roles && @$base_class_roles;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _collect_metaroles {
0.000005,3,0.000002,my ($exports_from) = @_;
0.000000,0,0.000000,
0.000021,3,0.000007,my @old_style_role_types = map { "${_}_roles" } qw(
0.000000,0,0.000000,metaclass
0.000000,0,0.000000,attribute_metaclass
0.000000,0,0.000000,method_metaclass
0.000000,0,0.000000,wrapped_method_metaclass
0.000000,0,0.000000,instance_metaclass
0.000000,0,0.000000,constructor_class
0.000000,0,0.000000,destructor_class
0.000000,0,0.000000,error_class
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,3,0.000001,my %class_metaroles;
0.000004,3,0.000001,my %role_metaroles;
0.000004,3,0.000001,my @base_class_roles;
0.000004,3,0.000001,my %old_style_roles;
0.000000,0,0.000000,
0.000010,3,0.000003,for my $exporter (@$exports_from) {
0.000006,3,0.000002,my $data = $EXPORT_SPEC{$exporter};
0.000000,0,0.000000,
0.000007,3,0.000002,if (exists $data->{class_metaroles}) {
0.000000,0,0.000000,for my $type (keys %{ $data->{class_metaroles} }) {
0.000000,0,0.000000,push @{ $class_metaroles{$type} ||= [] },
0.000000,0,0.000000,@{ $data->{class_metaroles}{$type} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,3,0.000002,if (exists $data->{role_metaroles}) {
0.000000,0,0.000000,for my $type (keys %{ $data->{role_metaroles} }) {
0.000000,0,0.000000,push @{ $role_metaroles{$type} ||= [] },
0.000000,0,0.000000,@{ $data->{role_metaroles}{$type} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,3,0.000002,if (exists $data->{base_class_roles}) {
0.000000,0,0.000000,push @base_class_roles, @{ $data->{base_class_roles} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000015,3,0.000005,for my $type (@old_style_role_types) {
0.000070,24,0.000003,if (exists $data->{$type}) {
0.000000,0,0.000000,push @{ $old_style_roles{$type} ||= [] },
0.000000,0,0.000000,@{ $data->{$type} };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000027,3,0.000009,(keys(%class_metaroles)
0.000000,0,0.000000,? (class_metaroles  => \%class_metaroles)
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,(keys(%role_metaroles)
0.000000,0,0.000000,? (role_metaroles   => \%role_metaroles)
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,(@base_class_roles
0.000000,0,0.000000,? (base_class_roles => \@base_class_roles)
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,%old_style_roles,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _apply_meta_traits {
0.000000,0,0.000000,my ( $class, $traits, $meta_lookup ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return unless @{$traits};
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = $meta_lookup->($class);
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = $meta->isa('Moose::Meta::Role') ? 'Role'
0.000000,0,0.000000,: $meta->isa('Class::MOP::Class') ? 'Class'
0.000000,0,0.000000,: Moose->throw_error('Cannot determine metaclass type for '
0.000000,0,0.000000,. 'trait application. Meta isa '
0.000000,0,0.000000,. ref $meta);
0.000000,0,0.000000,
0.000000,0,0.000000,my @resolved_traits = map {
0.000000,0,0.000000,ref $_
0.000000,0,0.000000,? $_
0.000000,0,0.000000,: Moose::Util::resolve_metatrait_alias( $type => $_ )
0.000000,0,0.000000,} @$traits;
0.000000,0,0.000000,
0.000000,0,0.000000,return unless @resolved_traits;
0.000000,0,0.000000,
0.000000,0,0.000000,my %args = ( for => $class );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $meta->isa('Moose::Meta::Role') ) {
0.000000,0,0.000000,$args{role_metaroles} = { role => \@resolved_traits };
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$args{class_metaroles} = { class => \@resolved_traits };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Util::MetaRole::apply_metaroles(%args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_caller {
0.000000,0,0.000000,
0.000000,0,0.000000,# 1 extra level because it's called by import so there's a layer
0.000000,0,0.000000,# of indirection
0.000005,3,0.000002,my $offset = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000023,3,0.000008,( ref $_[1] && defined $_[1]->{into} ) ? $_[1]->{into}
0.000000,0,0.000000,: ( ref $_[1] && defined $_[1]->{into_level} )
0.000000,0,0.000000,? caller( $offset + $_[1]->{into_level} )
0.000000,0,0.000000,: caller($offset);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_unimport_sub {
0.000003,2,0.000002,shift;
0.000003,2,0.000002,my $exporting_package = shift;
0.000003,2,0.000001,my $exports           = shift;
0.000003,2,0.000001,my $export_recorder   = shift;
0.000003,2,0.000002,my $is_reexport       = shift;
0.000003,2,0.000002,my $meta_lookup       = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,my $caller = scalar caller();
0.000000,0,0.000000,Moose::Exporter->_remove_keywords(
0.000000,0,0.000000,$caller,
0.000000,0,0.000000,[ keys %{$exports} ],
0.000000,0,0.000000,$export_recorder,
0.000000,0,0.000000,$is_reexport,
0.000000,0,0.000000,);
0.000016,2,0.000008,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remove_keywords {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,my $package          = shift;
0.000000,0,0.000000,my $keywords         = shift;
0.000000,0,0.000000,my $recorded_exports = shift;
0.000000,0,0.000000,my $is_reexport      = shift;
0.000000,0,0.000000,
0.000072,2,0.000036,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $name ( @{$keywords} ) {
0.000000,0,0.000000,if ( defined &{ $package . '::' . $name } ) {
0.000000,0,0.000000,my $sub = \&{ $package . '::' . $name };
0.000000,0,0.000000,
0.000000,0,0.000000,# make sure it is from us
0.000000,0,0.000000,next unless $recorded_exports->{$sub};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $is_reexport->{$name} ) {
0.000282,2,0.000141,no strict 'refs';
0.000000,0,0.000000,next
0.000000,0,0.000000,unless _export_is_flagged(
0.000000,0,0.000000,\*{ join q{::} => $package, $name } );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# and if it is from us, then undef the slot
0.000000,0,0.000000,delete ${ $package . '::' }{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# maintain this for now for backcompat
0.000000,0,0.000000,# make sure to return a sub to install in the same circumstances as previously
0.000000,0,0.000000,# but this functionality now happens at the end of ->import
0.000000,0,0.000000,sub _make_init_meta {
0.000004,2,0.000002,shift;
0.000003,2,0.000002,my $class          = shift;
0.000003,2,0.000001,my $args           = shift;
0.000003,2,0.000001,my $meta_lookup    = shift;
0.000000,0,0.000000,
0.000003,2,0.000001,my %old_style_roles;
0.000017,2,0.000008,for my $role (
0.000000,0,0.000000,map {"${_}_roles"}
0.000000,0,0.000000,qw(
0.000000,0,0.000000,metaclass
0.000000,0,0.000000,attribute_metaclass
0.000000,0,0.000000,method_metaclass
0.000000,0,0.000000,wrapped_method_metaclass
0.000000,0,0.000000,instance_metaclass
0.000000,0,0.000000,constructor_class
0.000000,0,0.000000,destructor_class
0.000000,0,0.000000,error_class
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000048,16,0.000003,$old_style_roles{$role} = $args->{$role}
0.000000,0,0.000000,if exists $args->{$role};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,2,0.000001,my %base_class_roles;
0.000003,2,0.000002,%base_class_roles = ( roles => $args->{base_class_roles} )
0.000000,0,0.000000,if exists $args->{base_class_roles};
0.000000,0,0.000000,
0.000000,0,0.000000,my %new_style_roles = map { $_ => $args->{$_} }
0.000007,2,0.000003,grep { exists $args->{$_} } qw( class_metaroles role_metaroles );
0.000000,0,0.000000,
0.000014,2,0.000007,return unless %new_style_roles || %old_style_roles || %base_class_roles;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,my %opts = @_;
0.000000,0,0.000000,$meta_lookup->($opts{for_class});
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000011,2,0.000005,strict->import;
0.000021,2,0.000010,warnings->import;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: make an import() and unimport() just like Moose.pm
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
