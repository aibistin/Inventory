# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Pod::Simple::BlackBox;
0.000000,0,0.000000,#
0.000000,0,0.000000,# "What's in the box?"  "Pain."
0.000000,0,0.000000,#
0.000000,0,0.000000,###########################################################################
0.000000,0,0.000000,#
0.000000,0,0.000000,# This is where all the scary things happen: parsing lines into
0.000000,0,0.000000,#  paragraphs; and then into directives, verbatims, and then also
0.000000,0,0.000000,#  turning formatting sequences into treelets.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Are you really sure you want to read this code?
0.000000,0,0.000000,#
0.000000,0,0.000000,#-----------------------------------------------------------------------------
0.000000,0,0.000000,#
0.000000,0,0.000000,# The basic work of this module Pod::Simple::BlackBox is doing the dirty work
0.000000,0,0.000000,# of parsing Pod into treelets (generally one per non-verbatim paragraph), and
0.000000,0,0.000000,# to call the proper callbacks on the treelets.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Every node in a treelet is a ['name', {attrhash}, ...children...]
0.000000,0,0.000000,
0.000032,2,0.000016,use integer; # vroom!
0.000031,2,0.000015,use strict;
0.000029,2,0.000015,use Carp ();
0.000060,2,0.000030,use vars qw($VERSION );
0.000002,1,0.000002,$VERSION = '3.28';
0.000000,0,0.000000,#use constant DEBUG => 7;
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,require Pod::Simple;
0.000008,1,0.000008,*DEBUG = \&Pod::Simple::DEBUG unless defined &DEBUG
0.005167,1,0.005167,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_line { shift->parse_lines(@_) } # alias
0.000000,0,0.000000,
0.000000,0,0.000000,# - - -  Turn back now!  Run away!  - - -
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_lines {             # Usage: $parser->parse_lines(@lines)
0.000000,0,0.000000,# an undef means end-of-stream
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $code_handler = $self->{'code_handler'};
0.000000,0,0.000000,my $cut_handler  = $self->{'cut_handler'};
0.000000,0,0.000000,my $wl_handler   = $self->{'whiteline_handler'};
0.000000,0,0.000000,$self->{'line_count'} ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $scratch;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and 
0.000000,0,0.000000,print "# Parsing starting at line ", $self->{'line_count'}, ".\n";
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 5 and
0.000000,0,0.000000,print "#  About to parse lines: ",
0.000000,0,0.000000,join(' ', map defined($_) ? "[$_]" : "EOF", @_), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $paras = ($self->{'paras'} ||= []);
0.000000,0,0.000000,# paragraph buffer.  Because we need to defer processing of =over
0.000000,0,0.000000,# directives and verbatim paragraphs.  We call _ponder_paragraph_buffer
0.000000,0,0.000000,# to process this.
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'pod_para_count'} ||= 0;
0.000000,0,0.000000,
0.000000,0,0.000000,my $line;
0.000000,0,0.000000,foreach my $source_line (@_) {
0.000000,0,0.000000,if( $self->{'source_dead'} ) {
0.000000,0,0.000000,DEBUG > 4 and print "# Source is dead.\n";
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless( defined $source_line ) {
0.000000,0,0.000000,DEBUG > 4 and print "# Undef-line seen.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,push @$paras, ['~end', {'start_line' => $self->{'line_count'}}];
0.000000,0,0.000000,push @$paras, $paras->[-1], $paras->[-1];
0.000000,0,0.000000,# So that it definitely fills the buffer.
0.000000,0,0.000000,$self->{'source_dead'} = 1;
0.000000,0,0.000000,$self->_ponder_paragraph_buffer;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if( $self->{'line_count'}++ ) {
0.000000,0,0.000000,($line = $source_line) =~ tr/\n\r//d;
0.000000,0,0.000000,# If we don't have two vars, we'll end up with that there
0.000000,0,0.000000,# tr/// modding the (potentially read-only) original source line!
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print "First line: [$source_line]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if( ($line = $source_line) =~ s/^\xEF\xBB\xBF//s ) {
0.000000,0,0.000000,DEBUG and print "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";
0.000000,0,0.000000,$self->_handle_encoding_line( "=encoding utf8" );
0.000000,0,0.000000,delete $self->{'_processed_encoding'};
0.000000,0,0.000000,$line =~ tr/\n\r//d;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( $line =~ s/^\xFE\xFF//s ) {
0.000000,0,0.000000,DEBUG and print "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";
0.000000,0,0.000000,$self->scream(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
0.000000,0,0.000000,);
0.000000,0,0.000000,splice @_;
0.000000,0,0.000000,push @_, undef;
0.000000,0,0.000000,next;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: implement somehow?
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( $line =~ s/^\xFF\xFE//s ) {
0.000000,0,0.000000,DEBUG and print "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";
0.000000,0,0.000000,$self->scream(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet."
0.000000,0,0.000000,);
0.000000,0,0.000000,splice @_;
0.000000,0,0.000000,push @_, undef;
0.000000,0,0.000000,next;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: implement somehow?
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print "First line is BOM-less.\n";
0.000000,0,0.000000,($line = $source_line) =~ tr/\n\r//d;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Try to guess encoding. Inlined for performance reasons.
0.000000,0,0.000000,if(!$self->{'parse_characters'} && !$self->{'encoding'}
0.000000,0,0.000000,&& ($self->{'in_pod'} || $line =~ /^=/s)
0.000000,0,0.000000,&& $line =~ /[^\x00-\x7f]/
0.000000,0,0.000000,) {
0.000000,0,0.000000,my $encoding = $line =~ /^[\x00-\x7f]*[\xC0-\xFD][\x80-\xBF]/ ? 'UTF-8' : 'ISO8859-1';
0.000000,0,0.000000,$self->_handle_encoding_line( "=encoding $encoding" );
0.000000,0,0.000000,$self->{'_transcoder'} && $self->{'_transcoder'}->($line);
0.000000,0,0.000000,
0.000000,0,0.000000,my ($word) = $line =~ /(\S*[^\x00-\x7f]\S*)/;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"Non-ASCII character seen before =encoding in '$word'. Assuming $encoding"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 5 and print "# Parsing line: [$line]\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'in_pod'}) {
0.000000,0,0.000000,if($line =~ m/^=([a-zA-Z]+)/s) {
0.000000,0,0.000000,if($1 eq 'cut') {
0.000000,0,0.000000,$self->scream(
0.000000,0,0.000000,$self->{'line_count'},
0.000000,0,0.000000,"=cut found outside a pod block.  Skipping to next block."
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## Before there were errata sections in the world, it was
0.000000,0,0.000000,## least-pessimal to abort processing the file.  But now we can
0.000000,0,0.000000,## just barrel on thru (but still not start a pod block).
0.000000,0,0.000000,#splice @_;
0.000000,0,0.000000,#push @_, undef;
0.000000,0,0.000000,
0.000000,0,0.000000,next;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{'in_pod'} = $self->{'start_of_pod_block'}
0.000000,0,0.000000,= $self->{'last_was_blank'}     = 1;
0.000000,0,0.000000,# And fall thru to the pod-mode block further down
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print "# It's a code-line.\n";
0.000000,0,0.000000,$code_handler->(map $_, $line, $self->{'line_count'}, $self)
0.000000,0,0.000000,if $code_handler;
0.000000,0,0.000000,# Note: this may cause code to be processed out of order relative
0.000000,0,0.000000,#  to pods, but in order relative to cuts.
0.000000,0,0.000000,
0.000000,0,0.000000,# Note also that we haven't yet applied the transcoding to $line
0.000000,0,0.000000,#  by time we call $code_handler!
0.000000,0,0.000000,
0.000000,0,0.000000,if( $line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/ ) {
0.000000,0,0.000000,# That RE is from perlsyn, section "Plain Old Comments (Not!)",
0.000000,0,0.000000,#$fname = $2 if defined $2;
0.000000,0,0.000000,#DEBUG > 1 and defined $2 and print "# Setting fname to \"$fname\"\n";
0.000000,0,0.000000,DEBUG > 1 and print "# Setting nextline to $1\n";
0.000000,0,0.000000,$self->{'line_count'} = $1 - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
0.000000,0,0.000000,# Else we're in pod mode:
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply any necessary transcoding:
0.000000,0,0.000000,$self->{'_transcoder'} && $self->{'_transcoder'}->($line);
0.000000,0,0.000000,
0.000000,0,0.000000,# HERE WE CATCH =encoding EARLY!
0.000000,0,0.000000,if( $line =~ m/^=encoding\s+\S+\s*$/s ) {
0.000000,0,0.000000,next if $self->parse_characters;   # Ignore this line
0.000000,0,0.000000,$line = $self->_handle_encoding_line( $line );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($line =~ m/^=cut/s) {
0.000000,0,0.000000,# here ends the pod block, and therefore the previous pod para
0.000000,0,0.000000,DEBUG > 1 and print "Noting =cut at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,$self->{'in_pod'} = 0;
0.000000,0,0.000000,# ++$self->{'pod_para_count'};
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,$cut_handler->(map $_, $line, $self->{'line_count'}, $self)
0.000000,0,0.000000,if $cut_handler;
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: add to docs: Note: this may cause cuts to be processed out
0.000000,0,0.000000,#  of order relative to pods, but in order relative to code.
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($line =~ m/^(\s*)$/s) {  # it's a blank line
0.000000,0,0.000000,if (defined $1 and $1 =~ /[^\S\r\n]/) { # it's a white line
0.000000,0,0.000000,$wl_handler->(map $_, $line, $self->{'line_count'}, $self)
0.000000,0,0.000000,if $wl_handler;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
0.000000,0,0.000000,DEBUG > 1 and print "Saving blank line at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,push @{$paras->[-1]}, $line;
0.000000,0,0.000000,}  # otherwise it's not interesting
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'start_of_pod_block'} and !$self->{'last_was_blank'}) {
0.000000,0,0.000000,DEBUG > 1 and print "Noting para ends with blank line at ${$self}{'line_count'}\n"; 
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'last_was_blank'} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($self->{'last_was_blank'}) {  # A non-blank line starting a new para...
0.000000,0,0.000000,
0.000000,0,0.000000,if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(?:\s+|$)(.*)/s) {
0.000000,0,0.000000,# THIS IS THE ONE PLACE WHERE WE CONSTRUCT NEW DIRECTIVE OBJECTS
0.000000,0,0.000000,my $new = [$1, {'start_line' => $self->{'line_count'}}, $2];
0.000000,0,0.000000,# Note that in "=head1 foo", the WS is lost.
0.000000,0,0.000000,# Example: ['=head1', {'start_line' => 123}, ' foo']
0.000000,0,0.000000,
0.000000,0,0.000000,++$self->{'pod_para_count'};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,
0.000000,0,0.000000,push @$paras, $new; # the new incipient paragraph
0.000000,0,0.000000,DEBUG > 1 and print "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($line =~ m/^\s/s) {
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$self->{'start_of_pod_block'} and @$paras and $paras->[-1][0] eq '~Verbatim') {
0.000000,0,0.000000,DEBUG > 1 and print "Resuming verbatim para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,push @{$paras->[-1]}, $line;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,++$self->{'pod_para_count'};
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,DEBUG > 1 and print "Starting verbatim para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,push @$paras, ['~Verbatim', {'start_line' => $self->{'line_count'}}, $line];
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,++$self->{'pod_para_count'};
0.000000,0,0.000000,$self->_ponder_paragraph_buffer();
0.000000,0,0.000000,# by now it's safe to consider the previous paragraph as done.
0.000000,0,0.000000,push @$paras, ['~Para',  {'start_line' => $self->{'line_count'}}, $line];
0.000000,0,0.000000,DEBUG > 1 and print "Starting plain para at line ${$self}{'line_count'}\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# It's a non-blank line /continuing/ the current para
0.000000,0,0.000000,if(@$paras) {
0.000000,0,0.000000,DEBUG > 2 and print "Line ${$self}{'line_count'} continues current paragraph\n";
0.000000,0,0.000000,push @{$paras->[-1]}, $line;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Unexpected case!
0.000000,0,0.000000,die "Continuing a paragraph but \@\$paras is empty?";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{'last_was_blank'} = $self->{'start_of_pod_block'} = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} # ends the big while loop
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print(pretty(@$paras), "\n");
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_encoding_line {
0.000000,0,0.000000,my($self, $line) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $self->parse_characters;
0.000000,0,0.000000,
0.000000,0,0.000000,# The point of this routine is to set $self->{'_transcoder'} as indicated.
0.000000,0,0.000000,
0.000000,0,0.000000,return $line unless $line =~ m/^=encoding\s+(\S+)\s*$/s;
0.000000,0,0.000000,DEBUG > 1 and print "Found an encoding line \"=encoding $1\"\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $e    = $1;
0.000000,0,0.000000,my $orig = $e;
0.000000,0,0.000000,push @{ $self->{'encoding_command_reqs'} }, "=encoding $orig";
0.000000,0,0.000000,
0.000000,0,0.000000,my $enc_error;
0.000000,0,0.000000,
0.000000,0,0.000000,# Cf.   perldoc Encode   and   perldoc Encode::Supported
0.000000,0,0.000000,
0.000000,0,0.000000,require Pod::Simple::Transcode;
0.000000,0,0.000000,
0.000000,0,0.000000,if( $self->{'encoding'} ) {
0.000000,0,0.000000,my $norm_current = $self->{'encoding'};
0.000000,0,0.000000,my $norm_e = $e;
0.000000,0,0.000000,foreach my $that ($norm_current, $norm_e) {
0.000000,0,0.000000,$that =  lc($that);
0.000000,0,0.000000,$that =~ s/[-_]//g;
0.000000,0,0.000000,}
0.000000,0,0.000000,if($norm_current eq $norm_e) {
0.000000,0,0.000000,DEBUG > 1 and print "The '=encoding $orig' line is ",
0.000000,0,0.000000,"redundant.  ($norm_current eq $norm_e).  Ignoring.\n";
0.000000,0,0.000000,$enc_error = '';
0.000000,0,0.000000,# But that doesn't necessarily mean that the earlier one went okay
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$enc_error = "Encoding is already set to " . $self->{'encoding'};
0.000000,0,0.000000,DEBUG > 1 and print $enc_error;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif (
0.000000,0,0.000000,# OK, let's turn on the encoding
0.000000,0,0.000000,do {
0.000000,0,0.000000,DEBUG > 1 and print " Setting encoding to $e\n";
0.000000,0,0.000000,$self->{'encoding'} = $e;
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,and $e eq 'HACKRAW'
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG and print " Putting in HACKRAW (no-op) encoding mode.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( Pod::Simple::Transcode::->encoding_is_available($e) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,die($enc_error = "WHAT? _transcoder is already set?!")
0.000000,0,0.000000,if $self->{'_transcoder'};   # should never happen
0.000000,0,0.000000,require Pod::Simple::Transcode;
0.000000,0,0.000000,$self->{'_transcoder'} = Pod::Simple::Transcode::->make_transcoder($e);
0.000000,0,0.000000,eval {
0.000000,0,0.000000,my @x = ('', "abc", "123");
0.000000,0,0.000000,$self->{'_transcoder'}->(@x);
0.000000,0,0.000000,};
0.000000,0,0.000000,$@ && die( $enc_error =
0.000000,0,0.000000,"Really unexpected error setting up encoding $e: $@\nAborting"
0.000000,0,0.000000,);
0.000000,0,0.000000,$self->{'detected_encoding'} = $e;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my @supported = Pod::Simple::Transcode::->all_encodings;
0.000000,0,0.000000,
0.000000,0,0.000000,# Note unsupported, and complain
0.000000,0,0.000000,DEBUG and print " Encoding [$e] is unsupported.",
0.000000,0,0.000000,"\nSupporteds: @supported\n";
0.000000,0,0.000000,my $suggestion = '';
0.000000,0,0.000000,
0.000000,0,0.000000,# Look for a near match:
0.000000,0,0.000000,my $norm = lc($e);
0.000000,0,0.000000,$norm =~ tr[-_][]d;
0.000000,0,0.000000,my $n;
0.000000,0,0.000000,foreach my $enc (@supported) {
0.000000,0,0.000000,$n = lc($enc);
0.000000,0,0.000000,$n =~ tr[-_][]d;
0.000000,0,0.000000,next unless $n eq $norm;
0.000000,0,0.000000,$suggestion = "  (Maybe \"$e\" should be \"$enc\"?)";
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $encmodver = Pod::Simple::Transcode::->encmodver;
0.000000,0,0.000000,$enc_error = join '' =>
0.000000,0,0.000000,"This document probably does not appear as it should, because its ",
0.000000,0,0.000000,"\"=encoding $e\" line calls for an unsupported encoding.",
0.000000,0,0.000000,$suggestion, "  [$encmodver\'s supported encodings are: @supported]"
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->scream( $self->{'line_count'}, $enc_error );
0.000000,0,0.000000,}
0.000000,0,0.000000,push @{ $self->{'encoding_command_statuses'} }, $enc_error;
0.000000,0,0.000000,if (defined($self->{'_processed_encoding'})) {
0.000000,0,0.000000,# Should never happen
0.000000,0,0.000000,die "Nested processed encoding.";
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->{'_processed_encoding'} = $orig;
0.000000,0,0.000000,
0.000000,0,0.000000,return $line;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
0.000000,0,0.000000,
0.000000,0,0.000000,sub _handle_encoding_second_level {
0.000000,0,0.000000,# By time this is called, the encoding (if well formed) will already
0.000000,0,0.000000,#  have been acted one.
0.000000,0,0.000000,my($self, $para) = @_;
0.000000,0,0.000000,my @x = @$para;
0.000000,0,0.000000,my $content = join ' ', splice @x, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and print "Ogling encoding directive: =encoding $content\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined($self->{'_processed_encoding'})) {
0.000000,0,0.000000,#if($content ne $self->{'_processed_encoding'}) {
0.000000,0,0.000000,#  Could it happen?
0.000000,0,0.000000,#}
0.000000,0,0.000000,delete $self->{'_processed_encoding'};
0.000000,0,0.000000,# It's already been handled.  Check for errors.
0.000000,0,0.000000,if(! $self->{'encoding_command_statuses'} ) {
0.000000,0,0.000000,DEBUG > 2 and print " CRAZY ERROR: It wasn't really handled?!\n";
0.000000,0,0.000000,} elsif( $self->{'encoding_command_statuses'}[-1] ) {
0.000000,0,0.000000,$self->whine( $para->[1]{'start_line'},
0.000000,0,0.000000,sprintf "Couldn't do %s: %s",
0.000000,0,0.000000,$self->{'encoding_command_reqs'  }[-1],
0.000000,0,0.000000,$self->{'encoding_command_statuses'}[-1],
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 2 and print " (Yup, it was successfully handled already.)\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Otherwise it's a syntax error
0.000000,0,0.000000,$self->whine( $para->[1]{'start_line'},
0.000000,0,0.000000,"Invalid =encoding syntax: $content"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`~`
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000005,2,0.000002,my $m = -321;   # magic line number
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_errata {
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,# Return 0 or more fake-o paragraphs explaining the accumulated
0.000000,0,0.000000,#  errors on this document.
0.000000,0,0.000000,
0.000000,0,0.000000,return() unless $self->{'errata'} and keys %{$self->{'errata'}};
0.000000,0,0.000000,
0.000000,0,0.000000,my @out;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $line (sort {$a <=> $b} keys %{$self->{'errata'}}) {
0.000000,0,0.000000,push @out,
0.000000,0,0.000000,['=item', {'start_line' => $m}, "Around line $line:"],
0.000000,0,0.000000,map( ['~Para', {'start_line' => $m, '~cooked' => 1},
0.000000,0,0.000000,#['~Top', {'start_line' => $m},
0.000000,0,0.000000,$_
0.000000,0,0.000000,#]
0.000000,0,0.000000,],
0.000000,0,0.000000,@{$self->{'errata'}{$line}}
0.000000,0,0.000000,)
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: report of unknown entities? unrenderable characters?
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @out,
0.000000,0,0.000000,['=head1', {'start_line' => $m, 'errata' => 1}, 'POD ERRORS'],
0.000000,0,0.000000,['~Para', {'start_line' => $m, '~cooked' => 1, 'errata' => 1},
0.000000,0,0.000000,"Hey! ",
0.000000,0,0.000000,['B', {},
0.000000,0,0.000000,'The above document had some coding errors, which are explained below:'
0.000000,0,0.000000,]
0.000000,0,0.000000,],
0.000000,0,0.000000,['=over',  {'start_line' => $m, 'errata' => 1}, ''],
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,push @out, 
0.000000,0,0.000000,['=back',  {'start_line' => $m, 'errata' => 1}, ''],
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print "\n<<\n", pretty(\@out), "\n>>\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,return @out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,##
0.000000,0,0.000000,##  stop reading now stop reading now stop reading now stop reading now stop
0.000000,0,0.000000,##
0.000000,0,0.000000,##                         HERE IT BECOMES REALLY SCARY
0.000000,0,0.000000,##
0.000000,0,0.000000,##  stop reading now stop reading now stop reading now stop reading now stop
0.000000,0,0.000000,##
0.000000,0,0.000000,##############################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_paragraph_buffer {
0.000000,0,0.000000,
0.000000,0,0.000000,# Para-token types as found in the buffer.
0.000000,0,0.000000,#   ~Verbatim, ~Para, ~end, =head1..4, =for, =begin, =end,
0.000000,0,0.000000,#   =over, =back, =item
0.000000,0,0.000000,#   and the null =pod (to be complained about if over one line)
0.000000,0,0.000000,#
0.000000,0,0.000000,# "~data" paragraphs are something we generate at this level, depending on
0.000000,0,0.000000,# a currently open =over region
0.000000,0,0.000000,
0.000000,0,0.000000,# Events fired:  Begin and end for:
0.000000,0,0.000000,#                   directivename (like head1 .. head4), item, extend,
0.000000,0,0.000000,#                   for (from =begin...=end, =for),
0.000000,0,0.000000,#                   over-bullet, over-number, over-text, over-block,
0.000000,0,0.000000,#                   item-bullet, item-number, item-text,
0.000000,0,0.000000,#                   Document,
0.000000,0,0.000000,#                   Data, Para, Verbatim
0.000000,0,0.000000,#                   B, C, longdirname (TODO -- wha?), etc. for all directives
0.000000,0,0.000000,# 
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,my $paras;
0.000000,0,0.000000,return unless @{$paras = $self->{'paras'}};
0.000000,0,0.000000,my $curr_open = ($self->{'curr_open'} ||= []);
0.000000,0,0.000000,
0.000000,0,0.000000,my $scratch;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 10 and print "# Paragraph buffer: <<", pretty($paras), ">>\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# We have something in our buffer.  So apparently the document has started.
0.000000,0,0.000000,unless($self->{'doc_has_started'}) {
0.000000,0,0.000000,$self->{'doc_has_started'} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $starting_contentless;
0.000000,0,0.000000,$starting_contentless =
0.000000,0,0.000000,(
0.000000,0,0.000000,!@$curr_open  
0.000000,0,0.000000,and @$paras and ! grep $_->[0] ne '~end', @$paras
0.000000,0,0.000000,# i.e., if the paras is all ~ends
0.000000,0,0.000000,)
0.000000,0,0.000000,;
0.000000,0,0.000000,DEBUG and print "# Starting ", 
0.000000,0,0.000000,$starting_contentless ? 'contentless' : 'contentful',
0.000000,0,0.000000," document\n"
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_element_start(
0.000000,0,0.000000,($scratch = 'Document'),
0.000000,0,0.000000,{
0.000000,0,0.000000,'start_line' => $paras->[0][1]{'start_line'},
0.000000,0,0.000000,$starting_contentless ? ( 'contentless' => 1 ) : (),
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my($para, $para_type);
0.000000,0,0.000000,while(@$paras) {
0.000000,0,0.000000,last if @$paras == 1 and
0.000000,0,0.000000,( $paras->[0][0] eq '=over' or $paras->[0][0] eq '~Verbatim'
0.000000,0,0.000000,or $paras->[0][0] eq '=item' )
0.000000,0,0.000000,;
0.000000,0,0.000000,# Those're the three kinds of paragraphs that require lookahead.
0.000000,0,0.000000,#   Actually, an "=item Foo" inside an <over type=text> region
0.000000,0,0.000000,#   and any =item inside an <over type=block> region (rare)
0.000000,0,0.000000,#   don't require any lookahead, but all others (bullets
0.000000,0,0.000000,#   and numbers) do.
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: whinge about many kinds of directives in non-resolving =for regions?
0.000000,0,0.000000,# TODO: many?  like what?  =head1 etc?
0.000000,0,0.000000,
0.000000,0,0.000000,$para = shift @$paras;
0.000000,0,0.000000,$para_type = $para->[0];
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print "Pondering a $para_type paragraph, given the stack: (",
0.000000,0,0.000000,$self->_dump_curr_open(), ")\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq '=for') {
0.000000,0,0.000000,next if $self->_ponder_for($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=begin') {
0.000000,0,0.000000,next if $self->_ponder_begin($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=end') {
0.000000,0,0.000000,next if $self->_ponder_end($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '~end') { # The virtual end-document signal
0.000000,0,0.000000,next if $self->_ponder_doc_end($para,$curr_open,$paras);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,if(grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and
0.000000,0,0.000000,print "Skipping $para_type paragraph because in ignore mode.\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq '=pod') {
0.000000,0,0.000000,$self->_ponder_pod($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=over') {
0.000000,0,0.000000,next if $self->_ponder_over($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=back') {
0.000000,0,0.000000,next if $self->_ponder_back($para,$curr_open,$paras);
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,# All non-magical codes!!!
0.000000,0,0.000000,
0.000000,0,0.000000,# Here we start using $para_type for our own twisted purposes, to
0.000000,0,0.000000,#  mean how it should get treated, not as what the element name
0.000000,0,0.000000,#  should be.
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print "Pondering non-magical $para_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $i;
0.000000,0,0.000000,
0.000000,0,0.000000,# Enforce some =headN discipline
0.000000,0,0.000000,if($para_type =~ m/^=head\d$/s
0.000000,0,0.000000,and ! $self->{'accept_heads_anywhere'}
0.000000,0,0.000000,and @$curr_open
0.000000,0,0.000000,and $curr_open->[-1][0] eq '=over'
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 2 and print "'=$para_type' inside an '=over'!\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You forgot a '=back' before '$para_type'"
0.000000,0,0.000000,);
0.000000,0,0.000000,unshift @$paras, ['=back', {}, ''], $para;   # close the =over
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq '=item') {
0.000000,0,0.000000,
0.000000,0,0.000000,my $over;
0.000000,0,0.000000,unless(@$curr_open and
0.000000,0,0.000000,$over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=item' outside of any '=over'"
0.000000,0,0.000000,);
0.000000,0,0.000000,unshift @$paras,
0.000000,0,0.000000,['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
0.000000,0,0.000000,$para
0.000000,0,0.000000,;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $over_type = $over->[1]{'~type'};
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$over_type) {
0.000000,0,0.000000,# Shouldn't happen1
0.000000,0,0.000000,die "Typeless over in stack, starting at line "
0.000000,0,0.000000,. $over->[1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'block') {
0.000000,0,0.000000,unless($curr_open->[-1][1]{'~bitched_about'}) {
0.000000,0,0.000000,$curr_open->[-1][1]{'~bitched_about'} = 1;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$curr_open->[-1][1]{'start_line'},
0.000000,0,0.000000,"You can't have =items (as at line "
0.000000,0,0.000000,. $para->[1]{'start_line'}
0.000000,0,0.000000,. ") unless the first thing after the =over is an =item"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Just turn it into a paragraph and reconsider it
0.000000,0,0.000000,$para->[0] = '~Para';
0.000000,0,0.000000,unshift @$paras, $para;
0.000000,0,0.000000,next;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'text') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'text') {
0.000000,0,0.000000,# Nothing special needs doing for 'text'
0.000000,0,0.000000,} elsif($item_type eq 'number' or $item_type eq 'bullet') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected text after =item, not a $item_type"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Undo our clobbering:
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# =item-text thingies don't need any assimilation, it seems.
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'number') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# restore the bullet, blocking the assimilation of next para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Text content will still be there and will block next ~Para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type ne 'number') {
0.000000,0,0.000000,die "Unknown item type $item_type"; # should never happen
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($expected_value == $para->[1]{'number'}) {
0.000000,0,0.000000,DEBUG > 1 and print " Numeric item has the expected value of $expected_value\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print " Numeric item has ", $para->[1]{'number'},
0.000000,0,0.000000," instead of the expected value of $expected_value\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You have '=item " . $para->[1]{'number'} .
0.000000,0,0.000000,"' instead of the expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;  # correcting!!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'bullet') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# as expected!
0.000000,0,0.000000,
0.000000,0,0.000000,if( $para->[1]{'~_freaky_para_hack'} ) {
0.000000,0,0.000000,DEBUG and print "Accomodating '=item * Foo' tolerance hack.\n";
0.000000,0,0.000000,push @$para, delete $para->[1]{'~_freaky_para_hack'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'number') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# and block assimilation of the next paragraph
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# But doesn't need processing.  But it'll block assimilation
0.000000,0,0.000000,#  of the next para.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled =over type \"$over_type\"?";
0.000000,0,0.000000,# Shouldn't happen!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$para_type = 'Plain';
0.000000,0,0.000000,$para->[0] .= '-' . $over_type;
0.000000,0,0.000000,# Whew.  Now fall thru and process it.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($para_type eq '=extend') {
0.000000,0,0.000000,# Well, might as well implement it here.
0.000000,0,0.000000,$self->_ponder_extend($para);
0.000000,0,0.000000,next;  # and skip
0.000000,0,0.000000,} elsif($para_type eq '=encoding') {
0.000000,0,0.000000,# Not actually acted on here, but we catch errors here.
0.000000,0,0.000000,$self->_handle_encoding_second_level($para);
0.000000,0,0.000000,next unless $self->keep_encoding_directive;
0.000000,0,0.000000,$para_type = 'Plain';
0.000000,0,0.000000,} elsif($para_type eq '~Verbatim') {
0.000000,0,0.000000,$para->[0] = 'Verbatim';
0.000000,0,0.000000,$para_type = '?Verbatim';
0.000000,0,0.000000,} elsif($para_type eq '~Para') {
0.000000,0,0.000000,$para->[0] = 'Para';
0.000000,0,0.000000,$para_type = '?Plain';
0.000000,0,0.000000,} elsif($para_type eq 'Data') {
0.000000,0,0.000000,$para->[0] = 'Data';
0.000000,0,0.000000,$para_type = '?Data';
0.000000,0,0.000000,} elsif( $para_type =~ s/^=//s
0.000000,0,0.000000,and defined( $para_type = $self->{'accept_directives'}{$para_type} )
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 1 and print " Pondering known directive ${$para}[0] as $para_type\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# An unknown directive!
0.000000,0,0.000000,DEBUG > 1 and printf "Unhandled directive %s (Handled: %s)\n",
0.000000,0,0.000000,$para->[0], join(' ', sort keys %{$self->{'accept_directives'}} )
0.000000,0,0.000000,;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Unknown directive: $para->[0]"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# And maybe treat it as text instead of just letting it go?
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type =~ s/^\?//s) {
0.000000,0,0.000000,if(! @$curr_open) {  # usual case
0.000000,0,0.000000,DEBUG and print "Treating $para_type paragraph as such because stack is empty.\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my @fors = grep $_->[0] eq '=for', @$curr_open;
0.000000,0,0.000000,DEBUG > 1 and print "Containing fors: ",
0.000000,0,0.000000,join(',', map $_->[1]{'target'}, @fors), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(! @fors) {
0.000000,0,0.000000,DEBUG and print "Treating $para_type paragraph as such because stack has no =for's\n";
0.000000,0,0.000000,
0.000000,0,0.000000,#} elsif(grep $_->[1]{'~resolve'}, @fors) {
0.000000,0,0.000000,#} elsif(not grep !$_->[1]{'~resolve'}, @fors) {
0.000000,0,0.000000,} elsif( $fors[-1][1]{'~resolve'} ) {
0.000000,0,0.000000,# Look to the immediately containing for
0.000000,0,0.000000,
0.000000,0,0.000000,if($para_type eq 'Data') {
0.000000,0,0.000000,DEBUG and print "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
0.000000,0,0.000000,$para->[0] = 'Para';
0.000000,0,0.000000,$para_type = 'Plain';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";
0.000000,0,0.000000,$para->[0] = $para_type = 'Data';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0.000000,0,0.000000,if($para_type eq 'Plain') {
0.000000,0,0.000000,$self->_ponder_Plain($para);
0.000000,0,0.000000,} elsif($para_type eq 'Verbatim') {
0.000000,0,0.000000,$self->_ponder_Verbatim($para);        
0.000000,0,0.000000,} elsif($para_type eq 'Data') {
0.000000,0,0.000000,$self->_ponder_Data($para);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "\$para type is $para_type -- how did that happen?";
0.000000,0,0.000000,# Shouldn't happen.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0.000000,0,0.000000,$para->[0] =~ s/^[~=]//s;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print "\n", pretty($para), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# traverse the treelet (which might well be just one string scalar)
0.000000,0,0.000000,$self->{'content_seen'} ||= 1;
0.000000,0,0.000000,$self->_traverse_treelet_bit(@$para);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################################################
0.000000,0,0.000000,# The sub-ponderers...
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_for {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Fake it out as a begin/end
0.000000,0,0.000000,my $target;
0.000000,0,0.000000,
0.000000,0,0.000000,if(grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and print "Ignoring ignorable =for\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$para; ++$i) {
0.000000,0,0.000000,if($para->[$i] =~ s/^\s*(\S+)\s*//s) {
0.000000,0,0.000000,$target = $1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,unless(defined $target) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=for without a target?"
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and
0.000000,0,0.000000,print "Faking out a =for $target as a =begin $target / =end $target\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[0] = 'Data';
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @$paras,
0.000000,0,0.000000,['=begin',
0.000000,0,0.000000,{'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
0.000000,0,0.000000,$target,
0.000000,0,0.000000,],
0.000000,0,0.000000,$para,
0.000000,0,0.000000,['=end',
0.000000,0,0.000000,{'start_line' => $para->[1]{'start_line'}, '~really' => '=for'},
0.000000,0,0.000000,$target,
0.000000,0,0.000000,],
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_begin {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,unless(length($content)) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=begin without a target?"
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print "Ignoring targetless =begin\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ($target, $title) = $content =~ m/^(\S+)\s*(.*)$/;
0.000000,0,0.000000,$para->[1]{'title'} = $title if ($title);
0.000000,0,0.000000,$para->[1]{'target'} = $target;  # without any ':'
0.000000,0,0.000000,$content = $target; # strip off the title
0.000000,0,0.000000,
0.000000,0,0.000000,$content =~ s/^:!/!:/s;
0.000000,0,0.000000,my $neg;  # whether this is a negation-match
0.000000,0,0.000000,$neg = 1        if $content =~ s/^!//s;
0.000000,0,0.000000,my $to_resolve;  # whether to process formatting codes
0.000000,0,0.000000,$to_resolve = 1 if $content =~ s/^://s;
0.000000,0,0.000000,
0.000000,0,0.000000,my $dont_ignore; # whether this target matches us
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $target_name (
0.000000,0,0.000000,split(',', $content, -1),
0.000000,0,0.000000,$neg ? () : '*'
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 2 and
0.000000,0,0.000000,print " Considering whether =begin $content matches $target_name\n";
0.000000,0,0.000000,next unless $self->{'accept_targets'}{$target_name};
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 2 and
0.000000,0,0.000000,print "  It DOES match the acceptable target $target_name!\n";
0.000000,0,0.000000,$to_resolve = 1
0.000000,0,0.000000,if $self->{'accept_targets'}{$target_name} eq 'force_resolve';
0.000000,0,0.000000,$dont_ignore = 1;
0.000000,0,0.000000,$para->[1]{'target_matching'} = $target_name;
0.000000,0,0.000000,last; # stop looking at other target names
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($neg) {
0.000000,0,0.000000,if( $dont_ignore ) {
0.000000,0,0.000000,$dont_ignore = '';
0.000000,0,0.000000,delete $para->[1]{'target_matching'};
0.000000,0,0.000000,DEBUG > 2 and print " But the leading ! means that this is a NON-match!\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$dont_ignore = 1;
0.000000,0,0.000000,$para->[1]{'target_matching'} = '!';
0.000000,0,0.000000,DEBUG > 2 and print " But the leading ! means that this IS a match!\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[0] = '=for';  # Just what we happen to call these, internally
0.000000,0,0.000000,$para->[1]{'~really'} ||= '=begin';
0.000000,0,0.000000,$para->[1]{'~ignore'}   = (! $dont_ignore) || 0;
0.000000,0,0.000000,$para->[1]{'~resolve'}  = $to_resolve || 0;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 1 and print " Making note to ", $dont_ignore ? 'not ' : '',
0.000000,0,0.000000,"ignore contents of this region\n";
0.000000,0,0.000000,DEBUG > 1 and $dont_ignore and print " Making note to treat contents as ",
0.000000,0,0.000000,($to_resolve ? 'verbatim/plain' : 'data'), " paragraphs\n";
0.000000,0,0.000000,DEBUG > 1 and print " (Stack now: ", $self->_dump_curr_open(), ")\n";
0.000000,0,0.000000,
0.000000,0,0.000000,push @$curr_open, $para;
0.000000,0,0.000000,if(!$dont_ignore or scalar grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and print "Ignoring ignorable =begin\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->{'content_seen'} ||= 1;
0.000000,0,0.000000,$self->_handle_element_start((my $scratch='for'), $para->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_end {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,$content =~ s/^\s+//s;
0.000000,0,0.000000,$content =~ s/\s+$//s;
0.000000,0,0.000000,DEBUG and print "Ogling '=end $content' directive\n";
0.000000,0,0.000000,
0.000000,0,0.000000,unless(length($content)) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=end' without a target?" . (
0.000000,0,0.000000,( @$curr_open and $curr_open->[-1][0] eq '=for' )
0.000000,0,0.000000,? ( " (Should be \"=end " . $curr_open->[-1][1]{'target'} . '")' )
0.000000,0,0.000000,: ''
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print "Ignoring targetless =end\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless($content =~ m/^\S+$/) {  # i.e., unless it's one word
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=end $content' is invalid.  (Stack: "
0.000000,0,0.000000,. $self->_dump_curr_open() . ')'
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print "Ignoring mistargetted =end $content\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless(@$curr_open and $curr_open->[-1][0] eq '=for') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=end $content without matching =begin.  (Stack: "
0.000000,0,0.000000,. $self->_dump_curr_open() . ')'
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print "Ignoring mistargetted =end $content\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless($content eq $curr_open->[-1][1]{'target'}) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=end $content doesn't match =begin " 
0.000000,0,0.000000,. $curr_open->[-1][1]{'target'}
0.000000,0,0.000000,. ".  (Stack: "
0.000000,0,0.000000,. $self->_dump_curr_open() . ')'
0.000000,0,0.000000,);
0.000000,0,0.000000,DEBUG and print "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Else it's okay to close...
0.000000,0,0.000000,if(grep $_->[1]{'~ignore'}, @$curr_open) {
0.000000,0,0.000000,DEBUG > 1 and print "Not firing any event for this =end $content because in an ignored region\n";
0.000000,0,0.000000,# And that may be because of this to-be-closed =for region, or some
0.000000,0,0.000000,#  other one, but it doesn't matter.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$curr_open->[-1][1]{'start_line'} = $para->[1]{'start_line'};
0.000000,0,0.000000,# what's that for?
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'content_seen'} ||= 1;
0.000000,0,0.000000,$self->_handle_element_end( my $scratch = 'for', $para->[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and print "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";
0.000000,0,0.000000,pop @$curr_open;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_doc_end {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,if(@$curr_open) { # Deal with things left open
0.000000,0,0.000000,DEBUG and print "Stack is nonempty at end-document: (",
0.000000,0,0.000000,$self->_dump_curr_open(), ")\n";
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 9 and print "Stack: ", pretty($curr_open), "\n";
0.000000,0,0.000000,unshift @$paras, $self->_closers_for_all_curr_open;
0.000000,0,0.000000,# Make sure there is exactly one ~end in the parastack, at the end:
0.000000,0,0.000000,@$paras = grep $_->[0] ne '~end', @$paras;
0.000000,0,0.000000,push @$paras, $para, $para;
0.000000,0,0.000000,# We need two -- once for the next cycle where we
0.000000,0,0.000000,#  generate errata, and then another to be at the end
0.000000,0,0.000000,#  when that loop back around to process the errata.
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Okay, stack is empty now.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Try generating errata section, if applicable
0.000000,0,0.000000,unless($self->{'~tried_gen_errata'}) {
0.000000,0,0.000000,$self->{'~tried_gen_errata'} = 1;
0.000000,0,0.000000,my @extras = $self->_gen_errata();
0.000000,0,0.000000,if(@extras) {
0.000000,0,0.000000,unshift @$paras, @extras;
0.000000,0,0.000000,DEBUG and print "Generated errata... relooping...\n";
0.000000,0,0.000000,return 1;  # I.e., loop around again to process these fake-o paragraphs
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,splice @$paras; # Well, that's that for this paragraph buffer.
0.000000,0,0.000000,DEBUG and print "Throwing end-document event.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_element_end( my $scratch = 'Document' );
0.000000,0,0.000000,return 1; # Hasta la byebye
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_pod {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=pod directives shouldn't be over one line long!  Ignoring all "
0.000000,0,0.000000,. (@$para - 2) . " lines of content"
0.000000,0,0.000000,) if @$para > 3;
0.000000,0,0.000000,
0.000000,0,0.000000,# Content ignored unless 'pod_handler' is set
0.000000,0,0.000000,if (my $pod_handler = $self->{'pod_handler'}) {
0.000000,0,0.000000,my ($line_num, $line) = map $_, $para->[1]{'start_line'}, $para->[2];
0.000000,0,0.000000,$line = $line eq '' ? "=pod" : "=pod $line"; # imitate cut_handler output
0.000000,0,0.000000,$pod_handler->($line, $line_num, $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The surrounding methods set content_seen, so let us remain consistent.
0.000000,0,0.000000,# I do not know why it was not here before -- should it not be here?
0.000000,0,0.000000,# $self->{'content_seen'} ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_over {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,return 1 unless @$paras;
0.000000,0,0.000000,my $list_type;
0.000000,0,0.000000,
0.000000,0,0.000000,if($paras->[0][0] eq '=item') { # most common case
0.000000,0,0.000000,$list_type = $self->_get_initial_item_type($paras->[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($paras->[0][0] eq '=back') {
0.000000,0,0.000000,# Ignore empty lists by default
0.000000,0,0.000000,if ($self->{'parse_empty_lists'}) {
0.000000,0,0.000000,$list_type = 'empty';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,shift @$paras;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif($paras->[0][0] eq '~end') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=over is the last thing in the document?!"
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1; # But feh, ignore it.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$list_type = 'block';
0.000000,0,0.000000,}
0.000000,0,0.000000,$para->[1]{'~type'} = $list_type;
0.000000,0,0.000000,push @$curr_open, $para;
0.000000,0,0.000000,# yes, we reuse the paragraph as a stack item
0.000000,0,0.000000,
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,my $overness;
0.000000,0,0.000000,if($content =~ m/^\s*$/s) {
0.000000,0,0.000000,$para->[1]{'indent'} = 4;
0.000000,0,0.000000,} elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s) {
0.003818,2,0.001909,no integer;
0.000000,0,0.000000,$para->[1]{'indent'} = $1;
0.000000,0,0.000000,if($1 == 0) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Can't have a 0 in =over $content"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'indent'} = 4;
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=over should be: '=over' or '=over positive_number'"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'indent'} = 4;
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and print "=over found of type $list_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{'content_seen'} ||= 1;
0.000000,0,0.000000,$self->_handle_element_start((my $scratch = 'over-' . $list_type), $para->[1]);
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_back {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,# TODO: fire off </item-number> or </item-bullet> or </item-text> ??
0.000000,0,0.000000,
0.000000,0,0.000000,my $content = join ' ', splice @$para, 2;
0.000000,0,0.000000,if($content =~ m/\S/) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"=back doesn't take any parameters, but you said =back $content"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$curr_open and $curr_open->[-1][0] eq '=over') {
0.000000,0,0.000000,DEBUG > 1 and print "=back happily closes matching =over\n";
0.000000,0,0.000000,# Expected case: we're closing the most recently opened thing
0.000000,0,0.000000,#my $over = pop @$curr_open;
0.000000,0,0.000000,$self->{'content_seen'} ||= 1;
0.000000,0,0.000000,$self->_handle_element_end( my $scratch =
0.000000,0,0.000000,'over-' . ( (pop @$curr_open)->[1]{'~type'} ), $para->[1]
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print "=back found without a matching =over.  Stack: (",
0.000000,0,0.000000,join(', ', map $_->[0], @$curr_open), ").\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,'=back without =over'
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1; # and ignore it
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_item {
0.000000,0,0.000000,my ($self,$para,$curr_open,$paras) = @_;
0.000000,0,0.000000,my $over;
0.000000,0,0.000000,unless(@$curr_open and
0.000000,0,0.000000,$over = (grep { $_->[0] eq '=over' } @$curr_open)[-1]) {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"'=item' outside of any '=over'"
0.000000,0,0.000000,);
0.000000,0,0.000000,unshift @$paras,
0.000000,0,0.000000,['=over', {'start_line' => $para->[1]{'start_line'}}, ''],
0.000000,0,0.000000,$para
0.000000,0,0.000000,;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my $over_type = $over->[1]{'~type'};
0.000000,0,0.000000,
0.000000,0,0.000000,if(!$over_type) {
0.000000,0,0.000000,# Shouldn't happen1
0.000000,0,0.000000,die "Typeless over in stack, starting at line "
0.000000,0,0.000000,. $over->[1]{'start_line'};
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'block') {
0.000000,0,0.000000,unless($curr_open->[-1][1]{'~bitched_about'}) {
0.000000,0,0.000000,$curr_open->[-1][1]{'~bitched_about'} = 1;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$curr_open->[-1][1]{'start_line'},
0.000000,0,0.000000,"You can't have =items (as at line "
0.000000,0,0.000000,. $para->[1]{'start_line'}
0.000000,0,0.000000,. ") unless the first thing after the =over is an =item"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Just turn it into a paragraph and reconsider it
0.000000,0,0.000000,$para->[0] = '~Para';
0.000000,0,0.000000,unshift @$paras, $para;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'text') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'text') {
0.000000,0,0.000000,# Nothing special needs doing for 'text'
0.000000,0,0.000000,} elsif($item_type eq 'number' or $item_type eq 'bullet') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected text after =item, not a $item_type"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Undo our clobbering:
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# =item-text thingies don't need any assimilation, it seems.
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'number') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,my $expected_value = ++ $curr_open->[-1][1]{'~counter'};
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# restore the bullet, blocking the assimilation of next para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,# Hm, it's not numeric.  Correct for this.
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# Text content will still be there and will block next ~Para
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type ne 'number') {
0.000000,0,0.000000,die "Unknown item type $item_type"; # should never happen
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($expected_value == $para->[1]{'number'}) {
0.000000,0,0.000000,DEBUG > 1 and print " Numeric item has the expected value of $expected_value\n";
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 1 and print " Numeric item has ", $para->[1]{'number'},
0.000000,0,0.000000," instead of the expected value of $expected_value\n";
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"You have '=item " . $para->[1]{'number'} .
0.000000,0,0.000000,"' instead of the expected '=item $expected_value'"
0.000000,0,0.000000,);
0.000000,0,0.000000,$para->[1]{'number'} = $expected_value;  # correcting!!
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($over_type eq 'bullet') {
0.000000,0,0.000000,my $item_type = $self->_get_item_type($para);
0.000000,0,0.000000,# That kills the content of the item if it's a number or bullet.
0.000000,0,0.000000,DEBUG and print " Item is of type ", $para->[0], " under $over_type\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($item_type eq 'bullet') {
0.000000,0,0.000000,# as expected!
0.000000,0,0.000000,
0.000000,0,0.000000,if( $para->[1]{'~_freaky_para_hack'} ) {
0.000000,0,0.000000,DEBUG and print "Accomodating '=item * Foo' tolerance hack.\n";
0.000000,0,0.000000,push @$para, delete $para->[1]{'~_freaky_para_hack'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif($item_type eq 'number') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @$para, $para->[1]{'~orig_content'};
0.000000,0,0.000000,# and block assimilation of the next paragraph
0.000000,0,0.000000,delete $para->[1]{'number'};
0.000000,0,0.000000,# Only a PROPER item-number element is allowed
0.000000,0,0.000000,#  to have a number attribute.
0.000000,0,0.000000,} elsif($item_type eq 'text') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$para->[1]{'start_line'},
0.000000,0,0.000000,"Expected '=item *'"
0.000000,0,0.000000,);
0.000000,0,0.000000,# But doesn't need processing.  But it'll block assimilation
0.000000,0,0.000000,#  of the next para.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled item type $item_type"; # should never happen
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@$para == 2) {
0.000000,0,0.000000,# For the cases where we /didn't/ push to @$para
0.000000,0,0.000000,if($paras->[0][0] eq '~Para') {
0.000000,0,0.000000,DEBUG and print "Assimilating following ~Para content into $over_type item\n";
0.000000,0,0.000000,push @$para, splice @{shift @$paras},2;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG and print "Can't assimilate following ", $paras->[0][0], "\n";
0.000000,0,0.000000,push @$para, '';  # Just so it's not contentless
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unhandled =over type \"$over_type\"?";
0.000000,0,0.000000,# Shouldn't happen!
0.000000,0,0.000000,}
0.000000,0,0.000000,$para->[0] .= '-' . $over_type;
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_Plain {
0.000000,0,0.000000,my ($self,$para) = @_;
0.000000,0,0.000000,DEBUG and print " giving plain treatment...\n";
0.000000,0,0.000000,unless( @$para == 2 or ( @$para == 3 and $para->[2] eq '' )
0.000000,0,0.000000,or $para->[1]{'~cooked'}
0.000000,0,0.000000,) {
0.000000,0,0.000000,push @$para,
0.000000,0,0.000000,@{$self->_make_treelet(
0.000000,0,0.000000,join("\n", splice(@$para, 2)),
0.000000,0,0.000000,$para->[1]{'start_line'}
0.000000,0,0.000000,)};
0.000000,0,0.000000,}
0.000000,0,0.000000,# Empty paragraphs don't need a treelet for any reason I can see.
0.000000,0,0.000000,# And precooked paragraphs already have a treelet.
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_Verbatim {
0.000000,0,0.000000,my ($self,$para) = @_;
0.000000,0,0.000000,DEBUG and print " giving verbatim treatment...\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$para->[1]{'xml:space'} = 'preserve';
0.000000,0,0.000000,
0.000000,0,0.000000,my $indent = $self->strip_verbatim_indent;
0.000000,0,0.000000,if ($indent && ref $indent eq 'CODE') {
0.000000,0,0.000000,my @shifted = (shift @{$para}, shift @{$para});
0.000000,0,0.000000,$indent = $indent->($para);
0.000000,0,0.000000,unshift @{$para}, @shifted;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$para; $i++) {
0.000000,0,0.000000,foreach my $line ($para->[$i]) { # just for aliasing
0.000000,0,0.000000,# Strip indentation.
0.000000,0,0.000000,$line =~ s/^\Q$indent// if $indent
0.000000,0,0.000000,&& !($self->{accept_codes} && $self->{accept_codes}{VerbatimFormatted});
0.000000,0,0.000000,while( $line =~
0.000000,0,0.000000,# Sort of adapted from Text::Tabs -- yes, it's hardwired in that
0.000000,0,0.000000,# tabs are at every EIGHTH column.  For portability, it has to be
0.000000,0,0.000000,# one setting everywhere, and 8th wins.
0.000000,0,0.000000,s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e
0.000000,0,0.000000,) {}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: whinge about (or otherwise treat) unindented or overlong lines
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now the VerbatimFormatted hoodoo...
0.000000,0,0.000000,if( $self->{'accept_codes'} and
0.000000,0,0.000000,$self->{'accept_codes'}{'VerbatimFormatted'}
0.000000,0,0.000000,) {
0.000000,0,0.000000,while(@$para > 3 and $para->[-1] !~ m/\S/) { pop @$para }
0.000000,0,0.000000,# Kill any number of terminal newlines
0.000000,0,0.000000,$self->_verbatim_format($para);
0.000000,0,0.000000,} elsif ($self->{'codes_in_verbatim'}) {
0.000000,0,0.000000,push @$para,
0.000000,0,0.000000,@{$self->_make_treelet(
0.000000,0,0.000000,join("\n", splice(@$para, 2)),
0.000000,0,0.000000,$para->[1]{'start_line'}, $para->[1]{'xml:space'}
0.000000,0,0.000000,)};
0.000000,0,0.000000,$para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
0.000000,0,0.000000,} else {
0.000000,0,0.000000,push @$para, join "\n", splice(@$para, 2) if @$para > 3;
0.000000,0,0.000000,$para->[-1] =~ s/\n+$//s; # Kill any number of terminal newlines
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _ponder_Data {
0.000000,0,0.000000,my ($self,$para) = @_;
0.000000,0,0.000000,DEBUG and print " giving data treatment...\n";
0.000000,0,0.000000,$para->[1]{'xml:space'} = 'preserve';
0.000000,0,0.000000,push @$para, join "\n", splice(@$para, 2) if @$para > 3;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,sub _traverse_treelet_bit {  # for use only by the routine above
0.000000,0,0.000000,my($self, $name) = splice @_,0,2;
0.000000,0,0.000000,
0.000000,0,0.000000,my $scratch;
0.000000,0,0.000000,$self->_handle_element_start(($scratch=$name), shift @_);
0.000000,0,0.000000,
0.000000,0,0.000000,while (@_) {
0.000000,0,0.000000,my $x = shift;
0.000000,0,0.000000,if (ref($x)) {
0.000000,0,0.000000,&_traverse_treelet_bit($self, @$x);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$x .= shift while @_ && !ref($_[0]);
0.000000,0,0.000000,$self->_handle_text($x);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_handle_element_end($scratch=$name);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _closers_for_all_curr_open {
0.000000,0,0.000000,my $self = $_[0];
0.000000,0,0.000000,my @closers;
0.000000,0,0.000000,foreach my $still_open (@{  $self->{'curr_open'} || return  }) {
0.000000,0,0.000000,my @copy = @$still_open;
0.000000,0,0.000000,$copy[1] = {%{ $copy[1] }};
0.000000,0,0.000000,#$copy[1]{'start_line'} = -1;
0.000000,0,0.000000,if($copy[0] eq '=for') {
0.000000,0,0.000000,$copy[0] = '=end';
0.000000,0,0.000000,} elsif($copy[0] eq '=over') {
0.000000,0,0.000000,$self->whine(
0.000000,0,0.000000,$still_open->[1]{start_line} ,
0.000000,0,0.000000,"=over without closing =back"
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$copy[0] = '=back';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "I don't know how to auto-close an open $copy[0] region";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless( @copy > 2 ) {
0.000000,0,0.000000,push @copy, $copy[1]{'target'};
0.000000,0,0.000000,$copy[-1] = '' unless defined $copy[-1];
0.000000,0,0.000000,# since =over's don't have targets
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$copy[1]{'fake-closer'} = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG and print "Queuing up fake-o event: ", pretty(\@copy), "\n";
0.000000,0,0.000000,unshift @closers, \@copy;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @closers;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#--------------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub _verbatim_format {
0.000000,0,0.000000,my($it, $p) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $formatting;
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = 2; $i < @$p; $i++) { # work backwards over the lines
0.000000,0,0.000000,DEBUG and print "_verbatim_format appends a newline to $i: $p->[$i]\n";
0.000000,0,0.000000,$p->[$i] .= "\n";
0.000000,0,0.000000,# Unlike with simple Verbatim blocks, we don't end up just doing
0.000000,0,0.000000,# a join("\n", ...) on the contents, so we have to append a
0.000000,0,0.000000,# newline to ever line, and then nix the last one later.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( DEBUG > 4 ) {
0.000000,0,0.000000,print "<<\n";
0.000000,0,0.000000,for(my $i = $#$p; $i >= 2; $i--) { # work backwards over the lines
0.000000,0,0.000000,print "_verbatim_format $i: $p->[$i]";
0.000000,0,0.000000,}
0.000000,0,0.000000,print ">>\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for(my $i = $#$p; $i > 2; $i--) {
0.000000,0,0.000000,# work backwards over the lines, except the first (#2)
0.000000,0,0.000000,
0.000000,0,0.000000,#next unless $p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s
0.000000,0,0.000000,#        and $p->[$i-1] !~ m{^#:[ \^\/\%]*\n?$}s;
0.000000,0,0.000000,# look at a formatty line preceding a nonformatty one
0.000000,0,0.000000,DEBUG > 5 and print "Scrutinizing line $i: $$p[$i]\n";
0.000000,0,0.000000,if($p->[$i]   =~ m{^#:([ \^\/\%]*)\n?$}s) {
0.000000,0,0.000000,DEBUG > 5 and print "  It's a formatty line.  ",
0.000000,0,0.000000,"Peeking at previous line ", $i-1, ": $$p[$i-1]: \n";
0.000000,0,0.000000,
0.000000,0,0.000000,if( $p->[$i-1] =~ m{^#:[ \^\/\%]*\n?$}s ) {
0.000000,0,0.000000,DEBUG > 5 and print "  Previous line is formatty!  Skipping this one.\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print "  Previous line is non-formatty!  Yay!\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print "  It's not a formatty line.  Ignoring\n";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# A formatty line has to have #: in the first two columns, and uses
0.000000,0,0.000000,# "^" to mean bold, "/" to mean underline, and "%" to mean bold italic.
0.000000,0,0.000000,# Example:
0.000000,0,0.000000,#   What do you want?  i like pie. [or whatever]
0.000000,0,0.000000,# #:^^^^^^^^^^^^^^^^^              /////////////         
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";
0.000000,0,0.000000,
0.000000,0,0.000000,$formatting = '  ' . $1;
0.000000,0,0.000000,$formatting =~ s/\s+$//s; # nix trailing whitespace
0.000000,0,0.000000,unless(length $formatting and $p->[$i-1] =~ m/\S/) { # no-op
0.000000,0,0.000000,splice @$p,$i,1; # remove this line
0.000000,0,0.000000,$i--; # don't consider next line
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( length($formatting) >= length($p->[$i-1]) ) {
0.000000,0,0.000000,$formatting = substr($formatting, 0, length($p->[$i-1]) - 1) . ' ';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$formatting .= ' ' x (length($p->[$i-1]) - length($formatting));
0.000000,0,0.000000,}
0.000000,0,0.000000,# Make $formatting and the previous line be exactly the same length,
0.000000,0,0.000000,# with $formatting having a " " as the last character.
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print "Formatting <$formatting>    on <", $p->[$i-1], ">\n";
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,my @new_line;
0.000000,0,0.000000,while( $formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g ) {
0.000000,0,0.000000,#print "Format matches $1\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if($2) {
0.000000,0,0.000000,#print "SKIPPING <$2>\n";
0.000000,0,0.000000,push @new_line,
0.000000,0,0.000000,substr($p->[$i-1], pos($formatting)-length($1), length($1));
0.000000,0,0.000000,} else {
0.000000,0,0.000000,#print "SNARING $+\n";
0.000000,0,0.000000,push @new_line, [
0.000000,0,0.000000,(
0.000000,0,0.000000,$3 ? 'VerbatimB'  :
0.000000,0,0.000000,$4 ? 'VerbatimI'  :
0.000000,0,0.000000,$5 ? 'VerbatimBI' : die("Should never get called")
0.000000,0,0.000000,), {},
0.000000,0,0.000000,substr($p->[$i-1], pos($formatting)-length($1), length($1))
0.000000,0,0.000000,];
0.000000,0,0.000000,#print "Formatting <$new_line[-1][-1]> as $new_line[-1][0]\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my @nixed =    
0.000000,0,0.000000,splice @$p, $i-1, 2, @new_line; # replace myself and the next line
0.000000,0,0.000000,DEBUG > 10 and print "Nixed count: ", scalar(@nixed), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 6 and print "New version of the above line is these tokens (",
0.000000,0,0.000000,scalar(@new_line), "):",
0.000000,0,0.000000,map( ref($_)?"<@$_> ":"<$_>", @new_line ), "\n";
0.000000,0,0.000000,$i--; # So the next line we scrutinize is the line before the one
0.000000,0,0.000000,#  that we just went and formatted
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$p->[0] = 'VerbatimFormatted';
0.000000,0,0.000000,
0.000000,0,0.000000,# Collapse adjacent text nodes, just for kicks.
0.000000,0,0.000000,for( my $i = 2; $i > $#$p; $i++ ) { # work forwards over the tokens except for the last
0.000000,0,0.000000,if( !ref($p->[$i]) and !ref($p->[$i + 1]) ) {
0.000000,0,0.000000,DEBUG > 5 and print "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";
0.000000,0,0.000000,$p->[$i] .= splice @$p, $i+1, 1; # merge
0.000000,0,0.000000,--$i;  # and back up
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now look for the last text token, and remove the terminal newline
0.000000,0,0.000000,for( my $i = $#$p; $i >= 2; $i-- ) {
0.000000,0,0.000000,# work backwards over the tokens, even the first
0.000000,0,0.000000,if( !ref($p->[$i]) ) {
0.000000,0,0.000000,if($p->[$i] =~ s/\n$//s) {
0.000000,0,0.000000,DEBUG > 5 and print "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 5 and print
0.000000,0,0.000000,"No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,last; # we only want the next one
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _treelet_from_formatting_codes {
0.000000,0,0.000000,# Given a paragraph, returns a treelet.  Full of scary tokenizing code.
0.000000,0,0.000000,#  Like [ '~Top', {'start_line' => $start_line},
0.000000,0,0.000000,#            "I like ",
0.000000,0,0.000000,#            [ 'B', {}, "pie" ],
0.000000,0,0.000000,#            "!"
0.000000,0,0.000000,#       ]
0.000000,0,0.000000,
0.000000,0,0.000000,my($self, $para, $start_line, $preserve_space) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $treelet = ['~Top', {'start_line' => $start_line},];
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($preserve_space || $self->{'preserve_whitespace'}) {
0.000000,0,0.000000,$para =~ s/\s+/ /g; # collapse and trim all whitespace first.
0.000000,0,0.000000,$para =~ s/ $//;
0.000000,0,0.000000,$para =~ s/^ //;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Only apparent problem the above code is that N<<  >> turns into
0.000000,0,0.000000,# N<< >>.  But then, word wrapping does that too!  So don't do that!
0.000000,0,0.000000,
0.000000,0,0.000000,my @stack;
0.000000,0,0.000000,my @lineage = ($treelet);
0.000000,0,0.000000,my $raw = ''; # raw content of L<> fcode before splitting/processing
0.000000,0,0.000000,# XXX 'raw' is not 100% accurate: all surrounding whitespace is condensed
0.000000,0,0.000000,# into just 1 ' '. Is this the regex's doing or 'raw's?
0.000000,0,0.000000,my $inL = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,DEBUG > 4 and print "Paragraph:\n$para\n\n";
0.000000,0,0.000000,
0.000000,0,0.000000,# Here begins our frightening tokenizer RE.  The following regex matches
0.000000,0,0.000000,# text in four main parts:
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * Start-codes.  The first alternative matches C< or C<<, the latter
0.000000,0,0.000000,#    followed by some whitespace.  $1 will hold the entire start code
0.000000,0,0.000000,#    (including any space following a multiple-angle-bracket delimiter),
0.000000,0,0.000000,#    and $2 will hold only the additional brackets past the first in a
0.000000,0,0.000000,#    multiple-bracket delimiter.  length($2) + 1 will be the number of
0.000000,0,0.000000,#    closing brackets we have to find.
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * Closing brackets.  Match some amount of whitespace followed by
0.000000,0,0.000000,#    multiple close brackets.  The logic to see if this closes anything
0.000000,0,0.000000,#    is down below.  Note that in order to parse C<<  >> correctly, we
0.000000,0,0.000000,#    have to use look-behind (?<=\s\s), since the match of the starting
0.000000,0,0.000000,#    code will have consumed the whitespace.
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * A single closing bracket, to close a simple code like C<>.
0.000000,0,0.000000,#
0.000000,0,0.000000,#  * Something that isn't a start or end code.  We have to be careful
0.000000,0,0.000000,#    about accepting whitespace, since perlpodspec says that any whitespace
0.000000,0,0.000000,#    before a multiple-bracket closing delimiter should be ignored.
0.000000,0,0.000000,#
0.000000,0,0.000000,while($para =~
0.000000,0,0.000000,m/\G
0.000000,0,0.000000,(?:
0.000000,0,0.000000,# Match starting codes, including the whitespace following a
0.000000,0,0.000000,# multiple-delimiter start code.  $1 gets the whole start code and
0.000000,0,0.000000,# $2 gets all but one of the <s in the multiple-bracket case.
0.000000,0,0.000000,([A-Z]<(?:(<+)\s+)?)
0.000000,0,0.000000,|
0.000000,0,0.000000,# Match multiple-bracket end codes.  $3 gets the whitespace that
0.000000,0,0.000000,# should be discarded before an end bracket but kept in other cases
0.000000,0,0.000000,# and $4 gets the end brackets themselves.
0.000000,0,0.000000,(\s+|(?<=\s\s))(>{2,})
0.000000,0,0.000000,|
0.000000,0,0.000000,(\s?>)          # $5: simple end-codes
0.000000,0,0.000000,|
0.000000,0,0.000000,(               # $6: stuff containing no start-codes or end-codes
0.000000,0,0.000000,(?:
0.000000,0,0.000000,[^A-Z\s>]
0.000000,0,0.000000,|
0.000000,0,0.000000,(?:
0.000000,0,0.000000,[A-Z](?!<)
0.000000,0,0.000000,)
0.000000,0,0.000000,|
0.000000,0,0.000000,# whitespace is ok, but we don't want to eat the whitespace before
0.000000,0,0.000000,# a multiple-bracket end code.
0.000000,0,0.000000,# NOTE: we may still have problems with e.g. S<<    >>
0.000000,0,0.000000,(?:
0.000000,0,0.000000,\s(?!\s*>{2,})
0.000000,0,0.000000,)
0.000000,0,0.000000,)+
0.000000,0,0.000000,)
0.000000,0,0.000000,)
0.000000,0,0.000000,/xgo
0.000000,0,0.000000,) {
0.000000,0,0.000000,DEBUG > 4 and print "\nParagraphic tokenstack = (@stack)\n";
0.000000,0,0.000000,if(defined $1) {
0.000000,0,0.000000,if(defined $2) {
0.000000,0,0.000000,DEBUG > 3 and print "Found complex start-text code \"$1\"\n";
0.000000,0,0.000000,push @stack, length($2) + 1; 
0.000000,0,0.000000,# length of the necessary complex end-code string
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 3 and print "Found simple start-text code \"$1\"\n";
0.000000,0,0.000000,push @stack, 0;  # signal that we're looking for simple
0.000000,0,0.000000,}
0.000000,0,0.000000,push @lineage, [ substr($1,0,1), {}, ];  # new node object
0.000000,0,0.000000,push @{ $lineage[-2] }, $lineage[-1];
0.000000,0,0.000000,if ('L' eq substr($1,0,1)) {
0.000000,0,0.000000,$raw = $inL ? $raw.$1 : ''; # reset raw content accumulator
0.000000,0,0.000000,$inL = 1;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$raw .= $1 if $inL;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(defined $4) {
0.000000,0,0.000000,DEBUG > 3 and print "Found apparent complex end-text code \"$3$4\"\n";
0.000000,0,0.000000,# This is where it gets messy...
0.000000,0,0.000000,if(! @stack) {
0.000000,0,0.000000,# We saw " >>>>" but needed nothing.  This is ALL just stuff then.
0.000000,0,0.000000,DEBUG > 4 and print " But it's really just stuff.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $3, $4;
0.000000,0,0.000000,next;
0.000000,0,0.000000,} elsif(!$stack[-1]) {
0.000000,0,0.000000,# We saw " >>>>" but needed only ">".  Back pos up.
0.000000,0,0.000000,DEBUG > 4 and print " And that's more than we needed to close simple.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $3; # That was a for-real space, too.
0.000000,0,0.000000,pos($para) = pos($para) - length($4) + 1;
0.000000,0,0.000000,} elsif($stack[-1] == length($4)) {
0.000000,0,0.000000,# We found " >>>>", and it was exactly what we needed.  Commonest case.
0.000000,0,0.000000,DEBUG > 4 and print " And that's exactly what we needed to close complex.\n";
0.000000,0,0.000000,} elsif($stack[-1] < length($4)) {
0.000000,0,0.000000,# We saw " >>>>" but needed only " >>".  Back pos up.
0.000000,0,0.000000,DEBUG > 4 and print " And that's more than we needed to close complex.\n";
0.000000,0,0.000000,pos($para) = pos($para) - length($4) + $stack[-1];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# We saw " >>>>" but needed " >>>>>>".  So this is all just stuff!
0.000000,0,0.000000,DEBUG > 4 and print " But it's really just stuff, because we needed more.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $3, $4;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,#print "\nHOOBOY ", scalar(@{$lineage[-1]}), "!!!\n";
0.000000,0,0.000000,
0.000000,0,0.000000,push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
0.000000,0,0.000000,# Keep the element from being childless
0.000000,0,0.000000,
0.000000,0,0.000000,pop @stack;
0.000000,0,0.000000,pop @lineage;
0.000000,0,0.000000,
0.000000,0,0.000000,unless (@stack) { # not in an L if there are no open fcodes
0.000000,0,0.000000,$inL = 0;
0.000000,0,0.000000,if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
0.000000,0,0.000000,$lineage[-1][-1][1]{'raw'} = $raw
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$raw .= $3.$4 if $inL;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(defined $5) {
0.000000,0,0.000000,DEBUG > 3 and print "Found apparent simple end-text code \"$5\"\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(@stack and ! $stack[-1]) {
0.000000,0,0.000000,# We're indeed expecting a simple end-code
0.000000,0,0.000000,DEBUG > 4 and print " It's indeed an end-code.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,if(length($5) == 2) { # There was a space there: " >"
0.000000,0,0.000000,push @{ $lineage[-1] }, ' ';
0.000000,0,0.000000,} elsif( 2 == @{ $lineage[-1] } ) { # Closing a childless element
0.000000,0,0.000000,push @{ $lineage[-1] }, ''; # keep it from being really childless
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,pop @stack;
0.000000,0,0.000000,pop @lineage;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,DEBUG > 4 and print " It's just stuff.\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $5;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless (@stack) { # not in an L if there are no open fcodes
0.000000,0,0.000000,$inL = 0;
0.000000,0,0.000000,if (ref $lineage[-1][-1] && $lineage[-1][-1][0] eq 'L') {
0.000000,0,0.000000,$lineage[-1][-1][1]{'raw'} = $raw
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$raw .= $5 if $inL;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(defined $6) {
0.000000,0,0.000000,DEBUG > 3 and print "Found stuff \"$6\"\n";
0.000000,0,0.000000,push @{ $lineage[-1] }, $6;
0.000000,0,0.000000,$raw .= $6 if $inL;
0.000000,0,0.000000,# XXX does not capture multiplace whitespaces -- 'raw' ends up with
0.000000,0,0.000000,#     at most 1 leading/trailing whitespace, why not all of it?
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# should never ever ever ever happen
0.000000,0,0.000000,DEBUG and print "AYYAYAAAAA at line ", __LINE__, "\n";
0.000000,0,0.000000,die "SPORK 512512!";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@stack) { # Uhoh, some sequences weren't closed.
0.000000,0,0.000000,my $x= "...";
0.000000,0,0.000000,while(@stack) {
0.000000,0,0.000000,push @{ $lineage[-1] }, '' if 2 == @{ $lineage[-1] };
0.000000,0,0.000000,# Hmmmmm!
0.000000,0,0.000000,
0.000000,0,0.000000,my $code         = (pop @lineage)->[0];
0.000000,0,0.000000,my $ender_length =  pop @stack;
0.000000,0,0.000000,if($ender_length) {
0.000000,0,0.000000,--$ender_length;
0.000000,0,0.000000,$x = $code . ("<" x $ender_length) . " $x " . (">" x $ender_length);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$x = $code . "<$x>";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,DEBUG > 1 and print "Unterminated $x sequence\n";
0.000000,0,0.000000,$self->whine($start_line,
0.000000,0,0.000000,"Unterminated $x sequence",
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $treelet;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub text_content_of_treelet {  # method: $parser->text_content_of_treelet($lol)
0.000000,0,0.000000,return stringify_lol($_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub stringify_lol {  # function: stringify_lol($lol)
0.000000,0,0.000000,my $string_form = '';
0.000000,0,0.000000,_stringify_lol( $_[0] => \$string_form );
0.000000,0,0.000000,return $string_form;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify_lol {  # the real recursor
0.000000,0,0.000000,my($lol, $to) = @_;
0.000000,0,0.000000,for(my $i = 2; $i < @$lol; ++$i) {
0.000000,0,0.000000,if( ref($lol->[$i] || '') and UNIVERSAL::isa($lol->[$i], 'ARRAY') ) {
0.000000,0,0.000000,_stringify_lol( $lol->[$i], $to);  # recurse!
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$$to .= $lol->[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dump_curr_open { # return a string representation of the stack
0.000000,0,0.000000,my $curr_open = $_[0]{'curr_open'};
0.000000,0,0.000000,
0.000000,0,0.000000,return '[empty]' unless @$curr_open;
0.000000,0,0.000000,return join '; ',
0.000000,0,0.000000,map {;
0.000000,0,0.000000,($_->[0] eq '=for')
0.000000,0,0.000000,? ( ($_->[1]{'~really'} || '=over')
0.000000,0,0.000000,. ' ' . $_->[1]{'target'})
0.000000,0,0.000000,: $_->[0]
0.000000,0,0.000000,}
0.000000,0,0.000000,@$curr_open
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################################################
0.000008,1,0.000008,my %pretty_form = (
0.000000,0,0.000000,"\a" => '\a', # ding!
0.000000,0,0.000000,"\b" => '\b', # BS
0.000000,0,0.000000,"\e" => '\e', # ESC
0.000000,0,0.000000,"\f" => '\f', # FF
0.000000,0,0.000000,"\t" => '\t', # tab
0.000000,0,0.000000,"\cm" => '\cm',
0.000000,0,0.000000,"\cj" => '\cj',
0.000000,0,0.000000,"\n" => '\n', # probably overrides one of either \cm or \cj
0.000000,0,0.000000,'"' => '\"',
0.000000,0,0.000000,'\\' => '\\\\',
0.000000,0,0.000000,'$' => '\\$',
0.000000,0,0.000000,'@' => '\\@',
0.000000,0,0.000000,'%' => '\\%',
0.000000,0,0.000000,'#' => '\\#',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub pretty { # adopted from Class::Classless
0.000000,0,0.000000,# Not the most brilliant routine, but passable.
0.000000,0,0.000000,# Don't give it a cyclic data structure!
0.000000,0,0.000000,my @stuff = @_; # copy
0.000000,0,0.000000,my $x;
0.000000,0,0.000000,my $out =
0.000000,0,0.000000,# join ",\n" .
0.000000,0,0.000000,join ", ",
0.000000,0,0.000000,map {;
0.000000,0,0.000000,if(!defined($_)) {
0.000000,0,0.000000,"undef";
0.000000,0,0.000000,} elsif(ref($_) eq 'ARRAY' or ref($_) eq 'Pod::Simple::LinkSection') {
0.000000,0,0.000000,$x = "[ " . pretty(@$_) . " ]" ;
0.000000,0,0.000000,$x;
0.000000,0,0.000000,} elsif(ref($_) eq 'SCALAR') {
0.000000,0,0.000000,$x = "\\" . pretty($$_) ;
0.000000,0,0.000000,$x;
0.000000,0,0.000000,} elsif(ref($_) eq 'HASH') {
0.000000,0,0.000000,my $hr = $_;
0.000000,0,0.000000,$x = "{" . join(", ",
0.000000,0,0.000000,map(pretty($_) . '=>' . pretty($hr->{$_}),
0.000000,0,0.000000,sort keys %$hr ) ) . "}" ;
0.000000,0,0.000000,$x;
0.000000,0,0.000000,} elsif(!length($_)) { q{''} # empty string
0.000000,0,0.000000,} elsif(
0.000000,0,0.000000,$_ eq '0' # very common case
0.000000,0,0.000000,or(
0.000000,0,0.000000,m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s
0.000000,0,0.000000,and $_ ne '-0' # the strange case that that RE lets thru
0.000000,0,0.000000,)
0.000000,0,0.000000,) { $_;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,if( chr(65) eq 'A' ) {
0.000000,0,0.000000,s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
0.000000,0,0.000000,#<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
0.000000,0,0.000000,<$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# We're in some crazy non-ASCII world!
0.000000,0,0.000000,s<([^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])>
0.000000,0,0.000000,#<$pretty_form{$1} || '\\x'.(unpack("H2",$1))>eg;
0.000000,0,0.000000,<$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;
0.000000,0,0.000000,}
0.000000,0,0.000000,qq{"$_"};
0.000000,0,0.000000,}
0.000000,0,0.000000,} @stuff;
0.000000,0,0.000000,# $out =~ s/\n */ /g if length($out) < 75;
0.000000,0,0.000000,return $out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000000,0,0.000000,
0.000000,0,0.000000,# A rather unsubtle method of blowing away all the state information
0.000000,0,0.000000,# from a parser object so it can be reused. Provided as a utility for
0.000000,0,0.000000,# backward compatibility in Pod::Man, etc. but not recommended for
0.000000,0,0.000000,# general use.
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinit {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,foreach (qw(source_dead source_filename doc_has_started
0.000000,0,0.000000,start_of_pod_block content_seen last_was_blank paras curr_open
0.000000,0,0.000000,line_count pod_para_count in_pod ~tried_gen_errata errata errors_seen
0.000000,0,0.000000,Title)) {
0.000000,0,0.000000,
0.000000,0,0.000000,delete $self->{$_};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
0.000006,1,0.000006,1;
0.000000,0,0.000000,
