# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Devel::Declare;
0.000000,0,0.000000,# ABSTRACT: Adding keywords to perl, in perl
0.000000,0,0.000000,
0.000034,2,0.000017,use strict;
0.000035,2,0.000017,use warnings;
0.000080,2,0.000040,use 5.008001;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.006014';
0.000000,0,0.000000,
0.000037,2,0.000018,use constant DECLARE_NAME => 1;
0.000033,2,0.000017,use constant DECLARE_PROTO => 2;
0.000036,2,0.000018,use constant DECLARE_NONE => 4;
0.000038,2,0.000019,use constant DECLARE_PACKAGE => 8+1; # name implicit
0.000000,0,0.000000,
0.000037,2,0.000018,use vars qw(%declarators %declarator_handlers @ISA);
0.000036,2,0.000018,use base qw(DynaLoader);
0.000039,2,0.000019,use Scalar::Util 'set_prototype';
0.000248,3,0.000083,use B::Hooks::OP::Check 0.19;
0.000000,0,0.000000,
0.000009,1,0.000009,bootstrap Devel::Declare;
0.000000,0,0.000000,
0.000008,1,0.000008,@ISA = ();
0.000000,0,0.000000,
0.000017,1,0.000017,initialize();
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,my ($class, %args) = @_;
0.000000,0,0.000000,my $target = caller;
0.000000,0,0.000000,if (@_ == 1) { # "use Devel::Declare;"
0.000451,2,0.000225,no strict 'refs';
0.000000,0,0.000000,foreach my $name (qw(NAME PROTO NONE PACKAGE)) {
0.000000,0,0.000000,*{"${target}::DECLARE_${name}"} = *{"DECLARE_${name}"};
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$class->setup_for($target => \%args);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my ($class) = @_;
0.000000,0,0.000000,my $target = caller;
0.000000,0,0.000000,$class->teardown_for($target);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub setup_for {
0.000004,2,0.000002,my ($class, $target, $args) = @_;
0.000060,2,0.000030,setup();
0.000017,2,0.000009,foreach my $key (keys %$args) {
0.000003,2,0.000002,my $info = $args->{$key};
0.000003,2,0.000001,my ($flags, $sub);
0.000008,2,0.000004,if (ref($info) eq 'ARRAY') {
0.000000,0,0.000000,($flags, $sub) = @$info;
0.000000,0,0.000000,} elsif (ref($info) eq 'CODE') {
0.000000,0,0.000000,$flags = DECLARE_NAME;
0.000000,0,0.000000,$sub = $info;
0.000000,0,0.000000,} elsif (ref($info) eq 'HASH') {
0.000003,2,0.000002,$flags = 1;
0.000003,2,0.000002,$sub = $info;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Info for sub ${key} must be [ \$flags, \$sub ] or \$sub or handler hashref";
0.000000,0,0.000000,}
0.000004,2,0.000002,$declarators{$target}{$key} = $flags;
0.000008,2,0.000004,$declarator_handlers{$target}{$key} = $sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub teardown_for {
0.000000,0,0.000000,my ($class, $target) = @_;
0.000000,0,0.000000,delete $declarators{$target};
0.000000,0,0.000000,delete $declarator_handlers{$target};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $temp_name;
0.000001,1,0.000001,my $temp_save;
0.000000,0,0.000000,
0.000000,0,0.000000,sub init_declare {
0.000000,0,0.000000,my ($usepack, $use, $inpack, $name, $proto, $traits) = @_;
0.000000,0,0.000000,my ($name_h, $XX_h, $extra_code)
0.000000,0,0.000000,= $declarator_handlers{$usepack}{$use}->(
0.000000,0,0.000000,$usepack, $use, $inpack, $name, $proto, defined(wantarray), $traits
0.000000,0,0.000000,);
0.000000,0,0.000000,($temp_name, $temp_save) = ([], []);
0.000000,0,0.000000,if ($name) {
0.000000,0,0.000000,$name = "${inpack}::${name}" unless $name =~ /::/;
0.000000,0,0.000000,shadow_sub($name, $name_h);
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($XX_h) {
0.000000,0,0.000000,shadow_sub("${inpack}::X", $XX_h);
0.000000,0,0.000000,}
0.000000,0,0.000000,if (defined wantarray) {
0.000000,0,0.000000,return $extra_code || '0;';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shadow_sub {
0.000029,17,0.000002,my ($name, $cr) = @_;
0.000031,17,0.000002,push(@$temp_name, $name);
0.000075,2,0.000038,no strict 'refs';
0.000167,17,0.000010,my ($pack, $pname) = ($name =~ m/(.+)::([^:]+)/);
0.000154,17,0.000009,push(@$temp_save, $pack->can($pname));
0.000040,2,0.000020,no warnings 'redefine';
0.000072,2,0.000036,no warnings 'prototype';
0.000047,17,0.000003,*{$name} = $cr;
0.000177,17,0.000010,set_in_declare(~~@{$temp_name||[]});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub done_declare {
0.000096,2,0.000048,no strict 'refs';
0.000032,17,0.000002,my $name = shift(@{$temp_name||[]});
0.000025,17,0.000001,die "done_declare called with no temp_name stack" unless defined($name);
0.000026,17,0.000002,my $saved = shift(@$temp_save);
0.000143,17,0.000008,$name =~ s/(.*):://;
0.000042,17,0.000002,my $temp_pack = $1;
0.000049,17,0.000003,delete ${"${temp_pack}::"}{$name};
0.000048,17,0.000003,if ($saved) {
0.001174,2,0.000587,no warnings 'prototype';
0.000068,17,0.000004,*{"${temp_pack}::${name}"} = $saved;
0.000000,0,0.000000,}
0.000197,17,0.000012,set_in_declare(~~@{$temp_name||[]});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub build_sub_installer {
0.000000,0,0.000000,my ($class, $pack, $name, $proto) = @_;
0.000000,0,0.000000,return eval "
0.000000,0,0.000000,package ${pack};
0.000000,0,0.000000,my \$body;
0.000000,0,0.000000,sub ${name} (${proto}) :lvalue {\n"
0.000000,0,0.000000,.'  if (wantarray) {
0.000000,0,0.000000,goto &$body;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $ret = $body->(@_);
0.000000,0,0.000000,return $ret;
0.000000,0,0.000000,};
0.000000,0,0.000000,sub { ($body) = @_; };';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub setup_declarators {
0.000000,0,0.000000,my ($class, $pack, $to_setup) = @_;
0.000000,0,0.000000,die "${class}->setup_declarators(\$pack, \\\%to_setup)"
0.000000,0,0.000000,unless defined($pack) && ref($to_setup) eq 'HASH';
0.000000,0,0.000000,my %setup_for_args;
0.000000,0,0.000000,foreach my $name (keys %$to_setup) {
0.000000,0,0.000000,my $info = $to_setup->{$name};
0.000000,0,0.000000,my $flags = $info->{flags} || DECLARE_NAME;
0.000000,0,0.000000,my $run = $info->{run};
0.000000,0,0.000000,my $compile = $info->{compile};
0.000000,0,0.000000,my $proto = $info->{proto} || '&';
0.000000,0,0.000000,my $sub_proto = $proto;
0.000000,0,0.000000,# make all args optional to enable lvalue for DECLARE_NONE
0.000000,0,0.000000,$sub_proto =~ s/;//; $sub_proto = ';'.$sub_proto;
0.000000,0,0.000000,#my $installer = $class->build_sub_installer($pack, $name, $proto);
0.000000,0,0.000000,my $installer = $class->build_sub_installer($pack, $name, '@');
0.000000,0,0.000000,$installer->(sub :lvalue {
0.000000,0,0.000000,#{ no warnings 'uninitialized'; warn 'INST: '.join(', ', @_)."\n"; }
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,if (ref $_[0] eq 'HASH') {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,my @ret = $run->(undef, undef, @_);
0.000000,0,0.000000,return @ret;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $r = $run->(undef, undef, @_);
0.000000,0,0.000000,return $r;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return @_[1..$#_];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return my $sv;
0.000000,0,0.000000,});
0.000000,0,0.000000,$setup_for_args{$name} = [
0.000000,0,0.000000,$flags,
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my ($usepack, $use, $inpack, $name, $proto, $shift_hashref, $traits) = @_;
0.000000,0,0.000000,my $extra_code = $compile->($name, $proto, $traits);
0.000000,0,0.000000,my $main_handler = sub { shift if $shift_hashref;
0.000000,0,0.000000,("DONE", $run->($name, $proto, @_));
0.000000,0,0.000000,};
0.000000,0,0.000000,my ($name_h, $XX);
0.000000,0,0.000000,if (defined $proto) {
0.000000,0,0.000000,$name_h = sub :lvalue { return my $sv; };
0.000000,0,0.000000,$XX = $main_handler;
0.000000,0,0.000000,} elsif (defined $name && length $name) {
0.000000,0,0.000000,$name_h = $main_handler;
0.000000,0,0.000000,}
0.000000,0,0.000000,$extra_code ||= '';
0.000000,0,0.000000,$extra_code = '}, sub {'.$extra_code;
0.000000,0,0.000000,return ($name_h, $XX, $extra_code);
0.000000,0,0.000000,}
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,$class->setup_for($pack, \%setup_for_args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_declarator {
0.000000,0,0.000000,my ($class, $target_pack, $target_name, $flags, $filter, $handler) = @_;
0.000000,0,0.000000,$class->setup_declarators($target_pack, {
0.000000,0,0.000000,$target_name => {
0.000000,0,0.000000,flags => $flags,
0.000000,0,0.000000,compile => $filter,
0.000000,0,0.000000,run => $handler,
0.000000,0,0.000000,}
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub linestr_callback_rv2cv {
0.000000,0,0.000000,my ($name, $offset) = @_;
0.000000,0,0.000000,$offset += toke_move_past_token($offset);
0.000000,0,0.000000,my $pack = get_curstash_name();
0.000000,0,0.000000,my $flags = $declarators{$pack}{$name};
0.000000,0,0.000000,my ($found_name, $found_proto);
0.000000,0,0.000000,if ($flags & DECLARE_NAME) {
0.000000,0,0.000000,$offset += toke_skipspace($offset);
0.000000,0,0.000000,my $linestr = get_linestr();
0.000000,0,0.000000,if (substr($linestr, $offset, 2) eq '::') {
0.000000,0,0.000000,substr($linestr, $offset, 2) = '';
0.000000,0,0.000000,set_linestr($linestr);
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my $len = toke_scan_word($offset, $flags & DECLARE_PACKAGE)) {
0.000000,0,0.000000,$found_name = substr($linestr, $offset, $len);
0.000000,0,0.000000,$offset += $len;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($flags & DECLARE_PROTO) {
0.000000,0,0.000000,$offset += toke_skipspace($offset);
0.000000,0,0.000000,my $linestr = get_linestr();
0.000000,0,0.000000,if (substr($linestr, $offset, 1) eq '(') {
0.000000,0,0.000000,my $length = toke_scan_str($offset);
0.000000,0,0.000000,$found_proto = get_lex_stuff();
0.000000,0,0.000000,clear_lex_stuff();
0.000000,0,0.000000,my $replace =
0.000000,0,0.000000,($found_name ? ' ' : '=')
0.000000,0,0.000000,.'X'.(' ' x length($found_proto));
0.000000,0,0.000000,$linestr = get_linestr();
0.000000,0,0.000000,substr($linestr, $offset, $length) = $replace;
0.000000,0,0.000000,set_linestr($linestr);
0.000000,0,0.000000,$offset += $length;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my @args = ($pack, $name, $pack, $found_name, $found_proto);
0.000000,0,0.000000,$offset += toke_skipspace($offset);
0.000000,0,0.000000,my $linestr = get_linestr();
0.000000,0,0.000000,if (substr($linestr, $offset, 1) eq '{') {
0.000000,0,0.000000,my $ret = init_declare(@args);
0.000000,0,0.000000,$offset++;
0.000000,0,0.000000,if (defined $ret && length $ret) {
0.000000,0,0.000000,substr($linestr, $offset, 0) = $ret;
0.000000,0,0.000000,set_linestr($linestr);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,init_declare(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,#warn "linestr now ${linestr}";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub linestr_callback_const {
0.000000,0,0.000000,my ($name, $offset) = @_;
0.000000,0,0.000000,my $pack = get_curstash_name();
0.000000,0,0.000000,my $flags = $declarators{$pack}{$name};
0.000000,0,0.000000,if ($flags & DECLARE_NAME) {
0.000000,0,0.000000,$offset += toke_move_past_token($offset);
0.000000,0,0.000000,$offset += toke_skipspace($offset);
0.000000,0,0.000000,if (toke_scan_word($offset, $flags & DECLARE_PACKAGE)) {
0.000000,0,0.000000,my $linestr = get_linestr();
0.000000,0,0.000000,substr($linestr, $offset, 0) = '::';
0.000000,0,0.000000,set_linestr($linestr);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub linestr_callback {
0.000029,17,0.000002,my $type = shift;
0.000025,17,0.000001,my $name = $_[0];
0.000131,17,0.000008,my $pack = get_curstash_name();
0.000038,17,0.000002,my $handlers = $declarator_handlers{$pack}{$name};
0.000190,17,0.000011,if (ref $handlers eq 'CODE') {
0.000000,0,0.000000,my $meth = "linestr_callback_${type}";
0.000000,0,0.000000,__PACKAGE__->can($meth)->(@_);
0.000000,0,0.000000,} elsif (ref $handlers eq 'HASH') {
0.000000,0,0.000000,if ($handlers->{$type}) {
0.000000,0,0.000000,$handlers->{$type}->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "PANIC: unknown thing in handlers for $pack $name: $handlers";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Devel::Declare - Adding keywords to perl, in perl
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Method::Signatures;
0.000000,0,0.000000,# or ...
0.000000,0,0.000000,use MooseX::Declare;
0.000000,0,0.000000,# etc.
0.000000,0,0.000000,
0.000000,0,0.000000,# Use some new and exciting syntax like:
0.000000,0,0.000000,method hello (Str :$who, Int :$age where { $_ > 0 }) {
0.000000,0,0.000000,$self->say("Hello ${who}, I am ${age} years old!");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,L<Devel::Declare> can install subroutines called declarators which locally take
0.000000,0,0.000000,over Perl's parser, allowing the creation of new syntax.
0.000000,0,0.000000,
0.000000,0,0.000000,This document describes how to create a simple declarator.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 USAGE
0.000000,0,0.000000,
0.000000,0,0.000000,We'll demonstrate the usage of C<Devel::Declare> with a motivating example: a new
0.000000,0,0.000000,C<method> keyword, which acts like the builtin C<sub>, but automatically unpacks
0.000000,0,0.000000,C<$self> and the other arguments.
0.000000,0,0.000000,
0.000000,0,0.000000,package My::Methods;
0.000000,0,0.000000,use Devel::Declare;
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Creating a declarator with C<setup_for>
0.000000,0,0.000000,
0.000000,0,0.000000,You will typically create
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my $caller = caller;
0.000000,0,0.000000,
0.000000,0,0.000000,Devel::Declare->setup_for(
0.000000,0,0.000000,$caller,
0.000000,0,0.000000,{ method => { const => \&parser } }
0.000000,0,0.000000,);
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,*{$caller.'::method'} = sub (&) {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Starting from the end of this import routine, you'll see that we're creating a
0.000000,0,0.000000,subroutine called C<method> in the caller's namespace.  Yes, that's just a normal
0.000000,0,0.000000,subroutine, and it does nothing at all (yet!)  Note the prototype C<(&)> which means
0.000000,0,0.000000,that the caller would call it like so:
0.000000,0,0.000000,
0.000000,0,0.000000,method {
0.000000,0,0.000000,my ($self, $arg1, $arg2) = @_;
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,However we want to be able to call it like this
0.000000,0,0.000000,
0.000000,0,0.000000,method foo ($arg1, $arg2) {
0.000000,0,0.000000,...
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,That's why we call C<setup_for> above, to register the declarator 'method' with a custom
0.000000,0,0.000000,parser, as per the next section.  It acts on an optype, usually C<'const'> as above.
0.000000,0,0.000000,(Other valid values are C<'check'> and C<'rv2cv'>).
0.000000,0,0.000000,
0.000000,0,0.000000,For a simpler way to install new methods, see also L<Devel::Declare::MethodInstaller::Simple>
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Writing a parser subroutine
0.000000,0,0.000000,
0.000000,0,0.000000,This subroutine is called at I<compilation> time, and allows you to read the custom
0.000000,0,0.000000,syntaxes that we want (in a syntax that may or may not be valid core Perl 5) and
0.000000,0,0.000000,munge it so that the result will be parsed by the C<perl> compiler.
0.000000,0,0.000000,
0.000000,0,0.000000,For this example, we're defining some globals for convenience:
0.000000,0,0.000000,
0.000000,0,0.000000,our ($Declarator, $Offset);
0.000000,0,0.000000,
0.000000,0,0.000000,Then we define a parser subroutine to handle our declarator.  We'll look at this in
0.000000,0,0.000000,a few chunks.
0.000000,0,0.000000,
0.000000,0,0.000000,sub parser {
0.000000,0,0.000000,local ($Declarator, $Offset) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,C<Devel::Declare> provides some very low level utility methods to parse character
0.000000,0,0.000000,strings.  We'll define some useful higher level routines below for convenience,
0.000000,0,0.000000,and we can use these to parse the various elements in our new syntax.
0.000000,0,0.000000,
0.000000,0,0.000000,Notice how our parser subroutine is invoked at compile time,
0.000000,0,0.000000,when the C<perl> parser is pointed just I<before> the declarator name.
0.000000,0,0.000000,
0.000000,0,0.000000,skip_declarator;          # step past 'method'
0.000000,0,0.000000,my $name = strip_name;    # strip out the name 'foo', if present
0.000000,0,0.000000,my $proto = strip_proto;  # strip out the prototype '($arg1, $arg2)', if present
0.000000,0,0.000000,
0.000000,0,0.000000,Now we can prepare some code to 'inject' into the new subroutine.  For example we
0.000000,0,0.000000,might want the method as above to have C<my ($self, $arg1, $arg2) = @_> injected at
0.000000,0,0.000000,the beginning of it.  We also do some clever stuff with scopes that we'll look
0.000000,0,0.000000,at shortly.
0.000000,0,0.000000,
0.000000,0,0.000000,my $inject = make_proto_unwrap($proto);
0.000000,0,0.000000,if (defined $name) {
0.000000,0,0.000000,$inject = scope_injector_call().$inject;
0.000000,0,0.000000,}
0.000000,0,0.000000,inject_if_block($inject);
0.000000,0,0.000000,
0.000000,0,0.000000,We've now managed to change C<method ($arg1, $arg2) { ... }> into C<method {
0.000000,0,0.000000,injected_code; ... }>.  This will compile...  but we've lost the name of the
0.000000,0,0.000000,method!
0.000000,0,0.000000,
0.000000,0,0.000000,In a cute (or horrifying, depending on your perspective) trick, we temporarily
0.000000,0,0.000000,change the definition of the subroutine C<method> itself, to specialise it with
0.000000,0,0.000000,the C<$name> we stripped, so that it assigns the code block to that name.
0.000000,0,0.000000,
0.000000,0,0.000000,Even though the I<next> time C<method> is compiled, it will be
0.000000,0,0.000000,redefined again, C<perl> caches these definitions in its parse
0.000000,0,0.000000,tree, so we'll always get the right one!
0.000000,0,0.000000,
0.000000,0,0.000000,Note that we also handle the case where there was no name, allowing
0.000000,0,0.000000,an anonymous method analogous to an anonymous subroutine.
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $name) {
0.000000,0,0.000000,$name = join('::', Devel::Declare::get_curstash_name(), $name)
0.000000,0,0.000000,unless ($name =~ /::/);
0.000000,0,0.000000,shadow(sub (&) { no strict 'refs'; *{$name} = shift; });
0.000000,0,0.000000,} else {
0.000000,0,0.000000,shadow(sub (&) { shift });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Parser utilities in detail
0.000000,0,0.000000,
0.000000,0,0.000000,For simplicity, we're using global variables like C<$Offset> in these examples.
0.000000,0,0.000000,You may prefer to look at L<Devel::Declare::Context::Simple>, which
0.000000,0,0.000000,encapsulates the context much more cleanly.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<skip_declarator>
0.000000,0,0.000000,
0.000000,0,0.000000,This simple parser just moves across a 'token'.  The common case is
0.000000,0,0.000000,to skip the declarator, i.e.  to move to the end of the string
0.000000,0,0.000000,'method' and before the prototype and code block.
0.000000,0,0.000000,
0.000000,0,0.000000,sub skip_declarator {
0.000000,0,0.000000,$Offset += Devel::Declare::toke_move_past_token($Offset);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<toke_move_past_token>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin parser simply moves past a 'token' (matching C</[a-zA-Z_]\w*/>)
0.000000,0,0.000000,It takes an offset into the source document, and skips past the token.
0.000000,0,0.000000,It returns the number of characters skipped.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<strip_name>
0.000000,0,0.000000,
0.000000,0,0.000000,This parser skips any whitespace, then scans the next word (again matching a
0.000000,0,0.000000,'token').  We can then analyse the current line, and manipulate it (using pure
0.000000,0,0.000000,Perl).  In this case we take the name of the method out, and return it.
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_name {
0.000000,0,0.000000,skipspace;
0.000000,0,0.000000,if (my $len = Devel::Declare::toke_scan_word($Offset, 1)) {
0.000000,0,0.000000,my $linestr = Devel::Declare::get_linestr();
0.000000,0,0.000000,my $name = substr($linestr, $Offset, $len);
0.000000,0,0.000000,substr($linestr, $Offset, $len) = '';
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<toke_scan_word>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin parser, given an offset into the source document,
0.000000,0,0.000000,matches a 'token' as above but does not skip.  It returns the
0.000000,0,0.000000,length of the token matched, if any.
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<get_linestr>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin returns the full text of the current line of the source document.
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<set_linestr>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin sets the full text of the current line of the source document.
0.000000,0,0.000000,Beware that injecting a newline into the middle of the line is likely
0.000000,0,0.000000,to fail in surprising ways.  Generally, Perl's parser can rely on the
0.000000,0,0.000000,`current line' actually being only a single line.  Use other kinds of
0.000000,0,0.000000,whitespace instead, in the code that you inject.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<skipspace>
0.000000,0,0.000000,
0.000000,0,0.000000,This parser skips whitsepace.
0.000000,0,0.000000,
0.000000,0,0.000000,sub skipspace {
0.000000,0,0.000000,$Offset += Devel::Declare::toke_skipspace($Offset);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<toke_skipspace>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin parser, given an offset into the source document,
0.000000,0,0.000000,skips over any whitespace, and returns the number of characters
0.000000,0,0.000000,skipped.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<strip_proto>
0.000000,0,0.000000,
0.000000,0,0.000000,This is a more complex parser that checks if it's found something that
0.000000,0,0.000000,starts with C<'('> and returns everything till the matching C<')'>.
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_proto {
0.000000,0,0.000000,skipspace;
0.000000,0,0.000000,
0.000000,0,0.000000,my $linestr = Devel::Declare::get_linestr();
0.000000,0,0.000000,if (substr($linestr, $Offset, 1) eq '(') {
0.000000,0,0.000000,my $length = Devel::Declare::toke_scan_str($Offset);
0.000000,0,0.000000,my $proto = Devel::Declare::get_lex_stuff();
0.000000,0,0.000000,Devel::Declare::clear_lex_stuff();
0.000000,0,0.000000,$linestr = Devel::Declare::get_linestr();
0.000000,0,0.000000,substr($linestr, $Offset, $length) = '';
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,return $proto;
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<toke_scan_str>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin parser uses Perl's own parsing routines to match a "stringlike"
0.000000,0,0.000000,expression.  Handily, this includes bracketed expressions (just think about
0.000000,0,0.000000,things like C<q(this is a quote)>).
0.000000,0,0.000000,
0.000000,0,0.000000,Also it Does The Right Thing with nested delimiters (like C<q(this (is (a) quote))>).
0.000000,0,0.000000,
0.000000,0,0.000000,It returns the effective length of the expression matched.  Really, what
0.000000,0,0.000000,it returns is the difference in position between where the string started,
0.000000,0,0.000000,within the buffer, and where it finished.  If the string extended across
0.000000,0,0.000000,multiple lines then the contents of the buffer may have been completely
0.000000,0,0.000000,replaced by the new lines, so this position difference is not the same
0.000000,0,0.000000,thing as the actual length of the expression matched.  However, because
0.000000,0,0.000000,moving backward in the buffer causes problems, the function arranges
0.000000,0,0.000000,for the effective length to always be positive, padding the start of
0.000000,0,0.000000,the buffer if necessary.
0.000000,0,0.000000,
0.000000,0,0.000000,Use C<get_lex_stuff> to get the actual matched text, the content of
0.000000,0,0.000000,the string.  Because of the behaviour around multiline strings, you
0.000000,0,0.000000,can't reliably get this from the buffer.  In fact, after the function
0.000000,0,0.000000,returns, you can't rely on any content of the buffer preceding the end
0.000000,0,0.000000,of the string.
0.000000,0,0.000000,
0.000000,0,0.000000,If the string being scanned is not well formed (has no closing delimiter),
0.000000,0,0.000000,C<toke_scan_str> returns C<undef>.  In this case you cannot rely on the
0.000000,0,0.000000,contents of the buffer.
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<get_lex_stuff>
0.000000,0,0.000000,
0.000000,0,0.000000,This builtin returns what was matched by C<toke_scan_str>.  To avoid segfaults,
0.000000,0,0.000000,you should call C<clear_lex_stuff> immediately afterwards.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Munging the subroutine
0.000000,0,0.000000,
0.000000,0,0.000000,Let's look at what we need to do in detail.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<make_proto_unwrap>
0.000000,0,0.000000,
0.000000,0,0.000000,We may have defined our method in different ways, which will result
0.000000,0,0.000000,in a different value for our prototype, as parsed above.  For example:
0.000000,0,0.000000,
0.000000,0,0.000000,method foo         {  # undefined
0.000000,0,0.000000,method foo ()      {  # ''
0.000000,0,0.000000,method foo ($arg1) {  # '$arg1'
0.000000,0,0.000000,
0.000000,0,0.000000,We deal with them as follows, and return the appropriate C<my ($self, ...) = @_;>
0.000000,0,0.000000,string.
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_proto_unwrap {
0.000000,0,0.000000,my ($proto) = @_;
0.000000,0,0.000000,my $inject = 'my ($self';
0.000000,0,0.000000,if (defined $proto) {
0.000000,0,0.000000,$inject .= ", $proto" if length($proto);
0.000000,0,0.000000,$inject .= ') = @_; ';
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$inject .= ') = shift;';
0.000000,0,0.000000,}
0.000000,0,0.000000,return $inject;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<inject_if_block>
0.000000,0,0.000000,
0.000000,0,0.000000,Now we need to inject it after the opening C<'{'> of the method body.
0.000000,0,0.000000,We can do this with the building blocks we defined above like C<skipspace>
0.000000,0,0.000000,and C<get_linestr>.
0.000000,0,0.000000,
0.000000,0,0.000000,sub inject_if_block {
0.000000,0,0.000000,my $inject = shift;
0.000000,0,0.000000,skipspace;
0.000000,0,0.000000,my $linestr = Devel::Declare::get_linestr;
0.000000,0,0.000000,if (substr($linestr, $Offset, 1) eq '{') {
0.000000,0,0.000000,substr($linestr, $Offset+1, 0) = $inject;
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<scope_injector_call>
0.000000,0,0.000000,
0.000000,0,0.000000,We want to be able to handle both named and anonymous methods.  i.e.
0.000000,0,0.000000,
0.000000,0,0.000000,method foo () { ... }
0.000000,0,0.000000,my $meth = method () { ... };
0.000000,0,0.000000,
0.000000,0,0.000000,These will then get rewritten as
0.000000,0,0.000000,
0.000000,0,0.000000,method { ... }
0.000000,0,0.000000,my $meth = method { ... };
0.000000,0,0.000000,
0.000000,0,0.000000,where 'method' is a subroutine that takes a code block.  Spot the problem?
0.000000,0,0.000000,The first one doesn't have a semicolon at the end of it!  Unlike 'sub' which
0.000000,0,0.000000,is a builtin, this is just a normal statement, so we need to terminate it.
0.000000,0,0.000000,Luckily, using C<B::Hooks::EndOfScope>, we can do this!
0.000000,0,0.000000,
0.000000,0,0.000000,use B::Hooks::EndOfScope;
0.000000,0,0.000000,
0.000000,0,0.000000,We'll add this to what gets 'injected' at the beginning of the method source.
0.000000,0,0.000000,
0.000000,0,0.000000,sub scope_injector_call {
0.000000,0,0.000000,return ' BEGIN { MethodHandlers::inject_scope }; ';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,So at the beginning of every method, we are passing a callback that will get invoked
0.000000,0,0.000000,at the I<end> of the method's compilation... i.e. exactly then the closing C<'}'>
0.000000,0,0.000000,is compiled.
0.000000,0,0.000000,
0.000000,0,0.000000,sub inject_scope {
0.000000,0,0.000000,on_scope_end {
0.000000,0,0.000000,my $linestr = Devel::Declare::get_linestr;
0.000000,0,0.000000,my $offset = Devel::Declare::get_linestr_offset;
0.000000,0,0.000000,substr($linestr, $offset, 0) = ';';
0.000000,0,0.000000,Devel::Declare::set_linestr($linestr);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Shadowing each method.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 C<shadow>
0.000000,0,0.000000,
0.000000,0,0.000000,We override the current definition of 'method' using C<shadow>.
0.000000,0,0.000000,
0.000000,0,0.000000,sub shadow {
0.000000,0,0.000000,my $pack = Devel::Declare::get_curstash_name;
0.000000,0,0.000000,Devel::Declare::shadow_sub("${pack}::${Declarator}", $_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,For a named method we invoked like this:
0.000000,0,0.000000,
0.000000,0,0.000000,shadow(sub (&) { no strict 'refs'; *{$name} = shift; });
0.000000,0,0.000000,
0.000000,0,0.000000,So in the case of a C<method foo { ... }>, this call would redefine C<method>
0.000000,0,0.000000,to be a subroutine that exports 'sub foo' as the (munged) contents of C<{...}>.
0.000000,0,0.000000,
0.000000,0,0.000000,The case of an anonymous method is also cute:
0.000000,0,0.000000,
0.000000,0,0.000000,shadow(sub (&) { shift });
0.000000,0,0.000000,
0.000000,0,0.000000,This means that
0.000000,0,0.000000,
0.000000,0,0.000000,my $meth = method () { ... };
0.000000,0,0.000000,
0.000000,0,0.000000,is rewritten with C<method> taking the codeblock, and returning it as is to become
0.000000,0,0.000000,the value of C<$meth>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<get_curstash_name>
0.000000,0,0.000000,
0.000000,0,0.000000,This returns the package name I<currently being compiled>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head4 C<shadow_sub>
0.000000,0,0.000000,
0.000000,0,0.000000,Handles the details of redefining the subroutine.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,One of the best ways to learn C<Devel::Declare> is still to look at
0.000000,0,0.000000,modules that use it:
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://cpants.perl.org/dist/used_by/Devel-Declare>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHORS
0.000000,0,0.000000,
0.000000,0,0.000000,Matt S Trout - E<lt>mst@shadowcat.co.ukE<gt> - original author
0.000000,0,0.000000,
0.000000,0,0.000000,Company: http://www.shadowcat.co.uk/
0.000000,0,0.000000,Blog: http://chainsawblues.vox.com/
0.000000,0,0.000000,
0.000000,0,0.000000,Florian Ragwitz E<lt>rafl@debian.orgE<gt> - maintainer
0.000000,0,0.000000,
0.000000,0,0.000000,osfameron E<lt>osfameron@cpan.orgE<gt> - first draft of documentation
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT AND LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This library is free software under the same terms as perl itself
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (c) 2007, 2008, 2009  Matt S Trout
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (c) 2008, 2009  Florian Ragwitz
0.000000,0,0.000000,
0.000000,0,0.000000,stolen_chunk_of_toke.c based on toke.c from the perl core, which is
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
0.000000,0,0.000000,2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000006,1,0.000006,1;
