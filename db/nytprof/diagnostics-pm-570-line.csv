# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package diagnostics;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,diagnostics, splain - produce verbose warning diagnostics
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,Using the C<diagnostics> pragma:
0.000000,0,0.000000,
0.000000,0,0.000000,use diagnostics;
0.000000,0,0.000000,use diagnostics -verbose;
0.000000,0,0.000000,
0.000000,0,0.000000,enable  diagnostics;
0.000000,0,0.000000,disable diagnostics;
0.000000,0,0.000000,
0.000000,0,0.000000,Using the C<splain> standalone filter program:
0.000000,0,0.000000,
0.000000,0,0.000000,perl program 2>diag.out
0.000000,0,0.000000,splain [-v] [-p] diag.out
0.000000,0,0.000000,
0.000000,0,0.000000,Using diagnostics to get stack traces from a misbehaving script:
0.000000,0,0.000000,
0.000000,0,0.000000,perl -Mdiagnostics=-traceonly my_script.pl
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The C<diagnostics> Pragma
0.000000,0,0.000000,
0.000000,0,0.000000,This module extends the terse diagnostics normally emitted by both the
0.000000,0,0.000000,perl compiler and the perl interpreter (from running perl with a -w 
0.000000,0,0.000000,switch or C<use warnings>), augmenting them with the more
0.000000,0,0.000000,explicative and endearing descriptions found in L<perldiag>.  Like the
0.000000,0,0.000000,other pragmata, it affects the compilation phase of your program rather
0.000000,0,0.000000,than merely the execution phase.
0.000000,0,0.000000,
0.000000,0,0.000000,To use in your program as a pragma, merely invoke
0.000000,0,0.000000,
0.000000,0,0.000000,use diagnostics;
0.000000,0,0.000000,
0.000000,0,0.000000,at the start (or near the start) of your program.  (Note 
0.000000,0,0.000000,that this I<does> enable perl's B<-w> flag.)  Your whole
0.000000,0,0.000000,compilation will then be subject(ed :-) to the enhanced diagnostics.
0.000000,0,0.000000,These still go out B<STDERR>.
0.000000,0,0.000000,
0.000000,0,0.000000,Due to the interaction between runtime and compiletime issues,
0.000000,0,0.000000,and because it's probably not a very good idea anyway,
0.000000,0,0.000000,you may not use C<no diagnostics> to turn them off at compiletime.
0.000000,0,0.000000,However, you may control their behaviour at runtime using the 
0.000000,0,0.000000,disable() and enable() methods to turn them off and on respectively.
0.000000,0,0.000000,
0.000000,0,0.000000,The B<-verbose> flag first prints out the L<perldiag> introduction before
0.000000,0,0.000000,any other diagnostics.  The $diagnostics::PRETTY variable can generate nicer
0.000000,0,0.000000,escape sequences for pagers.
0.000000,0,0.000000,
0.000000,0,0.000000,Warnings dispatched from perl itself (or more accurately, those that match
0.000000,0,0.000000,descriptions found in L<perldiag>) are only displayed once (no duplicate
0.000000,0,0.000000,descriptions).  User code generated warnings a la warn() are unaffected,
0.000000,0,0.000000,allowing duplicate user messages to be displayed.
0.000000,0,0.000000,
0.000000,0,0.000000,This module also adds a stack trace to the error message when perl dies.
0.000000,0,0.000000,This is useful for pinpointing what
0.000000,0,0.000000,caused the death.  The B<-traceonly> (or
0.000000,0,0.000000,just B<-t>) flag turns off the explanations of warning messages leaving just
0.000000,0,0.000000,the stack traces.  So if your script is dieing, run it again with
0.000000,0,0.000000,
0.000000,0,0.000000,perl -Mdiagnostics=-traceonly my_bad_script
0.000000,0,0.000000,
0.000000,0,0.000000,to see the call stack at the time of death.  By supplying the B<-warntrace>
0.000000,0,0.000000,(or just B<-w>) flag, any warnings emitted will also come with a stack
0.000000,0,0.000000,trace.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 The I<splain> Program
0.000000,0,0.000000,
0.000000,0,0.000000,While apparently a whole nuther program, I<splain> is actually nothing
0.000000,0,0.000000,more than a link to the (executable) F<diagnostics.pm> module, as well as
0.000000,0,0.000000,a link to the F<diagnostics.pod> documentation.  The B<-v> flag is like
0.000000,0,0.000000,the C<use diagnostics -verbose> directive.
0.000000,0,0.000000,The B<-p> flag is like the
0.000000,0,0.000000,$diagnostics::PRETTY variable.  Since you're post-processing with 
0.000000,0,0.000000,I<splain>, there's no sense in being able to enable() or disable() processing.
0.000000,0,0.000000,
0.000000,0,0.000000,Output from I<splain> is directed to B<STDOUT>, unlike the pragma.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXAMPLES
0.000000,0,0.000000,
0.000000,0,0.000000,The following file is certain to trigger a few errors at both
0.000000,0,0.000000,runtime and compiletime:
0.000000,0,0.000000,
0.000000,0,0.000000,use diagnostics;
0.000000,0,0.000000,print NOWHERE "nothing\n";
0.000000,0,0.000000,print STDERR "\n\tThis message should be unadorned.\n";
0.000000,0,0.000000,warn "\tThis is a user warning";
0.000000,0,0.000000,print "\nDIAGNOSTIC TESTER: Please enter a <CR> here: ";
0.000000,0,0.000000,my $a, $b = scalar <STDIN>;
0.000000,0,0.000000,print "\n";
0.000000,0,0.000000,print $x/$y;
0.000000,0,0.000000,
0.000000,0,0.000000,If you prefer to run your program first and look at its problem
0.000000,0,0.000000,afterwards, do this:
0.000000,0,0.000000,
0.000000,0,0.000000,perl -w test.pl 2>test.out
0.000000,0,0.000000,./splain < test.out
0.000000,0,0.000000,
0.000000,0,0.000000,Note that this is not in general possible in shells of more dubious heritage, 
0.000000,0,0.000000,as the theoretical 
0.000000,0,0.000000,
0.000000,0,0.000000,(perl -w test.pl >/dev/tty) >& test.out
0.000000,0,0.000000,./splain < test.out
0.000000,0,0.000000,
0.000000,0,0.000000,Because you just moved the existing B<stdout> to somewhere else.
0.000000,0,0.000000,
0.000000,0,0.000000,If you don't want to modify your source code, but still have on-the-fly
0.000000,0,0.000000,warnings, do this:
0.000000,0,0.000000,
0.000000,0,0.000000,exec 3>&1; perl -w test.pl 2>&1 1>&3 3>&- | splain 1>&2 3>&- 
0.000000,0,0.000000,
0.000000,0,0.000000,Nifty, eh?
0.000000,0,0.000000,
0.000000,0,0.000000,If you want to control warnings on the fly, do something like this.
0.000000,0,0.000000,Make sure you do the C<use> first, or you won't be able to get
0.000000,0,0.000000,at the enable() or disable() methods.
0.000000,0,0.000000,
0.000000,0,0.000000,use diagnostics; # checks entire compilation phase 
0.000000,0,0.000000,print "\ntime for 1st bogus diags: SQUAWKINGS\n";
0.000000,0,0.000000,print BOGUS1 'nada';
0.000000,0,0.000000,print "done with 1st bogus\n";
0.000000,0,0.000000,
0.000000,0,0.000000,disable diagnostics; # only turns off runtime warnings
0.000000,0,0.000000,print "\ntime for 2nd bogus: (squelched)\n";
0.000000,0,0.000000,print BOGUS2 'nada';
0.000000,0,0.000000,print "done with 2nd bogus\n";
0.000000,0,0.000000,
0.000000,0,0.000000,enable diagnostics; # turns back on runtime warnings
0.000000,0,0.000000,print "\ntime for 3rd bogus: SQUAWKINGS\n";
0.000000,0,0.000000,print BOGUS3 'nada';
0.000000,0,0.000000,print "done with 3rd bogus\n";
0.000000,0,0.000000,
0.000000,0,0.000000,disable diagnostics;
0.000000,0,0.000000,print "\ntime for 4th bogus: (squelched)\n";
0.000000,0,0.000000,print BOGUS4 'nada';
0.000000,0,0.000000,print "done with 4th bogus\n";
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 INTERNALS
0.000000,0,0.000000,
0.000000,0,0.000000,Diagnostic messages derive from the F<perldiag.pod> file when available at
0.000000,0,0.000000,runtime.  Otherwise, they may be embedded in the file itself when the
0.000000,0,0.000000,splain package is built.   See the F<Makefile> for details.
0.000000,0,0.000000,
0.000000,0,0.000000,If an extant $SIG{__WARN__} handler is discovered, it will continue
0.000000,0,0.000000,to be honored, but only after the diagnostics::splainthis() function 
0.000000,0,0.000000,(the module's $SIG{__WARN__} interceptor) has had its way with your
0.000000,0,0.000000,warnings.
0.000000,0,0.000000,
0.000000,0,0.000000,There is a $diagnostics::DEBUG variable you may set if you're desperately
0.000000,0,0.000000,curious what sorts of things are being intercepted.
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN { $diagnostics::DEBUG = 1 } 
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,Not being able to say "no diagnostics" is annoying, but may not be
0.000000,0,0.000000,insurmountable.
0.000000,0,0.000000,
0.000000,0,0.000000,The C<-pretty> directive is called too late to affect matters.
0.000000,0,0.000000,You have to do this instead, and I<before> you load the module.
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN { $diagnostics::PRETTY = 1 } 
0.000000,0,0.000000,
0.000000,0,0.000000,I could start up faster by delaying compilation until it should be
0.000000,0,0.000000,needed, but this gets a "panic: top_level" when using the pragma form
0.000000,0,0.000000,in Perl 5.001e.
0.000000,0,0.000000,
0.000000,0,0.000000,While it's true that this documentation is somewhat subserious, if you use
0.000000,0,0.000000,a program named I<splain>, you should expect a bit of whimsy.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Tom Christiansen <F<tchrist@mox.perl.com>>, 25 June 1995.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000036,2,0.000018,use strict;
0.000057,2,0.000029,use 5.009001;
0.000094,2,0.000047,use Carp;
0.000003,1,0.000003,$Carp::Internal{__PACKAGE__.""}++;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.31';
0.000001,1,0.000001,our $DEBUG;
0.000001,1,0.000001,our $VERBOSE;
0.000001,1,0.000001,our $PRETTY;
0.000002,1,0.000002,our $TRACEONLY = 0;
0.000001,1,0.000001,our $WARNTRACE = 0;
0.000000,0,0.000000,
0.003130,2,0.001565,use Config;
0.000017,1,0.000017,my $privlib = $Config{privlibexp};
0.000002,1,0.000002,if ($^O eq 'VMS') {
0.000000,0,0.000000,require VMS::Filespec;
0.000000,0,0.000000,$privlib = VMS::Filespec::unixify($privlib);
0.000000,0,0.000000,}
0.000003,1,0.000003,my @trypod = (
0.000000,0,0.000000,"$privlib/pod/perldiag.pod",
0.000000,0,0.000000,"$privlib/pods/perldiag.pod",
0.000000,0,0.000000,);
0.000000,0,0.000000,# handy for development testing of new warnings etc
0.000014,1,0.000014,unshift @trypod, "./pod/perldiag.pod" if -e "pod/perldiag.pod";
0.000021,1,0.000021,(my $PODFILE) = ((grep { -e } @trypod), $trypod[$#trypod])[0];
0.000000,0,0.000000,
0.000002,1,0.000002,$DEBUG ||= 0;
0.000011,1,0.000011,my $WHOAMI = ref bless [];  # nobody's business, prolly not even mine
0.000000,0,0.000000,
0.000004,1,0.000004,local $| = 1;
0.000001,1,0.000001,local $_;
0.000002,1,0.000002,local $.;
0.000000,0,0.000000,
0.000001,1,0.000001,my $standalone;
0.000001,1,0.000001,my(%HTML_2_Troff, %HTML_2_Latin_1, %HTML_2_ASCII_7);
0.000000,0,0.000000,
0.000002,1,0.000002,CONFIG: {
0.000002,1,0.000002,our $opt_p = our $opt_d = our $opt_v = our $opt_f = '';
0.000000,0,0.000000,
0.000002,1,0.000002,unless (caller) {
0.000000,0,0.000000,$standalone++;
0.000000,0,0.000000,require Getopt::Std;
0.000000,0,0.000000,Getopt::Std::getopts('pdvf:')
0.000000,0,0.000000,or die "Usage: $0 [-v] [-p] [-f splainpod]";
0.000000,0,0.000000,$PODFILE = $opt_f if $opt_f;
0.000000,0,0.000000,$DEBUG = 2 if $opt_d;
0.000000,0,0.000000,$VERBOSE = $opt_v;
0.000000,0,0.000000,$PRETTY = $opt_p;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000027,1,0.000027,if (open(POD_DIAG, $PODFILE)) {
0.000001,1,0.000001,warn "Happy happy podfile from real $PODFILE\n" if $DEBUG;
0.000003,1,0.000003,last CONFIG;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,if (caller) {
0.000000,0,0.000000,INCPATH: {
0.000000,0,0.000000,for my $file ( (map { "$_/$WHOAMI.pm" } @INC), $0) {
0.000000,0,0.000000,warn "Checking $file\n" if $DEBUG;
0.000000,0,0.000000,if (open(POD_DIAG, $file)) {
0.000000,0,0.000000,while (<POD_DIAG>) {
0.000000,0,0.000000,next unless
0.000000,0,0.000000,/^__END__\s*# wish diag dbase were more accessible/;
0.000000,0,0.000000,print STDERR "podfile is $file\n" if $DEBUG;
0.000000,0,0.000000,last INCPATH;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} 
0.000000,0,0.000000,}
0.000000,0,0.000000,} else { 
0.000000,0,0.000000,print STDERR "podfile is <DATA>\n" if $DEBUG;
0.000000,0,0.000000,*POD_DIAG = *main::DATA;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000021,1,0.000021,if (eof(POD_DIAG)) { 
0.000000,0,0.000000,die "couldn't find diagnostic data in $PODFILE @INC $0";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,%HTML_2_Troff = (
0.000005,1,0.000005,'amp'	=>	'&',	#   ampersand
0.000000,0,0.000000,'lt'	=>	'<',	#   left chevron, less-than
0.000000,0,0.000000,'gt'	=>	'>',	#   right chevron, greater-than
0.000000,0,0.000000,'quot'	=>	'"',	#   double quote
0.000000,0,0.000000,
0.000000,0,0.000000,"Aacute"	=>	"A\\*'",	#   capital A, acute accent
0.000000,0,0.000000,# etc
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,%HTML_2_Latin_1 = (
0.000000,0,0.000000,'amp'	=>	'&',	#   ampersand
0.000000,0,0.000000,'lt'	=>	'<',	#   left chevron, less-than
0.000000,0,0.000000,'gt'	=>	'>',	#   right chevron, greater-than
0.000000,0,0.000000,'quot'	=>	'"',	#   double quote
0.000000,0,0.000000,
0.000000,0,0.000000,"Aacute"	=>	"\xC1"	#   capital A, acute accent
0.000000,0,0.000000,
0.000000,0,0.000000,# etc
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,%HTML_2_ASCII_7 = (
0.000000,0,0.000000,'amp'	=>	'&',	#   ampersand
0.000000,0,0.000000,'lt'	=>	'<',	#   left chevron, less-than
0.000000,0,0.000000,'gt'	=>	'>',	#   right chevron, greater-than
0.000000,0,0.000000,'quot'	=>	'"',	#   double quote
0.000000,0,0.000000,
0.000000,0,0.000000,"Aacute"	=>	"A"	#   capital A, acute accent
0.000000,0,0.000000,# etc
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,our %HTML_Escapes;
0.000004,1,0.000004,*HTML_Escapes = do {
0.000000,0,0.000000,if ($standalone) {
0.000000,0,0.000000,$PRETTY ? \%HTML_2_Latin_1 : \%HTML_2_ASCII_7; 
0.000000,0,0.000000,} else {
0.000002,1,0.000002,\%HTML_2_Latin_1; 
0.000000,0,0.000000,}
0.000000,0,0.000000,}; 
0.000000,0,0.000000,
0.000002,1,0.000002,*THITHER = $standalone ? *STDOUT : *STDERR;
0.000000,0,0.000000,
0.000002,1,0.000002,my %transfmt = (); 
0.000002,1,0.000002,my $transmo = <<EOFUNC;
0.000000,0,0.000000,sub transmo {
0.000000,0,0.000000,#local \$^W = 0;  # recursive warnings we do NOT need!
0.000000,0,0.000000,EOFUNC
0.000000,0,0.000000,
0.000001,1,0.000001,my %msg;
0.000000,0,0.000000,{
0.000004,2,0.000002,print STDERR "FINISHING COMPILATION for $_\n" if $DEBUG;
0.000003,1,0.000003,local $/ = '';
0.000001,1,0.000001,local $_;
0.000001,1,0.000001,my $header;
0.000001,1,0.000001,my @headers;
0.000001,1,0.000001,my $for_item;
0.000001,1,0.000001,my $seen_body;
0.007989,1,0.007989,while (<POD_DIAG>) {
0.000000,0,0.000000,
0.000000,0,0.000000,sub _split_pod_link {
0.002055,242,0.000008,$_[0] =~ '(?:([^|]*)\|)?([^/]*)(?:/("?)(.*)\3)?';
0.001410,242,0.000006,($1,$2,$4);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.010286,2073,0.000005,unescape();
0.005846,2073,0.000003,if ($PRETTY) {
0.000000,0,0.000000,sub noop   { return $_[0] }  # spensive for a noop
0.000000,0,0.000000,sub bold   { my $str =$_[0];  $str =~ s/(.)/$1\b$1/g; return $str; } 
0.000000,0,0.000000,sub italic { my $str = $_[0]; $str =~ s/(.)/_\b$1/g;  return $str; } 
0.000000,0,0.000000,s/C<<< (.*?) >>>|C<< (.*?) >>|[BC]<(.*?)>/bold($+)/ges;
0.000000,0,0.000000,s/[IF]<(.*?)>/italic($1)/ges;
0.000000,0,0.000000,s/L<(.*?)>/
0.000000,0,0.000000,my($text,$page,$sect) = _split_pod_link($1);
0.000000,0,0.000000,defined $text
0.000000,0,0.000000,? $text
0.000000,0,0.000000,: defined $sect
0.000000,0,0.000000,? italic($sect) . ' in ' . italic($page)
0.000000,0,0.000000,: italic($page)
0.000000,0,0.000000,/ges;
0.000000,0,0.000000,s/S<(.*?)>/
0.000000,0,0.000000,$1
0.000000,0,0.000000,/ges;
0.000000,0,0.000000,} else {
0.049047,2073,0.000024,s/C<<< (.*?) >>>|C<< (.*?) >>|[BC]<(.*?)>/$+/gs;
0.017561,2073,0.000008,s/[IF]<(.*?)>/$1/gs;
0.027787,2073,0.000013,s/L<(.*?)>/
0.001359,242,0.000006,my($text,$page,$sect) = _split_pod_link($1);
0.000522,242,0.000002,defined $text
0.000000,0,0.000000,? $text
0.000000,0,0.000000,: defined $sect
0.000000,0,0.000000,? qq '"$sect" in $page'
0.000000,0,0.000000,: $page
0.000000,0,0.000000,/ges;
0.017518,2073,0.000008,s/S<(.*?)>/
0.000000,0,0.000000,$1
0.000000,0,0.000000,/ges;
0.000000,0,0.000000,} 
0.011657,2073,0.000006,unless (/^=/) {
0.003365,1176,0.000003,if (defined $header) { 
0.001770,1175,0.000002,if ( $header eq 'DESCRIPTION' && 
0.000000,0,0.000000,(   /Optional warnings are enabled/ 
0.000000,0,0.000000,|| /Some of these messages are generic./
0.000000,0,0.000000,) )
0.000000,0,0.000000,{
0.000003,2,0.000002,next;
0.000000,0,0.000000,}
0.018223,1173,0.000016,s/^/    /gm;
0.002618,1173,0.000002,$msg{$header} .= $_;
0.003857,1197,0.000003,for my $h(@headers) { $msg{$h} .= $_ }
0.001626,1173,0.000001,++$seen_body;
0.001786,1173,0.000002,undef $for_item;	
0.000000,0,0.000000,}
0.001917,1174,0.000002,next;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,# If we have not come across the body of the description yet, then
0.000000,0,0.000000,# the previous header needs to share the same description.
0.001583,897,0.000002,if ($seen_body) {
0.000000,0,0.000000,@headers = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000029,14,0.000002,push @headers, $header if defined $header;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.009091,897,0.000010,unless ( s/=item (.*?)\s*\z//s) {
0.000000,0,0.000000,
0.000055,6,0.000009,if ( s/=head1\sDESCRIPTION//) {
0.000003,1,0.000003,$msg{$header = 'DESCRIPTION'} = '';
0.000002,1,0.000002,undef $for_item;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( s/^=for\s+diagnostics\s*\n(.*?)\s*\z// ) {
0.000000,0,0.000000,$for_item = $1;
0.000000,0,0.000000,} 
0.000011,6,0.000002,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002527,891,0.000003,if( $for_item ) { $header = $for_item; undef $for_item } 
0.000000,0,0.000000,else {
0.001878,891,0.000002,$header = $1;
0.000000,0,0.000000,
0.005109,891,0.000006,$header =~ s/\n/ /gs; # Allow multi-line headers
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# strip formatting directives from =item line
0.010763,891,0.000012,$header =~ s/[A-Z]<(.*?)>/$1/g;
0.000000,0,0.000000,
0.000000,0,0.000000,# Since we strip "(\.\s*)\n" when we search a warning, strip it here as well
0.012986,891,0.000015,$header =~ s/(\.\s*)?$//;
0.000000,0,0.000000,
0.004044,891,0.000005,my @toks = split( /(%l?[dxX]|%[ucp]|%(?:\.\d+)?[fs])/, $header );
0.002716,891,0.000003,if (@toks > 1) {
0.000791,537,0.000001,my $conlen = 0;
0.001843,537,0.000003,for my $i (0..$#toks){
0.008284,1806,0.000005,if( $i % 2 ){
0.008152,724,0.000011,if(      $toks[$i] eq '%c' ){
0.000000,0,0.000000,$toks[$i] = '.';
0.000000,0,0.000000,} elsif( $toks[$i] =~ /^%(?:d|u)$/ ){
0.000000,0,0.000000,$toks[$i] = '\d+';
0.000000,0,0.000000,} elsif( $toks[$i] =~ '^%(?:s|.*f)$' ){
0.000000,0,0.000000,$toks[$i] = $i == $#toks ? '.*' : '.*?';
0.000000,0,0.000000,} elsif( $toks[$i] =~ '%.(\d+)s' ){
0.000000,0,0.000000,$toks[$i] = ".{$1}";
0.000000,0,0.000000,} elsif( $toks[$i] =~ '^%l*([pxX])$' ){
0.000000,0,0.000000,$toks[$i] = $1 eq 'X' ? '[\dA-F]+' : '[\da-f]+';
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif( length( $toks[$i] ) ){
0.002004,1052,0.000002,$toks[$i] = quotemeta $toks[$i];
0.001674,1052,0.000002,$conlen += length( $toks[$i] );
0.000000,0,0.000000,}
0.000000,0,0.000000,}  
0.001125,537,0.000002,my $lhs = join( '', @toks );
0.006441,537,0.000012,$lhs =~ s/(\\\s)+/\\s+/g; # Replace lit space with multi-space match
0.002284,537,0.000004,$transfmt{$header}{pat} =
0.000000,0,0.000000,"    s^\\s*$lhs\\s*\Q$header\Es\n\t&& return 1;\n";
0.001188,537,0.000002,$transfmt{$header}{len} = $conlen;
0.000000,0,0.000000,} else {
0.000702,354,0.000002,my $lhs = "\Q$header\E";
0.003789,354,0.000011,$lhs =~ s/(\\\s)+/\\s+/g; # Replace lit space with multi-space match
0.001405,354,0.000004,$transfmt{$header}{pat} =
0.000000,0,0.000000,"    s^\\s*$lhs\\s*\Q$header\E\n\t && return 1;\n";
0.000801,354,0.000002,$transfmt{$header}{len} = length( $header );
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.001429,891,0.000002,print STDERR "$WHOAMI: Duplicate entry: \"$header\"\n"
0.000000,0,0.000000,if $msg{$header};
0.000000,0,0.000000,
0.001710,891,0.000002,$msg{$header} = '';
0.015448,891,0.000017,$seen_body = 0;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000023,1,0.000023,close POD_DIAG unless *main::DATA eq *POD_DIAG;
0.000000,0,0.000000,
0.000002,1,0.000002,die "No diagnostics?" unless %msg;
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply patterns in order of decreasing sum of lengths of fixed parts
0.000000,0,0.000000,# Seems the best way of hitting the right one.
0.002488,1,0.002488,for my $hdr ( sort { $transfmt{$b}{len} <=> $transfmt{$a}{len} }
0.000000,0,0.000000,keys %transfmt ){
0.002704,891,0.000003,$transmo .= $transfmt{$hdr}{pat};
0.000000,0,0.000000,}
0.000002,1,0.000002,$transmo .= "    return 0;\n}\n";
0.000002,1,0.000002,print STDERR $transmo if $DEBUG;
0.017873,1,0.017873,eval $transmo;
0.000006,1,0.000006,die $@ if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,if ($standalone) {
0.000000,0,0.000000,if (!@ARGV and -t STDIN) { print STDERR "$0: Reading from STDIN\n" } 
0.000000,0,0.000000,while (defined (my $error = <>)) {
0.000000,0,0.000000,splainthis($error) || print THITHER $error;
0.000000,0,0.000000,} 
0.000000,0,0.000000,exit;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000001,1,0.000001,my $olddie;
0.000001,1,0.000001,my $oldwarn;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000002,1,0.000002,shift;
0.000002,1,0.000002,$^W = 1; # yup, clobbered the global variable; 
0.000000,0,0.000000,# tough, if you want diags, you want diags.
0.000003,1,0.000003,return if defined $SIG{__WARN__} && ($SIG{__WARN__} eq \&warn_trap);
0.000000,0,0.000000,
0.000007,1,0.000007,for (@_) {
0.000000,0,0.000000,
0.000018,1,0.000018,/^-d(ebug)?$/ 	   	&& do {
0.000000,0,0.000000,$DEBUG++;
0.000000,0,0.000000,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000013,1,0.000013,/^-v(erbose)?$/ 	&& do {
0.000007,1,0.000007,$VERBOSE++;
0.000002,1,0.000002,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,/^-p(retty)?$/ 		&& do {
0.000000,0,0.000000,print STDERR "$0: I'm afraid it's too late for prettiness.\n";
0.000000,0,0.000000,$PRETTY++;
0.000000,0,0.000000,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,# matches trace and traceonly for legacy doc mixup reasons
0.000000,0,0.000000,/^-t(race(only)?)?$/	&& do {
0.000000,0,0.000000,$TRACEONLY++;
0.000000,0,0.000000,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,/^-w(arntrace)?$/ 	&& do {
0.000000,0,0.000000,$WARNTRACE++;
0.000000,0,0.000000,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,warn "Unknown flag: $_";
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000002,1,0.000002,$oldwarn = $SIG{__WARN__};
0.000002,1,0.000002,$olddie = $SIG{__DIE__};
0.000005,1,0.000005,$SIG{__WARN__} = \&warn_trap;
0.000008,1,0.000008,$SIG{__DIE__} = \&death_trap;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,sub enable { &import }
0.000000,0,0.000000,
0.000000,0,0.000000,sub disable {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,return unless $SIG{__WARN__} eq \&warn_trap;
0.000000,0,0.000000,$SIG{__WARN__} = $oldwarn || '';
0.000000,0,0.000000,$SIG{__DIE__} = $olddie || '';
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,sub warn_trap {
0.000000,0,0.000000,my $warning = $_[0];
0.000000,0,0.000000,if (caller eq $WHOAMI or !splainthis($warning)) {
0.000000,0,0.000000,if ($WARNTRACE) {
0.000000,0,0.000000,print STDERR Carp::longmess($warning);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,print STDERR $warning;
0.000000,0,0.000000,}
0.000000,0,0.000000,} 
0.000000,0,0.000000,goto &$oldwarn if defined $oldwarn and $oldwarn and $oldwarn ne \&warn_trap;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub death_trap {
0.000000,0,0.000000,my $exception = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,# See if we are coming from anywhere within an eval. If so we don't
0.000000,0,0.000000,# want to explain the exception because it's going to get caught.
0.000000,0,0.000000,my $in_eval = 0;
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,while (my $caller = (caller($i++))[3]) {
0.000000,0,0.000000,if ($caller eq '(eval)') {
0.000000,0,0.000000,$in_eval = 1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,splainthis($exception) unless $in_eval;
0.000000,0,0.000000,if (caller eq $WHOAMI) { print STDERR "INTERNAL EXCEPTION: $exception"; } 
0.000000,0,0.000000,&$olddie if defined $olddie and $olddie and $olddie ne \&death_trap;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $in_eval;
0.000000,0,0.000000,
0.000000,0,0.000000,# We don't want to unset these if we're coming from an eval because
0.000000,0,0.000000,# then we've turned off diagnostics.
0.000000,0,0.000000,
0.000000,0,0.000000,# Switch off our die/warn handlers so we don't wind up in our own
0.000000,0,0.000000,# traps.
0.000000,0,0.000000,$SIG{__DIE__} = $SIG{__WARN__} = '';
0.000000,0,0.000000,
0.000000,0,0.000000,$exception =~ s/\n(?=.)/\n\t/gas;
0.000000,0,0.000000,
0.000000,0,0.000000,die Carp::longmess("__diagnostics__")
0.000000,0,0.000000,=~ s/^__diagnostics__.*?line \d+\.?\n/
0.000000,0,0.000000,"Uncaught exception from user code:\n\t$exception"
0.000000,0,0.000000,/re;
0.000000,0,0.000000,# up we go; where we stop, nobody knows, but i think we die now
0.000000,0,0.000000,# but i'm deeply afraid of the &$olddie guy reraising and us getting
0.000000,0,0.000000,# into an indirect recursion loop
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000001,1,0.000001,my %exact_duplicate;
0.000001,1,0.000001,my %old_diag;
0.000001,1,0.000001,my $count;
0.000001,1,0.000001,my $wantspace;
0.000000,0,0.000000,sub splainthis {
0.000000,0,0.000000,return 0 if $TRACEONLY;
0.000000,0,0.000000,for (my $tmp = shift) {
0.000000,0,0.000000,local $\;
0.000000,0,0.000000,local $!;
0.000000,0,0.000000,### &finish_compilation unless %msg;
0.000000,0,0.000000,s/(\.\s*)?\n+$//;
0.000000,0,0.000000,my $orig = $_;
0.000000,0,0.000000,# return unless defined;
0.000000,0,0.000000,
0.000000,0,0.000000,# get rid of the where-are-we-in-input part
0.000000,0,0.000000,s/, <.*?> (?:line|chunk).*$//;
0.000000,0,0.000000,
0.000000,0,0.000000,# Discard 1st " at <file> line <no>" and all text beyond
0.000000,0,0.000000,# but be aware of messages containing " at this-or-that"
0.000000,0,0.000000,my $real = 0;
0.000000,0,0.000000,my @secs = split( / at / );
0.000000,0,0.000000,return unless @secs;
0.000000,0,0.000000,$_ = $secs[0];
0.000000,0,0.000000,for my $i ( 1..$#secs ){
0.000000,0,0.000000,if( $secs[$i] =~ /.+? (?:line|chunk) \d+/ ){
0.000000,0,0.000000,$real = 1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$_ .= ' at ' . $secs[$i];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# remove parenthesis occurring at the end of some messages 
0.000000,0,0.000000,s/^\((.*)\)$/$1/;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($exact_duplicate{$orig}++) {
0.000000,0,0.000000,return &transmo;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return 0 unless &transmo;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $short = shorten($orig);
0.000000,0,0.000000,if ($old_diag{$_}) {
0.000000,0,0.000000,autodescribe();
0.000000,0,0.000000,print THITHER "$short (#$old_diag{$_})\n";
0.000000,0,0.000000,$wantspace = 1;
0.000000,0,0.000000,} elsif (!$msg{$_} && $orig =~ /\n./s) {
0.000000,0,0.000000,# A multiline message, like "Attempt to reload /
0.000000,0,0.000000,# Compilation failed"
0.000000,0,0.000000,my $found;
0.000000,0,0.000000,for (split /^/, $orig) {
0.000000,0,0.000000,splainthis($_) and $found = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $found;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,autodescribe();
0.000000,0,0.000000,$old_diag{$_} = ++$count;
0.000000,0,0.000000,print THITHER "\n" if $wantspace;
0.000000,0,0.000000,$wantspace = 0;
0.000000,0,0.000000,print THITHER "$short (#$old_diag{$_})\n";
0.000000,0,0.000000,if ($msg{$_}) {
0.000000,0,0.000000,print THITHER $msg{$_};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,if (0 and $standalone) { 
0.000000,0,0.000000,print THITHER "    **** Error #$old_diag{$_} ",
0.000000,0,0.000000,($real ? "is" : "appears to be"),
0.000000,0,0.000000," an unknown diagnostic message.\n\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,} 
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,sub autodescribe {
0.000000,0,0.000000,if ($VERBOSE and not $count) {
0.000000,0,0.000000,print THITHER &{$PRETTY ? \&bold : \&noop}("DESCRIPTION OF DIAGNOSTICS"),
0.000000,0,0.000000,"\n$msg{DESCRIPTION}\n";
0.000000,0,0.000000,} 
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,sub unescape { 
0.023512,2073,0.000011,s {
0.000000,0,0.000000,E<  
0.000000,0,0.000000,( [A-Za-z]+ )       
0.000000,0,0.000000,>   
0.000000,0,0.000000,} { 
0.000000,0,0.000000,do {   
0.000000,0,0.000000,exists $HTML_Escapes{$1}
0.000000,0,0.000000,? do { $HTML_Escapes{$1} }
0.000000,0,0.000000,: do {
0.000000,0,0.000000,warn "Unknown escape: E<$1> in $_";
0.000000,0,0.000000,"E<$1>";
0.000000,0,0.000000,} 
0.000000,0,0.000000,} 
0.000000,0,0.000000,}egx;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shorten {
0.000000,0,0.000000,my $line = $_[0];
0.000000,0,0.000000,if (length($line) > 79 and index($line, "\n") == -1) {
0.000000,0,0.000000,my $space_place = rindex($line, ' ', 79);
0.000000,0,0.000000,if ($space_place != -1) {
0.000000,0,0.000000,substr($line, $space_place, 1) = "\n\t";
0.000000,0,0.000000,} 
0.000000,0,0.000000,} 
0.000000,0,0.000000,return $line;
0.000000,0,0.000000,} 
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000450,1,0.000450,1 unless $standalone;  # or it'll complain about itself
0.000000,0,0.000000,__END__ # wish diag dbase were more accessible
