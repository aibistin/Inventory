# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Sub::Install;
0.000000,0,0.000000,
0.000033,2,0.000016,use warnings;
0.000031,2,0.000015,use strict;
0.000000,0,0.000000,
0.000033,2,0.000016,use Carp;
0.000391,2,0.000196,use Scalar::Util ();
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install - install subroutines into packages easily
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 VERSION
0.000000,0,0.000000,
0.000000,0,0.000000,version 0.926
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.926';
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Sub::Install;
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install::install_sub({
0.000000,0,0.000000,code => sub { ... },
0.000000,0,0.000000,into => $package,
0.000000,0,0.000000,as   => $subname
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module makes it easy to install subroutines into packages without the
0.000000,0,0.000000,unslightly mess of C<no strict> or typeglobs lying about where just anyone can
0.000000,0,0.000000,see them.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FUNCTIONS
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 install_sub
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install::install_sub({
0.000000,0,0.000000,code => \&subroutine,
0.000000,0,0.000000,into => "Finance::Shady",
0.000000,0,0.000000,as   => 'launder',
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,This routine installs a given code reference into a package as a normal
0.000000,0,0.000000,subroutine.  The above is equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,no strict 'refs';
0.000000,0,0.000000,*{"Finance::Shady" . '::' . "launder"} = \&subroutine;
0.000000,0,0.000000,
0.000000,0,0.000000,If C<into> is not given, the sub is installed into the calling package.
0.000000,0,0.000000,
0.000000,0,0.000000,If C<code> is not a code reference, it is looked for as an existing sub in the
0.000000,0,0.000000,package named in the C<from> parameter.  If C<from> is not given, it will look
0.000000,0,0.000000,in the calling package.
0.000000,0,0.000000,
0.000000,0,0.000000,If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
0.000000,0,0.000000,If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
0.000000,0,0.000000,find the name of the given code ref and use that as C<as>.
0.000000,0,0.000000,
0.000000,0,0.000000,That means that this code:
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install::install_sub({
0.000000,0,0.000000,code => 'twitch',
0.000000,0,0.000000,from => 'Person::InPain',
0.000000,0,0.000000,into => 'Person::Teenager',
0.000000,0,0.000000,as   => 'dance',
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,is the same as:
0.000000,0,0.000000,
0.000000,0,0.000000,package Person::Teenager;
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install::install_sub({
0.000000,0,0.000000,code => Person::InPain->can('twitch'),
0.000000,0,0.000000,as   => 'dance',
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 reinstall_sub
0.000000,0,0.000000,
0.000000,0,0.000000,This routine behaves exactly like C<L</install_sub>>, but does not emit a
0.000000,0,0.000000,warning if warnings are on and the destination is already defined.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub _name_of_code {
0.000000,0,0.000000,my ($code) = @_;
0.000000,0,0.000000,require B;
0.000000,0,0.000000,my $name = B::svref_2object($code)->GV->NAME;
0.000000,0,0.000000,return $name unless $name =~ /\A__ANON__/;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# See also Params::Util, to which this code was donated.
0.000000,0,0.000000,sub _CODELIKE {
0.000667,60,0.000011,(Scalar::Util::reftype($_[0])||'') eq 'CODE'
0.000000,0,0.000000,|| Scalar::Util::blessed($_[0])
0.000000,0,0.000000,&& (overload::Method($_[0],'&{}') ? $_[0] : undef);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# do the heavy lifting
0.000000,0,0.000000,sub _build_public_installer {
0.000003,2,0.000002,my ($installer) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000095,60,0.000002,my ($arg) = @_;
0.000255,60,0.000004,my ($calling_pkg) = caller(0);
0.000000,0,0.000000,
0.000000,0,0.000000,# I'd rather use ||= but I'm whoring for Devel::Cover.
0.000596,180,0.000003,for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
0.000000,0,0.000000,
0.000000,0,0.000000,# This is the only absolutely required argument, in many cases.
0.000091,60,0.000002,Carp::croak "named argument 'code' is not optional" unless $arg->{code};
0.000000,0,0.000000,
0.000323,60,0.000005,if (_CODELIKE($arg->{code})) {
0.000000,0,0.000000,$arg->{as} ||= _name_of_code($arg->{code});
0.000000,0,0.000000,} else {
0.000013,1,0.000013,Carp::croak
0.000000,0,0.000000,"couldn't find subroutine named $arg->{code} in package $arg->{from}"
0.000000,0,0.000000,unless my $code = $arg->{from}->can($arg->{code});
0.000000,0,0.000000,
0.000002,1,0.000002,$arg->{as}   = $arg->{code} unless $arg->{as};
0.000002,1,0.000002,$arg->{code} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000090,60,0.000002,Carp::croak "couldn't determine name under which to install subroutine"
0.000000,0,0.000000,unless $arg->{as};
0.000000,0,0.000000,
0.000552,60,0.000009,$installer->(@$arg{qw(into as code) });
0.000000,0,0.000000,}
0.000015,2,0.000007,}
0.000000,0,0.000000,
0.000000,0,0.000000,# do the ugly work
0.000000,0,0.000000,
0.000002,1,0.000002,my $_misc_warn_re;
0.000001,1,0.000001,my $_redef_warn_re;
0.000000,0,0.000000,BEGIN {
0.000012,1,0.000012,$_misc_warn_re = qr/
0.000000,0,0.000000,Prototype\ mismatch:\ sub\ .+?  |
0.000000,0,0.000000,Constant subroutine \S+ redefined
0.000000,0,0.000000,/x;
0.000011,1,0.000011,$_redef_warn_re = qr/Subroutine\ \S+\ redefined/x;
0.000038,1,0.000038,}
0.000000,0,0.000000,
0.000001,1,0.000001,my $eow_re;
0.000286,1,0.000286,BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
0.000000,0,0.000000,
0.000000,0,0.000000,sub _do_with_warn {
0.000004,3,0.000001,my ($arg) = @_;
0.000005,3,0.000002,my $code = delete $arg->{code};
0.000000,0,0.000000,my $wants_code = sub {
0.000005,3,0.000002,my $code = shift;
0.000000,0,0.000000,sub {
0.000199,60,0.000003,my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
0.000000,0,0.000000,local $SIG{__WARN__} = sub {
0.000000,0,0.000000,my ($error) = @_;
0.000000,0,0.000000,for (@{ $arg->{suppress} }) {
0.000000,0,0.000000,return if $error =~ $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,for (@{ $arg->{croak} }) {
0.000000,0,0.000000,if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
0.000000,0,0.000000,Carp::croak $base_error;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,for (@{ $arg->{carp} }) {
0.000000,0,0.000000,if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
0.000000,0,0.000000,return $warn->(Carp::shortmess $base_error);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,($arg->{default} || $warn)->($error);
0.000254,60,0.000004,};
0.000788,60,0.000013,$code->(@_);
0.000032,3,0.000011,};
0.000009,3,0.000003,};
0.000012,3,0.000004,return $wants_code->($code) if $code;
0.000014,2,0.000007,return $wants_code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _installer {
0.000000,0,0.000000,sub {
0.000101,60,0.000002,my ($pkg, $name, $code) = @_;
0.000138,2,0.000069,no strict 'refs'; ## no critic ProhibitNoStrict
0.000250,60,0.000004,*{"$pkg\::$name"} = $code;
0.000363,60,0.000006,return $code;
0.000000,0,0.000000,}
0.000025,3,0.000008,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000007,1,0.000007,*_ignore_warnings = _do_with_warn({
0.000000,0,0.000000,carp => [ $_misc_warn_re, $_redef_warn_re ]
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000013,1,0.000013,*install_sub = _build_public_installer(_ignore_warnings(_installer));
0.000000,0,0.000000,
0.000007,1,0.000007,*_carp_warnings =  _do_with_warn({
0.000000,0,0.000000,carp     => [ $_misc_warn_re ],
0.000000,0,0.000000,suppress => [ $_redef_warn_re ],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000013,1,0.000013,*reinstall_sub = _build_public_installer(_carp_warnings(_installer));
0.000000,0,0.000000,
0.000014,1,0.000014,*_install_fatal = _do_with_warn({
0.000000,0,0.000000,code     => _installer,
0.000000,0,0.000000,croak    => [ $_redef_warn_re ],
0.000000,0,0.000000,});
0.000289,1,0.000289,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 install_installers
0.000000,0,0.000000,
0.000000,0,0.000000,This routine is provided to allow Sub::Install compatibility with
0.000000,0,0.000000,Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
0.000000,0,0.000000,the package named by its argument.
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install::install_installers('Code::Builder'); # just for us, please
0.000000,0,0.000000,Code::Builder->install_sub({ name => $code_ref });
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
0.000000,0,0.000000,Anything::At::All->install_sub({ name => $code_ref });
0.000000,0,0.000000,
0.000000,0,0.000000,The installed installers are similar, but not identical, to those provided by
0.000000,0,0.000000,Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
0.000000,0,0.000000,are used as the C<as> and C<code> parameters to the C<install_sub> routine
0.000000,0,0.000000,detailed above.  The package name on which the method is called is used as the
0.000000,0,0.000000,C<into> parameter.
0.000000,0,0.000000,
0.000000,0,0.000000,Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
0.000000,0,0.000000,will look for named code in the calling package.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_installers {
0.000000,0,0.000000,my ($into) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $method (qw(install_sub reinstall_sub)) {
0.000000,0,0.000000,my $code = sub {
0.000000,0,0.000000,my ($package, $subs) = @_;
0.000000,0,0.000000,my ($caller) = caller(0);
0.000000,0,0.000000,my $return;
0.000000,0,0.000000,for (my ($name, $sub) = %$subs) {
0.000000,0,0.000000,$return = Sub::Install->can($method)->({
0.000000,0,0.000000,code => $sub,
0.000000,0,0.000000,from => $caller,
0.000000,0,0.000000,into => $package,
0.000000,0,0.000000,as   => $name
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,return $return;
0.000000,0,0.000000,};
0.000000,0,0.000000,install_sub({ code => $code, into => $into, as => $method });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXPORTS
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
0.000000,0,0.000000,requested.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 exporter
0.000000,0,0.000000,
0.000000,0,0.000000,Sub::Install has a never-exported subroutine called C<exporter>, which is used
0.000000,0,0.000000,to implement its C<import> routine.  It takes a hashref of named arguments,
0.000000,0,0.000000,only one of which is currently recognize: C<exports>.  This must be an arrayref
0.000000,0,0.000000,of subroutines to offer for export.
0.000000,0,0.000000,
0.000000,0,0.000000,This routine is mainly for Sub::Install's own consumption.  Instead, consider
0.000000,0,0.000000,L<Sub::Exporter>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub exporter {
0.000003,2,0.000002,my ($arg) = @_;
0.000000,0,0.000000,
0.000010,2,0.000005,my %is_exported = map { $_ => undef } @{ $arg->{exports} };
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000009,5,0.000002,my $class = shift;
0.000009,5,0.000002,my $target = caller;
0.000048,5,0.000010,for (@_) {
0.000002,1,0.000002,Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
0.000009,1,0.000009,install_sub({ code => $_, from => $class, into => $target });
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000019,2,0.000010,}
0.000000,0,0.000000,
0.000052,1,0.000052,BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item L<Sub::Installer>
0.000000,0,0.000000,
0.000000,0,0.000000,This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
0.000000,0,0.000000,does the same thing, but does it by getting its greasy fingers all over
0.000000,0,0.000000,UNIVERSAL.  I was really happy about the idea of making the installation of
0.000000,0,0.000000,coderefs less ugly, but I couldn't bring myself to replace the ugliness of
0.000000,0,0.000000,typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
0.000000,0,0.000000,
0.000000,0,0.000000,=item L<Sub::Exporter>
0.000000,0,0.000000,
0.000000,0,0.000000,This is a complete Exporter.pm replacement, built atop Sub::Install.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Ricardo Signes, C<< <rjbs@cpan.org> >>
0.000000,0,0.000000,
0.000000,0,0.000000,Several of the tests are adapted from tests that shipped with Damian Conway's
0.000000,0,0.000000,Sub-Installer distribution.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,Please report any bugs or feature requests through the web interface at
0.000000,0,0.000000,L<http://rt.cpan.org>.  I will be notified, and then you'll automatically be
0.000000,0,0.000000,notified of progress on your bug as I make changes.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2005-2006 Ricardo Signes, All Rights Reserved.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute it and/or modify it
0.000000,0,0.000000,under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000004,1,0.000004,1;
