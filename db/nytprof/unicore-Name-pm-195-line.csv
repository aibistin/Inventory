# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
0.000000,0,0.000000,# This file is machine-generated by lib/unicore/mktables from the Unicode
0.000000,0,0.000000,# database, Version 6.2.0.  Any changes made here will be lost!
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# !!!!!!!   INTERNAL PERL USE ONLY   !!!!!!!
0.000000,0,0.000000,# This file is for internal use by core Perl only.  The format and even the
0.000000,0,0.000000,# name or existence of this file are subject to change without notice.  Don't
0.000000,0,0.000000,# use it directly.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,package charnames;
0.000000,0,0.000000,
0.000000,0,0.000000,# This module contains machine-generated tables and code for the
0.000000,0,0.000000,# algorithmically-determinable Unicode character names.  The following
0.000000,0,0.000000,# routines can be used to translate between name and code point and vice versa
0.000000,0,0.000000,
0.000000,0,0.000000,{ # Closure
0.000000,0,0.000000,
0.000000,0,0.000000,# Matches legal code point.  4-6 hex numbers, If there are 6, the first
0.000000,0,0.000000,# two must be 10; if there are 5, the first must not be a 0.  Written this
0.000000,0,0.000000,# way to decrease backtracking.  The first regex allows the code point to
0.000000,0,0.000000,# be at the end of a word, but to work properly, the word shouldn't end
0.000000,0,0.000000,# with a valid hex character.  The second one won't match a code point at
0.000000,0,0.000000,# the end of a word, and doesn't have the run-on issue
0.000015,2,0.000008,my $run_on_code_point_re = qr/(?^aax: (?: 10[0-9A-F]{4} | [1-9A-F][0-9A-F]{4} | [0-9A-F]{4} ) \b)/;
0.000007,1,0.000007,my $code_point_re = qr/(?^aa:\b(?^aax: (?: 10[0-9A-F]{4} | [1-9A-F][0-9A-F]{4} | [0-9A-F]{4} ) \b))/;
0.000000,0,0.000000,
0.000000,0,0.000000,# In the following hash, the keys are the bases of names which include
0.000000,0,0.000000,# the code point in the name, like CJK UNIFIED IDEOGRAPH-4E01.  The value
0.000000,0,0.000000,# of each key is another hash which is used to get the low and high ends
0.000000,0,0.000000,# for each range of code points that apply to the name.
0.000006,1,0.000006,my %names_ending_in_code_point = (
0.000000,0,0.000000,'CJK COMPATIBILITY IDEOGRAPH' => 
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,64109,
0.000000,0,0.000000,64217,
0.000000,0,0.000000,195101,
0.000000,0,0.000000,],
0.000000,0,0.000000,'low' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,63744,
0.000000,0,0.000000,64112,
0.000000,0,0.000000,194560,
0.000000,0,0.000000,],
0.000000,0,0.000000,},
0.000000,0,0.000000,'CJK UNIFIED IDEOGRAPH' => 
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,19893,
0.000000,0,0.000000,40908,
0.000000,0,0.000000,173782,
0.000000,0,0.000000,177972,
0.000000,0,0.000000,178205,
0.000000,0,0.000000,],
0.000000,0,0.000000,'low' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,13312,
0.000000,0,0.000000,19968,
0.000000,0,0.000000,131072,
0.000000,0,0.000000,173824,
0.000000,0,0.000000,177984,
0.000000,0,0.000000,],
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# The following hash is a copy of the previous one, except is for loose
0.000000,0,0.000000,# matching, so each name has blanks and dashes squeezed out
0.000004,1,0.000004,my %loose_names_ending_in_code_point = (
0.000000,0,0.000000,'CJKCOMPATIBILITYIDEOGRAPH' => 
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,64109,
0.000000,0,0.000000,64217,
0.000000,0,0.000000,195101,
0.000000,0,0.000000,],
0.000000,0,0.000000,'low' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,63744,
0.000000,0,0.000000,64112,
0.000000,0,0.000000,194560,
0.000000,0,0.000000,],
0.000000,0,0.000000,},
0.000000,0,0.000000,'CJKUNIFIEDIDEOGRAPH' => 
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,19893,
0.000000,0,0.000000,40908,
0.000000,0,0.000000,173782,
0.000000,0,0.000000,177972,
0.000000,0,0.000000,178205,
0.000000,0,0.000000,],
0.000000,0,0.000000,'low' => 
0.000000,0,0.000000,[
0.000000,0,0.000000,13312,
0.000000,0,0.000000,19968,
0.000000,0,0.000000,131072,
0.000000,0,0.000000,173824,
0.000000,0,0.000000,177984,
0.000000,0,0.000000,],
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# And the following array gives the inverse mapping from code points to
0.000000,0,0.000000,# names.  Lowest code points are first
0.000008,1,0.000008,my @code_points_ending_in_code_point = (
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 19893,
0.000000,0,0.000000,'low' => 13312,
0.000000,0,0.000000,'name' => 'CJK UNIFIED IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 40908,
0.000000,0,0.000000,'low' => 19968,
0.000000,0,0.000000,'name' => 'CJK UNIFIED IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 64109,
0.000000,0,0.000000,'low' => 63744,
0.000000,0,0.000000,'name' => 'CJK COMPATIBILITY IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 64217,
0.000000,0,0.000000,'low' => 64112,
0.000000,0,0.000000,'name' => 'CJK COMPATIBILITY IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 173782,
0.000000,0,0.000000,'low' => 131072,
0.000000,0,0.000000,'name' => 'CJK UNIFIED IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 177972,
0.000000,0,0.000000,'low' => 173824,
0.000000,0,0.000000,'name' => 'CJK UNIFIED IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 178205,
0.000000,0,0.000000,'low' => 177984,
0.000000,0,0.000000,'name' => 'CJK UNIFIED IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,'high' => 195101,
0.000000,0,0.000000,'low' => 194560,
0.000000,0,0.000000,'name' => 'CJK COMPATIBILITY IDEOGRAPH',
0.000000,0,0.000000,},
0.000000,0,0.000000,,
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Convert from code point to Jamo short name for use in composing Hangul
0.000000,0,0.000000,# syllable names
0.000042,1,0.000042,my %Jamo = (
0.000000,0,0.000000,4352 => 'G',
0.000000,0,0.000000,4353 => 'GG',
0.000000,0,0.000000,4354 => 'N',
0.000000,0,0.000000,4355 => 'D',
0.000000,0,0.000000,4356 => 'DD',
0.000000,0,0.000000,4357 => 'R',
0.000000,0,0.000000,4358 => 'M',
0.000000,0,0.000000,4359 => 'B',
0.000000,0,0.000000,4360 => 'BB',
0.000000,0,0.000000,4361 => 'S',
0.000000,0,0.000000,4362 => 'SS',
0.000000,0,0.000000,4363 => '',
0.000000,0,0.000000,4364 => 'J',
0.000000,0,0.000000,4365 => 'JJ',
0.000000,0,0.000000,4366 => 'C',
0.000000,0,0.000000,4367 => 'K',
0.000000,0,0.000000,4368 => 'T',
0.000000,0,0.000000,4369 => 'P',
0.000000,0,0.000000,4370 => 'H',
0.000000,0,0.000000,4449 => 'A',
0.000000,0,0.000000,4450 => 'AE',
0.000000,0,0.000000,4451 => 'YA',
0.000000,0,0.000000,4452 => 'YAE',
0.000000,0,0.000000,4453 => 'EO',
0.000000,0,0.000000,4454 => 'E',
0.000000,0,0.000000,4455 => 'YEO',
0.000000,0,0.000000,4456 => 'YE',
0.000000,0,0.000000,4457 => 'O',
0.000000,0,0.000000,4458 => 'WA',
0.000000,0,0.000000,4459 => 'WAE',
0.000000,0,0.000000,4460 => 'OE',
0.000000,0,0.000000,4461 => 'YO',
0.000000,0,0.000000,4462 => 'U',
0.000000,0,0.000000,4463 => 'WEO',
0.000000,0,0.000000,4464 => 'WE',
0.000000,0,0.000000,4465 => 'WI',
0.000000,0,0.000000,4466 => 'YU',
0.000000,0,0.000000,4467 => 'EU',
0.000000,0,0.000000,4468 => 'YI',
0.000000,0,0.000000,4469 => 'I',
0.000000,0,0.000000,4520 => 'G',
0.000000,0,0.000000,4521 => 'GG',
0.000000,0,0.000000,4522 => 'GS',
0.000000,0,0.000000,4523 => 'N',
0.000000,0,0.000000,4524 => 'NJ',
0.000000,0,0.000000,4525 => 'NH',
0.000000,0,0.000000,4526 => 'D',
0.000000,0,0.000000,4527 => 'L',
0.000000,0,0.000000,4528 => 'LG',
0.000000,0,0.000000,4529 => 'LM',
0.000000,0,0.000000,4530 => 'LB',
0.000000,0,0.000000,4531 => 'LS',
0.000000,0,0.000000,4532 => 'LT',
0.000000,0,0.000000,4533 => 'LP',
0.000000,0,0.000000,4534 => 'LH',
0.000000,0,0.000000,4535 => 'M',
0.000000,0,0.000000,4536 => 'B',
0.000000,0,0.000000,4537 => 'BS',
0.000000,0,0.000000,4538 => 'S',
0.000000,0,0.000000,4539 => 'SS',
0.000000,0,0.000000,4540 => 'NG',
0.000000,0,0.000000,4541 => 'J',
0.000000,0,0.000000,4542 => 'C',
0.000000,0,0.000000,4543 => 'K',
0.000000,0,0.000000,4544 => 'T',
0.000000,0,0.000000,4545 => 'P',
0.000000,0,0.000000,4546 => 'H',
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Leading consonant (can be null)
0.000014,1,0.000014,my %Jamo_L = (
0.000000,0,0.000000,'' => 11,
0.000000,0,0.000000,'B' => 7,
0.000000,0,0.000000,'BB' => 8,
0.000000,0,0.000000,'C' => 14,
0.000000,0,0.000000,'D' => 3,
0.000000,0,0.000000,'DD' => 4,
0.000000,0,0.000000,'G' => 0,
0.000000,0,0.000000,'GG' => 1,
0.000000,0,0.000000,'H' => 18,
0.000000,0,0.000000,'J' => 12,
0.000000,0,0.000000,'JJ' => 13,
0.000000,0,0.000000,'K' => 15,
0.000000,0,0.000000,'M' => 6,
0.000000,0,0.000000,'N' => 2,
0.000000,0,0.000000,'P' => 17,
0.000000,0,0.000000,'R' => 5,
0.000000,0,0.000000,'S' => 9,
0.000000,0,0.000000,'SS' => 10,
0.000000,0,0.000000,'T' => 16,
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Vowel
0.000010,1,0.000010,my %Jamo_V = (
0.000000,0,0.000000,'A' => 0,
0.000000,0,0.000000,'AE' => 1,
0.000000,0,0.000000,'E' => 5,
0.000000,0,0.000000,'EO' => 4,
0.000000,0,0.000000,'EU' => 18,
0.000000,0,0.000000,'I' => 20,
0.000000,0,0.000000,'O' => 8,
0.000000,0,0.000000,'OE' => 11,
0.000000,0,0.000000,'U' => 13,
0.000000,0,0.000000,'WA' => 9,
0.000000,0,0.000000,'WAE' => 10,
0.000000,0,0.000000,'WE' => 15,
0.000000,0,0.000000,'WEO' => 14,
0.000000,0,0.000000,'WI' => 16,
0.000000,0,0.000000,'YA' => 2,
0.000000,0,0.000000,'YAE' => 3,
0.000000,0,0.000000,'YE' => 7,
0.000000,0,0.000000,'YEO' => 6,
0.000000,0,0.000000,'YI' => 19,
0.000000,0,0.000000,'YO' => 12,
0.000000,0,0.000000,'YU' => 17,
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Optional trailing consonant
0.000008,1,0.000008,my %Jamo_T = (
0.000000,0,0.000000,'B' => 17,
0.000000,0,0.000000,'BS' => 18,
0.000000,0,0.000000,'C' => 23,
0.000000,0,0.000000,'D' => 7,
0.000000,0,0.000000,'G' => 1,
0.000000,0,0.000000,'GG' => 2,
0.000000,0,0.000000,'GS' => 3,
0.000000,0,0.000000,'H' => 27,
0.000000,0,0.000000,'J' => 22,
0.000000,0,0.000000,'K' => 24,
0.000000,0,0.000000,'L' => 8,
0.000000,0,0.000000,'LB' => 11,
0.000000,0,0.000000,'LG' => 9,
0.000000,0,0.000000,'LH' => 15,
0.000000,0,0.000000,'LM' => 10,
0.000000,0,0.000000,'LP' => 14,
0.000000,0,0.000000,'LS' => 12,
0.000000,0,0.000000,'LT' => 13,
0.000000,0,0.000000,'M' => 16,
0.000000,0,0.000000,'N' => 4,
0.000000,0,0.000000,'NG' => 21,
0.000000,0,0.000000,'NH' => 6,
0.000000,0,0.000000,'NJ' => 5,
0.000000,0,0.000000,'P' => 26,
0.000000,0,0.000000,'S' => 19,
0.000000,0,0.000000,'SS' => 20,
0.000000,0,0.000000,'T' => 25,
0.000000,0,0.000000,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Computed re that splits up a Hangul name into LVT or LV syllables
0.000009,1,0.000009,my $syllable_re = qr/(|B|BB|C|D|DD|G|GG|H|J|JJ|K|M|N|P|R|S|SS|T)(A|AE|E|EO|EU|I|O|OE|U|WA|WAE|WE|WEO|WI|YA|YAE|YE|YEO|YI|YO|YU)(B|BS|C|D|G|GG|GS|H|J|K|L|LB|LG|LH|LM|LP|LS|LT|M|N|NG|NH|NJ|P|S|SS|T)?/;
0.000000,0,0.000000,
0.000002,1,0.000002,my $HANGUL_SYLLABLE = "HANGUL SYLLABLE ";
0.000001,1,0.000001,my $loose_HANGUL_SYLLABLE = "HANGULSYLLABLE";
0.000000,0,0.000000,
0.000000,0,0.000000,# These constants names and values were taken from the Unicode standard,
0.000000,0,0.000000,# version 5.1, section 3.12.  They are used in conjunction with Hangul
0.000000,0,0.000000,# syllables
0.000001,1,0.000001,my $SBase = 0xAC00;
0.000001,1,0.000001,my $LBase = 0x1100;
0.000001,1,0.000001,my $VBase = 0x1161;
0.000001,1,0.000001,my $TBase = 0x11A7;
0.000001,1,0.000001,my $SCount = 11172;
0.000001,1,0.000001,my $LCount = 19;
0.000001,1,0.000001,my $VCount = 21;
0.000001,1,0.000001,my $TCount = 28;
0.000003,1,0.000003,my $NCount = $VCount * $TCount;
0.000000,0,0.000000,
0.000000,0,0.000000,sub name_to_code_point_special {
0.000000,0,0.000000,my ($name, $loose) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns undef if not one of the specially handled names; otherwise
0.000000,0,0.000000,# returns the code point equivalent to the input name
0.000000,0,0.000000,# $loose is non-zero if to use loose matching, 'name' in that case
0.000000,0,0.000000,# must be input as upper case with all blanks and dashes squeezed out.
0.000000,0,0.000000,
0.000000,0,0.000000,if ((! $loose && $name =~ s/$HANGUL_SYLLABLE//)
0.000000,0,0.000000,|| ($loose && $name =~ s/$loose_HANGUL_SYLLABLE//))
0.000000,0,0.000000,{
0.000000,0,0.000000,return if $name !~ qr/^$syllable_re$/;
0.000000,0,0.000000,my $L = $Jamo_L{$1};
0.000000,0,0.000000,my $V = $Jamo_V{$2};
0.000000,0,0.000000,my $T = (defined $3) ? $Jamo_T{$3} : 0;
0.000000,0,0.000000,return ($L * $VCount + $V) * $TCount + $T + $SBase;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Name must end in 'code_point' for this to handle.
0.000000,0,0.000000,return if (($loose && $name !~ /^ (.*?) ($run_on_code_point_re) $/x)
0.000000,0,0.000000,|| (! $loose && $name !~ /^ (.*) ($code_point_re) $/x));
0.000000,0,0.000000,
0.000000,0,0.000000,my $base = $1;
0.000000,0,0.000000,my $code_point = CORE::hex $2;
0.000000,0,0.000000,my $names_ref;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($loose) {
0.000000,0,0.000000,$names_ref = \%loose_names_ending_in_code_point;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return if $base !~ s/-$//;
0.000000,0,0.000000,$names_ref = \%names_ending_in_code_point;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Name must be one of the ones which has the code point in it.
0.000000,0,0.000000,return if ! $names_ref->{$base};
0.000000,0,0.000000,
0.000000,0,0.000000,# Look through the list of ranges that apply to this name to see if
0.000000,0,0.000000,# the code point is in one of them.
0.000000,0,0.000000,for (my $i = 0; $i < scalar @{$names_ref->{$base}{'low'}}; $i++) {
0.000000,0,0.000000,return if $names_ref->{$base}{'low'}->[$i] > $code_point;
0.000000,0,0.000000,next if $names_ref->{$base}{'high'}->[$i] < $code_point;
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, the code point is in the range.
0.000000,0,0.000000,return $code_point;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, looked like the name had a code point number in it, but
0.000000,0,0.000000,# did not match one of the valid ones.
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub code_point_to_name_special {
0.000000,0,0.000000,my $code_point = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns the name of a code point if algorithmically determinable;
0.000000,0,0.000000,# undef if not
0.000000,0,0.000000,
0.000000,0,0.000000,# If in the Hangul range, calculate the name based on Unicode's
0.000000,0,0.000000,# algorithm
0.000000,0,0.000000,if ($code_point >= $SBase && $code_point <= $SBase + $SCount -1) {
0.000154,2,0.000077,use integer;
0.000000,0,0.000000,my $SIndex = $code_point - $SBase;
0.000000,0,0.000000,my $L = $LBase + $SIndex / $NCount;
0.000000,0,0.000000,my $V = $VBase + ($SIndex % $NCount) / $TCount;
0.000000,0,0.000000,my $T = $TBase + $SIndex % $TCount;
0.000000,0,0.000000,$name = "$HANGUL_SYLLABLE$Jamo{$L}$Jamo{$V}";
0.000000,0,0.000000,$name .= $Jamo{$T} if $T != $TBase;
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Look through list of these code points for one in range.
0.000000,0,0.000000,foreach my $hash (@code_points_ending_in_code_point) {
0.000000,0,0.000000,return if $code_point < $hash->{'low'};
0.000000,0,0.000000,if ($code_point <= $hash->{'high'}) {
0.000000,0,0.000000,return sprintf("%s-%04X", $hash->{'name'}, $code_point);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return;            # None found
0.000000,0,0.000000,}
0.000000,0,0.000000,} # End closure
0.000000,0,0.000000,
0.000025,1,0.000025,1;
