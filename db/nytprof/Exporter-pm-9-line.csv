# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Exporter;
0.000000,0,0.000000,
0.000011,1,0.000011,require 5.006;
0.000000,0,0.000000,
0.000000,0,0.000000,# Be lean.
0.000000,0,0.000000,#use strict;
0.000000,0,0.000000,#no strict 'refs';
0.000000,0,0.000000,
0.000002,1,0.000002,our $Debug = 0;
0.000001,1,0.000001,our $ExportLevel = 0;
0.000002,1,0.000002,our $Verbose ||= 0;
0.000002,1,0.000002,our $VERSION = '5.68';
0.000002,1,0.000002,our (%Cache);
0.000000,0,0.000000,
0.000000,0,0.000000,sub as_heavy {
0.000169,3,0.000056,require Exporter::Heavy;
0.000000,0,0.000000,# Unfortunately, this does not work if the caller is aliased as *name = \&foo
0.000000,0,0.000000,# Thus the need to create a lot of identical subroutines
0.000013,3,0.000004,my $c = (caller(1))[3];
0.000034,3,0.000012,$c =~ s/.*:://;
0.000025,3,0.000008,\&{"Exporter::Heavy::heavy_$c"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub export {
0.000027,2,0.000014,goto &{as_heavy()};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000364,214,0.000002,my $pkg = shift;
0.000420,214,0.000002,my $callpkg = caller($ExportLevel);
0.000000,0,0.000000,
0.000335,214,0.000002,if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
0.000008,1,0.000008,*{$callpkg."::import"} = \&import;
0.000013,1,0.000013,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
0.000662,213,0.000003,my $exports = \@{"$pkg\::EXPORT"};
0.000000,0,0.000000,# But, avoid creating things if they don't exist, which saves a couple of
0.000000,0,0.000000,# hundred bytes per package processed.
0.000532,213,0.000002,my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
0.000377,213,0.000002,return export $pkg, $callpkg, @_
0.000000,0,0.000000,if $Verbose or $Debug or $fail && @$fail > 1;
0.000449,213,0.000002,my $export_cache = ($Cache{$pkg} ||= {});
0.000439,213,0.000002,my $args = @_ or @_ = @$exports;
0.000000,0,0.000000,
0.000343,213,0.000002,if ($args and not %$export_cache) {
0.000000,0,0.000000,s/^&//, $export_cache->{$_} = 1
0.005667,14,0.000405,foreach (@$exports, @{"$pkg\::EXPORT_OK"});
0.000000,0,0.000000,}
0.000295,213,0.000001,my $heavy;
0.000000,0,0.000000,# Try very hard not to use {} and hence have to  enter scope on the foreach
0.000000,0,0.000000,# We bomb out of the loop with last as soon as heavy is set.
0.000662,213,0.000003,if ($args or $fail) {
0.000000,0,0.000000,($heavy = (/\W/ or $args and not exists $export_cache->{$_}
0.000000,0,0.000000,or $fail and @$fail and $_ eq $fail->[0])) and last
0.003175,166,0.000019,foreach (@_);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,($heavy = /\W/) and last
0.000807,47,0.000017,foreach (@_);
0.000000,0,0.000000,}
0.000319,213,0.000001,return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
0.000000,0,0.000000,local $SIG{__WARN__} = 
0.001131,211,0.000005,sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
0.000000,0,0.000000,# shortcut for the common case of no type character
0.004349,211,0.000021,*{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Default methods
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_fail {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,@_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
0.000000,0,0.000000,# *name = \&foo.  Thus the need to create a lot of identical subroutines
0.000000,0,0.000000,# Otherwise we could have aliased them to export().
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_to_level {
0.000000,0,0.000000,goto &{as_heavy()};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_tags {
0.000000,0,0.000000,goto &{as_heavy()};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_ok_tags {
0.000013,1,0.000013,goto &{as_heavy()};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub require_version {
0.000000,0,0.000000,goto &{as_heavy()};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,__END__
