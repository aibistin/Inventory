# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# $Id$
0.000000,0,0.000000,# vim: ts=8:sw=4:et
0.000000,0,0.000000,#
0.000000,0,0.000000,# Copyright (c) 1994-2012  Tim Bunce  Ireland
0.000000,0,0.000000,#
0.000000,0,0.000000,# See COPYRIGHT section in pod text below for usage and distribution rights.
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000000,0,0.000000,package DBI;
0.000000,0,0.000000,
0.000014,1,0.000014,require 5.008_001;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$VERSION = "1.628"; # ==> ALSO update the version in the pod text below!
0.000079,1,0.000079,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,DBI - Database independent interface for Perl
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use DBI;
0.000000,0,0.000000,
0.000000,0,0.000000,@driver_names = DBI->available_drivers;
0.000000,0,0.000000,%drivers      = DBI->installed_drivers;
0.000000,0,0.000000,@data_sources = DBI->data_sources($driver_name, \%attr);
0.000000,0,0.000000,
0.000000,0,0.000000,$dbh = DBI->connect($data_source, $username, $auth, \%attr);
0.000000,0,0.000000,
0.000000,0,0.000000,$rv  = $dbh->do($statement);
0.000000,0,0.000000,$rv  = $dbh->do($statement, \%attr);
0.000000,0,0.000000,$rv  = $dbh->do($statement, \%attr, @bind_values);
0.000000,0,0.000000,
0.000000,0,0.000000,$ary_ref  = $dbh->selectall_arrayref($statement);
0.000000,0,0.000000,$hash_ref = $dbh->selectall_hashref($statement, $key_field);
0.000000,0,0.000000,
0.000000,0,0.000000,$ary_ref  = $dbh->selectcol_arrayref($statement);
0.000000,0,0.000000,$ary_ref  = $dbh->selectcol_arrayref($statement, \%attr);
0.000000,0,0.000000,
0.000000,0,0.000000,@row_ary  = $dbh->selectrow_array($statement);
0.000000,0,0.000000,$ary_ref  = $dbh->selectrow_arrayref($statement);
0.000000,0,0.000000,$hash_ref = $dbh->selectrow_hashref($statement);
0.000000,0,0.000000,
0.000000,0,0.000000,$sth = $dbh->prepare($statement);
0.000000,0,0.000000,$sth = $dbh->prepare_cached($statement);
0.000000,0,0.000000,
0.000000,0,0.000000,$rc = $sth->bind_param($p_num, $bind_value);
0.000000,0,0.000000,$rc = $sth->bind_param($p_num, $bind_value, $bind_type);
0.000000,0,0.000000,$rc = $sth->bind_param($p_num, $bind_value, \%attr);
0.000000,0,0.000000,
0.000000,0,0.000000,$rv = $sth->execute;
0.000000,0,0.000000,$rv = $sth->execute(@bind_values);
0.000000,0,0.000000,$rv = $sth->execute_array(\%attr, ...);
0.000000,0,0.000000,
0.000000,0,0.000000,$rc = $sth->bind_col($col_num, \$col_variable);
0.000000,0,0.000000,$rc = $sth->bind_columns(@list_of_refs_to_vars_to_bind);
0.000000,0,0.000000,
0.000000,0,0.000000,@row_ary  = $sth->fetchrow_array;
0.000000,0,0.000000,$ary_ref  = $sth->fetchrow_arrayref;
0.000000,0,0.000000,$hash_ref = $sth->fetchrow_hashref;
0.000000,0,0.000000,
0.000000,0,0.000000,$ary_ref  = $sth->fetchall_arrayref;
0.000000,0,0.000000,$ary_ref  = $sth->fetchall_arrayref( $slice, $max_rows );
0.000000,0,0.000000,
0.000000,0,0.000000,$hash_ref = $sth->fetchall_hashref( $key_field );
0.000000,0,0.000000,
0.000000,0,0.000000,$rv  = $sth->rows;
0.000000,0,0.000000,
0.000000,0,0.000000,$rc  = $dbh->begin_work;
0.000000,0,0.000000,$rc  = $dbh->commit;
0.000000,0,0.000000,$rc  = $dbh->rollback;
0.000000,0,0.000000,
0.000000,0,0.000000,$quoted_string = $dbh->quote($string);
0.000000,0,0.000000,
0.000000,0,0.000000,$rc  = $h->err;
0.000000,0,0.000000,$str = $h->errstr;
0.000000,0,0.000000,$rv  = $h->state;
0.000000,0,0.000000,
0.000000,0,0.000000,$rc  = $dbh->disconnect;
0.000000,0,0.000000,
0.000000,0,0.000000,I<The synopsis above only lists the major methods and parameters.>
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 GETTING HELP
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 General
0.000000,0,0.000000,
0.000000,0,0.000000,Before asking any questions, reread this document, consult the
0.000000,0,0.000000,archives and read the DBI FAQ. The archives are listed
0.000000,0,0.000000,at the end of this document and on the DBI home page L<http://dbi.perl.org/support/>
0.000000,0,0.000000,
0.000000,0,0.000000,You might also like to read the Advanced DBI Tutorial at
0.000000,0,0.000000,L<http://www.slideshare.net/Tim.Bunce/dbi-advanced-tutorial-2007>
0.000000,0,0.000000,
0.000000,0,0.000000,To help you make the best use of the dbi-users mailing list,
0.000000,0,0.000000,and any other lists or forums you may use, I recommend that you read
0.000000,0,0.000000,"Getting Answers" by Mike Ash: L<http://mikeash.com/getting_answers.html>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Mailing Lists
0.000000,0,0.000000,
0.000000,0,0.000000,If you have questions about DBI, or DBD driver modules, you can get
0.000000,0,0.000000,help from the I<dbi-users@perl.org> mailing list. This is the best way to get
0.000000,0,0.000000,help. You don't have to subscribe to the list in order to post, though I'd
0.000000,0,0.000000,recommend it. You can get help on subscribing and using the list by emailing
0.000000,0,0.000000,I<dbi-users-help@perl.org>.
0.000000,0,0.000000,
0.000000,0,0.000000,Please note that Tim Bunce does not maintain the mailing lists or the
0.000000,0,0.000000,web pages (generous volunteers do that).  So please don't send mail
0.000000,0,0.000000,directly to him; he just doesn't have the time to answer questions
0.000000,0,0.000000,personally. The I<dbi-users> mailing list has lots of experienced
0.000000,0,0.000000,people who should be able to help you if you need it. If you do email
0.000000,0,0.000000,Tim he is very likely to just forward it to the mailing list.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Online
0.000000,0,0.000000,
0.000000,0,0.000000,StackOverflow has a DBI tag L<http://stackoverflow.com/questions/tagged/dbi>
0.000000,0,0.000000,with over 400 questions.
0.000000,0,0.000000,
0.000000,0,0.000000,The DBI home page at L<http://dbi.perl.org/> and the DBI FAQ
0.000000,0,0.000000,at L<http://faq.dbi-support.com/> may be worth a visit.
0.000000,0,0.000000,They include links to other resources, but I<are rather out-dated>.
0.000000,0,0.000000,
0.000000,0,0.000000,I don't recommend the DBI cpanforum (at http://www.cpanforum.com/dist/DBI)
0.000000,0,0.000000,because relatively few people read it compared with dbi-users@perl.org.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Reporting a Bug
0.000000,0,0.000000,
0.000000,0,0.000000,If you think you've found a bug then please read
0.000000,0,0.000000,"How to Report Bugs Effectively" by Simon Tatham:
0.000000,0,0.000000,L<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
0.000000,0,0.000000,
0.000000,0,0.000000,Your problem is most likely related to the specific DBD driver module you're
0.000000,0,0.000000,using. If that's the case then click on the 'Bugs' link on the L<http://metacpan.org>
0.000000,0,0.000000,page for your driver. Only submit a bug report against the DBI itself if you're
0.000000,0,0.000000,sure that your issue isn't related to the driver you're using.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 NOTES
0.000000,0,0.000000,
0.000000,0,0.000000,This is the DBI specification that corresponds to DBI version 1.628
0.000000,0,0.000000,(see L<DBI::Changes> for details).
0.000000,0,0.000000,
0.000000,0,0.000000,The DBI is evolving at a steady pace, so it's good to check that
0.000000,0,0.000000,you have the latest copy.
0.000000,0,0.000000,
0.000000,0,0.000000,The significant user-visible changes in each release are documented
0.000000,0,0.000000,in the L<DBI::Changes> module so you can read them by executing
0.000000,0,0.000000,C<perldoc DBI::Changes>.
0.000000,0,0.000000,
0.000000,0,0.000000,Some DBI changes require changes in the drivers, but the drivers
0.000000,0,0.000000,can take some time to catch up. Newer versions of the DBI have
0.000000,0,0.000000,added features that may not yet be supported by the drivers you
0.000000,0,0.000000,use.  Talk to the authors of your drivers if you need a new feature
0.000000,0,0.000000,that is not yet supported.
0.000000,0,0.000000,
0.000000,0,0.000000,Features added after DBI 1.21 (February 2002) are marked in the
0.000000,0,0.000000,text with the version number of the DBI release they first appeared in.
0.000000,0,0.000000,
0.000000,0,0.000000,Extensions to the DBI API often use the C<DBIx::*> namespace.
0.000000,0,0.000000,See L</Naming Conventions and Name Space>. DBI extension modules
0.000000,0,0.000000,can be found at L<https://metacpan.org/search?q=DBIx>.  And all modules
0.000000,0,0.000000,related to the DBI can be found at L<https://metacpan.org/search?q=DBI>.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,# The POD text continues at the end of the file.
0.000000,0,0.000000,
0.000027,2,0.000013,use Carp();
0.000217,2,0.000109,use DynaLoader ();
0.000213,2,0.000106,use Exporter ();
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000009,1,0.000009,@ISA = qw(Exporter DynaLoader);
0.000000,0,0.000000,
0.000000,0,0.000000,# Make some utility functions available if asked for
0.000002,1,0.000002,@EXPORT    = ();		    # we export nothing by default
0.000002,1,0.000002,@EXPORT_OK = qw(%DBI %DBI_methods hash); # also populated by export_ok_tags:
0.000014,1,0.000014,%EXPORT_TAGS = (
0.000000,0,0.000000,sql_types => [ qw(
0.000000,0,0.000000,SQL_GUID
0.000000,0,0.000000,SQL_WLONGVARCHAR
0.000000,0,0.000000,SQL_WVARCHAR
0.000000,0,0.000000,SQL_WCHAR
0.000000,0,0.000000,SQL_BIGINT
0.000000,0,0.000000,SQL_BIT
0.000000,0,0.000000,SQL_TINYINT
0.000000,0,0.000000,SQL_LONGVARBINARY
0.000000,0,0.000000,SQL_VARBINARY
0.000000,0,0.000000,SQL_BINARY
0.000000,0,0.000000,SQL_LONGVARCHAR
0.000000,0,0.000000,SQL_UNKNOWN_TYPE
0.000000,0,0.000000,SQL_ALL_TYPES
0.000000,0,0.000000,SQL_CHAR
0.000000,0,0.000000,SQL_NUMERIC
0.000000,0,0.000000,SQL_DECIMAL
0.000000,0,0.000000,SQL_INTEGER
0.000000,0,0.000000,SQL_SMALLINT
0.000000,0,0.000000,SQL_FLOAT
0.000000,0,0.000000,SQL_REAL
0.000000,0,0.000000,SQL_DOUBLE
0.000000,0,0.000000,SQL_DATETIME
0.000000,0,0.000000,SQL_DATE
0.000000,0,0.000000,SQL_INTERVAL
0.000000,0,0.000000,SQL_TIME
0.000000,0,0.000000,SQL_TIMESTAMP
0.000000,0,0.000000,SQL_VARCHAR
0.000000,0,0.000000,SQL_BOOLEAN
0.000000,0,0.000000,SQL_UDT
0.000000,0,0.000000,SQL_UDT_LOCATOR
0.000000,0,0.000000,SQL_ROW
0.000000,0,0.000000,SQL_REF
0.000000,0,0.000000,SQL_BLOB
0.000000,0,0.000000,SQL_BLOB_LOCATOR
0.000000,0,0.000000,SQL_CLOB
0.000000,0,0.000000,SQL_CLOB_LOCATOR
0.000000,0,0.000000,SQL_ARRAY
0.000000,0,0.000000,SQL_ARRAY_LOCATOR
0.000000,0,0.000000,SQL_MULTISET
0.000000,0,0.000000,SQL_MULTISET_LOCATOR
0.000000,0,0.000000,SQL_TYPE_DATE
0.000000,0,0.000000,SQL_TYPE_TIME
0.000000,0,0.000000,SQL_TYPE_TIMESTAMP
0.000000,0,0.000000,SQL_TYPE_TIME_WITH_TIMEZONE
0.000000,0,0.000000,SQL_TYPE_TIMESTAMP_WITH_TIMEZONE
0.000000,0,0.000000,SQL_INTERVAL_YEAR
0.000000,0,0.000000,SQL_INTERVAL_MONTH
0.000000,0,0.000000,SQL_INTERVAL_DAY
0.000000,0,0.000000,SQL_INTERVAL_HOUR
0.000000,0,0.000000,SQL_INTERVAL_MINUTE
0.000000,0,0.000000,SQL_INTERVAL_SECOND
0.000000,0,0.000000,SQL_INTERVAL_YEAR_TO_MONTH
0.000000,0,0.000000,SQL_INTERVAL_DAY_TO_HOUR
0.000000,0,0.000000,SQL_INTERVAL_DAY_TO_MINUTE
0.000000,0,0.000000,SQL_INTERVAL_DAY_TO_SECOND
0.000000,0,0.000000,SQL_INTERVAL_HOUR_TO_MINUTE
0.000000,0,0.000000,SQL_INTERVAL_HOUR_TO_SECOND
0.000000,0,0.000000,SQL_INTERVAL_MINUTE_TO_SECOND
0.000000,0,0.000000,DBIstcf_DISCARD_STRING
0.000000,0,0.000000,DBIstcf_STRICT
0.000000,0,0.000000,) ],
0.000000,0,0.000000,sql_cursor_types => [ qw(
0.000000,0,0.000000,SQL_CURSOR_FORWARD_ONLY
0.000000,0,0.000000,SQL_CURSOR_KEYSET_DRIVEN
0.000000,0,0.000000,SQL_CURSOR_DYNAMIC
0.000000,0,0.000000,SQL_CURSOR_STATIC
0.000000,0,0.000000,SQL_CURSOR_TYPE_DEFAULT
0.000000,0,0.000000,) ], # for ODBC cursor types
0.000000,0,0.000000,utils     => [ qw(
0.000000,0,0.000000,neat neat_list $neat_maxlen dump_results looks_like_number
0.000000,0,0.000000,data_string_diff data_string_desc data_diff sql_type_cast
0.000000,0,0.000000,) ],
0.000000,0,0.000000,profile   => [ qw(
0.000000,0,0.000000,dbi_profile dbi_profile_merge dbi_profile_merge_nodes dbi_time
0.000000,0,0.000000,) ], # notionally "in" DBI::Profile and normally imported from there
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000001,1,0.000001,$DBI::dbi_debug = 0;          # mixture of bit fields and int sub-fields
0.000001,1,0.000001,$DBI::neat_maxlen = 1000;
0.000001,1,0.000001,$DBI::stderr = 2_000_000_000; # a very round number below 2**31
0.000000,0,0.000000,
0.000000,0,0.000000,# If you get an error here like "Can't find loadable object ..."
0.000000,0,0.000000,# then you haven't installed the DBI correctly. Read the README
0.000000,0,0.000000,# then install it again.
0.000005,1,0.000005,if ( $ENV{DBI_PUREPERL} ) {
0.000000,0,0.000000,eval { bootstrap DBI } if       $ENV{DBI_PUREPERL} == 1;
0.000000,0,0.000000,require DBI::PurePerl  if $@ or $ENV{DBI_PUREPERL} >= 2;
0.000000,0,0.000000,$DBI::PurePerl ||= 0; # just to silence "only used once" warnings
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000009,1,0.000009,bootstrap DBI;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000906,127,0.000007,$EXPORT_TAGS{preparse_flags} = [ grep { /^DBIpp_\w\w_/ } keys %{__PACKAGE__."::"} ];
0.000000,0,0.000000,
0.000010,1,0.000010,Exporter::export_ok_tags(keys %EXPORT_TAGS);
0.000000,0,0.000000,
0.000046,1,0.000046,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Alias some handle methods to also be DBI class methods
0.000003,1,0.000003,for (qw(trace_msg set_err parse_trace_flag parse_trace_flags)) {
0.000053,2,0.000026,no strict;
0.000022,4,0.000005,*$_ = \&{"DBD::_::common::$_"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001047,2,0.000524,use strict;
0.000000,0,0.000000,
0.000002,1,0.000002,DBI->trace(split /=/, $ENV{DBI_TRACE}, 2) if $ENV{DBI_TRACE};
0.000000,0,0.000000,
0.000002,1,0.000002,$DBI::connect_via ||= "connect";
0.000000,0,0.000000,
0.000000,0,0.000000,# check if user wants a persistent database connection ( Apache + mod_perl )
0.000002,1,0.000002,if ($INC{'Apache/DBI.pm'} && $ENV{MOD_PERL}) {
0.000000,0,0.000000,$DBI::connect_via = "Apache::DBI::connect";
0.000000,0,0.000000,DBI->trace_msg("DBI connect via $DBI::connect_via in $INC{'Apache/DBI.pm'}\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# check for weaken support, used by ChildHandles
0.000003,1,0.000003,my $HAS_WEAKEN = eval {
0.000002,1,0.000002,require Scalar::Util;
0.000000,0,0.000000,# this will croak() if this Scalar::Util doesn't have a working weaken().
0.000016,1,0.000016,Scalar::Util::weaken( \my $test ); # same test as in t/72childhandles.t
0.000002,1,0.000002,1;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000002,1,0.000002,%DBI::installed_drh = ();  # maps driver names to installed driver handles
0.000000,0,0.000000,sub installed_drivers { %DBI::installed_drh }
0.000002,1,0.000002,%DBI::installed_methods = (); # XXX undocumented, may change
0.000000,0,0.000000,sub installed_methods { %DBI::installed_methods }
0.000000,0,0.000000,
0.000000,0,0.000000,# Setup special DBI dynamic variables. See DBI::var::FETCH for details.
0.000000,0,0.000000,# These are dynamically associated with the last handle used.
0.000012,1,0.000012,tie $DBI::err,    'DBI::var', '*err';    # special case: referenced via IHA list
0.000006,1,0.000006,tie $DBI::state,  'DBI::var', '"state';  # special case: referenced via IHA list
0.000006,1,0.000006,tie $DBI::lasth,  'DBI::var', '!lasth';  # special case: return boolean
0.000006,1,0.000006,tie $DBI::errstr, 'DBI::var', '&errstr'; # call &errstr in last used pkg
0.000006,1,0.000006,tie $DBI::rows,   'DBI::var', '&rows';   # call &rows   in last used pkg
0.000040,10,0.000004,sub DBI::var::TIESCALAR{ my $var = $_[1]; bless \$var, 'DBI::var'; }
0.000000,0,0.000000,sub DBI::var::STORE    { Carp::croak("Can't modify \$DBI::${$_[0]} special variable") }
0.000000,0,0.000000,
0.000000,0,0.000000,# --- Driver Specific Prefix Registry ---
0.000000,0,0.000000,
0.000041,1,0.000041,my $dbd_prefix_registry = {
0.000000,0,0.000000,ad_          => { class => 'DBD::AnyData',        },
0.000000,0,0.000000,ado_         => { class => 'DBD::ADO',            },
0.000000,0,0.000000,amzn_        => { class => 'DBD::Amazon',         },
0.000000,0,0.000000,best_        => { class => 'DBD::BestWins',       },
0.000000,0,0.000000,csv_         => { class => 'DBD::CSV',            },
0.000000,0,0.000000,cubrid_      => { class => 'DBD::cubrid',         },
0.000000,0,0.000000,db2_         => { class => 'DBD::DB2',            },
0.000000,0,0.000000,dbi_         => { class => 'DBI',                 },
0.000000,0,0.000000,dbm_         => { class => 'DBD::DBM',            },
0.000000,0,0.000000,df_          => { class => 'DBD::DF',             },
0.000000,0,0.000000,f_           => { class => 'DBD::File',           },
0.000000,0,0.000000,file_        => { class => 'DBD::TextFile',       },
0.000000,0,0.000000,go_          => { class => 'DBD::Gofer',          },
0.000000,0,0.000000,ib_          => { class => 'DBD::InterBase',      },
0.000000,0,0.000000,ing_         => { class => 'DBD::Ingres',         },
0.000000,0,0.000000,ix_          => { class => 'DBD::Informix',       },
0.000000,0,0.000000,jdbc_        => { class => 'DBD::JDBC',           },
0.000000,0,0.000000,mo_          => { class => 'DBD::MO',             },
0.000000,0,0.000000,monetdb_     => { class => 'DBD::monetdb',        },
0.000000,0,0.000000,msql_        => { class => 'DBD::mSQL',           },
0.000000,0,0.000000,mvsftp_      => { class => 'DBD::MVS_FTPSQL',     },
0.000000,0,0.000000,mysql_       => { class => 'DBD::mysql',          },
0.000000,0,0.000000,mx_          => { class => 'DBD::Multiplex',      },
0.000000,0,0.000000,nullp_       => { class => 'DBD::NullP',          },
0.000000,0,0.000000,odbc_        => { class => 'DBD::ODBC',           },
0.000000,0,0.000000,ora_         => { class => 'DBD::Oracle',         },
0.000000,0,0.000000,pg_          => { class => 'DBD::Pg',             },
0.000000,0,0.000000,pgpp_        => { class => 'DBD::PgPP',           },
0.000000,0,0.000000,plb_         => { class => 'DBD::Plibdata',       },
0.000000,0,0.000000,po_          => { class => 'DBD::PO',             },
0.000000,0,0.000000,proxy_       => { class => 'DBD::Proxy',          },
0.000000,0,0.000000,ram_         => { class => 'DBD::RAM',            },
0.000000,0,0.000000,rdb_         => { class => 'DBD::RDB',            },
0.000000,0,0.000000,sapdb_       => { class => 'DBD::SAP_DB',         },
0.000000,0,0.000000,snmp_        => { class => 'DBD::SNMP',           },
0.000000,0,0.000000,solid_       => { class => 'DBD::Solid',          },
0.000000,0,0.000000,spatialite_  => { class => 'DBD::Spatialite',     },
0.000000,0,0.000000,sponge_      => { class => 'DBD::Sponge',         },
0.000000,0,0.000000,sql_         => { class => 'DBI::DBD::SqlEngine', },
0.000000,0,0.000000,sqlite_      => { class => 'DBD::SQLite',         },
0.000000,0,0.000000,syb_         => { class => 'DBD::Sybase',         },
0.000000,0,0.000000,sys_         => { class => 'DBD::Sys',            },
0.000000,0,0.000000,tdat_        => { class => 'DBD::Teradata',       },
0.000000,0,0.000000,tmpl_        => { class => 'DBD::Template',       },
0.000000,0,0.000000,tmplss_      => { class => 'DBD::TemplateSS',     },
0.000000,0,0.000000,tree_        => { class => 'DBD::TreeData',       },
0.000000,0,0.000000,tuber_       => { class => 'DBD::Tuber',          },
0.000000,0,0.000000,uni_         => { class => 'DBD::Unify',          },
0.000000,0,0.000000,vt_          => { class => 'DBD::Vt',             },
0.000000,0,0.000000,wmi_         => { class => 'DBD::WMI',            },
0.000000,0,0.000000,x_           => { }, # for private use
0.000000,0,0.000000,xbase_       => { class => 'DBD::XBase',          },
0.000000,0,0.000000,xl_          => { class => 'DBD::Excel',          },
0.000000,0,0.000000,yaswi_       => { class => 'DBD::Yaswi',          },
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my %dbd_class_registry = map { $dbd_prefix_registry->{$_}->{class} => { prefix => $_ } }
0.000000,0,0.000000,grep { exists $dbd_prefix_registry->{$_}->{class} }
0.000082,1,0.000082,keys %{$dbd_prefix_registry};
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump_dbd_registry {
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,local $Data::Dumper::Sortkeys=1;
0.000000,0,0.000000,local $Data::Dumper::Indent=1;
0.000000,0,0.000000,print Data::Dumper->Dump([$dbd_prefix_registry], [qw($dbd_prefix_registry)]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# --- Dynamically create the DBI Standard Interface
0.000000,0,0.000000,
0.000002,1,0.000002,my $keeperr = { O=>0x0004 };
0.000000,0,0.000000,
0.000096,1,0.000096,%DBI::DBI_methods = ( # Define the DBI interface methods per class:
0.000000,0,0.000000,
0.000000,0,0.000000,common => {		# Interface methods common to all DBI handle classes
0.000000,0,0.000000,'DESTROY'	=> { O=>0x004|0x10000 },
0.000000,0,0.000000,'CLEAR'  	=> $keeperr,
0.000000,0,0.000000,'EXISTS' 	=> $keeperr,
0.000000,0,0.000000,'FETCH'		=> { O=>0x0404 },
0.000000,0,0.000000,'FETCH_many'	=> { O=>0x0404 },
0.000000,0,0.000000,'FIRSTKEY'	=> $keeperr,
0.000000,0,0.000000,'NEXTKEY'	=> $keeperr,
0.000000,0,0.000000,'STORE'		=> { O=>0x0418 | 0x4 },
0.000000,0,0.000000,can		=> { O=>0x0100 }, # special case, see dispatch
0.000000,0,0.000000,debug 	 	=> { U =>[1,2,'[$debug_level]'],	O=>0x0004 }, # old name for trace
0.000000,0,0.000000,dump_handle 	=> { U =>[1,3,'[$message [, $level]]'],	O=>0x0004 },
0.000000,0,0.000000,err		=> $keeperr,
0.000000,0,0.000000,errstr		=> $keeperr,
0.000000,0,0.000000,state		=> $keeperr,
0.000000,0,0.000000,func	   	=> { O=>0x0006	},
0.000000,0,0.000000,parse_trace_flag   => { U =>[2,2,'$name'],	O=>0x0404, T=>8 },
0.000000,0,0.000000,parse_trace_flags  => { U =>[2,2,'$flags'],	O=>0x0404, T=>8 },
0.000000,0,0.000000,private_data	=> { U =>[1,1],			O=>0x0004 },
0.000000,0,0.000000,set_err		=> { U =>[3,6,'$err, $errmsg [, $state, $method, $rv]'], O=>0x0010 },
0.000000,0,0.000000,trace		=> { U =>[1,3,'[$trace_level, [$filename]]'],	O=>0x0004 },
0.000000,0,0.000000,trace_msg	=> { U =>[2,3,'$message_text [, $min_level ]' ],	O=>0x0004, T=>8 },
0.000000,0,0.000000,swap_inner_handle => { U =>[2,3,'$h [, $allow_reparent ]'] },
0.000000,0,0.000000,private_attribute_info => { },
0.000000,0,0.000000,visit_child_handles => { U => [2,3,'$coderef [, $info ]'], O=>0x0404, T=>4 },
0.000000,0,0.000000,},
0.000000,0,0.000000,dr => {		# Database Driver Interface
0.000000,0,0.000000,'connect'  =>	{ U =>[1,5,'[$db [,$user [,$passwd [,\%attr]]]]'], H=>3, O=>0x8000, T=>0x200 },
0.000000,0,0.000000,'connect_cached'=>{U=>[1,5,'[$db [,$user [,$passwd [,\%attr]]]]'], H=>3, O=>0x8000, T=>0x200 },
0.000000,0,0.000000,'disconnect_all'=>{ U =>[1,1], O=>0x0800, T=>0x200 },
0.000000,0,0.000000,data_sources => { U =>[1,2,'[\%attr]' ], O=>0x0800, T=>0x200 },
0.000000,0,0.000000,default_user => { U =>[3,4,'$user, $pass [, \%attr]' ], T=>0x200 },
0.000000,0,0.000000,dbixs_revision  => $keeperr,
0.000000,0,0.000000,},
0.000000,0,0.000000,db => {		# Database Session Class Interface
0.000000,0,0.000000,data_sources	=> { U =>[1,2,'[\%attr]' ], O=>0x0200 },
0.000000,0,0.000000,take_imp_data	=> { U =>[1,1], O=>0x10000 },
0.000000,0,0.000000,clone   	=> { U =>[1,2,'[\%attr]'], T=>0x200 },
0.000000,0,0.000000,connected   	=> { U =>[1,0], O => 0x0004, T=>0x200, H=>3 },
0.000000,0,0.000000,begin_work   	=> { U =>[1,2,'[ \%attr ]'], O=>0x0400, T=>0x1000 },
0.000000,0,0.000000,commit     	=> { U =>[1,1], O=>0x0480|0x0800, T=>0x1000 },
0.000000,0,0.000000,rollback   	=> { U =>[1,1], O=>0x0480|0x0800, T=>0x1000 },
0.000000,0,0.000000,'do'       	=> { U =>[2,0,'$statement [, \%attr [, @bind_params ] ]'], O=>0x3200 },
0.000000,0,0.000000,last_insert_id	=> { U =>[5,6,'$catalog, $schema, $table_name, $field_name [, \%attr ]'], O=>0x2800 },
0.000000,0,0.000000,preparse    	=> {  }, # XXX
0.000000,0,0.000000,prepare    	=> { U =>[2,3,'$statement [, \%attr]'],                    O=>0xA200 },
0.000000,0,0.000000,prepare_cached	=> { U =>[2,4,'$statement [, \%attr [, $if_active ] ]'],   O=>0xA200 },
0.000000,0,0.000000,selectrow_array	=> { U =>[2,0,'$statement [, \%attr [, @bind_params ] ]'], O=>0x2000 },
0.000000,0,0.000000,selectrow_arrayref=>{U =>[2,0,'$statement [, \%attr [, @bind_params ] ]'], O=>0x2000 },
0.000000,0,0.000000,selectrow_hashref=>{ U =>[2,0,'$statement [, \%attr [, @bind_params ] ]'], O=>0x2000 },
0.000000,0,0.000000,selectall_arrayref=>{U =>[2,0,'$statement [, \%attr [, @bind_params ] ]'], O=>0x2000 },
0.000000,0,0.000000,selectall_hashref=>{ U =>[3,0,'$statement, $keyfield [, \%attr [, @bind_params ] ]'], O=>0x2000 },
0.000000,0,0.000000,selectcol_arrayref=>{U =>[2,0,'$statement [, \%attr [, @bind_params ] ]'], O=>0x2000 },
0.000000,0,0.000000,ping       	=> { U =>[1,1], O=>0x0404 },
0.000000,0,0.000000,disconnect 	=> { U =>[1,1], O=>0x0400|0x0800|0x10000, T=>0x200 },
0.000000,0,0.000000,quote      	=> { U =>[2,3, '$string [, $data_type ]' ], O=>0x0430 },
0.000000,0,0.000000,quote_identifier=> { U =>[2,6, '$name [, ...] [, \%attr ]' ],    O=>0x0430 },
0.000000,0,0.000000,rows       	=> $keeperr,
0.000000,0,0.000000,
0.000000,0,0.000000,tables          => { U =>[1,6,'$catalog, $schema, $table, $type [, \%attr ]' ], O=>0x2200 },
0.000000,0,0.000000,table_info      => { U =>[1,6,'$catalog, $schema, $table, $type [, \%attr ]' ],	O=>0x2200|0x8800 },
0.000000,0,0.000000,column_info     => { U =>[5,6,'$catalog, $schema, $table, $column [, \%attr ]'],O=>0x2200|0x8800 },
0.000000,0,0.000000,primary_key_info=> { U =>[4,5,'$catalog, $schema, $table [, \%attr ]' ],	O=>0x2200|0x8800 },
0.000000,0,0.000000,primary_key     => { U =>[4,5,'$catalog, $schema, $table [, \%attr ]' ],	O=>0x2200 },
0.000000,0,0.000000,foreign_key_info=> { U =>[7,8,'$pk_catalog, $pk_schema, $pk_table, $fk_catalog, $fk_schema, $fk_table [, \%attr ]' ], O=>0x2200|0x8800 },
0.000000,0,0.000000,statistics_info => { U =>[6,7,'$catalog, $schema, $table, $unique_only, $quick, [, \%attr ]' ], O=>0x2200|0x8800 },
0.000000,0,0.000000,type_info_all	=> { U =>[1,1], O=>0x2200|0x0800 },
0.000000,0,0.000000,type_info	=> { U =>[1,2,'$data_type'], O=>0x2200 },
0.000000,0,0.000000,get_info	=> { U =>[2,2,'$info_type'], O=>0x2200|0x0800 },
0.000000,0,0.000000,},
0.000000,0,0.000000,st => {		# Statement Class Interface
0.000000,0,0.000000,bind_col	=> { U =>[3,4,'$column, \\$var [, \%attr]'] },
0.000000,0,0.000000,bind_columns	=> { U =>[2,0,'\\$var1 [, \\$var2, ...]'] },
0.000000,0,0.000000,bind_param	=> { U =>[3,4,'$parameter, $var [, \%attr]'] },
0.000000,0,0.000000,bind_param_inout=> { U =>[4,5,'$parameter, \\$var, $maxlen, [, \%attr]'] },
0.000000,0,0.000000,execute		=> { U =>[1,0,'[@args]'], O=>0x1040 },
0.000000,0,0.000000,
0.000000,0,0.000000,bind_param_array  => { U =>[3,4,'$parameter, $var [, \%attr]'] },
0.000000,0,0.000000,bind_param_inout_array => { U =>[4,5,'$parameter, \\@var, $maxlen, [, \%attr]'] },
0.000000,0,0.000000,execute_array     => { U =>[2,0,'\\%attribs [, @args]'],         O=>0x1040|0x4000 },
0.000000,0,0.000000,execute_for_fetch => { U =>[2,3,'$fetch_sub [, $tuple_status]'], O=>0x1040|0x4000 },
0.000000,0,0.000000,
0.000000,0,0.000000,fetch    	  => undef, # alias for fetchrow_arrayref
0.000000,0,0.000000,fetchrow_arrayref => undef,
0.000000,0,0.000000,fetchrow_hashref  => undef,
0.000000,0,0.000000,fetchrow_array    => undef,
0.000000,0,0.000000,fetchrow   	  => undef, # old alias for fetchrow_array
0.000000,0,0.000000,
0.000000,0,0.000000,fetchall_arrayref => { U =>[1,3, '[ $slice [, $max_rows]]'] },
0.000000,0,0.000000,fetchall_hashref  => { U =>[2,2,'$key_field'] },
0.000000,0,0.000000,
0.000000,0,0.000000,blob_read  =>	{ U =>[4,5,'$field, $offset, $len [, \\$buf [, $bufoffset]]'] },
0.000000,0,0.000000,blob_copy_to_file => { U =>[3,3,'$field, $filename_or_handleref'] },
0.000000,0,0.000000,dump_results => { U =>[1,5,'$maxfieldlen, $linesep, $fieldsep, $filehandle'] },
0.000000,0,0.000000,more_results => { U =>[1,1] },
0.000000,0,0.000000,finish     => 	{ U =>[1,1] },
0.000000,0,0.000000,cancel     => 	{ U =>[1,1], O=>0x0800 },
0.000000,0,0.000000,rows       =>	$keeperr,
0.000000,0,0.000000,
0.000000,0,0.000000,_get_fbav	=> undef,
0.000000,0,0.000000,_set_fbav	=> { T=>6 },
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000017,1,0.000017,while ( my ($class, $meths) = each %DBI::DBI_methods ) {
0.000008,4,0.000002,my $ima_trace = 0+($ENV{DBI_IMA_TRACE}||0);
0.000331,4,0.000083,while ( my ($method, $info) = each %$meths ) {
0.000154,88,0.000002,my $fullmeth = "DBI::${class}::$method";
0.000127,88,0.000001,if (($DBI::dbi_debug & 0xF) == 15) { # quick hack to list DBI methods
0.000000,0,0.000000,# and optionally filter by IMA flags
0.000000,0,0.000000,my $O = $info->{O}||0;
0.000000,0,0.000000,printf "0x%04x %-20s\n", $O, $fullmeth
0.000000,0,0.000000,unless $ima_trace && !($O & $ima_trace);
0.000000,0,0.000000,}
0.000921,88,0.000010,DBI->_install_method($fullmeth, 'DBI.pm', $info);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000003,1,0.000003,package DBI::common;
0.000008,1,0.000008,@DBI::dr::ISA = ('DBI::common');
0.000004,1,0.000004,@DBI::db::ISA = ('DBI::common');
0.000004,1,0.000004,@DBI::st::ISA = ('DBI::common');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# End of init code
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,END {
0.000002,1,0.000002,return unless defined &DBI::trace_msg; # return unless bootstrap'd ok
0.000195,1,0.000195,local ($!,$?);
0.000018,1,0.000018,DBI->trace_msg(sprintf("    -- DBI::END (\$\@: %s, \$!: %s)\n", $@||'', $!||''), 2);
0.000000,0,0.000000,# Let drivers know why we are calling disconnect_all:
0.000002,1,0.000002,$DBI::PERL_ENDING = $DBI::PERL_ENDING = 1;	# avoid typo warning
0.000013,1,0.000013,DBI->disconnect_all() if %DBI::installed_drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,_clone_dbis() unless $DBI::PurePerl; # clone the DBIS structure
0.000000,0,0.000000,DBI->trace_msg("CLONE DBI for new thread\n");
0.000000,0,0.000000,while ( my ($driver, $drh) = each %DBI::installed_drh) {
0.000904,2,0.000452,no strict 'refs';
0.000000,0,0.000000,next if defined &{"DBD::${driver}::CLONE"};
0.000000,0,0.000000,warn("$driver has no driver CLONE() function so is unsafe threaded\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,%DBI::installed_drh = ();	# clear loaded drivers so they have a chance to reinitialize
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_dsn {
0.000000,0,0.000000,my ($class, $dsn) = @_;
0.000000,0,0.000000,$dsn =~ s/^(dbi):(\w*?)(?:\((.*?)\))?://i or return;
0.000000,0,0.000000,my ($scheme, $driver, $attr, $attr_hash) = (lc($1), $2, $3);
0.000000,0,0.000000,$driver ||= $ENV{DBI_DRIVER} || '';
0.000000,0,0.000000,$attr_hash = { split /\s*=>?\s*|\s*,\s*/, $attr, -1 } if $attr;
0.000000,0,0.000000,return ($scheme, $driver, $attr, $attr_hash, $dsn);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub visit_handles {
0.000000,0,0.000000,my ($class, $code, $outer_info) = @_;
0.000000,0,0.000000,$outer_info = {} if not defined $outer_info;
0.000000,0,0.000000,my %drh = DBI->installed_drivers;
0.000000,0,0.000000,for my $h (values %drh) {
0.000000,0,0.000000,my $child_info = $code->($h, $outer_info)
0.000000,0,0.000000,or next;
0.000000,0,0.000000,$h->visit_child_handles($code, $child_info);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $outer_info;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# --- The DBI->connect Front Door methods
0.000000,0,0.000000,
0.000000,0,0.000000,sub connect_cached {
0.000000,0,0.000000,# For library code using connect_cached() with mod_perl
0.000000,0,0.000000,# we redirect those calls to Apache::DBI::connect() as well
0.000000,0,0.000000,my ($class, $dsn, $user, $pass, $attr) = @_;
0.000000,0,0.000000,my $dbi_connect_method = ($DBI::connect_via eq "Apache::DBI::connect")
0.000000,0,0.000000,? 'Apache::DBI::connect' : 'connect_cached';
0.000000,0,0.000000,$attr = {
0.000000,0,0.000000,$attr ? %$attr : (), # clone, don't modify callers data
0.000000,0,0.000000,dbi_connect_method => $dbi_connect_method,
0.000000,0,0.000000,};
0.000000,0,0.000000,return $class->connect($dsn, $user, $pass, $attr);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub connect {
0.000002,1,0.000002,my $class = shift;
0.000003,1,0.000003,my ($dsn, $user, $pass, $attr, $old_driver) = my @orig_args = @_;
0.000001,1,0.000001,my $driver;
0.000000,0,0.000000,
0.000002,1,0.000002,if ($attr and !ref($attr)) { # switch $old_driver<->$attr if called in old style
0.000000,0,0.000000,Carp::carp("DBI->connect using 'old-style' syntax is deprecated and will be an error in future versions");
0.000000,0,0.000000,($old_driver, $attr) = ($attr, $old_driver);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $connect_meth = $attr->{dbi_connect_method};
0.000002,1,0.000002,$connect_meth ||= $DBI::connect_via;	# fallback to default
0.000000,0,0.000000,
0.000002,1,0.000002,$dsn ||= $ENV{DBI_DSN} || $ENV{DBI_DBNAME} || '' unless $old_driver;
0.000000,0,0.000000,
0.000002,1,0.000002,if ($DBI::dbi_debug) {
0.000000,0,0.000000,local $^W = 0;
0.000000,0,0.000000,pop @_ if $connect_meth ne 'connect';
0.000000,0,0.000000,my @args = @_; $args[2] = '****'; # hide password
0.000000,0,0.000000,DBI->trace_msg("    -> $class->$connect_meth(".join(", ",@args).")\n");
0.000000,0,0.000000,}
0.000002,1,0.000002,Carp::croak('Usage: $class->connect([$dsn [,$user [,$passwd [,\%attr]]]])')
0.000000,0,0.000000,if (ref $old_driver or ($attr and not ref $attr) or ref $pass);
0.000000,0,0.000000,
0.000000,0,0.000000,# extract dbi:driver prefix from $dsn into $1
0.000016,1,0.000016,$dsn =~ s/^dbi:(\w*?)(?:\((.*?)\))?://i
0.000000,0,0.000000,or '' =~ /()/; # ensure $1 etc are empty if match fails
0.000003,1,0.000003,my $driver_attrib_spec = $2 || '';
0.000000,0,0.000000,
0.000000,0,0.000000,# Set $driver. Old style driver, if specified, overrides new dsn style.
0.000003,1,0.000003,$driver = $old_driver || $1 || $ENV{DBI_DRIVER}
0.000000,0,0.000000,or Carp::croak("Can't connect to data source '$dsn' "
0.000000,0,0.000000,."because I can't work out what driver to use "
0.000000,0,0.000000,."(it doesn't seem to contain a 'dbi:driver:' prefix "
0.000000,0,0.000000,."and the DBI_DRIVER env var is not set)");
0.000000,0,0.000000,
0.000002,1,0.000002,my $proxy;
0.000002,1,0.000002,if ($ENV{DBI_AUTOPROXY} && $driver ne 'Proxy' && $driver ne 'Sponge' && $driver ne 'Switch') {
0.000000,0,0.000000,my $dbi_autoproxy = $ENV{DBI_AUTOPROXY};
0.000000,0,0.000000,$proxy = 'Proxy';
0.000000,0,0.000000,if ($dbi_autoproxy =~ s/^dbi:(\w*?)(?:\((.*?)\))?://i) {
0.000000,0,0.000000,$proxy = $1;
0.000000,0,0.000000,$driver_attrib_spec = join ",",
0.000000,0,0.000000,($driver_attrib_spec) ? $driver_attrib_spec : (),
0.000000,0,0.000000,($2                 ) ? $2                  : ();
0.000000,0,0.000000,}
0.000000,0,0.000000,$dsn = "$dbi_autoproxy;dsn=dbi:$driver:$dsn";
0.000000,0,0.000000,$driver = $proxy;
0.000000,0,0.000000,DBI->trace_msg("       DBI_AUTOPROXY: dbi:$driver($driver_attrib_spec):$dsn\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,# avoid recursion if proxy calls DBI->connect itself
0.000002,1,0.000002,local $ENV{DBI_AUTOPROXY} if $ENV{DBI_AUTOPROXY};
0.000000,0,0.000000,
0.000002,1,0.000002,my %attributes;	# take a copy we can delete from
0.000003,1,0.000003,if ($old_driver) {
0.000000,0,0.000000,%attributes = %$attr if $attr;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {		# new-style connect so new default semantics
0.000005,1,0.000005,%attributes = (
0.000000,0,0.000000,PrintError => 1,
0.000000,0,0.000000,AutoCommit => 1,
0.000000,0,0.000000,ref $attr           ? %$attr : (),
0.000000,0,0.000000,# attributes in DSN take precedence over \%attr connect parameter
0.000000,0,0.000000,$driver_attrib_spec ? (split /\s*=>?\s*|\s*,\s*/, $driver_attrib_spec, -1) : (),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000002,1,0.000002,$attr = \%attributes; # now set $attr to refer to our local copy
0.000000,0,0.000000,
0.000007,1,0.000007,my $drh = $DBI::installed_drh{$driver} || $class->install_driver($driver)
0.000000,0,0.000000,or die "panic: $class->install_driver($driver) failed";
0.000000,0,0.000000,
0.000000,0,0.000000,# attributes in DSN take precedence over \%attr connect parameter
0.000002,1,0.000002,$user = $attr->{Username} if defined $attr->{Username};
0.000002,1,0.000002,$pass = $attr->{Password} if defined $attr->{Password};
0.000003,1,0.000003,delete $attr->{Password}; # always delete Password as closure stores it securely
0.000002,1,0.000002,if ( !(defined $user && defined $pass) ) {
0.000000,0,0.000000,($user, $pass) = $drh->default_user($user, $pass, $attr);
0.000000,0,0.000000,}
0.000003,1,0.000003,$attr->{Username} = $user; # force the Username to be the actual one used
0.000000,0,0.000000,
0.000000,0,0.000000,my $connect_closure = sub {
0.000002,1,0.000002,my ($old_dbh, $override_attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,#use Data::Dumper;
0.000000,0,0.000000,#warn "connect_closure: ".Data::Dumper::Dumper([$attr,\%attributes, $override_attr]);
0.000000,0,0.000000,
0.000002,1,0.000002,my $dbh;
0.000035,1,0.000035,unless ($dbh = $drh->$connect_meth($dsn, $user, $pass, $attr)) {
0.000000,0,0.000000,$user = '' if !defined $user;
0.000000,0,0.000000,$dsn = '' if !defined $dsn;
0.000000,0,0.000000,# $drh->errstr isn't safe here because $dbh->DESTROY may not have
0.000000,0,0.000000,# been called yet and so the dbh errstr would not have been copied
0.000000,0,0.000000,# up to the drh errstr. Certainly true for connect_cached!
0.000000,0,0.000000,my $errstr = $DBI::errstr;
0.000000,0,0.000000,# Getting '(no error string)' here is a symptom of a ref loop
0.000000,0,0.000000,$errstr = '(no error string)' if !defined $errstr;
0.000000,0,0.000000,my $msg = "$class connect('$dsn','$user',...) failed: $errstr";
0.000000,0,0.000000,DBI->trace_msg("       $msg\n");
0.000000,0,0.000000,# XXX HandleWarn
0.000000,0,0.000000,unless ($attr->{HandleError} && $attr->{HandleError}->($msg, $drh, $dbh)) {
0.000000,0,0.000000,Carp::croak($msg) if $attr->{RaiseError};
0.000000,0,0.000000,Carp::carp ($msg) if $attr->{PrintError};
0.000000,0,0.000000,}
0.000000,0,0.000000,$! = 0; # for the daft people who do DBI->connect(...) || die "$!";
0.000000,0,0.000000,return $dbh; # normally undef, but HandleError could change it
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# merge any attribute overrides but don't change $attr itself (for closure)
0.000006,1,0.000006,my $apply = { ($override_attr) ? (%$attr, %$override_attr ) : %$attr };
0.000000,0,0.000000,
0.000000,0,0.000000,# handle basic RootClass subclassing:
0.000003,1,0.000003,my $rebless_class = $apply->{RootClass} || ($class ne 'DBI' ? $class : '');
0.000002,1,0.000002,if ($rebless_class) {
0.000677,2,0.000338,no strict 'refs';
0.000000,0,0.000000,if ($apply->{RootClass}) { # explicit attribute (ie not static method call class)
0.000000,0,0.000000,delete $apply->{RootClass};
0.000000,0,0.000000,DBI::_load_class($rebless_class, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,unless (@{"$rebless_class\::db::ISA"} && @{"$rebless_class\::st::ISA"}) {
0.000000,0,0.000000,Carp::carp("DBI subclasses '$rebless_class\::db' and ::st are not setup, RootClass ignored");
0.000000,0,0.000000,$rebless_class = undef;
0.000000,0,0.000000,$class = 'DBI';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$dbh->{RootClass} = $rebless_class; # $dbh->STORE called via plain DBI::db
0.000000,0,0.000000,DBI::_set_isa([$rebless_class], 'DBI');     # sets up both '::db' and '::st'
0.000000,0,0.000000,DBI::_rebless($dbh, $rebless_class);        # appends '::db'
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,if (%$apply) {
0.000000,0,0.000000,
0.000002,1,0.000002,if ($apply->{DbTypeSubclass}) {
0.000000,0,0.000000,my $DbTypeSubclass = delete $apply->{DbTypeSubclass};
0.000000,0,0.000000,DBI::_rebless_dbtype_subclass($dbh, $rebless_class||$class, $DbTypeSubclass);
0.000000,0,0.000000,}
0.000001,1,0.000001,my $a;
0.000005,1,0.000005,foreach $a (qw(Profile RaiseError PrintError AutoCommit)) { # do these first
0.000007,4,0.000002,next unless  exists $apply->{$a};
0.000055,3,0.000018,$dbh->{$a} = delete $apply->{$a};
0.000000,0,0.000000,}
0.000012,1,0.000012,while ( my ($a, $v) = each %$apply) {
0.000030,4,0.000007,eval { $dbh->{$a} = $v }; # assign in void context to avoid re-FETCH
0.000003,2,0.000002,warn $@ if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# confirm to driver (ie if subclassed) that we've connected successfully
0.000000,0,0.000000,# and finished the attribute setup. pass in the original arguments
0.000015,1,0.000015,$dbh->connected(@orig_args); #if ref $dbh ne 'DBI::db' or $proxy;
0.000000,0,0.000000,
0.000002,1,0.000002,DBI->trace_msg("    <- connect= $dbh\n") if $DBI::dbi_debug & 0xF;
0.000000,0,0.000000,
0.000009,1,0.000009,return $dbh;
0.000012,1,0.000012,};
0.000000,0,0.000000,
0.000008,1,0.000008,my $dbh = &$connect_closure(undef, undef);
0.000000,0,0.000000,
0.000014,1,0.000014,$dbh->{dbi_connect_closure} = $connect_closure if $dbh;
0.000000,0,0.000000,
0.000008,1,0.000008,return $dbh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub disconnect_all {
0.000002,1,0.000002,keys %DBI::installed_drh; # reset iterator
0.000026,1,0.000026,while ( my ($name, $drh) = each %DBI::installed_drh ) {
0.000000,0,0.000000,$drh->disconnect_all() if ref $drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub disconnect {		# a regular beginners bug
0.000000,0,0.000000,Carp::croak("DBI->disconnect is not a DBI method (read the DBI manual)");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_driver {		# croaks on failure
0.000002,1,0.000002,my $class = shift;
0.000002,1,0.000002,my($driver, $attr) = @_;
0.000001,1,0.000001,my $drh;
0.000000,0,0.000000,
0.000001,1,0.000001,$driver ||= $ENV{DBI_DRIVER} || '';
0.000000,0,0.000000,
0.000000,0,0.000000,# allow driver to be specified as a 'dbi:driver:' string
0.000008,1,0.000008,$driver = $1 if $driver =~ s/^DBI:(.*?)://i;
0.000000,0,0.000000,
0.000002,1,0.000002,Carp::croak("usage: $class->install_driver(\$driver [, \%attr])")
0.000000,0,0.000000,unless ($driver and @_<=3);
0.000000,0,0.000000,
0.000000,0,0.000000,# already installed
0.000002,1,0.000002,return $drh if $drh = $DBI::installed_drh{$driver};
0.000000,0,0.000000,
0.000002,1,0.000002,$class->trace_msg("    -> $class->install_driver($driver"
0.000000,0,0.000000,.") for $^O perl=$] pid=$$ ruid=$< euid=$>\n")
0.000000,0,0.000000,if $DBI::dbi_debug & 0xF;
0.000000,0,0.000000,
0.000000,0,0.000000,# --- load the code
0.000002,1,0.000002,my $driver_class = "DBD::$driver";
0.000044,1,0.000044,eval qq{package			# hide from PAUSE
0.000000,0,0.000000,DBI::_firesafe;		# just in case
0.000000,0,0.000000,require $driver_class;	# load the driver
0.000000,0,0.000000,};
0.000002,1,0.000002,if ($@) {
0.000000,0,0.000000,my $err = $@;
0.000000,0,0.000000,my $advice = "";
0.000000,0,0.000000,if ($err =~ /Can't find loadable object/) {
0.000000,0,0.000000,$advice = "Perhaps DBD::$driver was statically linked into a new perl binary."
0.000000,0,0.000000,."\nIn which case you need to use that new perl binary."
0.000000,0,0.000000,."\nOr perhaps only the .pm file was installed but not the shared object file."
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($err =~ /Can't locate.*?DBD\/$driver\.pm in \@INC/) {
0.000000,0,0.000000,my @drv = $class->available_drivers(1);
0.000000,0,0.000000,$advice = "Perhaps the DBD::$driver perl module hasn't been fully installed,\n"
0.000000,0,0.000000,."or perhaps the capitalisation of '$driver' isn't right.\n"
0.000000,0,0.000000,."Available drivers: ".join(", ", @drv).".";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($err =~ /Can't load .*? for module DBD::/) {
0.000000,0,0.000000,$advice = "Perhaps a required shared library or dll isn't installed where expected";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($err =~ /Can't locate .*? in \@INC/) {
0.000000,0,0.000000,$advice = "Perhaps a module that DBD::$driver requires hasn't been fully installed";
0.000000,0,0.000000,}
0.000000,0,0.000000,Carp::croak("install_driver($driver) failed: $err$advice\n");
0.000000,0,0.000000,}
0.000002,1,0.000002,if ($DBI::dbi_debug & 0xF) {
0.000265,2,0.000132,no strict 'refs';
0.000000,0,0.000000,(my $driver_file = $driver_class) =~ s/::/\//g;
0.000000,0,0.000000,my $dbd_ver = ${"$driver_class\::VERSION"} || "undef";
0.000000,0,0.000000,$class->trace_msg("       install_driver: $driver_class version $dbd_ver"
0.000000,0,0.000000,." loaded from $INC{qq($driver_file.pm)}\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# --- do some behind-the-scenes checks and setups on the driver
0.000006,1,0.000006,$class->setup_driver($driver_class);
0.000000,0,0.000000,
0.000000,0,0.000000,# --- run the driver function
0.000012,2,0.000006,$drh = eval { $driver_class->driver($attr || {}) };
0.000009,1,0.000009,unless ($drh && ref $drh && !$@) {
0.000000,0,0.000000,my $advice = "";
0.000000,0,0.000000,$@ ||= "$driver_class->driver didn't return a handle";
0.000000,0,0.000000,# catch people on case in-sensitive systems using the wrong case
0.000000,0,0.000000,$advice = "\nPerhaps the capitalisation of DBD '$driver' isn't right."
0.000000,0,0.000000,if $@ =~ /locate object method/;
0.000000,0,0.000000,Carp::croak("$driver_class initialisation failed: $@$advice");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,$DBI::installed_drh{$driver} = $drh;
0.000002,1,0.000002,$class->trace_msg("    <- install_driver= $drh\n") if $DBI::dbi_debug & 0xF;
0.000007,1,0.000007,$drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,*driver = \&install_driver;	# currently an alias, may change
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub setup_driver {
0.000006,3,0.000002,my ($class, $driver_class) = @_;
0.000004,3,0.000001,my $h_type;
0.000024,3,0.000008,foreach $h_type (qw(dr db st)){
0.000016,9,0.000002,my $h_class = $driver_class."::$h_type";
0.000233,2,0.000117,no strict 'refs';
0.000125,9,0.000014,push @{"${h_class}::ISA"},     "DBD::_::$h_type"
0.000000,0,0.000000,unless UNIVERSAL::isa($h_class, "DBD::_::$h_type");
0.000000,0,0.000000,# The _mem class stuff is (IIRC) a crufty hack for global destruction
0.000000,0,0.000000,# timing issues in early versions of perl5 and possibly no longer needed.
0.000015,9,0.000002,my $mem_class = "DBD::_mem::$h_type";
0.000134,9,0.000015,push @{"${h_class}_mem::ISA"}, $mem_class
0.000000,0,0.000000,unless UNIVERSAL::isa("${h_class}_mem", $mem_class)
0.000000,0,0.000000,or $DBI::PurePerl;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _rebless {
0.000000,0,0.000000,my $dbh = shift;
0.000000,0,0.000000,my ($outer, $inner) = DBI::_handles($dbh);
0.000000,0,0.000000,my $class = shift(@_).'::db';
0.000000,0,0.000000,bless $inner => $class;
0.000000,0,0.000000,bless $outer => $class; # outer last for return
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _set_isa {
0.000000,0,0.000000,my ($classes, $topclass) = @_;
0.000000,0,0.000000,my $trace = DBI->trace_msg("       _set_isa([@$classes])\n");
0.000000,0,0.000000,foreach my $suffix ('::db','::st') {
0.000000,0,0.000000,my $previous = $topclass || 'DBI'; # trees are rooted here
0.000000,0,0.000000,foreach my $class (@$classes) {
0.000000,0,0.000000,my $base_class = $previous.$suffix;
0.000000,0,0.000000,my $sub_class  = $class.$suffix;
0.000000,0,0.000000,my $sub_class_isa  = "${sub_class}::ISA";
0.000546,2,0.000273,no strict 'refs';
0.000000,0,0.000000,if (@$sub_class_isa) {
0.000000,0,0.000000,DBI->trace_msg("       $sub_class_isa skipped (already set to @$sub_class_isa)\n")
0.000000,0,0.000000,if $trace;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@$sub_class_isa = ($base_class) unless @$sub_class_isa;
0.000000,0,0.000000,DBI->trace_msg("       $sub_class_isa = $base_class\n")
0.000000,0,0.000000,if $trace;
0.000000,0,0.000000,}
0.000000,0,0.000000,$previous = $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _rebless_dbtype_subclass {
0.000000,0,0.000000,my ($dbh, $rootclass, $DbTypeSubclass) = @_;
0.000000,0,0.000000,# determine the db type names for class hierarchy
0.000000,0,0.000000,my @hierarchy = DBI::_dbtype_names($dbh, $DbTypeSubclass);
0.000000,0,0.000000,# add the rootclass prefix to each ('DBI::' or 'MyDBI::' etc)
0.000000,0,0.000000,$_ = $rootclass.'::'.$_ foreach (@hierarchy);
0.000000,0,0.000000,# load the modules from the 'top down'
0.000000,0,0.000000,DBI::_load_class($_, 1) foreach (reverse @hierarchy);
0.000000,0,0.000000,# setup class hierarchy if needed, does both '::db' and '::st'
0.000000,0,0.000000,DBI::_set_isa(\@hierarchy, $rootclass);
0.000000,0,0.000000,# finally bless the handle into the subclass
0.000000,0,0.000000,DBI::_rebless($dbh, $hierarchy[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dbtype_names { # list dbtypes for hierarchy, ie Informix=>ADO=>ODBC
0.000000,0,0.000000,my ($dbh, $DbTypeSubclass) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($DbTypeSubclass && $DbTypeSubclass ne '1' && ref $DbTypeSubclass ne 'CODE') {
0.000000,0,0.000000,# treat $DbTypeSubclass as a comma separated list of names
0.000000,0,0.000000,my @dbtypes = split /\s*,\s*/, $DbTypeSubclass;
0.000000,0,0.000000,$dbh->trace_msg("    DbTypeSubclass($DbTypeSubclass)=@dbtypes (explicit)\n");
0.000000,0,0.000000,return @dbtypes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX will call $dbh->get_info(17) (=SQL_DBMS_NAME) in future?
0.000000,0,0.000000,
0.000000,0,0.000000,my $driver = $dbh->{Driver}->{Name};
0.000000,0,0.000000,if ( $driver eq 'Proxy' ) {
0.000000,0,0.000000,# XXX Looking into the internals of DBD::Proxy is questionable!
0.000000,0,0.000000,($driver) = $dbh->{proxy_client}->{application} =~ /^DBI:(.+?):/i
0.000000,0,0.000000,or die "Can't determine driver name from proxy";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @dbtypes = (ucfirst($driver));
0.000000,0,0.000000,if ($driver eq 'ODBC' || $driver eq 'ADO') {
0.000000,0,0.000000,# XXX will move these out and make extensible later:
0.000000,0,0.000000,my $_dbtype_name_regexp = 'Oracle'; # eg 'Oracle|Foo|Bar'
0.000000,0,0.000000,my %_dbtype_name_map = (
0.000000,0,0.000000,'Microsoft SQL Server'	=> 'MSSQL',
0.000000,0,0.000000,'SQL Server'		=> 'Sybase',
0.000000,0,0.000000,'Adaptive Server Anywhere'	=> 'ASAny',
0.000000,0,0.000000,'ADABAS D'			=> 'AdabasD',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $name;
0.000000,0,0.000000,$name = $dbh->func(17, 'GetInfo') # SQL_DBMS_NAME
0.000000,0,0.000000,if $driver eq 'ODBC';
0.000000,0,0.000000,$name = $dbh->{ado_conn}->Properties->Item('DBMS Name')->Value
0.000000,0,0.000000,if $driver eq 'ADO';
0.000000,0,0.000000,die "Can't determine driver name! ($DBI::errstr)\n"
0.000000,0,0.000000,unless $name;
0.000000,0,0.000000,
0.000000,0,0.000000,my $dbtype;
0.000000,0,0.000000,if ($_dbtype_name_map{$name}) {
0.000000,0,0.000000,$dbtype = $_dbtype_name_map{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,if ($name =~ /($_dbtype_name_regexp)/) {
0.000000,0,0.000000,$dbtype = lc($1);
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # generic mangling for other names:
0.000000,0,0.000000,$dbtype = lc($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,$dbtype =~ s/\b(\w)/\U$1/g;
0.000000,0,0.000000,$dbtype =~ s/\W+/_/g;
0.000000,0,0.000000,}
0.000000,0,0.000000,# add ODBC 'behind' ADO
0.000000,0,0.000000,push    @dbtypes, 'ODBC' if $driver eq 'ADO';
0.000000,0,0.000000,# add discovered dbtype in front of ADO/ODBC
0.000000,0,0.000000,unshift @dbtypes, $dbtype;
0.000000,0,0.000000,}
0.000000,0,0.000000,@dbtypes = &$DbTypeSubclass($dbh, \@dbtypes)
0.000000,0,0.000000,if (ref $DbTypeSubclass eq 'CODE');
0.000000,0,0.000000,$dbh->trace_msg("    DbTypeSubclass($DbTypeSubclass)=@dbtypes\n");
0.000000,0,0.000000,return @dbtypes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _load_class {
0.000000,0,0.000000,my ($load_class, $missing_ok) = @_;
0.000000,0,0.000000,DBI->trace_msg("    _load_class($load_class, $missing_ok)\n", 2);
0.000490,2,0.000245,no strict 'refs';
0.000000,0,0.000000,return 1 if @{"$load_class\::ISA"};	# already loaded/exists
0.000000,0,0.000000,(my $module = $load_class) =~ s!::!/!g;
0.000000,0,0.000000,DBI->trace_msg("    _load_class require $module\n", 2);
0.000000,0,0.000000,eval { require "$module.pm"; };
0.000000,0,0.000000,return 1 unless $@;
0.000000,0,0.000000,return 0 if $missing_ok && $@ =~ /^Can't locate \Q$module.pm\E/;
0.000000,0,0.000000,die $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub init_rootclass {	# deprecated
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000002,1,0.000002,*internal = \&DBD::Switch::dr::driver;
0.000000,0,0.000000,
0.000000,0,0.000000,sub driver_prefix {
0.000000,0,0.000000,my ($class, $driver) = @_;
0.000000,0,0.000000,return $dbd_class_registry{$driver}->{prefix} if exists $dbd_class_registry{$driver};
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub available_drivers {
0.000000,0,0.000000,my($quiet) = @_;
0.000000,0,0.000000,my(@drivers, $d, $f);
0.000000,0,0.000000,local(*DBI::DIR, $@);
0.000000,0,0.000000,my(%seen_dir, %seen_dbd);
0.000000,0,0.000000,my $haveFileSpec = eval { require File::Spec };
0.000000,0,0.000000,foreach $d (@INC){
0.000000,0,0.000000,chomp($d); # Perl 5 beta 3 bug in #!./perl -Ilib from Test::Harness
0.000000,0,0.000000,my $dbd_dir =
0.000000,0,0.000000,($haveFileSpec ? File::Spec->catdir($d, 'DBD') : "$d/DBD");
0.000000,0,0.000000,next unless -d $dbd_dir;
0.000000,0,0.000000,next if $seen_dir{$d};
0.000000,0,0.000000,$seen_dir{$d} = 1;
0.000000,0,0.000000,# XXX we have a problem here with case insensitive file systems
0.000000,0,0.000000,# XXX since we can't tell what case must be used when loading.
0.000000,0,0.000000,opendir(DBI::DIR, $dbd_dir) || Carp::carp "opendir $dbd_dir: $!\n";
0.000000,0,0.000000,foreach $f (readdir(DBI::DIR)){
0.000000,0,0.000000,next unless $f =~ s/\.pm$//;
0.000000,0,0.000000,next if $f eq 'NullP';
0.000000,0,0.000000,if ($seen_dbd{$f}){
0.000000,0,0.000000,Carp::carp "DBD::$f in $d is hidden by DBD::$f in $seen_dbd{$f}\n"
0.000000,0,0.000000,unless $quiet;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,push(@drivers, $f);
0.000000,0,0.000000,}
0.000000,0,0.000000,$seen_dbd{$f} = $d;
0.000000,0,0.000000,}
0.000000,0,0.000000,closedir(DBI::DIR);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# "return sort @drivers" will not DWIM in scalar context.
0.000000,0,0.000000,return wantarray ? sort @drivers : @drivers;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub installed_versions {
0.000000,0,0.000000,my ($class, $quiet) = @_;
0.000000,0,0.000000,my %error;
0.000000,0,0.000000,my %version;
0.000000,0,0.000000,for my $driver ($class->available_drivers($quiet)) {
0.000000,0,0.000000,next if $DBI::PurePerl && grep { -d "$_/auto/DBD/$driver" } @INC;
0.000000,0,0.000000,my $drh = eval {
0.000000,0,0.000000,local $SIG{__WARN__} = sub {};
0.000000,0,0.000000,$class->install_driver($driver);
0.000000,0,0.000000,};
0.000000,0,0.000000,($error{"DBD::$driver"}=$@),next if $@;
0.001968,2,0.000984,no strict 'refs';
0.000000,0,0.000000,my $vers = ${"DBD::$driver" . '::VERSION'};
0.000000,0,0.000000,$version{"DBD::$driver"} = $vers || '?';
0.000000,0,0.000000,}
0.000000,0,0.000000,if (wantarray) {
0.000000,0,0.000000,return map { m/^DBD::(\w+)/ ? ($1) : () } sort keys %version;
0.000000,0,0.000000,}
0.000000,0,0.000000,$version{"DBI"}           = $DBI::VERSION;
0.000000,0,0.000000,$version{"DBI::PurePerl"} = $DBI::PurePerl::VERSION if $DBI::PurePerl;
0.000000,0,0.000000,if (!defined wantarray) {	# void context
0.000000,0,0.000000,require Config;		# add more detail
0.000000,0,0.000000,$version{OS}   = "$^O\t($Config::Config{osvers})";
0.000000,0,0.000000,$version{Perl} = "$]\t($Config::Config{archname})";
0.000000,0,0.000000,$version{$_}   = (($error{$_} =~ s/ \(\@INC.*//s),$error{$_})
0.000000,0,0.000000,for keys %error;
0.000000,0,0.000000,printf "  %-16s: %s\n",$_,$version{$_}
0.000000,0,0.000000,for reverse sort keys %version;
0.000000,0,0.000000,}
0.000000,0,0.000000,return \%version;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub data_sources {
0.000000,0,0.000000,my ($class, $driver, @other) = @_;
0.000000,0,0.000000,my $drh = $class->install_driver($driver);
0.000000,0,0.000000,my @ds = $drh->data_sources(@other);
0.000000,0,0.000000,return @ds;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub neat_list {
0.000000,0,0.000000,my ($listref, $maxlen, $sep) = @_;
0.000000,0,0.000000,$maxlen = 0 unless defined $maxlen;	# 0 == use internal default
0.000000,0,0.000000,$sep = ", " unless defined $sep;
0.000000,0,0.000000,join($sep, map { neat($_,$maxlen) } @$listref);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub dump_results {	# also aliased as a method in DBD::_::st
0.000000,0,0.000000,my ($sth, $maxlen, $lsep, $fsep, $fh) = @_;
0.000000,0,0.000000,return 0 unless $sth;
0.000000,0,0.000000,$maxlen ||= 35;
0.000000,0,0.000000,$lsep   ||= "\n";
0.000000,0,0.000000,$fh ||= \*STDOUT;
0.000000,0,0.000000,my $rows = 0;
0.000000,0,0.000000,my $ref;
0.000000,0,0.000000,while($ref = $sth->fetch) {
0.000000,0,0.000000,print $fh $lsep if $rows++ and $lsep;
0.000000,0,0.000000,my $str = neat_list($ref,$maxlen,$fsep);
0.000000,0,0.000000,print $fh $str;	# done on two lines to avoid 5.003 errors
0.000000,0,0.000000,}
0.000000,0,0.000000,print $fh "\n$rows rows".($DBI::err ? " ($DBI::err: $DBI::errstr)" : "")."\n";
0.000000,0,0.000000,$rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub data_diff {
0.000000,0,0.000000,my ($a, $b, $logical) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $diff   = data_string_diff($a, $b);
0.000000,0,0.000000,return "" if $logical and !$diff;
0.000000,0,0.000000,
0.000000,0,0.000000,my $a_desc = data_string_desc($a);
0.000000,0,0.000000,my $b_desc = data_string_desc($b);
0.000000,0,0.000000,return "" if !$diff and $a_desc eq $b_desc;
0.000000,0,0.000000,
0.000000,0,0.000000,$diff ||= "Strings contain the same sequence of characters"
0.000000,0,0.000000,if length($a);
0.000000,0,0.000000,$diff .= "\n" if $diff;
0.000000,0,0.000000,return "a: $a_desc\nb: $b_desc\n$diff";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub data_string_diff {
0.000000,0,0.000000,# Compares 'logical' characters, not bytes, so a latin1 string and an
0.000000,0,0.000000,# an equivalent Unicode string will compare as equal even though their
0.000000,0,0.000000,# byte encodings are different.
0.000000,0,0.000000,my ($a, $b) = @_;
0.000000,0,0.000000,unless (defined $a and defined $b) {             # one undef
0.000000,0,0.000000,return ""
0.000000,0,0.000000,if !defined $a and !defined $b;
0.000000,0,0.000000,return "String a is undef, string b has ".length($b)." characters"
0.000000,0,0.000000,if !defined $a;
0.000000,0,0.000000,return "String b is undef, string a has ".length($a)." characters"
0.000000,0,0.000000,if !defined $b;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require utf8;
0.000000,0,0.000000,# hack to cater for perl 5.6
0.000000,0,0.000000,*utf8::is_utf8 = sub { (DBI::neat(shift)=~/^"/) } unless defined &utf8::is_utf8;
0.000000,0,0.000000,
0.000000,0,0.000000,my @a_chars = (utf8::is_utf8($a)) ? unpack("U*", $a) : unpack("C*", $a);
0.000000,0,0.000000,my @b_chars = (utf8::is_utf8($b)) ? unpack("U*", $b) : unpack("C*", $b);
0.000000,0,0.000000,my $i = 0;
0.000000,0,0.000000,while (@a_chars && @b_chars) {
0.000000,0,0.000000,++$i, shift(@a_chars), shift(@b_chars), next
0.000000,0,0.000000,if $a_chars[0] == $b_chars[0];# compare ordinal values
0.000000,0,0.000000,my @desc = map {
0.000000,0,0.000000,$_ > 255 ?                    # if wide character...
0.000000,0,0.000000,sprintf("\\x{%04X}", $_) :  # \x{...}
0.000000,0,0.000000,chr($_) =~ /[[:cntrl:]]/ ?  # else if control character ...
0.000000,0,0.000000,sprintf("\\x%02X", $_) :    # \x..
0.000000,0,0.000000,chr($_)                     # else as themselves
0.000000,0,0.000000,} ($a_chars[0], $b_chars[0]);
0.000000,0,0.000000,# highlight probable double-encoding?
0.000000,0,0.000000,foreach my $c ( @desc ) {
0.000000,0,0.000000,next unless $c =~ m/\\x\{08(..)}/;
0.000000,0,0.000000,$c .= "='" .chr(hex($1)) ."'"
0.000000,0,0.000000,}
0.000000,0,0.000000,return sprintf "Strings differ at index $i: a[$i]=$desc[0], b[$i]=$desc[1]";
0.000000,0,0.000000,}
0.000000,0,0.000000,return "String a truncated after $i characters" if @b_chars;
0.000000,0,0.000000,return "String b truncated after $i characters" if @a_chars;
0.000000,0,0.000000,return "";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub data_string_desc {	# describe a data string
0.000000,0,0.000000,my ($a) = @_;
0.000000,0,0.000000,require bytes;
0.000000,0,0.000000,require utf8;
0.000000,0,0.000000,
0.000000,0,0.000000,# hacks to cater for perl 5.6
0.000000,0,0.000000,*utf8::is_utf8 = sub { (DBI::neat(shift)=~/^"/) } unless defined &utf8::is_utf8;
0.000000,0,0.000000,*utf8::valid   = sub {                        1 } unless defined &utf8::valid;
0.000000,0,0.000000,
0.000000,0,0.000000,# Give sufficient info to help diagnose at least these kinds of situations:
0.000000,0,0.000000,# - valid UTF8 byte sequence but UTF8 flag not set
0.000000,0,0.000000,#   (might be ascii so also need to check for hibit to make it worthwhile)
0.000000,0,0.000000,# - UTF8 flag set but invalid UTF8 byte sequence
0.000000,0,0.000000,# could do better here, but this'll do for now
0.000000,0,0.000000,my $utf8 = sprintf "UTF8 %s%s",
0.000000,0,0.000000,utf8::is_utf8($a) ? "on" : "off",
0.000000,0,0.000000,utf8::valid($a||'') ? "" : " but INVALID encoding";
0.000000,0,0.000000,return "$utf8, undef" unless defined $a;
0.000000,0,0.000000,my $is_ascii = $a =~ m/^[\000-\177]*$/;
0.000000,0,0.000000,return sprintf "%s, %s, %d characters %d bytes",
0.000000,0,0.000000,$utf8, $is_ascii ? "ASCII" : "non-ASCII",
0.000000,0,0.000000,length($a), bytes::length($a);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub connect_test_perf {
0.000000,0,0.000000,my($class, $dsn,$dbuser,$dbpass, $attr) = @_;
0.000000,0,0.000000,Carp::croak("connect_test_perf needs hash ref as fourth arg") unless ref $attr;
0.000000,0,0.000000,# these are non standard attributes just for this special method
0.000000,0,0.000000,my $loops ||= $attr->{dbi_loops} || 5;
0.000000,0,0.000000,my $par   ||= $attr->{dbi_par}   || 1;	# parallelism
0.000000,0,0.000000,my $verb  ||= $attr->{dbi_verb}  || 1;
0.000000,0,0.000000,my $meth  ||= $attr->{dbi_meth}  || 'connect';
0.000000,0,0.000000,print "$dsn: testing $loops sets of $par connections:\n";
0.000000,0,0.000000,require "FileHandle.pm";	# don't let toke.c create empty FileHandle package
0.000000,0,0.000000,local $| = 1;
0.000000,0,0.000000,my $drh = $class->install_driver($dsn) or Carp::croak("Can't install $dsn driver\n");
0.000000,0,0.000000,# test the connection and warm up caches etc
0.000000,0,0.000000,$drh->connect($dsn,$dbuser,$dbpass) or Carp::croak("connect failed: $DBI::errstr");
0.000000,0,0.000000,my $t1 = dbi_time();
0.000000,0,0.000000,my $loop;
0.000000,0,0.000000,for $loop (1..$loops) {
0.000000,0,0.000000,my @cons;
0.000000,0,0.000000,print "Connecting... " if $verb;
0.000000,0,0.000000,for (1..$par) {
0.000000,0,0.000000,print "$_ ";
0.000000,0,0.000000,push @cons, ($drh->connect($dsn,$dbuser,$dbpass)
0.000000,0,0.000000,or Carp::croak("connect failed: $DBI::errstr\n"));
0.000000,0,0.000000,}
0.000000,0,0.000000,print "\nDisconnecting...\n" if $verb;
0.000000,0,0.000000,for (@cons) {
0.000000,0,0.000000,$_->disconnect or warn "disconnect failed: $DBI::errstr"
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $t2 = dbi_time();
0.000000,0,0.000000,my $td = $t2 - $t1;
0.000000,0,0.000000,printf "$meth %d and disconnect them, %d times: %.4fs / %d = %.4fs\n",
0.000000,0,0.000000,$par, $loops, $td, $loops*$par, $td/($loops*$par);
0.000000,0,0.000000,return $td;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Help people doing DBI->errstr, might even document it one day
0.000000,0,0.000000,# XXX probably best moved to cheaper XS code if this gets documented
0.000000,0,0.000000,sub err    { $DBI::err    }
0.000000,0,0.000000,sub errstr { $DBI::errstr }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# --- Private Internal Function for Creating New DBI Handles
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX move to PurePerl?
0.000002,1,0.000002,*DBI::dr::TIEHASH = \&DBI::st::TIEHASH;
0.000002,1,0.000002,*DBI::db::TIEHASH = \&DBI::st::TIEHASH;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# These three special constructors are called by the drivers
0.000000,0,0.000000,# The way they are called is likely to change.
0.000000,0,0.000000,
0.000001,1,0.000001,our $shared_profile;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new_drh {	# called by DBD::<drivername>::driver()
0.000002,1,0.000002,my ($class, $initial_attr, $imp_data) = @_;
0.000000,0,0.000000,# Provide default storage for State,Err and Errstr.
0.000000,0,0.000000,# Note that these are shared by all child handles by default! XXX
0.000000,0,0.000000,# State must be undef to get automatic faking in DBI::var::FETCH
0.000002,1,0.000002,my ($h_state_store, $h_err_store, $h_errstr_store) = (undef, 0, '');
0.000008,1,0.000008,my $attr = {
0.000000,0,0.000000,# these attributes get copied down to child handles by default
0.000000,0,0.000000,'State'		=> \$h_state_store,  # Holder for DBI::state
0.000000,0,0.000000,'Err'		=> \$h_err_store,    # Holder for DBI::err
0.000000,0,0.000000,'Errstr'	=> \$h_errstr_store, # Holder for DBI::errstr
0.000000,0,0.000000,'TraceLevel' 	=> 0,
0.000000,0,0.000000,FetchHashKeyName=> 'NAME',
0.000000,0,0.000000,%$initial_attr,
0.000000,0,0.000000,};
0.000046,1,0.000046,my ($h, $i) = _new_handle('DBI::dr', '', $attr, $imp_data, $class);
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX DBI_PROFILE unless DBI::PurePerl because for some reason
0.000000,0,0.000000,# it kills the t/zz_*_pp.t tests (they silently exit early)
0.000002,1,0.000002,if (($ENV{DBI_PROFILE} && !$DBI::PurePerl) || $shared_profile) {
0.000000,0,0.000000,# The profile object created here when the first driver is loaded
0.000000,0,0.000000,# is shared by all drivers so we end up with just one set of profile
0.000000,0,0.000000,# data and thus the 'total time in DBI' is really the true total.
0.000000,0,0.000000,if (!$shared_profile) {	# first time
0.000000,0,0.000000,$h->{Profile} = $ENV{DBI_PROFILE}; # write string
0.000000,0,0.000000,$shared_profile = $h->{Profile};   # read and record object
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$h->{Profile} = $shared_profile;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000008,1,0.000008,return $h unless wantarray;
0.000000,0,0.000000,($h, $i);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new_dbh {	# called by DBD::<drivername>::dr::connect()
0.000002,1,0.000002,my ($drh, $attr, $imp_data) = @_;
0.000003,1,0.000003,my $imp_class = $drh->{ImplementorClass}
0.000000,0,0.000000,or Carp::croak("DBI _new_dbh: $drh has no ImplementorClass");
0.000003,1,0.000003,substr($imp_class,-4,4) = '::db';
0.000002,1,0.000002,my $app_class = ref $drh;
0.000003,1,0.000003,substr($app_class,-4,4) = '::db';
0.000002,1,0.000002,$attr->{Err}    ||= \my $err;
0.000003,1,0.000003,$attr->{Errstr} ||= \my $errstr;
0.000002,1,0.000002,$attr->{State}  ||= \my $state;
0.000036,1,0.000036,_new_handle($app_class, $drh, $attr, $imp_data, $imp_class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new_sth {	# called by DBD::<drivername>::db::prepare)
0.000021,13,0.000002,my ($dbh, $attr, $imp_data) = @_;
0.000026,13,0.000002,my $imp_class = $dbh->{ImplementorClass}
0.000000,0,0.000000,or Carp::croak("DBI _new_sth: $dbh has no ImplementorClass");
0.000023,13,0.000002,substr($imp_class,-4,4) = '::st';
0.000022,13,0.000002,my $app_class = ref $dbh;
0.000028,13,0.000002,substr($app_class,-4,4) = '::st';
0.000277,13,0.000021,_new_handle($app_class, $dbh, $attr, $imp_data, $imp_class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# end of DBI package
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# --------------------------------------------------------------------
0.000000,0,0.000000,# === The internal DBI Switch pseudo 'driver' class ===
0.000000,0,0.000000,
0.000003,1,0.000003,{   package	# hide from PAUSE
0.000000,0,0.000000,DBD::Switch::dr;
0.000006,1,0.000006,DBI->setup_driver('DBD::Switch');	# sets up @ISA
0.000000,0,0.000000,
0.000002,1,0.000002,$DBD::Switch::dr::imp_data_size = 0;
0.000001,1,0.000001,$DBD::Switch::dr::imp_data_size = 0;	# avoid typo warning
0.000002,1,0.000002,my $drh;
0.000000,0,0.000000,
0.000000,0,0.000000,sub driver {
0.000000,0,0.000000,return $drh if $drh;	# a package global
0.000000,0,0.000000,
0.000000,0,0.000000,my $inner;
0.000000,0,0.000000,($drh, $inner) = DBI::_new_drh('DBD::Switch::dr', {
0.000000,0,0.000000,'Name'    => 'Switch',
0.000000,0,0.000000,'Version' => $DBI::VERSION,
0.000000,0,0.000000,'Attribution' => "DBI $DBI::VERSION by Tim Bunce",
0.000000,0,0.000000,});
0.000000,0,0.000000,Carp::croak("DBD::Switch init failed!") unless ($drh && $inner);
0.000000,0,0.000000,return $drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,undef $drh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub FETCH {
0.000000,0,0.000000,my($drh, $key) = @_;
0.000000,0,0.000000,return DBI->trace if $key eq 'DebugDispatch';
0.000000,0,0.000000,return undef if $key eq 'DebugLog';	# not worth fetching, sorry
0.000000,0,0.000000,return $drh->DBD::_::dr::FETCH($key);
0.000000,0,0.000000,undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,sub STORE {
0.000000,0,0.000000,my($drh, $key, $value) = @_;
0.000000,0,0.000000,if ($key eq 'DebugDispatch') {
0.000000,0,0.000000,DBI->trace($value);
0.000000,0,0.000000,} elsif ($key eq 'DebugLog') {
0.000000,0,0.000000,DBI->trace(-1, $value);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$drh->DBD::_::dr::STORE($key, $value);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# --------------------------------------------------------------------
0.000000,0,0.000000,# === OPTIONAL MINIMAL BASE CLASSES FOR DBI SUBCLASSES ===
0.000000,0,0.000000,
0.000000,0,0.000000,# We only define default methods for harmless functions.
0.000000,0,0.000000,# We don't, for example, define a DBD::_::st::prepare()
0.000000,0,0.000000,
0.000003,1,0.000003,{   package		# hide from PAUSE
0.000000,0,0.000000,DBD::_::common; # ====== Common base class methods ======
0.000679,2,0.000339,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,# methods common to all handle types:
0.000000,0,0.000000,
0.000000,0,0.000000,# generic TIEHASH default methods:
0.000007,1,0.000007,sub FIRSTKEY { }
0.000000,0,0.000000,sub NEXTKEY  { }
0.000000,0,0.000000,sub EXISTS   { defined($_[0]->FETCH($_[1])) } # XXX undef?
0.000000,0,0.000000,sub CLEAR    { Carp::carp "Can't CLEAR $_[0] (DBI)" }
0.000000,0,0.000000,
0.000000,0,0.000000,sub FETCH_many {    # XXX should move to C one day
0.000000,0,0.000000,my $h = shift;
0.000000,0,0.000000,# scalar is needed to workaround drivers that return an empty list
0.000000,0,0.000000,# for some attributes
0.000000,0,0.000000,return map { scalar $h->FETCH($_) } @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,*dump_handle = \&DBI::dump_handle;
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_method {
0.000000,0,0.000000,# special class method called directly by apps and/or drivers
0.000000,0,0.000000,# to install new methods into the DBI dispatcher
0.000000,0,0.000000,# DBD::Foo::db->install_method("foo_mumble", { usage => [...], options => '...' });
0.000040,22,0.000002,my ($class, $method, $attr) = @_;
0.000175,22,0.000008,Carp::croak("Class '$class' must begin with DBD:: and end with ::db or ::st")
0.000000,0,0.000000,unless $class =~ /^DBD::(\w+)::(dr|db|st)$/;
0.000053,22,0.000002,my ($driver, $subtype) = ($1, $2);
0.000156,22,0.000007,Carp::croak("invalid method name '$method'")
0.000000,0,0.000000,unless $method =~ m/^([a-z]+_)\w+$/;
0.000041,22,0.000002,my $prefix = $1;
0.000040,22,0.000002,my $reg_info = $dbd_prefix_registry->{$prefix};
0.000031,22,0.000001,Carp::carp("method name prefix '$prefix' is not associated with a registered driver") unless $reg_info;
0.000000,0,0.000000,
0.000042,22,0.000002,my $full_method = "DBI::${subtype}::$method";
0.000059,22,0.000003,$DBI::installed_methods{$full_method} = $attr;
0.000000,0,0.000000,
0.000058,22,0.000003,my (undef, $filename, $line) = caller;
0.000000,0,0.000000,# XXX reformat $attr as needed for _install_method
0.000057,22,0.000003,my %attr = %{$attr||{}}; # copy so we can edit
0.000427,22,0.000019,DBI->_install_method("DBI::${subtype}::$method", "$filename at line $line", \%attr);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_trace_flags {
0.000000,0,0.000000,my ($h, $spec) = @_;
0.000000,0,0.000000,my $level = 0;
0.000000,0,0.000000,my $flags = 0;
0.000000,0,0.000000,my @unknown;
0.000000,0,0.000000,for my $word (split /\s*[|&,]\s*/, $spec) {
0.000000,0,0.000000,if (DBI::looks_like_number($word) && $word <= 0xF && $word >= 0) {
0.000000,0,0.000000,$level = $word;
0.000000,0,0.000000,} elsif ($word eq 'ALL') {
0.000000,0,0.000000,$flags = 0x7FFFFFFF; # XXX last bit causes negative headaches
0.000000,0,0.000000,last;
0.000000,0,0.000000,} elsif (my $flag = $h->parse_trace_flag($word)) {
0.000000,0,0.000000,$flags |= $flag;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @unknown, $word;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if (@unknown && (ref $h ? $h->FETCH('Warn') : 1)) {
0.000000,0,0.000000,Carp::carp("$h->parse_trace_flags($spec) ignored unknown trace flags: ".
0.000000,0,0.000000,join(" ", map { DBI::neat($_) } @unknown));
0.000000,0,0.000000,}
0.000000,0,0.000000,$flags |= $level;
0.000000,0,0.000000,return $flags;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_trace_flag {
0.000000,0,0.000000,my ($h, $name) = @_;
0.000000,0,0.000000,#      0xddDDDDrL (driver, DBI, reserved, Level)
0.000000,0,0.000000,return 0x00000100 if $name eq 'SQL';
0.000000,0,0.000000,return 0x00000200 if $name eq 'CON';
0.000000,0,0.000000,return 0x00000400 if $name eq 'ENC';
0.000000,0,0.000000,return 0x00000800 if $name eq 'DBD';
0.000000,0,0.000000,return 0x00001000 if $name eq 'TXN';
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub private_attribute_info {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub visit_child_handles {
0.000000,0,0.000000,my ($h, $code, $info) = @_;
0.000000,0,0.000000,$info = {} if not defined $info;
0.000000,0,0.000000,for my $ch (@{ $h->{ChildHandles} || []}) {
0.000000,0,0.000000,next unless $ch;
0.000000,0,0.000000,my $child_info = $code->($ch, $info)
0.000000,0,0.000000,or next;
0.000000,0,0.000000,$ch->visit_child_handles($code, $child_info);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $info;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000004,1,0.000004,{   package		# hide from PAUSE
0.000000,0,0.000000,DBD::_::dr;	# ====== DRIVER ======
0.000010,1,0.000010,@DBD::_::dr::ISA = qw(DBD::_::common);
0.000478,2,0.000239,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_user {
0.000000,0,0.000000,my ($drh, $user, $pass, $attr) = @_;
0.000000,0,0.000000,$user = $ENV{DBI_USER} unless defined $user;
0.000000,0,0.000000,$pass = $ENV{DBI_PASS} unless defined $pass;
0.000000,0,0.000000,return ($user, $pass);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub connect { # normally overridden, but a handy default
0.000000,0,0.000000,my ($drh, $dsn, $user, $auth) = @_;
0.000000,0,0.000000,my ($this) = DBI::_new_dbh($drh, {
0.000000,0,0.000000,'Name' => $dsn,
0.000000,0,0.000000,});
0.000000,0,0.000000,# XXX debatable as there's no "server side" here
0.000000,0,0.000000,# (and now many uses would trigger warnings on DESTROY)
0.000000,0,0.000000,# $this->STORE(Active => 1);
0.000000,0,0.000000,# so drivers should set it in their own connect
0.000000,0,0.000000,$this;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub connect_cached {
0.000000,0,0.000000,my $drh = shift;
0.000000,0,0.000000,my ($dsn, $user, $auth, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $cache = $drh->{CachedKids} ||= {};
0.000000,0,0.000000,my $key = do { local $^W;
0.000000,0,0.000000,join "!\001", $dsn, $user, $auth, DBI::_concat_hash_sorted($attr, "=\001", ",\001", 0, 0)
0.000000,0,0.000000,};
0.000000,0,0.000000,my $dbh = $cache->{$key};
0.000000,0,0.000000,$drh->trace_msg(sprintf("    connect_cached: key '$key', cached dbh $dbh\n", DBI::neat($key), DBI::neat($dbh)))
0.000000,0,0.000000,if (($DBI::dbi_debug & 0xF) >= 4);
0.000000,0,0.000000,
0.000000,0,0.000000,my $cb = $attr->{Callbacks}; # take care not to autovivify
0.000000,0,0.000000,if ($dbh && $dbh->FETCH('Active') && eval { $dbh->ping }) {
0.000000,0,0.000000,# If the caller has provided a callback then call it
0.000000,0,0.000000,if ($cb and $cb = $cb->{"connect_cached.reused"}) {
0.000000,0,0.000000,local $_ = "connect_cached.reused";
0.000000,0,0.000000,$cb->($dbh, $dsn, $user, $auth, $attr);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $dbh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If the caller has provided a callback then call it
0.000000,0,0.000000,if ($cb and $cb = $cb->{"connect_cached.new"}) {
0.000000,0,0.000000,local $_ = "connect_cached.new";
0.000000,0,0.000000,$cb->($dbh, $dsn, $user, $auth, $attr);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$dbh = $drh->connect(@_);
0.000000,0,0.000000,$cache->{$key} = $dbh;	# replace prev entry, even if connect failed
0.000000,0,0.000000,return $dbh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000004,1,0.000004,{   package		# hide from PAUSE
0.000000,0,0.000000,DBD::_::db;	# ====== DATABASE ======
0.000008,1,0.000008,@DBD::_::db::ISA = qw(DBD::_::common);
0.001829,2,0.000915,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my ($old_dbh, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $closure = $old_dbh->{dbi_connect_closure}
0.000000,0,0.000000,or return $old_dbh->set_err($DBI::stderr, "Can't clone handle");
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($attr) { # XXX deprecated, caller should always pass a hash ref
0.000000,0,0.000000,# copy attributes visible in the attribute cache
0.000000,0,0.000000,keys %$old_dbh;	# reset iterator
0.000000,0,0.000000,while ( my ($k, $v) = each %$old_dbh ) {
0.000000,0,0.000000,# ignore non-code refs, i.e., caches, handles, Err etc
0.000000,0,0.000000,next if ref $v && ref $v ne 'CODE'; # HandleError etc
0.000000,0,0.000000,$attr->{$k} = $v;
0.000000,0,0.000000,}
0.000000,0,0.000000,# explicitly set attributes which are unlikely to be in the
0.000000,0,0.000000,# attribute cache, i.e., boolean's and some others
0.000000,0,0.000000,$attr->{$_} = $old_dbh->FETCH($_) for (qw(
0.000000,0,0.000000,AutoCommit ChopBlanks InactiveDestroy AutoInactiveDestroy
0.000000,0,0.000000,LongTruncOk PrintError PrintWarn Profile RaiseError
0.000000,0,0.000000,ShowErrorStatement TaintIn TaintOut
0.000000,0,0.000000,));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# use Data::Dumper; warn Dumper([$old_dbh, $attr]);
0.000000,0,0.000000,my $new_dbh = &$closure($old_dbh, $attr);
0.000000,0,0.000000,unless ($new_dbh) {
0.000000,0,0.000000,# need to copy err/errstr from driver back into $old_dbh
0.000000,0,0.000000,my $drh = $old_dbh->{Driver};
0.000000,0,0.000000,return $old_dbh->set_err($drh->err, $drh->errstr, $drh->state);
0.000000,0,0.000000,}
0.000000,0,0.000000,$new_dbh->{dbi_connect_closure} = $closure;
0.000000,0,0.000000,return $new_dbh;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quote_identifier {
0.000000,0,0.000000,my ($dbh, @id) = @_;
0.000000,0,0.000000,my $attr = (@id > 3 && ref($id[-1])) ? pop @id : undef;
0.000000,0,0.000000,
0.000000,0,0.000000,my $info = $dbh->{dbi_quote_identifier_cache} ||= [
0.000000,0,0.000000,$dbh->get_info(29)  || '"',	# SQL_IDENTIFIER_QUOTE_CHAR
0.000000,0,0.000000,$dbh->get_info(41)  || '.',	# SQL_CATALOG_NAME_SEPARATOR
0.000000,0,0.000000,$dbh->get_info(114) ||   1,	# SQL_CATALOG_LOCATION
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000000,0,0.000000,my $quote = $info->[0];
0.000000,0,0.000000,foreach (@id) {			# quote the elements
0.000000,0,0.000000,next unless defined;
0.000000,0,0.000000,s/$quote/$quote$quote/g;	# escape embedded quotes
0.000000,0,0.000000,$_ = qq{$quote$_$quote};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# strip out catalog if present for special handling
0.000000,0,0.000000,my $catalog = (@id >= 3) ? shift @id : undef;
0.000000,0,0.000000,
0.000000,0,0.000000,# join the dots, ignoring any null/undef elements (ie schema)
0.000000,0,0.000000,my $quoted_id = join '.', grep { defined } @id;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($catalog) {			# add catalog correctly
0.000000,0,0.000000,$quoted_id = ($info->[2] == 2)	# SQL_CL_END
0.000000,0,0.000000,? $quoted_id . $info->[1] . $catalog
0.000000,0,0.000000,: $catalog   . $info->[1] . $quoted_id;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $quoted_id;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub quote {
0.000000,0,0.000000,my ($dbh, $str, $data_type) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return "NULL" unless defined $str;
0.000000,0,0.000000,unless ($data_type) {
0.000000,0,0.000000,$str =~ s/'/''/g;		# ISO SQL2
0.000000,0,0.000000,return "'$str'";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $dbi_literal_quote_cache = $dbh->{'dbi_literal_quote_cache'} ||= [ {} , {} ];
0.000000,0,0.000000,my ($prefixes, $suffixes) = @$dbi_literal_quote_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,my $lp = $prefixes->{$data_type};
0.000000,0,0.000000,my $ls = $suffixes->{$data_type};
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ! defined $lp || ! defined $ls ) {
0.000000,0,0.000000,my $ti = $dbh->type_info($data_type);
0.000000,0,0.000000,$lp = $prefixes->{$data_type} = $ti ? $ti->{LITERAL_PREFIX} || "" : "'";
0.000000,0,0.000000,$ls = $suffixes->{$data_type} = $ti ? $ti->{LITERAL_SUFFIX} || "" : "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $str unless $lp || $ls; # no quoting required
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX don't know what the standard says about escaping
0.000000,0,0.000000,# in the 'general case' (where $lp != "'").
0.000000,0,0.000000,# So we just do this and hope:
0.000000,0,0.000000,$str =~ s/$lp/$lp$lp/g
0.000000,0,0.000000,if $lp && $lp eq $ls && ($lp eq "'" || $lp eq '"');
0.000000,0,0.000000,return "$lp$str$ls";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub rows { -1 }	# here so $DBI::rows 'works' after using $dbh
0.000000,0,0.000000,
0.000000,0,0.000000,sub do {
0.000000,0,0.000000,my($dbh, $statement, $attr, @params) = @_;
0.000000,0,0.000000,my $sth = $dbh->prepare($statement, $attr) or return undef;
0.000000,0,0.000000,$sth->execute(@params) or return undef;
0.000000,0,0.000000,my $rows = $sth->rows;
0.000000,0,0.000000,($rows == 0) ? "0E0" : $rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _do_selectrow {
0.000000,0,0.000000,my ($method, $dbh, $stmt, $attr, @bind) = @_;
0.000000,0,0.000000,my $sth = ((ref $stmt) ? $stmt : $dbh->prepare($stmt, $attr))
0.000000,0,0.000000,or return;
0.000000,0,0.000000,$sth->execute(@bind)
0.000000,0,0.000000,or return;
0.000000,0,0.000000,my $row = $sth->$method()
0.000000,0,0.000000,and $sth->finish;
0.000000,0,0.000000,return $row;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub selectrow_hashref {  return _do_selectrow('fetchrow_hashref',  @_); }
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX selectrow_array/ref also have C implementations in Driver.xst
0.000000,0,0.000000,sub selectrow_arrayref { return _do_selectrow('fetchrow_arrayref', @_); }
0.000000,0,0.000000,sub selectrow_array {
0.000000,0,0.000000,my $row = _do_selectrow('fetchrow_arrayref', @_) or return;
0.000000,0,0.000000,return $row->[0] unless wantarray;
0.000000,0,0.000000,return @$row;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX selectall_arrayref also has C implementation in Driver.xst
0.000000,0,0.000000,# which fallsback to this if a slice is given
0.000000,0,0.000000,sub selectall_arrayref {
0.000000,0,0.000000,my ($dbh, $stmt, $attr, @bind) = @_;
0.000000,0,0.000000,my $sth = (ref $stmt) ? $stmt : $dbh->prepare($stmt, $attr)
0.000000,0,0.000000,or return;
0.000000,0,0.000000,$sth->execute(@bind) || return;
0.000000,0,0.000000,my $slice = $attr->{Slice}; # typically undef, else hash or array ref
0.000000,0,0.000000,if (!$slice and $slice=$attr->{Columns}) {
0.000000,0,0.000000,if (ref $slice eq 'ARRAY') { # map col idx to perl array idx
0.000000,0,0.000000,$slice = [ @{$attr->{Columns}} ];	# take a copy
0.000000,0,0.000000,for (@$slice) { $_-- }
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $rows = $sth->fetchall_arrayref($slice, my $MaxRows = $attr->{MaxRows});
0.000000,0,0.000000,$sth->finish if defined $MaxRows;
0.000000,0,0.000000,return $rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub selectall_hashref {
0.000000,0,0.000000,my ($dbh, $stmt, $key_field, $attr, @bind) = @_;
0.000000,0,0.000000,my $sth = (ref $stmt) ? $stmt : $dbh->prepare($stmt, $attr);
0.000000,0,0.000000,return unless $sth;
0.000000,0,0.000000,$sth->execute(@bind) || return;
0.000000,0,0.000000,return $sth->fetchall_hashref($key_field);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub selectcol_arrayref {
0.000000,0,0.000000,my ($dbh, $stmt, $attr, @bind) = @_;
0.000000,0,0.000000,my $sth = (ref $stmt) ? $stmt : $dbh->prepare($stmt, $attr);
0.000000,0,0.000000,return unless $sth;
0.000000,0,0.000000,$sth->execute(@bind) || return;
0.000000,0,0.000000,my @columns = ($attr->{Columns}) ? @{$attr->{Columns}} : (1);
0.000000,0,0.000000,my @values  = (undef) x @columns;
0.000000,0,0.000000,my $idx = 0;
0.000000,0,0.000000,for (@columns) {
0.000000,0,0.000000,$sth->bind_col($_, \$values[$idx++]) || return;
0.000000,0,0.000000,}
0.000000,0,0.000000,my @col;
0.000000,0,0.000000,if (my $max = $attr->{MaxRows}) {
0.000000,0,0.000000,push @col, @values while 0 < $max-- && $sth->fetch;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @col, @values while $sth->fetch;
0.000000,0,0.000000,}
0.000000,0,0.000000,return \@col;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub prepare_cached {
0.000000,0,0.000000,my ($dbh, $statement, $attr, $if_active) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Needs support at dbh level to clear cache before complaining about
0.000000,0,0.000000,# active children. The XS template code does this. Drivers not using
0.000000,0,0.000000,# the template must handle clearing the cache themselves.
0.000000,0,0.000000,my $cache = $dbh->{CachedKids} ||= {};
0.000000,0,0.000000,my $key = do { local $^W;
0.000000,0,0.000000,join "!\001", $statement, DBI::_concat_hash_sorted($attr, "=\001", ",\001", 0, 0)
0.000000,0,0.000000,};
0.000000,0,0.000000,my $sth = $cache->{$key};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($sth) {
0.000000,0,0.000000,return $sth unless $sth->FETCH('Active');
0.000000,0,0.000000,Carp::carp("prepare_cached($statement) statement handle $sth still Active")
0.000000,0,0.000000,unless ($if_active ||= 0);
0.000000,0,0.000000,$sth->finish if $if_active <= 1;
0.000000,0,0.000000,return $sth  if $if_active <= 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$sth = $dbh->prepare($statement, $attr);
0.000000,0,0.000000,$cache->{$key} = $sth if $sth;
0.000000,0,0.000000,
0.000000,0,0.000000,return $sth;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ping {
0.000000,0,0.000000,my $dbh = shift;
0.000000,0,0.000000,# "0 but true" is a special kind of true 0 that is used here so
0.000000,0,0.000000,# applications can check if the ping was a real ping or not
0.000000,0,0.000000,($dbh->FETCH('Active')) ?  "0 but true" : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub begin_work {
0.000000,0,0.000000,my $dbh = shift;
0.000000,0,0.000000,return $dbh->set_err($DBI::stderr, "Already in a transaction")
0.000000,0,0.000000,unless $dbh->FETCH('AutoCommit');
0.000000,0,0.000000,$dbh->STORE('AutoCommit', 0); # will croak if driver doesn't support it
0.000000,0,0.000000,$dbh->STORE('BegunWork',  1); # trigger post commit/rollback action
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub primary_key {
0.000000,0,0.000000,my ($dbh, @args) = @_;
0.000000,0,0.000000,my $sth = $dbh->primary_key_info(@args) or return;
0.000000,0,0.000000,my ($row, @col);
0.000000,0,0.000000,push @col, $row->[3] while ($row = $sth->fetch);
0.000000,0,0.000000,Carp::croak("primary_key method not called in list context")
0.000000,0,0.000000,unless wantarray; # leave us some elbow room
0.000000,0,0.000000,return @col;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub tables {
0.000000,0,0.000000,my ($dbh, @args) = @_;
0.000000,0,0.000000,my $sth    = $dbh->table_info(@args[0,1,2,3,4]) or return;
0.000000,0,0.000000,my $tables = $sth->fetchall_arrayref or return;
0.000000,0,0.000000,my @tables;
0.000000,0,0.000000,if ($dbh->get_info(29)) { # SQL_IDENTIFIER_QUOTE_CHAR
0.000000,0,0.000000,@tables = map { $dbh->quote_identifier( @{$_}[0,1,2] ) } @$tables;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {		# temporary old style hack (yeach)
0.000000,0,0.000000,@tables = map {
0.000000,0,0.000000,my $name = $_->[2];
0.000000,0,0.000000,if ($_->[1]) {
0.000000,0,0.000000,my $schema = $_->[1];
0.000000,0,0.000000,# a sad hack (mostly for Informix I recall)
0.000000,0,0.000000,my $quote = ($schema eq uc($schema)) ? '' : '"';
0.000000,0,0.000000,$name = "$quote$schema$quote.$name"
0.000000,0,0.000000,}
0.000000,0,0.000000,$name;
0.000000,0,0.000000,} @$tables;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @tables;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub type_info {	# this should be sufficient for all drivers
0.000000,0,0.000000,my ($dbh, $data_type) = @_;
0.000000,0,0.000000,my $idx_hash;
0.000000,0,0.000000,my $tia = $dbh->{dbi_type_info_row_cache};
0.000000,0,0.000000,if ($tia) {
0.000000,0,0.000000,$idx_hash = $dbh->{dbi_type_info_idx_cache};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $temp = $dbh->type_info_all;
0.000000,0,0.000000,return unless $temp && @$temp;
0.000000,0,0.000000,# we cache here because type_info_all may be expensive to call
0.000000,0,0.000000,# (and we take a copy so the following shift can't corrupt
0.000000,0,0.000000,# the data that may be returned by future calls to type_info_all)
0.000000,0,0.000000,$tia      = $dbh->{dbi_type_info_row_cache} = [ @$temp ];
0.000000,0,0.000000,$idx_hash = $dbh->{dbi_type_info_idx_cache} = shift @$tia;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $dt_idx   = $idx_hash->{DATA_TYPE} || $idx_hash->{data_type};
0.000000,0,0.000000,Carp::croak("type_info_all returned non-standard DATA_TYPE index value ($dt_idx != 1)")
0.000000,0,0.000000,if $dt_idx && $dt_idx != 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# --- simple DATA_TYPE match filter
0.000000,0,0.000000,my @ti;
0.000000,0,0.000000,my @data_type_list = (ref $data_type) ? @$data_type : ($data_type);
0.000000,0,0.000000,foreach $data_type (@data_type_list) {
0.000000,0,0.000000,if (defined($data_type) && $data_type != DBI::SQL_ALL_TYPES()) {
0.000000,0,0.000000,push @ti, grep { $_->[$dt_idx] == $data_type } @$tia;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {	# SQL_ALL_TYPES
0.000000,0,0.000000,push @ti, @$tia;
0.000000,0,0.000000,}
0.000000,0,0.000000,last if @ti;	# found at least one match
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# --- format results into list of hash refs
0.000000,0,0.000000,my $idx_fields = keys %$idx_hash;
0.000000,0,0.000000,my @idx_names  = map { uc($_) } keys %$idx_hash;
0.000000,0,0.000000,my @idx_values = values %$idx_hash;
0.000000,0,0.000000,Carp::croak "type_info_all result has $idx_fields keys but ".(@{$ti[0]})." fields"
0.000000,0,0.000000,if @ti && @{$ti[0]} != $idx_fields;
0.000000,0,0.000000,my @out = map {
0.000000,0,0.000000,my %h; @h{@idx_names} = @{$_}[ @idx_values ]; \%h;
0.000000,0,0.000000,} @ti;
0.000000,0,0.000000,return $out[0] unless wantarray;
0.000000,0,0.000000,return @out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub data_sources {
0.000000,0,0.000000,my ($dbh, @other) = @_;
0.000000,0,0.000000,my $drh = $dbh->{Driver}; # XXX proxy issues?
0.000000,0,0.000000,return $drh->data_sources(@other);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000003,1,0.000003,{   package		# hide from PAUSE
0.000000,0,0.000000,DBD::_::st;	# ====== STATEMENT ======
0.000013,1,0.000013,@DBD::_::st::ISA = qw(DBD::_::common);
0.001690,2,0.000845,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,sub bind_param { Carp::croak("Can't bind_param, not implement by driver") }
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# ********************************************************
0.000000,0,0.000000,#
0.000000,0,0.000000,#	BEGIN ARRAY BINDING
0.000000,0,0.000000,#
0.000000,0,0.000000,#	Array binding support for drivers which don't support
0.000000,0,0.000000,#	array binding, but have sufficient interfaces to fake it.
0.000000,0,0.000000,#	NOTE: mixing scalars and arrayrefs requires using bind_param_array
0.000000,0,0.000000,#	for *all* params...unless we modify bind_param for the default
0.000000,0,0.000000,#	case...
0.000000,0,0.000000,#
0.000000,0,0.000000,#	2002-Apr-10	D. Arnold
0.000000,0,0.000000,
0.000000,0,0.000000,sub bind_param_array {
0.000000,0,0.000000,my $sth = shift;
0.000000,0,0.000000,my ($p_id, $value_array, $attr) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "Value for parameter $p_id must be a scalar or an arrayref, not a ".ref($value_array))
0.000000,0,0.000000,if defined $value_array and ref $value_array and ref $value_array ne 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "Can't use named placeholder '$p_id' for non-driver supported bind_param_array")
0.000000,0,0.000000,unless DBI::looks_like_number($p_id); # because we rely on execute(@ary) here
0.000000,0,0.000000,
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "Placeholder '$p_id' is out of range")
0.000000,0,0.000000,if $p_id <= 0; # can't easily/reliably test for too big
0.000000,0,0.000000,
0.000000,0,0.000000,# get/create arrayref to hold params
0.000000,0,0.000000,my $hash_of_arrays = $sth->{ParamArrays} ||= { };
0.000000,0,0.000000,
0.000000,0,0.000000,# If the bind has attribs then we rely on the driver conforming to
0.000000,0,0.000000,# the DBI spec in that a single bind_param() call with those attribs
0.000000,0,0.000000,# makes them 'sticky' and apply to all later execute(@values) calls.
0.000000,0,0.000000,# Since we only call bind_param() if we're given attribs then
0.000000,0,0.000000,# applications using drivers that don't support bind_param can still
0.000000,0,0.000000,# use bind_param_array() so long as they don't pass any attribs.
0.000000,0,0.000000,
0.000000,0,0.000000,$$hash_of_arrays{$p_id} = $value_array;
0.000000,0,0.000000,return $sth->bind_param($p_id, undef, $attr)
0.000000,0,0.000000,if $attr;
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bind_param_inout_array {
0.000000,0,0.000000,my $sth = shift;
0.000000,0,0.000000,# XXX not supported so we just call bind_param_array instead
0.000000,0,0.000000,# and then return an error
0.000000,0,0.000000,my ($p_num, $value_array, $attr) = @_;
0.000000,0,0.000000,$sth->bind_param_array($p_num, $value_array, $attr);
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "bind_param_inout_array not supported");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub bind_columns {
0.000000,0,0.000000,my $sth = shift;
0.000000,0,0.000000,my $fields = $sth->FETCH('NUM_OF_FIELDS') || 0;
0.000000,0,0.000000,if ($fields <= 0 && !$sth->{Active}) {
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "Statement has no result columns to bind"
0.000000,0,0.000000,." (perhaps you need to successfully call execute first)");
0.000000,0,0.000000,}
0.000000,0,0.000000,# Backwards compatibility for old-style call with attribute hash
0.000000,0,0.000000,# ref as first arg. Skip arg if undef or a hash ref.
0.000000,0,0.000000,my $attr;
0.000000,0,0.000000,$attr = shift if !defined $_[0] or ref($_[0]) eq 'HASH';
0.000000,0,0.000000,
0.000000,0,0.000000,my $idx = 0;
0.000000,0,0.000000,$sth->bind_col(++$idx, shift, $attr) or return
0.000000,0,0.000000,while (@_ and $idx < $fields);
0.000000,0,0.000000,
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "bind_columns called with ".($idx+@_)." values but $fields are needed")
0.000000,0,0.000000,if @_ or $idx != $fields;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub execute_array {
0.000000,0,0.000000,my $sth = shift;
0.000000,0,0.000000,my ($attr, @array_of_arrays) = @_;
0.000000,0,0.000000,my $NUM_OF_PARAMS = $sth->FETCH('NUM_OF_PARAMS'); # may be undef at this point
0.000000,0,0.000000,
0.000000,0,0.000000,# get tuple status array or hash attribute
0.000000,0,0.000000,my $tuple_sts = $attr->{ArrayTupleStatus};
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "ArrayTupleStatus attribute must be an arrayref")
0.000000,0,0.000000,if $tuple_sts and ref $tuple_sts ne 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,# bind all supplied arrays
0.000000,0,0.000000,if (@array_of_arrays) {
0.000000,0,0.000000,$sth->{ParamArrays} = { };	# clear out old params
0.000000,0,0.000000,return $sth->set_err($DBI::stderr,
0.000000,0,0.000000,@array_of_arrays." bind values supplied but $NUM_OF_PARAMS expected")
0.000000,0,0.000000,if defined ($NUM_OF_PARAMS) && @array_of_arrays != $NUM_OF_PARAMS;
0.000000,0,0.000000,$sth->bind_param_array($_, $array_of_arrays[$_-1]) or return
0.000000,0,0.000000,foreach (1..@array_of_arrays);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $fetch_tuple_sub;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($fetch_tuple_sub = $attr->{ArrayTupleFetch}) {	# fetch on demand
0.000000,0,0.000000,
0.000000,0,0.000000,return $sth->set_err($DBI::stderr,
0.000000,0,0.000000,"Can't use both ArrayTupleFetch and explicit bind values")
0.000000,0,0.000000,if @array_of_arrays; # previous bind_param_array calls will simply be ignored
0.000000,0,0.000000,
0.000000,0,0.000000,if (UNIVERSAL::isa($fetch_tuple_sub,'DBI::st')) {
0.000000,0,0.000000,my $fetch_sth = $fetch_tuple_sub;
0.000000,0,0.000000,return $sth->set_err($DBI::stderr,
0.000000,0,0.000000,"ArrayTupleFetch sth is not Active, need to execute() it first")
0.000000,0,0.000000,unless $fetch_sth->{Active};
0.000000,0,0.000000,# check column count match to give more friendly message
0.000000,0,0.000000,my $NUM_OF_FIELDS = $fetch_sth->{NUM_OF_FIELDS};
0.000000,0,0.000000,return $sth->set_err($DBI::stderr,
0.000000,0,0.000000,"$NUM_OF_FIELDS columns from ArrayTupleFetch sth but $NUM_OF_PARAMS expected")
0.000000,0,0.000000,if defined($NUM_OF_FIELDS) && defined($NUM_OF_PARAMS)
0.000000,0,0.000000,&& $NUM_OF_FIELDS != $NUM_OF_PARAMS;
0.000000,0,0.000000,$fetch_tuple_sub = sub { $fetch_sth->fetchrow_arrayref };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!UNIVERSAL::isa($fetch_tuple_sub,'CODE')) {
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "ArrayTupleFetch '$fetch_tuple_sub' is not a code ref or statement handle");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $NUM_OF_PARAMS_given = keys %{ $sth->{ParamArrays} || {} };
0.000000,0,0.000000,return $sth->set_err($DBI::stderr,
0.000000,0,0.000000,"$NUM_OF_PARAMS_given bind values supplied but $NUM_OF_PARAMS expected")
0.000000,0,0.000000,if defined($NUM_OF_PARAMS) && $NUM_OF_PARAMS != $NUM_OF_PARAMS_given;
0.000000,0,0.000000,
0.000000,0,0.000000,# get the length of a bound array
0.000000,0,0.000000,my $maxlen;
0.000000,0,0.000000,my %hash_of_arrays = %{$sth->{ParamArrays}};
0.000000,0,0.000000,foreach (keys(%hash_of_arrays)) {
0.000000,0,0.000000,my $ary = $hash_of_arrays{$_};
0.000000,0,0.000000,next unless ref $ary eq 'ARRAY';
0.000000,0,0.000000,$maxlen = @$ary if !$maxlen || @$ary > $maxlen;
0.000000,0,0.000000,}
0.000000,0,0.000000,# if there are no arrays then execute scalars once
0.000000,0,0.000000,$maxlen = 1 unless defined $maxlen;
0.000000,0,0.000000,my @bind_ids = 1..keys(%hash_of_arrays);
0.000000,0,0.000000,
0.000000,0,0.000000,my $tuple_idx = 0;
0.000000,0,0.000000,$fetch_tuple_sub = sub {
0.000000,0,0.000000,return if $tuple_idx >= $maxlen;
0.000000,0,0.000000,my @tuple = map {
0.000000,0,0.000000,my $a = $hash_of_arrays{$_};
0.000000,0,0.000000,ref($a) ? $a->[$tuple_idx] : $a
0.000000,0,0.000000,} @bind_ids;
0.000000,0,0.000000,++$tuple_idx;
0.000000,0,0.000000,return \@tuple;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,# pass thru the callers scalar or list context
0.000000,0,0.000000,return $sth->execute_for_fetch($fetch_tuple_sub, $tuple_sts);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub execute_for_fetch {
0.000000,0,0.000000,my ($sth, $fetch_tuple_sub, $tuple_status) = @_;
0.000000,0,0.000000,# start with empty status array
0.000000,0,0.000000,($tuple_status) ? @$tuple_status = () : $tuple_status = [];
0.000000,0,0.000000,
0.000000,0,0.000000,my $rc_total = 0;
0.000000,0,0.000000,my $err_count;
0.000000,0,0.000000,while ( my $tuple = &$fetch_tuple_sub() ) {
0.000000,0,0.000000,if ( my $rc = $sth->execute(@$tuple) ) {
0.000000,0,0.000000,push @$tuple_status, $rc;
0.000000,0,0.000000,$rc_total = ($rc >= 0 && $rc_total >= 0) ? $rc_total + $rc : -1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$err_count++;
0.000000,0,0.000000,push @$tuple_status, [ $sth->err, $sth->errstr, $sth->state ];
0.000000,0,0.000000,# XXX drivers implementing execute_for_fetch could opt to "last;" here
0.000000,0,0.000000,# if they know the error code means no further executes will work.
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,my $tuples = @$tuple_status;
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "executing $tuples generated $err_count errors")
0.000000,0,0.000000,if $err_count;
0.000000,0,0.000000,$tuples ||= "0E0";
0.000000,0,0.000000,return $tuples unless wantarray;
0.000000,0,0.000000,return ($tuples, $rc_total);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetchall_arrayref {	# ALSO IN Driver.xst
0.000000,0,0.000000,my ($sth, $slice, $max_rows) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# when batch fetching with $max_rows were very likely to try to
0.000000,0,0.000000,# fetch the 'next batch' after the previous batch returned
0.000000,0,0.000000,# <=$max_rows. So don't treat that as an error.
0.000000,0,0.000000,return undef if $max_rows and not $sth->FETCH('Active');
0.000000,0,0.000000,
0.000000,0,0.000000,my $mode = ref($slice) || 'ARRAY';
0.000000,0,0.000000,my @rows;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($mode eq 'ARRAY') {
0.000000,0,0.000000,my $row;
0.000000,0,0.000000,# we copy the array here because fetch (currently) always
0.000000,0,0.000000,# returns the same array ref. XXX
0.000000,0,0.000000,if ($slice && @$slice) {
0.000000,0,0.000000,$max_rows = -1 unless defined $max_rows;
0.000000,0,0.000000,push @rows, [ @{$row}[ @$slice] ]
0.000000,0,0.000000,while($max_rows-- and $row = $sth->fetch);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined $max_rows) {
0.000000,0,0.000000,push @rows, [ @$row ]
0.000000,0,0.000000,while($max_rows-- and $row = $sth->fetch);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @rows, [ @$row ] while($row = $sth->fetch);
0.000000,0,0.000000,}
0.000000,0,0.000000,return \@rows
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %row;
0.000000,0,0.000000,if ($mode eq 'REF' && ref($$slice) eq 'HASH') { # \{ $idx => $name }
0.000000,0,0.000000,keys %$$slice; # reset the iterator
0.000000,0,0.000000,while ( my ($idx, $name) = each %$$slice ) {
0.000000,0,0.000000,$sth->bind_col($idx+1, \$row{$name});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($mode eq 'HASH') {
0.000000,0,0.000000,if (keys %$slice) {
0.000000,0,0.000000,keys %$slice; # reset the iterator
0.000000,0,0.000000,my $name2idx = $sth->FETCH('NAME_lc_hash');
0.000000,0,0.000000,while ( my ($name, $unused) = each %$slice ) {
0.000000,0,0.000000,my $idx = $name2idx->{lc $name};
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "Invalid column name '$name' for slice")
0.000000,0,0.000000,if not defined $idx;
0.000000,0,0.000000,$sth->bind_col($idx+1, \$row{$name});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$sth->bind_columns( \( @row{ @{$sth->FETCH($sth->FETCH('FetchHashKeyName')) } } ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "fetchall_arrayref($mode) invalid");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (not defined $max_rows) {
0.000000,0,0.000000,push @rows, { %row } while ($sth->fetch); # full speed ahead!
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @rows, { %row } while ($max_rows-- and $sth->fetch);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub fetchall_hashref {
0.000000,0,0.000000,my ($sth, $key_field) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $hash_key_name = $sth->{FetchHashKeyName} || 'NAME';
0.000000,0,0.000000,my $names_hash = $sth->FETCH("${hash_key_name}_hash");
0.000000,0,0.000000,my @key_fields = (ref $key_field) ? @$key_field : ($key_field);
0.000000,0,0.000000,my @key_indexes;
0.000000,0,0.000000,my $num_of_fields = $sth->FETCH('NUM_OF_FIELDS');
0.000000,0,0.000000,foreach (@key_fields) {
0.000000,0,0.000000,my $index = $names_hash->{$_};  # perl index not column
0.000000,0,0.000000,$index = $_ - 1 if !defined $index && DBI::looks_like_number($_) && $_>=1 && $_ <= $num_of_fields;
0.000000,0,0.000000,return $sth->set_err($DBI::stderr, "Field '$_' does not exist (not one of @{[keys %$names_hash]})")
0.000000,0,0.000000,unless defined $index;
0.000000,0,0.000000,push @key_indexes, $index;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $rows = {};
0.000000,0,0.000000,my $NAME = $sth->FETCH($hash_key_name);
0.000000,0,0.000000,my @row = (undef) x $num_of_fields;
0.000000,0,0.000000,$sth->bind_columns(\(@row));
0.000000,0,0.000000,while ($sth->fetch) {
0.000000,0,0.000000,my $ref = $rows;
0.000000,0,0.000000,$ref = $ref->{$row[$_]} ||= {} for @key_indexes;
0.000000,0,0.000000,@{$ref}{@$NAME} = @row;
0.000000,0,0.000000,}
0.000000,0,0.000000,return $rows;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,*dump_results = \&DBI::dump_results;
0.000000,0,0.000000,
0.000000,0,0.000000,sub blob_copy_to_file {	# returns length or undef on error
0.000000,0,0.000000,my($self, $field, $filename_or_handleref, $blocksize) = @_;
0.000000,0,0.000000,my $fh = $filename_or_handleref;
0.000000,0,0.000000,my($len, $buf) = (0, "");
0.000000,0,0.000000,$blocksize ||= 512;	# not too ambitious
0.000000,0,0.000000,local(*FH);
0.000000,0,0.000000,unless(ref $fh) {
0.000000,0,0.000000,open(FH, ">$fh") || return undef;
0.000000,0,0.000000,$fh = \*FH;
0.000000,0,0.000000,}
0.000000,0,0.000000,while(defined($self->blob_read($field, $len, $blocksize, \$buf))) {
0.000000,0,0.000000,print $fh $buf;
0.000000,0,0.000000,$len += length $buf;
0.000000,0,0.000000,}
0.000000,0,0.000000,close(FH);
0.000000,0,0.000000,$len;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub more_results {
0.000000,0,0.000000,shift->{syb_more_results};	# handy grandfathering
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,unless ($DBI::PurePerl) {   # See install_driver
0.000013,2,0.000007,{ @DBD::_mem::dr::ISA = qw(DBD::_mem::common);	}
0.000012,2,0.000006,{ @DBD::_mem::db::ISA = qw(DBD::_mem::common);	}
0.000011,2,0.000005,{ @DBD::_mem::st::ISA = qw(DBD::_mem::common);	}
0.000000,0,0.000000,# DBD::_mem::common::DESTROY is implemented in DBI.xs
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000075,1,0.000075,1;
0.000000,0,0.000000,__END__
