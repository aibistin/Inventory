# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Class::MOP::Method::Wrapped;
0.000000,0,0.000000,BEGIN {
0.000009,1,0.000009,$Class::MOP::Method::Wrapped::AUTHORITY = 'cpan:STEVAN';
0.000034,1,0.000034,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Class::MOP::Method::Wrapped::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000016,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000034,2,0.000017,use Carp         'confess';
0.000034,2,0.000017,use Scalar::Util 'blessed';
0.000000,0,0.000000,
0.000878,2,0.000439,use base 'Class::MOP::Method';
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# this ugly beast is the result of trying
0.000000,0,0.000000,# to micro optimize this as much as possible
0.000000,0,0.000000,# while not completely loosing maintainability.
0.000000,0,0.000000,# At this point it's "fast enough", after all
0.000000,0,0.000000,# you can't get something for nothing :)
0.000000,0,0.000000,my $_build_wrapped_method = sub {
0.000131,88,0.000001,my $modifier_table = shift;
0.000181,88,0.000002,my ($before, $after, $around) = (
0.000000,0,0.000000,$modifier_table->{before},
0.000000,0,0.000000,$modifier_table->{after},
0.000000,0,0.000000,$modifier_table->{around},
0.000000,0,0.000000,);
0.000664,88,0.000008,if (@$before && @$after) {
0.000000,0,0.000000,$modifier_table->{cache} = sub {
0.000000,0,0.000000,for my $c (@$before) { $c->(@_) };
0.000000,0,0.000000,my @rval;
0.000000,0,0.000000,((defined wantarray) ?
0.000000,0,0.000000,((wantarray) ?
0.000000,0,0.000000,(@rval = $around->{cache}->(@_))
0.000000,0,0.000000,:
0.000000,0,0.000000,($rval[0] = $around->{cache}->(@_)))
0.000000,0,0.000000,:
0.000000,0,0.000000,$around->{cache}->(@_));
0.000000,0,0.000000,for my $c (@$after) { $c->(@_) };
0.000000,0,0.000000,return unless defined wantarray;
0.000000,0,0.000000,return wantarray ? @rval : $rval[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@$before && !@$after) {
0.000000,0,0.000000,$modifier_table->{cache} = sub {
0.000000,0,0.000000,for my $c (@$before) { $c->(@_) };
0.000000,0,0.000000,return $around->{cache}->(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@$after && !@$before) {
0.000000,0,0.000000,$modifier_table->{cache} = sub {
0.000000,0,0.000000,my @rval;
0.000000,0,0.000000,((defined wantarray) ?
0.000000,0,0.000000,((wantarray) ?
0.000000,0,0.000000,(@rval = $around->{cache}->(@_))
0.000000,0,0.000000,:
0.000000,0,0.000000,($rval[0] = $around->{cache}->(@_)))
0.000000,0,0.000000,:
0.000000,0,0.000000,$around->{cache}->(@_));
0.000000,0,0.000000,for my $c (@$after) { $c->(@_) };
0.000000,0,0.000000,return unless defined wantarray;
0.000000,0,0.000000,return wantarray ? @rval : $rval[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000153,88,0.000002,$modifier_table->{cache} = $around->{cache};
0.000000,0,0.000000,}
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub wrap {
0.000138,44,0.000003,my ( $class, $code, %params ) = @_;
0.000000,0,0.000000,
0.000528,44,0.000012,(blessed($code) && $code->isa('Class::MOP::Method'))
0.000000,0,0.000000,|| confess "Can only wrap blessed CODE";
0.000000,0,0.000000,
0.000632,44,0.000014,my $modifier_table = {
0.000000,0,0.000000,cache  => undef,
0.000000,0,0.000000,orig   => $code->body,
0.000000,0,0.000000,before => [],
0.000000,0,0.000000,after  => [],
0.000000,0,0.000000,around => {
0.000000,0,0.000000,cache   => $code->body,
0.000000,0,0.000000,methods => [],
0.000000,0,0.000000,},
0.000000,0,0.000000,};
0.000231,44,0.000005,$_build_wrapped_method->($modifier_table);
0.000000,0,0.000000,return $class->SUPER::wrap(
0.012370,689,0.000018,sub { $modifier_table->{cache}->(@_) },
0.000000,0,0.000000,# get these from the original
0.000000,0,0.000000,# unless explicitly overridden
0.000560,44,0.000013,package_name   => $params{package_name} || $code->package_name,
0.000000,0,0.000000,name           => $params{name}         || $code->name,
0.000000,0,0.000000,original_method => $code,
0.000000,0,0.000000,
0.000000,0,0.000000,modifier_table => $modifier_table,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000072,44,0.000002,my $class = shift;
0.000068,44,0.000002,return Class::MOP::Class->initialize($class)->new_object(@_)
0.000000,0,0.000000,if $class ne __PACKAGE__;
0.000000,0,0.000000,
0.000079,44,0.000002,my $params = @_ == 1 ? $_[0] : {@_};
0.000000,0,0.000000,
0.000410,44,0.000009,return bless {
0.000000,0,0.000000,# inherited from Class::MOP::Method
0.000000,0,0.000000,'body'                 => $params->{body},
0.000000,0,0.000000,'associated_metaclass' => $params->{associated_metaclass},
0.000000,0,0.000000,'package_name'         => $params->{package_name},
0.000000,0,0.000000,'name'                 => $params->{name},
0.000000,0,0.000000,'original_method'      => $params->{original_method},
0.000000,0,0.000000,
0.000000,0,0.000000,# defined in this class
0.000000,0,0.000000,'modifier_table'       => $params->{modifier_table}
0.000000,0,0.000000,} => $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_original_method {
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,$code->original_method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_before_modifier {
0.000000,0,0.000000,my $code     = shift;
0.000000,0,0.000000,my $modifier = shift;
0.000000,0,0.000000,unshift @{$code->{'modifier_table'}->{before}} => $modifier;
0.000000,0,0.000000,$_build_wrapped_method->($code->{'modifier_table'});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before_modifiers {
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,return @{$code->{'modifier_table'}->{before}};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_after_modifier {
0.000000,0,0.000000,my $code     = shift;
0.000000,0,0.000000,my $modifier = shift;
0.000000,0,0.000000,push @{$code->{'modifier_table'}->{after}} => $modifier;
0.000000,0,0.000000,$_build_wrapped_method->($code->{'modifier_table'});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after_modifiers {
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,return @{$code->{'modifier_table'}->{after}};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# this is another possible candidate for
0.000000,0,0.000000,# optimization as well. There is an overhead
0.000000,0,0.000000,# associated with the currying that, if
0.000000,0,0.000000,# eliminated might make around modifiers
0.000000,0,0.000000,# more manageable.
0.000134,89,0.000002,my $compile_around_method = sub {{
0.000065,44,0.000001,my $f1 = pop;
0.000355,88,0.000004,return $f1 unless @_;
0.000069,44,0.000002,my $f2 = pop;
0.011967,733,0.000016,push @_, sub { $f2->( $f1, @_ ) };
0.000070,44,0.000002,redo;
0.000002,1,0.000002,}};
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_around_modifier {
0.000068,44,0.000002,my $code     = shift;
0.000062,44,0.000001,my $modifier = shift;
0.000113,44,0.000003,unshift @{$code->{'modifier_table'}->{around}->{methods}} => $modifier;
0.000000,0,0.000000,$code->{'modifier_table'}->{around}->{cache} = $compile_around_method->(
0.000291,44,0.000007,@{$code->{'modifier_table'}->{around}->{methods}},
0.000000,0,0.000000,$code->{'modifier_table'}->{orig}
0.000000,0,0.000000,);
0.000375,44,0.000009,$_build_wrapped_method->($code->{'modifier_table'});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub around_modifiers {
0.000000,0,0.000000,my $code = shift;
0.000000,0,0.000000,return @{$code->{'modifier_table'}->{around}->{methods}};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_compatible_with {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($other) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: this is pretty gross. the issue here is that CMOP::Method::Wrapped
0.000000,0,0.000000,# objects are subclasses of CMOP::Method, but when we get to moose, they'll
0.000000,0,0.000000,# need to be compatible with Moose::Meta::Method, which isn't possible. the
0.000000,0,0.000000,# right solution here is to make ::Wrapped into a role that gets applied to
0.000000,0,0.000000,# whatever the method_metaclass happens to be and get rid of
0.000000,0,0.000000,# wrapped_method_metaclass entirely, but that's not going to happen until
0.000000,0,0.000000,# we ditch cmop and get roles into the bootstrapping, so. i'm not
0.000000,0,0.000000,# maintaining the previous behavior of turning them into instances of the
0.000000,0,0.000000,# new method_metaclass because that's equally broken, and at least this way
0.000000,0,0.000000,# any issues will at least be detectable and potentially fixable. -doy
0.000000,0,0.000000,return $self unless $other->_is_compatible_with($self->_real_ref_name);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->SUPER::_make_compatible_with(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Method Meta Object for methods with before/after/around modifiers
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
