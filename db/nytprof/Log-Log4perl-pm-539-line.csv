# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,package Log::Log4perl;
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000016,2,0.000008,END { local($?); Log::Log4perl::Logger::cleanup(); }
0.000000,0,0.000000,
0.000055,2,0.000027,use 5.006;
0.000033,2,0.000017,use strict;
0.000033,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000142,2,0.000071,use Log::Log4perl::Util;
0.000119,2,0.000060,use Log::Log4perl::Logger;
0.000036,2,0.000018,use Log::Log4perl::Level;
0.000030,2,0.000015,use Log::Log4perl::Config;
0.000210,2,0.000105,use Log::Log4perl::Appender;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.42';
0.000000,0,0.000000,
0.000000,0,0.000000,# set this to '1' if you're using a wrapper
0.000000,0,0.000000,# around Log::Log4perl
0.000002,1,0.000002,our $caller_depth = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,#this is a mapping of convenience names to opcode masks used in
0.000000,0,0.000000,#$ALLOWED_CODE_OPS_IN_CONFIG_FILE below
0.000005,1,0.000005,our %ALLOWED_CODE_OPS = (
0.000000,0,0.000000,'safe'        => [ ':browse' ],
0.000000,0,0.000000,'restrictive' => [ ':default' ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000004,1,0.000004,our %WRAPPERS_REGISTERED = map { $_ => 1 } qw(Log::Log4perl);
0.000000,0,0.000000,
0.000000,0,0.000000,#set this to the opcodes which are allowed when
0.000000,0,0.000000,#$ALLOW_CODE_IN_CONFIG_FILE is set to a true value
0.000000,0,0.000000,#if undefined, there are no restrictions on code that can be
0.000000,0,0.000000,#excuted
0.000001,1,0.000001,our @ALLOWED_CODE_OPS_IN_CONFIG_FILE;
0.000000,0,0.000000,
0.000000,0,0.000000,#this hash lists things that should be exported into the Safe
0.000000,0,0.000000,#compartment.  The keys are the package the symbol should be
0.000000,0,0.000000,#exported from and the values are array references to the names
0.000000,0,0.000000,#of the symbols (including the leading type specifier)
0.000003,1,0.000003,our %VARS_SHARED_WITH_SAFE_COMPARTMENT = (
0.000000,0,0.000000,main => [ '%ENV' ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,#setting this to a true value will allow Perl code to be executed
0.000000,0,0.000000,#within the config file.  It works in conjunction with
0.000000,0,0.000000,#$ALLOWED_CODE_OPS_IN_CONFIG_FILE, which if defined restricts the
0.000000,0,0.000000,#opcodes which can be executed using the 'Safe' module.
0.000000,0,0.000000,#setting this to a false value disables code execution in the
0.000000,0,0.000000,#config file
0.000001,1,0.000001,our $ALLOW_CODE_IN_CONFIG_FILE = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,#arrays in a log message will be joined using this character,
0.000000,0,0.000000,#see Log::Log4perl::Appender::DBI
0.000002,1,0.000002,our $JOIN_MSG_ARRAY_CHAR = '';
0.000000,0,0.000000,
0.000000,0,0.000000,#version required for XML::DOM, to enable XML Config parsing
0.000000,0,0.000000,#and XML Config unit tests
0.000002,1,0.000002,our $DOM_VERSION_REQUIRED = '1.29'; 
0.000000,0,0.000000,
0.000001,1,0.000001,our $CHATTY_DESTROY_METHODS = 0;
0.000000,0,0.000000,
0.000001,1,0.000001,our $LOGDIE_MESSAGE_ON_STDERR = 1;
0.000001,1,0.000001,our $LOGEXIT_CODE             = 1;
0.000001,1,0.000001,our %IMPORT_CALLED;
0.000000,0,0.000000,
0.000002,1,0.000002,our $EASY_CLOSURES = {};
0.000000,0,0.000000,
0.000000,0,0.000000,# to throw refs as exceptions via logcarp/confess, turn this off
0.000001,1,0.000001,our $STRINGIFY_DIE_MESSAGE = 1;
0.000000,0,0.000000,
0.000114,2,0.000057,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,##################################################
0.000002,1,0.000002,my($class) = shift;
0.000000,0,0.000000,
0.000002,1,0.000002,my $caller_pkg = caller();
0.000000,0,0.000000,
0.000002,1,0.000002,return 1 if $IMPORT_CALLED{$caller_pkg}++;
0.000000,0,0.000000,
0.000003,1,0.000003,my(%tags) = map { $_ => 1 } @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Lazy man's logger
0.000003,1,0.000003,if(exists $tags{':easy'}) {
0.000002,1,0.000002,$tags{':levels'} = 1;
0.000001,1,0.000001,$tags{':nowarn'} = 1;
0.000002,1,0.000002,$tags{'get_logger'} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,if(exists $tags{':no_extra_logdie_message'}) {
0.000000,0,0.000000,$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR = 0;
0.000000,0,0.000000,delete $tags{':no_extra_logdie_message'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,if(exists $tags{get_logger}) {
0.000000,0,0.000000,# Export get_logger into the calling module's 
0.000111,2,0.000056,no strict qw(refs);
0.000006,1,0.000006,*{"$caller_pkg\::get_logger"} = *get_logger;
0.000000,0,0.000000,
0.000002,1,0.000002,delete $tags{get_logger};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,if(exists $tags{':levels'}) {
0.000000,0,0.000000,# Export log levels ($DEBUG, $INFO etc.) from Log4perl::Level
0.000005,1,0.000005,for my $key (keys %Log::Log4perl::Level::PRIORITY) {
0.000013,8,0.000002,my $name  = "$caller_pkg\::$key";
0.000000,0,0.000000,# Need to split this up in two lines, or CVS will
0.000000,0,0.000000,# mess it up.
0.000012,8,0.000002,my $value = $
0.000000,0,0.000000,Log::Log4perl::Level::PRIORITY{$key};
0.001784,2,0.000892,no strict qw(refs);
0.000035,8,0.000004,*{"$name"} = \$value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,delete $tags{':levels'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Lazy man's logger
0.000003,1,0.000003,if(exists $tags{':easy'}) {
0.000002,1,0.000002,delete $tags{':easy'};
0.000000,0,0.000000,
0.000000,0,0.000000,# Define default logger object in caller's package
0.000005,1,0.000005,my $logger = get_logger("$caller_pkg");
0.000000,0,0.000000,
0.000000,0,0.000000,# Define DEBUG, INFO, etc. routines in caller's package
0.000003,1,0.000003,for(qw(TRACE DEBUG INFO WARN ERROR FATAL ALWAYS)) {
0.000012,7,0.000002,my $level   = $_;
0.000013,7,0.000002,$level = "OFF" if $level eq "ALWAYS";
0.000011,7,0.000002,my $lclevel = lc($_);
0.000000,0,0.000000,easy_closure_create($caller_pkg, $_, sub {
0.000004,2,0.000002,Log::Log4perl::Logger::init_warn() unless 
0.000000,0,0.000000,$Log::Log4perl::Logger::INITIALIZED or
0.000000,0,0.000000,$Log::Log4perl::Logger::NON_INIT_WARNED;
0.000028,2,0.000014,$logger->{$level}->($logger, @_, $level);
0.000064,7,0.000009,}, $logger);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Define LOGCROAK, LOGCLUCK, etc. routines in caller's package
0.000003,1,0.000003,for(qw(LOGCROAK LOGCLUCK LOGCARP LOGCONFESS)) {
0.000009,4,0.000002,my $method = "Log::Log4perl::Logger::" . lc($_);
0.000000,0,0.000000,
0.000000,0,0.000000,easy_closure_create($caller_pkg, $_, sub {
0.000000,0,0.000000,unshift @_, $logger;
0.000000,0,0.000000,goto &$method;
0.000031,4,0.000008,}, $logger);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Define LOGDIE, LOGWARN
0.000000,0,0.000000,easy_closure_create($caller_pkg, "LOGDIE", sub {
0.000000,0,0.000000,Log::Log4perl::Logger::init_warn() unless 
0.000000,0,0.000000,$Log::Log4perl::Logger::INITIALIZED or
0.000000,0,0.000000,$Log::Log4perl::Logger::NON_INIT_WARNED;
0.000000,0,0.000000,$logger->{FATAL}->($logger, @_, "FATAL");
0.000000,0,0.000000,$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ?
0.000000,0,0.000000,CORE::die(Log::Log4perl::Logger::callerline(join '', @_)) :
0.000000,0,0.000000,exit $Log::Log4perl::LOGEXIT_CODE;
0.000006,1,0.000006,}, $logger);
0.000000,0,0.000000,
0.000000,0,0.000000,easy_closure_create($caller_pkg, "LOGEXIT", sub {
0.000000,0,0.000000,Log::Log4perl::Logger::init_warn() unless 
0.000000,0,0.000000,$Log::Log4perl::Logger::INITIALIZED or
0.000000,0,0.000000,$Log::Log4perl::Logger::NON_INIT_WARNED;
0.000000,0,0.000000,$logger->{FATAL}->($logger, @_, "FATAL");
0.000000,0,0.000000,exit $Log::Log4perl::LOGEXIT_CODE;
0.000006,1,0.000006,}, $logger);
0.000000,0,0.000000,
0.000000,0,0.000000,easy_closure_create($caller_pkg, "LOGWARN", sub {
0.000000,0,0.000000,Log::Log4perl::Logger::init_warn() unless 
0.000000,0,0.000000,$Log::Log4perl::Logger::INITIALIZED or
0.000000,0,0.000000,$Log::Log4perl::Logger::NON_INIT_WARNED;
0.000000,0,0.000000,$logger->{WARN}->($logger, @_, "WARN");
0.000000,0,0.000000,CORE::warn(Log::Log4perl::Logger::callerline(join '', @_))
0.000000,0,0.000000,if $Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR;
0.000006,1,0.000006,}, $logger);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,if(exists $tags{':nowarn'}) {
0.000001,1,0.000001,$Log::Log4perl::Logger::NON_INIT_WARNED = 1;
0.000002,1,0.000002,delete $tags{':nowarn'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,if(exists $tags{':nostrict'}) {
0.000000,0,0.000000,$Log::Log4perl::Logger::NO_STRICT = 1;
0.000000,0,0.000000,delete $tags{':nostrict'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,if(exists $tags{':resurrect'}) {
0.000000,0,0.000000,my $FILTER_MODULE = "Filter::Util::Call";
0.000000,0,0.000000,if(! Log::Log4perl::Util::module_available($FILTER_MODULE)) {
0.000000,0,0.000000,die "$FILTER_MODULE required with :resurrect" .
0.000000,0,0.000000,"(install from CPAN)";
0.000000,0,0.000000,}
0.000000,0,0.000000,eval "require $FILTER_MODULE" or die "Cannot pull in $FILTER_MODULE";
0.000000,0,0.000000,Filter::Util::Call::filter_add(
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my($status);
0.000000,0,0.000000,s/^\s*###l4p// if
0.000000,0,0.000000,($status = Filter::Util::Call::filter_read()) > 0;
0.000000,0,0.000000,$status;
0.000000,0,0.000000,});
0.000000,0,0.000000,delete $tags{':resurrect'};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,if(keys %tags) {
0.000000,0,0.000000,# We received an Option we couldn't understand.
0.000000,0,0.000000,die "Unknown Option(s): @{[keys %tags]}";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub initialized {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,return $Log::Log4perl::Logger::INITIALIZED;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,die "THIS CLASS ISN'T FOR DIRECT USE. " .
0.000000,0,0.000000,"PLEASE CHECK 'perldoc " . __PACKAGE__ . "'.";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub reset { # Mainly for debugging/testing
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# Delegate this to the logger ...
0.000013,1,0.000013,return Log::Log4perl::Logger->reset();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub init_once { # Call init only if it hasn't been
0.000000,0,0.000000,# called yet.
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,init(@_) unless $Log::Log4perl::Logger::INITIALIZED;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub init { # Read the config file
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,#woops, they called ::init instead of ->init, let's be forgiving
0.000000,0,0.000000,if ($class ne __PACKAGE__) {
0.000000,0,0.000000,unshift(@args, $class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Delegate this to the config module
0.000000,0,0.000000,return Log::Log4perl::Config->init(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub init_and_watch { 
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,#woops, they called ::init instead of ->init, let's be forgiving
0.000000,0,0.000000,if ($class ne __PACKAGE__) {
0.000000,0,0.000000,unshift(@args, $class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Delegate this to the config module
0.000000,0,0.000000,return Log::Log4perl::Config->init_and_watch(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub easy_init { # Initialize the root logger with a screen appender
0.000000,0,0.000000,##################################################
0.000002,1,0.000002,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Did somebody call us with Log::Log4perl::easy_init()?
0.000012,1,0.000012,if(ref($class) or $class =~ /^\d+$/) {
0.000000,0,0.000000,unshift @args, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Reset everything first
0.000006,1,0.000006,Log::Log4perl->reset();
0.000000,0,0.000000,
0.000002,1,0.000002,my @loggers = ();
0.000000,0,0.000000,
0.000005,1,0.000005,my %default = ( level    => $DEBUG,
0.000000,0,0.000000,file     => "STDERR",
0.000000,0,0.000000,utf8     => undef,
0.000000,0,0.000000,category => "",
0.000000,0,0.000000,layout   => "%d %m%n",
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000003,1,0.000003,if(!@args) {
0.000000,0,0.000000,push @loggers, \%default;
0.000000,0,0.000000,} else {
0.000003,1,0.000003,for my $arg (@args) {
0.000013,1,0.000013,if($arg =~ /^\d+$/) {
0.000005,1,0.000005,my %logger = (%default, level => $arg);
0.000002,1,0.000002,push @loggers, \%logger;
0.000000,0,0.000000,} elsif(ref($arg) eq "HASH") {
0.000000,0,0.000000,my %logger = (%default, %$arg);
0.000000,0,0.000000,push @loggers, \%logger;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,for my $logger (@loggers) {
0.000000,0,0.000000,
0.000002,1,0.000002,my $app;
0.000000,0,0.000000,
0.000017,1,0.000017,if($logger->{file} =~ /^stderr$/i) {
0.000000,0,0.000000,$app = Log::Log4perl::Appender->new(
0.000000,0,0.000000,"Log::Log4perl::Appender::Screen",
0.000000,0,0.000000,utf8 => $logger->{utf8});
0.000000,0,0.000000,} elsif($logger->{file} =~ /^stdout$/i) {
0.000000,0,0.000000,$app = Log::Log4perl::Appender->new(
0.000000,0,0.000000,"Log::Log4perl::Appender::Screen",
0.000000,0,0.000000,stderr => 0,
0.000000,0,0.000000,utf8   => $logger->{utf8});
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my $binmode;
0.000000,0,0.000000,if($logger->{file} =~ s/^(:.*?)>/>/) {
0.000000,0,0.000000,$binmode = $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,$logger->{file} =~ /^(>)?(>)?/;
0.000000,0,0.000000,my $mode = ($2 ? "append" : "write");
0.000000,0,0.000000,$logger->{file} =~ s/.*>+\s*//g;
0.000000,0,0.000000,$app = Log::Log4perl::Appender->new(
0.000000,0,0.000000,"Log::Log4perl::Appender::File",
0.000000,0,0.000000,filename => $logger->{file},
0.000000,0,0.000000,mode     => $mode,
0.000000,0,0.000000,utf8     => $logger->{utf8},
0.000000,0,0.000000,binmode  => $binmode,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,1,0.000010,my $layout = Log::Log4perl::Layout::PatternLayout->new(
0.000000,0,0.000000,$logger->{layout});
0.000006,1,0.000006,$app->layout($layout);
0.000000,0,0.000000,
0.000007,1,0.000007,my $log = Log::Log4perl->get_logger($logger->{category});
0.000006,1,0.000006,$log->level($logger->{level});
0.000009,1,0.000009,$log->add_appender($app);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,$Log::Log4perl::Logger::INITIALIZED = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub wrapper_register {  
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $wrapper = $_[-1];
0.000000,0,0.000000,
0.000000,0,0.000000,$WRAPPERS_REGISTERED{ $wrapper } = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub get_logger {  # Get an instance (shortcut)
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# get_logger() can be called in the following ways:
0.000000,0,0.000000,#
0.000000,0,0.000000,#   (1) Log::Log4perl::get_logger()     => ()
0.000000,0,0.000000,#   (2) Log::Log4perl->get_logger()     => ("Log::Log4perl")
0.000000,0,0.000000,#   (3) Log::Log4perl::get_logger($cat) => ($cat)
0.000000,0,0.000000,#   
0.000000,0,0.000000,#   (5) Log::Log4perl->get_logger($cat) => ("Log::Log4perl", $cat)
0.000000,0,0.000000,#   (6)   L4pSubclass->get_logger($cat) => ("L4pSubclass", $cat)
0.000000,0,0.000000,
0.000000,0,0.000000,# Note that (4) L4pSubclass->get_logger() => ("L4pSubclass")
0.000000,0,0.000000,# is indistinguishable from (3) and therefore can't be allowed.
0.000000,0,0.000000,# Wrapper classes always have to specify the category explicitely.
0.000000,0,0.000000,
0.000003,2,0.000001,my $category;
0.000000,0,0.000000,
0.000007,2,0.000003,if(@_ == 0) {
0.000000,0,0.000000,# 1
0.000000,0,0.000000,my $level = 0;
0.000000,0,0.000000,do { $category = scalar caller($level++);
0.000000,0,0.000000,} while exists $WRAPPERS_REGISTERED{ $category };
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(@_ == 1) {
0.000000,0,0.000000,# 2, 3
0.000002,1,0.000002,$category = $_[0];
0.000000,0,0.000000,
0.000001,1,0.000001,my $level = 0;
0.000003,1,0.000003,while(exists $WRAPPERS_REGISTERED{ $category }) { 
0.000000,0,0.000000,$category = scalar caller($level++);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# 5, 6
0.000002,1,0.000002,$category = $_[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Delegate this to the logger module
0.000021,2,0.000011,return Log::Log4perl::Logger->get_logger($category);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub caller_depth_offset {
0.000000,0,0.000000,###########################################
0.000003,2,0.000002,my( $level ) = @_;
0.000000,0,0.000000,
0.000003,2,0.000002,my $category;
0.000000,0,0.000000,
0.000000,0,0.000000,{ 
0.000012,4,0.000003,my $category = scalar caller($level + 1);
0.000000,0,0.000000,
0.000005,2,0.000003,if(defined $category and
0.000000,0,0.000000,exists $WRAPPERS_REGISTERED{ $category }) {
0.000000,0,0.000000,$level++;
0.000000,0,0.000000,redo;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,2,0.000007,return $level;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub appenders {  # Get a hashref of all defined appender wrappers
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,return \%Log::Log4perl::Logger::APPENDER_BY_NAME;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub add_appender { # Add an appender to the system, but don't assign
0.000000,0,0.000000,# it to a logger yet
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($class, $appender) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $name = $appender->name();
0.000000,0,0.000000,die "Mandatory parameter 'name' missing in appender" unless defined $name;
0.000000,0,0.000000,
0.000000,0,0.000000,# Make it known by name in the Log4perl universe
0.000000,0,0.000000,# (so that composite appenders can find it)
0.000000,0,0.000000,Log::Log4perl->appenders()->{ $name } = $appender;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# Return number of appenders changed
0.000000,0,0.000000,sub appender_thresholds_adjust {  # Readjust appender thresholds
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# If someone calls L4p-> and not L4p::
0.000000,0,0.000000,shift if $_[0] eq __PACKAGE__;
0.000000,0,0.000000,my($delta, $appenders) = @_;
0.000000,0,0.000000,my $retval = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if($delta == 0) {
0.000000,0,0.000000,# Nothing to do, no delta given.
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $appenders) {
0.000000,0,0.000000,# Map names to objects
0.000000,0,0.000000,$appenders = [map { 
0.000000,0,0.000000,die "Unkown appender: '$_'" unless exists
0.000000,0,0.000000,$Log::Log4perl::Logger::APPENDER_BY_NAME{
0.000000,0,0.000000,$_};
0.000000,0,0.000000,$Log::Log4perl::Logger::APPENDER_BY_NAME{
0.000000,0,0.000000,$_} 
0.000000,0,0.000000,} @$appenders];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Just hand over all known appenders
0.000000,0,0.000000,$appenders = [values %{Log::Log4perl::appenders()}] unless 
0.000000,0,0.000000,defined $appenders;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Change all appender thresholds;
0.000000,0,0.000000,foreach my $app (@$appenders) {
0.000000,0,0.000000,my $old_thres = $app->threshold();
0.000000,0,0.000000,my $new_thres;
0.000000,0,0.000000,if($delta > 0) {
0.000000,0,0.000000,$new_thres = Log::Log4perl::Level::get_higher_level(
0.000000,0,0.000000,$old_thres, $delta);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$new_thres = Log::Log4perl::Level::get_lower_level(
0.000000,0,0.000000,$old_thres, -$delta);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,++$retval if ($app->threshold($new_thres) == $new_thres);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub appender_by_name {  # Get a (real) appender by name
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# If someone calls L4p->appender_by_name and not L4p::appender_by_name
0.000000,0,0.000000,shift if $_[0] eq __PACKAGE__;
0.000000,0,0.000000,
0.000000,0,0.000000,my($name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $name and
0.000000,0,0.000000,exists $Log::Log4perl::Logger::APPENDER_BY_NAME{
0.000000,0,0.000000,$name}) {
0.000000,0,0.000000,return $Log::Log4perl::Logger::APPENDER_BY_NAME{
0.000000,0,0.000000,$name}->{appender};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub eradicate_appender {  # Remove an appender from the system
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# If someone calls L4p->... and not L4p::...
0.000000,0,0.000000,shift if $_[0] eq __PACKAGE__;
0.000000,0,0.000000,Log::Log4perl::Logger->eradicate_appender(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub infiltrate_lwp {  # 
0.000000,0,0.000000,##################################################
0.000191,2,0.000096,no warnings qw(redefine);
0.000000,0,0.000000,
0.000000,0,0.000000,my $l4p_wrapper = sub {
0.000000,0,0.000000,my($prio, @message) = @_;
0.000000,0,0.000000,local $Log::Log4perl::caller_depth =
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 2;
0.000000,0,0.000000,get_logger(scalar caller(1))->log($prio, @message);
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,*LWP::Debug::trace = sub { 
0.000000,0,0.000000,$l4p_wrapper->($INFO, @_); 
0.000000,0,0.000000,};
0.000000,0,0.000000,*LWP::Debug::conns =
0.000000,0,0.000000,*LWP::Debug::debug = sub { 
0.000000,0,0.000000,$l4p_wrapper->($DEBUG, @_); 
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub easy_closure_create {
0.000000,0,0.000000,##################################################
0.000023,14,0.000002,my($caller_pkg, $entry, $code, $logger) = @_;
0.000000,0,0.000000,
0.000107,2,0.000054,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,print("easy_closure: Setting shortcut $caller_pkg\::$entry ", 
0.000000,0,0.000000,"(logger=$logger\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000031,14,0.000002,$EASY_CLOSURES->{ $caller_pkg }->{ $entry } = $logger;
0.000097,14,0.000007,*{"$caller_pkg\::$entry"} = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub easy_closure_cleanup {
0.000000,0,0.000000,###########################################
0.000023,14,0.000002,my($caller_pkg, $entry) = @_;
0.000000,0,0.000000,
0.000034,2,0.000017,no warnings 'redefine';
0.000370,2,0.000185,no strict 'refs';
0.000000,0,0.000000,
0.000025,14,0.000002,my $logger = $EASY_CLOSURES->{ $caller_pkg }->{ $entry };
0.000000,0,0.000000,
0.000000,0,0.000000,print("easy_closure: Nuking easy shortcut $caller_pkg\::$entry ", 
0.000000,0,0.000000,"(logger=$logger\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000081,14,0.000006,*{"$caller_pkg\::$entry"} = sub { };
0.000082,14,0.000006,delete $EASY_CLOSURES->{ $caller_pkg }->{ $entry };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub easy_closure_category_cleanup {
0.000000,0,0.000000,##################################################
0.000002,1,0.000002,my($caller_pkg) = @_;
0.000000,0,0.000000,
0.000002,1,0.000002,if(! exists $EASY_CLOSURES->{ $caller_pkg } ) {
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,for my $entry ( keys %{ $EASY_CLOSURES->{ $caller_pkg } } ) {
0.000092,14,0.000007,easy_closure_cleanup( $caller_pkg, $entry );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,delete $EASY_CLOSURES->{ $caller_pkg };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub easy_closure_global_cleanup {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,
0.000010,1,0.000010,for my $caller_pkg ( keys %$EASY_CLOSURES ) {
0.000008,1,0.000008,easy_closure_category_cleanup( $caller_pkg );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub easy_closure_logger_remove {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($class, $logger) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,PKG: for my $caller_pkg ( keys %$EASY_CLOSURES ) {
0.000000,0,0.000000,for my $entry ( keys %{ $EASY_CLOSURES->{ $caller_pkg } } ) {
0.000000,0,0.000000,if( $logger == $EASY_CLOSURES->{ $caller_pkg }->{ $entry } ) {
0.000000,0,0.000000,easy_closure_category_cleanup( $caller_pkg );
0.000000,0,0.000000,next PKG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub remove_logger {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($class, $logger) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Any stealth logger convenience function still using it will
0.000000,0,0.000000,# now become a no-op.
0.000000,0,0.000000,Log::Log4perl->easy_closure_logger_remove( $logger );
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove the logger from the system
0.000000,0,0.000000,delete $Log::Log4perl::Logger::LOGGERS_BY_NAME->{ $logger->{category} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
