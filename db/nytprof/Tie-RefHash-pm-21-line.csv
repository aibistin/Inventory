# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Tie::RefHash;
0.000000,0,0.000000,
0.000208,2,0.000104,use vars qw/$VERSION/;
0.000000,0,0.000000,
0.000002,1,0.000002,$VERSION = "1.39";
0.000000,0,0.000000,
0.000082,2,0.000041,use 5.005;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Tie::RefHash - use references as hash keys
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,require 5.004;
0.000000,0,0.000000,use Tie::RefHash;
0.000000,0,0.000000,tie HASHVARIABLE, 'Tie::RefHash', LIST;
0.000000,0,0.000000,tie HASHVARIABLE, 'Tie::RefHash::Nestable', LIST;
0.000000,0,0.000000,
0.000000,0,0.000000,untie HASHVARIABLE;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,This module provides the ability to use references as hash keys if you
0.000000,0,0.000000,first C<tie> the hash variable to this module.  Normally, only the
0.000000,0,0.000000,keys of the tied hash itself are preserved as references; to use
0.000000,0,0.000000,references as keys in hashes-of-hashes, use Tie::RefHash::Nestable,
0.000000,0,0.000000,included as part of Tie::RefHash.
0.000000,0,0.000000,
0.000000,0,0.000000,It is implemented using the standard perl TIEHASH interface.  Please
0.000000,0,0.000000,see the C<tie> entry in perlfunc(1) and perltie(1) for more information.
0.000000,0,0.000000,
0.000000,0,0.000000,The Nestable version works by looking for hash references being stored
0.000000,0,0.000000,and converting them to tied hashes so that they too can have
0.000000,0,0.000000,references as keys.  This will happen without warning whenever you
0.000000,0,0.000000,store a reference to one of your own hashes in the tied hash.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXAMPLE
0.000000,0,0.000000,
0.000000,0,0.000000,use Tie::RefHash;
0.000000,0,0.000000,tie %h, 'Tie::RefHash';
0.000000,0,0.000000,$a = [];
0.000000,0,0.000000,$b = {};
0.000000,0,0.000000,$c = \*main;
0.000000,0,0.000000,$d = \"gunk";
0.000000,0,0.000000,$e = sub { 'foo' };
0.000000,0,0.000000,%h = ($a => 1, $b => 2, $c => 3, $d => 4, $e => 5);
0.000000,0,0.000000,$a->[0] = 'foo';
0.000000,0,0.000000,$b->{foo} = 'bar';
0.000000,0,0.000000,for (keys %h) {
0.000000,0,0.000000,print ref($_), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,tie %h, 'Tie::RefHash::Nestable';
0.000000,0,0.000000,$h{$a}->{$b} = 1;
0.000000,0,0.000000,for (keys %h, keys %{$h{$a}}) {
0.000000,0,0.000000,print ref($_), "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 THREAD SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,L<Tie::RefHash> fully supports threading using the C<CLONE> method.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 STORABLE SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,L<Storable> hooks are provided for semantically correct serialization and
0.000000,0,0.000000,cloning of tied refhashes.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 RELIC SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,This version of Tie::RefHash seems to no longer work with 5.004. This has not
0.000000,0,0.000000,been throughly investigated. Patches welcome ;-)
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute it and/or modify it under
0.000000,0,0.000000,the same terms as Perl itself
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 MAINTAINER
0.000000,0,0.000000,
0.000000,0,0.000000,Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Gurusamy Sarathy        gsar@activestate.com
0.000000,0,0.000000,
0.000000,0,0.000000,'Nestable' by Ed Avis   ed@membled.com
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,perl(1), perlfunc(1), perltie(1)
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000260,2,0.000130,use Tie::Hash;
0.000038,2,0.000019,use vars '@ISA';
0.000006,1,0.000006,@ISA = qw(Tie::Hash);
0.000033,2,0.000016,use strict;
0.000040,2,0.000020,use Carp qw/croak/;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,local $@;
0.000000,0,0.000000,# determine whether we need to take care of threads
0.000278,2,0.000139,use Config ();
0.000009,1,0.000009,my $usethreads = $Config::Config{usethreads}; # && exists $INC{"threads.pm"}
0.000003,1,0.000003,*_HAS_THREADS = $usethreads ? sub () { 1 } : sub () { 0 };
0.000536,3,0.000179,*_HAS_SCALAR_UTIL = eval { require Scalar::Util; 1 } ? sub () { 1 } : sub () { 0 };
0.000009,1,0.000009,*_HAS_WEAKEN = defined(&Scalar::Util::weaken) ? sub () { 1 } : sub () { 0 };
0.000117,1,0.000117,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# create a refaddr function
0.000000,0,0.000000,
0.000002,1,0.000002,local $@;
0.000000,0,0.000000,
0.000017,1,0.000017,if ( _HAS_SCALAR_UTIL ) {
0.000000,0,0.000000,Scalar::Util->import("refaddr");
0.000000,0,0.000000,} else {
0.000000,0,0.000000,require overload;
0.000000,0,0.000000,
0.000000,0,0.000000,*refaddr = sub {
0.000000,0,0.000000,if ( overload::StrVal($_[0]) =~ /\( 0x ([a-zA-Z0-9]+) \)$/x) {
0.000000,0,0.000000,return $1;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "couldn't parse StrVal: " . overload::StrVal($_[0]);
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000608,1,0.000608,}
0.000000,0,0.000000,
0.000002,1,0.000002,my (@thread_object_registry, $count); # used by the CLONE method to rehash the keys after their refaddr changed
0.000000,0,0.000000,
0.000000,0,0.000000,sub TIEHASH {
0.000002,1,0.000002,my $c = shift;
0.000002,1,0.000002,my $s = [];
0.000002,1,0.000002,bless $s, $c;
0.000003,1,0.000003,while (@_) {
0.000000,0,0.000000,$s->STORE(shift, shift);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (_HAS_THREADS ) {
0.000000,0,0.000000,
0.000000,0,0.000000,if ( _HAS_WEAKEN ) {
0.000000,0,0.000000,# remember the object so that we can rekey it on CLONE
0.000000,0,0.000000,push @thread_object_registry, $s;
0.000000,0,0.000000,# but make this a weak reference, so that there are no leaks
0.000000,0,0.000000,Scalar::Util::weaken( $thread_object_registry[-1] );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( ++$count > 1000 ) {
0.000000,0,0.000000,# this ensures we don't fill up with a huge array dead weakrefs
0.000000,0,0.000000,@thread_object_registry = grep { defined } @thread_object_registry;
0.000000,0,0.000000,$count = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$count++; # used in the warning
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,return $s;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $storable_format_version = join("/", __PACKAGE__, "0.01");
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_freeze {
0.000000,0,0.000000,my ( $self, $is_cloning ) = @_;
0.000000,0,0.000000,my ( $refs, $reg ) = @$self;
0.000000,0,0.000000,return ( $storable_format_version, [ values %$refs ], $reg || {} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_thaw {
0.000000,0,0.000000,my ( $self, $is_cloning, $version, $refs, $reg ) = @_;
0.000000,0,0.000000,croak "incompatible versions of Tie::RefHash between freeze and thaw"
0.000000,0,0.000000,unless $version eq $storable_format_version;
0.000000,0,0.000000,
0.000000,0,0.000000,@$self = ( {}, $reg );
0.000000,0,0.000000,$self->_reindex_keys( $refs );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLONE {
0.000000,0,0.000000,my $pkg = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $count and not _HAS_WEAKEN ) {
0.000000,0,0.000000,warn "Tie::RefHash is not threadsafe without Scalar::Util::weaken";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# when the thread has been cloned all the objects need to be updated.
0.000000,0,0.000000,# dead weakrefs are undefined, so we filter them out
0.000000,0,0.000000,@thread_object_registry = grep { defined && do { $_->_reindex_keys; 1 } } @thread_object_registry;
0.000000,0,0.000000,$count = 0; # we just cleaned up
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _reindex_keys {
0.000000,0,0.000000,my ( $self, $extra_keys ) = @_;
0.000000,0,0.000000,# rehash all the ref keys based on their new StrVal
0.000000,0,0.000000,%{ $self->[0] } = map { refaddr($_->[0]) => $_ } (values(%{ $self->[0] }), @{ $extra_keys || [] });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub FETCH {
0.000000,0,0.000000,my($s, $k) = @_;
0.000000,0,0.000000,if (ref $k) {
0.000000,0,0.000000,my $kstr = refaddr($k);
0.000000,0,0.000000,if (defined $s->[0]{$kstr}) {
0.000000,0,0.000000,$s->[0]{$kstr}[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$s->[1]{$k};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORE {
0.000186,106,0.000002,my($s, $k, $v) = @_;
0.000973,106,0.000009,if (ref $k) {
0.000000,0,0.000000,$s->[0]{refaddr($k)} = [$k, $v];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$s->[1]{$k} = $v;
0.000000,0,0.000000,}
0.000490,106,0.000005,$v;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DELETE {
0.000000,0,0.000000,my($s, $k) = @_;
0.000000,0,0.000000,(ref $k)
0.000000,0,0.000000,? (delete($s->[0]{refaddr($k)}) || [])->[1]
0.000000,0,0.000000,: delete($s->[1]{$k});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub EXISTS {
0.000000,0,0.000000,my($s, $k) = @_;
0.000000,0,0.000000,(ref $k) ? exists($s->[0]{refaddr($k)}) : exists($s->[1]{$k});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub FIRSTKEY {
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,keys %{$s->[0]};  # reset iterator
0.000000,0,0.000000,keys %{$s->[1]};  # reset iterator
0.000000,0,0.000000,$s->[2] = 0;      # flag for iteration, see NEXTKEY
0.000000,0,0.000000,$s->NEXTKEY;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub NEXTKEY {
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,my ($k, $v);
0.000000,0,0.000000,if (!$s->[2]) {
0.000000,0,0.000000,if (($k, $v) = each %{$s->[0]}) {
0.000000,0,0.000000,return $v->[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$s->[2] = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return each %{$s->[1]};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub CLEAR {
0.000000,0,0.000000,my $s = shift;
0.000000,0,0.000000,$s->[2] = 0;
0.000000,0,0.000000,%{$s->[0]} = ();
0.000000,0,0.000000,%{$s->[1]} = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,package Tie::RefHash::Nestable;
0.000090,2,0.000045,use vars '@ISA';
0.000005,1,0.000005,@ISA = 'Tie::RefHash';
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORE {
0.000000,0,0.000000,my($s, $k, $v) = @_;
0.000000,0,0.000000,if (ref($v) eq 'HASH' and not tied %$v) {
0.000000,0,0.000000,my @elems = %$v;
0.000000,0,0.000000,tie %$v, ref($s), @elems;
0.000000,0,0.000000,}
0.000000,0,0.000000,$s->SUPER::STORE($k, $v);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
