# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,#      B.pm
0.000000,0,0.000000,#
0.000000,0,0.000000,#      Copyright (c) 1996, 1997, 1998 Malcolm Beattie
0.000000,0,0.000000,#
0.000000,0,0.000000,#      You may distribute under the terms of either the GNU General Public
0.000000,0,0.000000,#      License or the Artistic License, as specified in the README file.
0.000000,0,0.000000,#
0.000000,0,0.000000,package B;
0.000076,2,0.000038,use strict;
0.000000,0,0.000000,
0.000002,1,0.000002,require Exporter;
0.000008,1,0.000008,@B::ISA = qw(Exporter);
0.000000,0,0.000000,
0.000000,0,0.000000,# walkoptree_slow comes from B.pm (you are there),
0.000000,0,0.000000,# walkoptree comes from B.xs
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000002,1,0.000002,$B::VERSION = '1.42';
0.000002,1,0.000002,@B::EXPORT_OK = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Our BOOT code needs $VERSION set, and will append to @EXPORT_OK.
0.000000,0,0.000000,# Want our constants loaded before the compiler meets OPf_KIDS below, as
0.000000,0,0.000000,# the combination of having the constant stay a Proxy Constant Subroutine
0.000000,0,0.000000,# and its value being inlined saves a little over .5K
0.000000,0,0.000000,
0.000002,1,0.000002,require XSLoader;
0.000745,1,0.000745,XSLoader::load();
0.001269,1,0.001269,}
0.000000,0,0.000000,
0.000010,1,0.000010,push @B::EXPORT_OK, (qw(minus_c ppname save_BEGINs
0.000000,0,0.000000,class peekop cast_I32 cstring cchar hash threadsv_names
0.000000,0,0.000000,main_root main_start main_cv svref_2object opnumber
0.000000,0,0.000000,sub_generation amagic_generation perlstring
0.000000,0,0.000000,walkoptree_slow walkoptree walkoptree_exec walksymtable
0.000000,0,0.000000,parents comppadlist sv_undef compile_stats timing_info
0.000000,0,0.000000,begin_av init_av check_av end_av regex_padav dowarn
0.000000,0,0.000000,defstash curstash warnhook diehook inc_gv @optype
0.000000,0,0.000000,@specialsv_name unitcheck_av));
0.000000,0,0.000000,
0.000005,1,0.000005,@B::SV::ISA = 'B::OBJECT';
0.000004,1,0.000004,@B::NULL::ISA = 'B::SV';
0.000004,1,0.000004,@B::PV::ISA = 'B::SV';
0.000004,1,0.000004,@B::IV::ISA = 'B::SV';
0.000004,1,0.000004,@B::NV::ISA = 'B::SV';
0.000000,0,0.000000,# RV is eliminated with 5.11.0, but effectively is a specialisation of IV now.
0.000006,1,0.000006,@B::RV::ISA = $] >= 5.011 ? 'B::IV' : 'B::SV';
0.000005,1,0.000005,@B::PVIV::ISA = qw(B::PV B::IV);
0.000014,1,0.000014,@B::PVNV::ISA = qw(B::PVIV B::NV);
0.000007,1,0.000007,@B::PVMG::ISA = 'B::PVNV';
0.000006,1,0.000006,@B::REGEXP::ISA = 'B::PVMG' if $] >= 5.011;
0.000005,1,0.000005,@B::PVLV::ISA = 'B::GV';
0.000004,1,0.000004,@B::BM::ISA = 'B::GV';
0.000005,1,0.000005,@B::AV::ISA = 'B::PVMG';
0.000023,1,0.000023,@B::GV::ISA = 'B::PVMG';
0.000007,1,0.000007,@B::HV::ISA = 'B::PVMG';
0.000006,1,0.000006,@B::CV::ISA = 'B::PVMG';
0.000006,1,0.000006,@B::IO::ISA = 'B::PVMG';
0.000005,1,0.000005,@B::FM::ISA = 'B::CV';
0.000000,0,0.000000,
0.000004,1,0.000004,@B::OP::ISA = 'B::OBJECT';
0.000004,1,0.000004,@B::UNOP::ISA = 'B::OP';
0.000004,1,0.000004,@B::BINOP::ISA = 'B::UNOP';
0.000004,1,0.000004,@B::LOGOP::ISA = 'B::UNOP';
0.000004,1,0.000004,@B::LISTOP::ISA = 'B::BINOP';
0.000004,1,0.000004,@B::SVOP::ISA = 'B::OP';
0.000004,1,0.000004,@B::PADOP::ISA = 'B::OP';
0.000004,1,0.000004,@B::PVOP::ISA = 'B::OP';
0.000005,1,0.000005,@B::LOOP::ISA = 'B::LISTOP';
0.000004,1,0.000004,@B::PMOP::ISA = 'B::LISTOP';
0.000004,1,0.000004,@B::COP::ISA = 'B::OP';
0.000000,0,0.000000,
0.000004,1,0.000004,@B::SPECIAL::ISA = 'B::OBJECT';
0.000000,0,0.000000,
0.000006,1,0.000006,@B::optype = qw(OP UNOP BINOP LOGOP LISTOP PMOP SVOP PADOP PVOP LOOP COP);
0.000000,0,0.000000,# bytecode.pl contained the following comment:
0.000000,0,0.000000,# Nullsv *must* come first in the following so that the condition
0.000000,0,0.000000,# ($$sv == 0) can continue to be used to test (sv == Nullsv).
0.000003,1,0.000003,@B::specialsv_name = qw(Nullsv &PL_sv_undef &PL_sv_yes &PL_sv_no
0.000000,0,0.000000,(SV*)pWARN_ALL (SV*)pWARN_NONE (SV*)pWARN_STD);
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# Stop "-w" from complaining about the lack of a real B::OBJECT class
0.000003,1,0.000003,package B::OBJECT;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub B::GV::SAFENAME {
0.000000,0,0.000000,my $name = (shift())->NAME;
0.000000,0,0.000000,
0.000000,0,0.000000,# The regex below corresponds to the isCONTROLVAR macro
0.000000,0,0.000000,# from toke.c
0.000000,0,0.000000,
0.000000,0,0.000000,$name =~ s/^([\cA-\cZ\c\\c[\c]\c?\c_\c^])/"^".
0.000000,0,0.000000,chr( utf8::unicode_to_native( 64 ^ ord($1) ))/e;
0.000000,0,0.000000,
0.000000,0,0.000000,# When we say unicode_to_native we really mean ascii_to_native,
0.000000,0,0.000000,# which matters iff this is a non-ASCII platform (EBCDIC).
0.000000,0,0.000000,
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub B::IV::int_value {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,return (($self->FLAGS() & SVf_IVisUV()) ? $self->UVX : $self->IV);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub B::NULL::as_string() {""}
0.000008,1,0.000008,*B::IV::as_string = \*B::IV::int_value;
0.000006,1,0.000006,*B::PV::as_string = \*B::PV::PV;
0.000000,0,0.000000,
0.000000,0,0.000000,#  The input typemap checking makes no distinction between different SV types,
0.000000,0,0.000000,#  so the XS body will generate the same C code, despite the different XS
0.000000,0,0.000000,#  "types". So there is no change in behaviour from doing "newXS" like this,
0.000000,0,0.000000,#  compared with the old approach of having a (near) duplicate XS body.
0.000000,0,0.000000,#  We should fix the typemap checking.
0.000006,1,0.000006,*B::IV::RV = \*B::PV::RV if $] > 5.012;
0.000000,0,0.000000,
0.000001,1,0.000001,my $debug;
0.000002,1,0.000002,my $op_count = 0;
0.000002,1,0.000002,my @parents = ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub debug {
0.000000,0,0.000000,my ($class, $value) = @_;
0.000000,0,0.000000,$debug = $value;
0.000000,0,0.000000,walkoptree_debug($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub class {
0.000000,0,0.000000,my $obj = shift;
0.000000,0,0.000000,my $name = ref $obj;
0.000000,0,0.000000,$name =~ s/^.*:://;
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parents { \@parents }
0.000000,0,0.000000,
0.000000,0,0.000000,# For debugging
0.000000,0,0.000000,sub peekop {
0.000000,0,0.000000,my $op = shift;
0.000000,0,0.000000,return sprintf("%s (0x%x) %s", class($op), $$op, $op->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub walkoptree_slow {
0.000000,0,0.000000,my($op, $method, $level) = @_;
0.000000,0,0.000000,$op_count++; # just for statistics
0.000000,0,0.000000,$level ||= 0;
0.000000,0,0.000000,warn(sprintf("walkoptree: %d. %s\n", $level, peekop($op))) if $debug;
0.000000,0,0.000000,$op->$method($level) if $op->can($method);
0.000000,0,0.000000,if ($$op && ($op->flags & OPf_KIDS)) {
0.000000,0,0.000000,my $kid;
0.000000,0,0.000000,unshift(@parents, $op);
0.000000,0,0.000000,for ($kid = $op->first; $$kid; $kid = $kid->sibling) {
0.000000,0,0.000000,walkoptree_slow($kid, $method, $level + 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,shift @parents;
0.000000,0,0.000000,}
0.000000,0,0.000000,if (class($op) eq 'PMOP'
0.000000,0,0.000000,&& ref($op->pmreplroot)
0.000000,0,0.000000,&& ${$op->pmreplroot}
0.000000,0,0.000000,&& $op->pmreplroot->isa( 'B::OP' ))
0.000000,0,0.000000,{
0.000000,0,0.000000,unshift(@parents, $op);
0.000000,0,0.000000,walkoptree_slow($op->pmreplroot, $method, $level + 1);
0.000000,0,0.000000,shift @parents;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub compile_stats {
0.000000,0,0.000000,return "Total number of OPs processed: $op_count\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub timing_info {
0.000000,0,0.000000,my ($sec, $min, $hr) = localtime;
0.000000,0,0.000000,my ($user, $sys) = times;
0.000000,0,0.000000,sprintf("%02d:%02d:%02d user=$user sys=$sys",
0.000000,0,0.000000,$hr, $min, $sec, $user, $sys);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,my %symtable;
0.000000,0,0.000000,
0.000000,0,0.000000,sub clearsym {
0.000000,0,0.000000,%symtable = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub savesym {
0.000000,0,0.000000,my ($obj, $value) = @_;
0.000000,0,0.000000,#    warn(sprintf("savesym: sym_%x => %s\n", $$obj, $value)); # debug
0.000000,0,0.000000,$symtable{sprintf("sym_%x", $$obj)} = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub objsym {
0.000000,0,0.000000,my $obj = shift;
0.000000,0,0.000000,return $symtable{sprintf("sym_%x", $$obj)};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub walkoptree_exec {
0.000000,0,0.000000,my ($op, $method, $level) = @_;
0.000000,0,0.000000,$level ||= 0;
0.000000,0,0.000000,my ($sym, $ppname);
0.000000,0,0.000000,my $prefix = "    " x $level;
0.000000,0,0.000000,for (; $$op; $op = $op->next) {
0.000000,0,0.000000,$sym = objsym($op);
0.000000,0,0.000000,if (defined($sym)) {
0.000000,0,0.000000,print $prefix, "goto $sym\n";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,savesym($op, sprintf("%s (0x%lx)", class($op), $$op));
0.000000,0,0.000000,$op->$method($level);
0.000000,0,0.000000,$ppname = $op->name;
0.000000,0,0.000000,if ($ppname =~
0.000000,0,0.000000,/^(d?or(assign)?|and(assign)?|mapwhile|grepwhile|entertry|range|cond_expr)$/)
0.000000,0,0.000000,{
0.000000,0,0.000000,print $prefix, uc($1), " => {\n";
0.000000,0,0.000000,walkoptree_exec($op->other, $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n";
0.000000,0,0.000000,} elsif ($ppname eq "match" || $ppname eq "subst") {
0.000000,0,0.000000,my $pmreplstart = $op->pmreplstart;
0.000000,0,0.000000,if ($$pmreplstart) {
0.000000,0,0.000000,print $prefix, "PMREPLSTART => {\n";
0.000000,0,0.000000,walkoptree_exec($pmreplstart, $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif ($ppname eq "substcont") {
0.000000,0,0.000000,print $prefix, "SUBSTCONT => {\n";
0.000000,0,0.000000,walkoptree_exec($op->other->pmreplstart, $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n";
0.000000,0,0.000000,$op = $op->other;
0.000000,0,0.000000,} elsif ($ppname eq "enterloop") {
0.000000,0,0.000000,print $prefix, "REDO => {\n";
0.000000,0,0.000000,walkoptree_exec($op->redoop, $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n", $prefix, "NEXT => {\n";
0.000000,0,0.000000,walkoptree_exec($op->nextop, $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n", $prefix, "LAST => {\n";
0.000000,0,0.000000,walkoptree_exec($op->lastop,  $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n";
0.000000,0,0.000000,} elsif ($ppname eq "subst") {
0.000000,0,0.000000,my $replstart = $op->pmreplstart;
0.000000,0,0.000000,if ($$replstart) {
0.000000,0,0.000000,print $prefix, "SUBST => {\n";
0.000000,0,0.000000,walkoptree_exec($replstart, $method, $level + 1);
0.000000,0,0.000000,print $prefix, "}\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub walksymtable {
0.000000,0,0.000000,my ($symref, $method, $recurse, $prefix) = @_;
0.000000,0,0.000000,my $sym;
0.000000,0,0.000000,my $ref;
0.000000,0,0.000000,my $fullname;
0.000507,2,0.000253,no strict 'refs';
0.000000,0,0.000000,$prefix = '' unless defined $prefix;
0.000000,0,0.000000,foreach my $sym ( sort keys %$symref ) {
0.000000,0,0.000000,$ref= $symref->{$sym};
0.000000,0,0.000000,$fullname = "*main::".$prefix.$sym;
0.000000,0,0.000000,if ($sym =~ /::$/) {
0.000000,0,0.000000,$sym = $prefix . $sym;
0.000000,0,0.000000,if (svref_2object(\*$sym)->NAME ne "main::" && $sym ne "<none>::" && &$recurse($sym)) {
0.000000,0,0.000000,walksymtable(\%$fullname, $method, $recurse, $sym);
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,svref_2object(\*$fullname)->$method();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000003,1,0.000003,package B::Section;
0.000001,1,0.000001,my $output_fh;
0.000002,1,0.000002,my %sections;
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,my ($class, $section, $symtable, $default) = @_;
0.000000,0,0.000000,$output_fh ||= FileHandle->new_tmpfile;
0.000000,0,0.000000,my $obj = bless [-1, $section, $symtable, $default], $class;
0.000000,0,0.000000,$sections{$section} = $obj;
0.000000,0,0.000000,return $obj;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get {
0.000000,0,0.000000,my ($class, $section) = @_;
0.000000,0,0.000000,return $sections{$section};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add {
0.000000,0,0.000000,my $section = shift;
0.000000,0,0.000000,while (defined($_ = shift)) {
0.000000,0,0.000000,print $output_fh "$section->[1]\t$_\n";
0.000000,0,0.000000,$section->[0]++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub index {
0.000000,0,0.000000,my $section = shift;
0.000000,0,0.000000,return $section->[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub name {
0.000000,0,0.000000,my $section = shift;
0.000000,0,0.000000,return $section->[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub symtable {
0.000000,0,0.000000,my $section = shift;
0.000000,0,0.000000,return $section->[2];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub default {
0.000000,0,0.000000,my $section = shift;
0.000000,0,0.000000,return $section->[3];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub output {
0.000000,0,0.000000,my ($section, $fh, $format) = @_;
0.000000,0,0.000000,my $name = $section->name;
0.000000,0,0.000000,my $sym = $section->symtable || {};
0.000000,0,0.000000,my $default = $section->default;
0.000000,0,0.000000,
0.000000,0,0.000000,seek($output_fh, 0, 0);
0.000000,0,0.000000,while (<$output_fh>) {
0.000000,0,0.000000,chomp;
0.000000,0,0.000000,s/^(.*?)\t//;
0.000000,0,0.000000,if ($1 eq $name) {
0.000000,0,0.000000,s{(s\\_[0-9a-f]+)} {
0.000000,0,0.000000,exists($sym->{$1}) ? $sym->{$1} : $default;
0.000000,0,0.000000,}ge;
0.000000,0,0.000000,printf $fh $format, $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000019,1,0.000019,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
