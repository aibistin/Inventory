# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Util::TypeConstraints::Builtins;
0.000000,0,0.000000,BEGIN {
0.000009,1,0.000009,$Moose::Util::TypeConstraints::Builtins::AUTHORITY = 'cpan:STEVAN';
0.000036,1,0.000036,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Util::TypeConstraints::Builtins::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000036,2,0.000018,use strict;
0.000038,2,0.000019,use warnings;
0.000000,0,0.000000,
0.000037,2,0.000019,use Class::Load qw( is_class_loaded );
0.000032,2,0.000016,use List::MoreUtils ();
0.002157,2,0.001079,use Scalar::Util qw( blessed looks_like_number reftype );
0.000000,0,0.000000,
0.000009,1,0.000009,sub type { goto &Moose::Util::TypeConstraints::type }
0.000127,16,0.000008,sub subtype { goto &Moose::Util::TypeConstraints::subtype }
0.000133,16,0.000008,sub as { goto &Moose::Util::TypeConstraints::as }
0.000155,16,0.000010,sub where (&) { goto &Moose::Util::TypeConstraints::where }
0.000000,0,0.000000,sub optimize_as (&) { goto &Moose::Util::TypeConstraints::optimize_as }
0.000141,17,0.000008,sub inline_as (&) { goto &Moose::Util::TypeConstraints::inline_as }
0.000000,0,0.000000,
0.000000,0,0.000000,sub define_builtins {
0.000002,1,0.000002,my $registry = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,type 'Any'    # meta-type including all
0.000000,0,0.000000,=> where {1}
0.000028,3,0.000009,=> inline_as { '1' };
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Item'  # base type
0.000000,0,0.000000,=> as 'Any'
0.000015,1,0.000015,=> inline_as { '1' };
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Undef'
0.000000,0,0.000000,=> as 'Item'
0.000000,0,0.000000,=> where { !defined($_) }
0.000000,0,0.000000,=> inline_as {
0.000008,1,0.000008,'!defined(' . $_[1] . ')'
0.000020,1,0.000020,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Defined'
0.000000,0,0.000000,=> as 'Item'
0.000000,0,0.000000,=> where { defined($_) }
0.000000,0,0.000000,=> inline_as {
0.000082,14,0.000006,'defined(' . $_[1] . ')'
0.000021,1,0.000021,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Bool'
0.000000,0,0.000000,=> as 'Item'
0.000000,0,0.000000,=> where { !defined($_) || $_ eq "" || "$_" eq '1' || "$_" eq '0' }
0.000000,0,0.000000,=> inline_as {
0.000009,1,0.000009,'('
0.000000,0,0.000000,. '!defined(' . $_[1] . ') '
0.000000,0,0.000000,. '|| ' . $_[1] . ' eq "" '
0.000000,0,0.000000,. '|| (' . $_[1] . '."") eq "1" '
0.000000,0,0.000000,. '|| (' . $_[1] . '."") eq "0"'
0.000000,0,0.000000,. ')'
0.000020,1,0.000020,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Value'
0.000000,0,0.000000,=> as 'Defined'
0.000000,0,0.000000,=> where { !ref($_) }
0.000000,0,0.000000,=> inline_as {
0.000170,13,0.000013,$_[0]->parent()->_inline_check($_[1])
0.000000,0,0.000000,. ' && !ref(' . $_[1] . ')'
0.000020,1,0.000020,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Ref'
0.000000,0,0.000000,=> as 'Defined'
0.000000,0,0.000000,=> where { ref($_) }
0.000000,0,0.000000,# no need to call parent - ref also checks for definedness
0.000028,2,0.000014,=> inline_as { 'ref(' . $_[1] . ')' };
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Str'
0.000000,0,0.000000,=> as 'Value'
0.000000,0,0.000000,=> where { ref(\$_) eq 'SCALAR' || ref(\(my $val = $_)) eq 'SCALAR' }
0.000000,0,0.000000,=> inline_as {
0.000073,5,0.000015,$_[0]->parent()->_inline_check($_[1])
0.000000,0,0.000000,. ' && ('
0.000000,0,0.000000,. 'ref(\\' . $_[1] . ') eq "SCALAR"'
0.000000,0,0.000000,. ' || ref(\\(my $val = ' . $_[1] . ')) eq "SCALAR"'
0.000000,0,0.000000,. ')'
0.000021,1,0.000021,};
0.000000,0,0.000000,
0.000005,1,0.000005,my $value_type = Moose::Util::TypeConstraints::find_type_constraint('Value');
0.000000,0,0.000000,subtype 'Num'
0.000000,0,0.000000,=> as 'Str'
0.000000,0,0.000000,=> where {
0.000000,0,0.000000,my $val = $_;
0.000000,0,0.000000,($val =~ /\A[+-]?[0-9]+\z/) ||
0.000000,0,0.000000,( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
0.000000,0,0.000000,(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
0.000000,0,0.000000,[0-9]*                                #matches 0-9 zero or more times
0.000000,0,0.000000,(?:\.[0-9]+)?                         #matches optional .89 or nothing
0.000000,0,0.000000,(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
0.000000,0,0.000000,\z/x );
0.000000,0,0.000000,}
0.000000,0,0.000000,=> inline_as {
0.000000,0,0.000000,# the long Str tests are redundant here
0.000000,0,0.000000,#storing $_[1] in a temporary value,
0.000000,0,0.000000,#so that $_[1] won't get converted to a string for regex match
0.000000,0,0.000000,#see t/attributes/numeric_defaults.t for more details
0.000014,1,0.000014,'my $val = '.$_[1].';'.
0.000000,0,0.000000,$value_type->_inline_check('$val')
0.000000,0,0.000000,.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
0.000000,0,0.000000,. '$val =~ /\A(?:[+-]?)               #matches optional +- in the beginning
0.000000,0,0.000000,(?=[0-9]|\.[0-9])                 #matches previous +- only if there is something like 3 or .3
0.000000,0,0.000000,[0-9]*                            #matches 0-9 zero or more times
0.000000,0,0.000000,(?:\.[0-9]+)?                     #matches optional .89 or nothing
0.000000,0,0.000000,(?:[Ee](?:[+-]?[0-9]+))?          #matches E1 or e1 or e-1 or e+1 etc
0.000000,0,0.000000,\z/x ); '
0.000021,1,0.000021,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Int'
0.000000,0,0.000000,=> as 'Num'
0.000000,0,0.000000,=> where { (my $val = $_) =~ /\A-?[0-9]+\z/ }
0.000000,0,0.000000,=> inline_as {
0.000059,6,0.000010,$value_type->_inline_check($_[1])
0.000000,0,0.000000,. ' && (my $val = ' . $_[1] . ') =~ /\A-?[0-9]+\z/'
0.000022,1,0.000022,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'CodeRef'
0.000000,0,0.000000,=> as 'Ref'
0.000000,0,0.000000,=> where { ref($_) eq 'CODE' }
0.000028,2,0.000014,=> inline_as { 'ref(' . $_[1] . ') eq "CODE"' };
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'RegexpRef'
0.000000,0,0.000000,=> as 'Ref'
0.000000,0,0.000000,=> where( \&_RegexpRef )
0.000000,0,0.000000,=> inline_as {
0.000008,1,0.000008,'Moose::Util::TypeConstraints::Builtins::_RegexpRef(' . $_[1] . ')'
0.000021,1,0.000021,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'GlobRef'
0.000000,0,0.000000,=> as 'Ref'
0.000000,0,0.000000,=> where { ref($_) eq 'GLOB' }
0.000028,2,0.000014,=> inline_as { 'ref(' . $_[1] . ') eq "GLOB"' };
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: scalar filehandles are GLOB refs, but a GLOB ref is not always a
0.000000,0,0.000000,# filehandle
0.000000,0,0.000000,subtype 'FileHandle'
0.000000,0,0.000000,=> as 'Ref'
0.000000,0,0.000000,=> where {
0.000000,0,0.000000,(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
0.000000,0,0.000000,|| (blessed($_) && $_->isa("IO::Handle"));
0.000000,0,0.000000,}
0.000000,0,0.000000,=> inline_as {
0.000010,1,0.000010,'(ref(' . $_[1] . ') eq "GLOB" '
0.000000,0,0.000000,. '&& Scalar::Util::openhandle(' . $_[1] . ')) '
0.000000,0,0.000000,. '|| (Scalar::Util::blessed(' . $_[1] . ') '
0.000000,0,0.000000,. '&& ' . $_[1] . '->isa("IO::Handle"))'
0.000021,1,0.000021,};
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'Object'
0.000000,0,0.000000,=> as 'Ref'
0.000000,0,0.000000,=> where { blessed($_) }
0.000029,2,0.000014,=> inline_as { 'Scalar::Util::blessed(' . $_[1] . ')' };
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'ClassName'
0.000000,0,0.000000,=> as 'Str'
0.000000,0,0.000000,=> where { is_class_loaded($_) }
0.000000,0,0.000000,# the long Str tests are redundant here
0.000034,3,0.000011,=> inline_as { 'Class::Load::is_class_loaded(' . $_[1] . ')' };
0.000000,0,0.000000,
0.000000,0,0.000000,subtype 'RoleName'
0.000000,0,0.000000,=> as 'ClassName'
0.000000,0,0.000000,=> where {
0.000000,0,0.000000,(Class::MOP::class_of($_) || return)->isa('Moose::Meta::Role');
0.000000,0,0.000000,}
0.000000,0,0.000000,=> inline_as {
0.000016,1,0.000016,$_[0]->parent()->_inline_check($_[1])
0.000000,0,0.000000,. ' && do {'
0.000000,0,0.000000,. 'my $meta = Class::MOP::class_of(' . $_[1] . ');'
0.000000,0,0.000000,. '$meta && $meta->isa("Moose::Meta::Role");'
0.000000,0,0.000000,. '}'
0.000020,1,0.000020,};
0.000000,0,0.000000,
0.000000,0,0.000000,$registry->add_type_constraint(
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Parameterizable->new(
0.000000,0,0.000000,name               => 'ScalarRef',
0.000000,0,0.000000,package_defined_in => __PACKAGE__,
0.000000,0,0.000000,parent =>
0.000000,0,0.000000,Moose::Util::TypeConstraints::find_type_constraint('Ref'),
0.000000,0,0.000000,constraint => sub { ref($_) eq 'SCALAR' || ref($_) eq 'REF' },
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $check = $type_parameter->_compiled_type_constraint;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,return $check->( ${$_} );
0.000000,0,0.000000,};
0.000000,0,0.000000,},
0.000000,0,0.000000,inlined => sub {
0.000009,1,0.000009,'ref(' . $_[1] . ') eq "SCALAR" '
0.000000,0,0.000000,. '|| ref(' . $_[1] . ') eq "REF"'
0.000000,0,0.000000,},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $self           = shift;
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $val            = shift;
0.000000,0,0.000000,'(ref(' . $val . ') eq "SCALAR" || ref(' . $val . ') eq "REF") '
0.000000,0,0.000000,. '&& ' . $type_parameter->_inline_check('${(' . $val . ')}')
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000027,1,0.000027,);
0.000000,0,0.000000,
0.000000,0,0.000000,$registry->add_type_constraint(
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Parameterizable->new(
0.000000,0,0.000000,name               => 'ArrayRef',
0.000000,0,0.000000,package_defined_in => __PACKAGE__,
0.000000,0,0.000000,parent =>
0.000000,0,0.000000,Moose::Util::TypeConstraints::find_type_constraint('Ref'),
0.000000,0,0.000000,constraint => sub { ref($_) eq 'ARRAY' },
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $check = $type_parameter->_compiled_type_constraint;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,foreach my $x (@$_) {
0.000000,0,0.000000,( $check->($x) ) || return;
0.000000,0,0.000000,}
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000008,1,0.000008,inlined          => sub { 'ref(' . $_[1] . ') eq "ARRAY"' },
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $self           = shift;
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $val            = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,'do {'
0.000000,0,0.000000,. 'my $check = ' . $val . ';'
0.000000,0,0.000000,. 'ref($check) eq "ARRAY" '
0.000000,0,0.000000,. '&& &List::MoreUtils::all('
0.000000,0,0.000000,. 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
0.000000,0,0.000000,. '@{$check}'
0.000000,0,0.000000,. ')'
0.000000,0,0.000000,. '}';
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000018,1,0.000018,);
0.000000,0,0.000000,
0.000000,0,0.000000,$registry->add_type_constraint(
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Parameterizable->new(
0.000000,0,0.000000,name               => 'HashRef',
0.000000,0,0.000000,package_defined_in => __PACKAGE__,
0.000000,0,0.000000,parent =>
0.000000,0,0.000000,Moose::Util::TypeConstraints::find_type_constraint('Ref'),
0.000000,0,0.000000,constraint => sub { ref($_) eq 'HASH' },
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $check = $type_parameter->_compiled_type_constraint;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,foreach my $x ( values %$_ ) {
0.000000,0,0.000000,( $check->($x) ) || return;
0.000000,0,0.000000,}
0.000000,0,0.000000,1;
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.011730,3,0.003910,inlined          => sub { 'ref(' . $_[1] . ') eq "HASH"' },
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $self           = shift;
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $val            = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,'do {'
0.000000,0,0.000000,. 'my $check = ' . $val . ';'
0.000000,0,0.000000,. 'ref($check) eq "HASH" '
0.000000,0,0.000000,. '&& &List::MoreUtils::all('
0.000000,0,0.000000,. 'sub { ' . $type_parameter->_inline_check('$_') . ' }, '
0.000000,0,0.000000,. 'values %{$check}'
0.000000,0,0.000000,. ')'
0.000000,0,0.000000,. '}';
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000018,1,0.000018,);
0.000000,0,0.000000,
0.000000,0,0.000000,$registry->add_type_constraint(
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Parameterizable->new(
0.000000,0,0.000000,name               => 'Maybe',
0.000000,0,0.000000,package_defined_in => __PACKAGE__,
0.000000,0,0.000000,parent =>
0.000000,0,0.000000,Moose::Util::TypeConstraints::find_type_constraint('Item'),
0.000000,0,0.000000,constraint           => sub {1},
0.000000,0,0.000000,constraint_generator => sub {
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $check = $type_parameter->_compiled_type_constraint;
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,return 1 if not( defined($_) ) || $check->($_);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000007,1,0.000007,inlined          => sub {'1'},
0.000000,0,0.000000,inline_generator => sub {
0.000000,0,0.000000,my $self           = shift;
0.000000,0,0.000000,my $type_parameter = shift;
0.000000,0,0.000000,my $val            = shift;
0.000000,0,0.000000,'!defined(' . $val . ') '
0.000000,0,0.000000,. '|| (' . $type_parameter->_inline_check($val) . ')'
0.000000,0,0.000000,},
0.000000,0,0.000000,)
0.000026,1,0.000026,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
