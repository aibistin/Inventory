# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Class::MOP::Mixin::HasMethods;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Class::MOP::Mixin::HasMethods::AUTHORITY = 'cpan:STEVAN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Class::MOP::Mixin::HasMethods::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000016,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000118,2,0.000059,use Class::MOP::Method::Meta;
0.000105,2,0.000052,use Class::MOP::Method::Overload;
0.000000,0,0.000000,
0.000035,2,0.000018,use Scalar::Util 'blessed', 'reftype';
0.000034,2,0.000017,use Carp         'confess';
0.000036,2,0.000018,use Sub::Name    'subname';
0.000000,0,0.000000,
0.000030,2,0.000015,use overload ();
0.000000,0,0.000000,
0.001287,2,0.000643,use base 'Class::MOP::Mixin';
0.000000,0,0.000000,
0.000139,25,0.000006,sub _meta_method_class { 'Class::MOP::Method::Meta' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _add_meta_method {
0.000039,25,0.000002,my $self = shift;
0.000045,25,0.000002,my ($name) = @_;
0.000306,25,0.000012,my $existing_method = $self->can('find_method_by_name')
0.000000,0,0.000000,? $self->find_method_by_name($name)
0.000000,0,0.000000,: $self->get_method($name);
0.000072,25,0.000003,return if $existing_method
0.000000,0,0.000000,&& $existing_method->isa($self->_meta_method_class);
0.000623,25,0.000025,$self->add_method(
0.000000,0,0.000000,$name => $self->_meta_method_class->wrap(
0.000000,0,0.000000,name                 => $name,
0.000000,0,0.000000,package_name         => $self->name,
0.000000,0,0.000000,associated_metaclass => $self,
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub wrap_method_body {
0.000196,68,0.000003,my ( $self, %args ) = @_;
0.000000,0,0.000000,
0.000467,68,0.000007,( 'CODE' eq reftype $args{body} )
0.000000,0,0.000000,|| confess "Your code block must be a CODE reference";
0.000000,0,0.000000,
0.001349,68,0.000020,$self->method_metaclass->wrap(
0.000000,0,0.000000,package_name => $self->name,
0.000000,0,0.000000,%args,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_method {
0.000709,397,0.000002,my ( $self, $method_name, $method ) = @_;
0.000662,397,0.000002,( defined $method_name && length $method_name )
0.000000,0,0.000000,|| confess "You must define a method name";
0.000000,0,0.000000,
0.002723,397,0.000007,my $package_name = $self->name;
0.000000,0,0.000000,
0.000560,397,0.000001,my $body;
0.005282,397,0.000013,if ( blessed($method) && $method->isa('Class::MOP::Method') ) {
0.002459,374,0.000007,$body = $method->body;
0.002448,374,0.000007,if ( $method->package_name ne $package_name ) {
0.000000,0,0.000000,$method = $method->clone(
0.000000,0,0.000000,package_name => $package_name,
0.000000,0,0.000000,name         => $method_name,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002005,374,0.000005,$method->attach_to_class($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# If a raw code reference is supplied, its method object is not created.
0.000000,0,0.000000,# The method object won't be created until required.
0.000035,23,0.000002,$body = $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.004227,397,0.000011,$self->_method_map->{$method_name} = $method;
0.000000,0,0.000000,
0.003072,397,0.000008,my ($current_package, $current_name) = Class::MOP::get_code_info($body);
0.000000,0,0.000000,
0.013091,397,0.000033,subname($package_name . '::' . $method_name, $body)
0.000000,0,0.000000,unless defined $current_name && $current_name !~ /^__ANON__/;
0.000000,0,0.000000,
0.002260,397,0.000006,$self->add_package_symbol("&$method_name", $body);
0.000000,0,0.000000,
0.000000,0,0.000000,# we added the method to the method map too, so it's still valid
0.009311,397,0.000023,$self->update_package_cache_flag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _code_is_mine {
0.000232,145,0.000002,my ( $self, $code ) = @_;
0.000000,0,0.000000,
0.001073,145,0.000007,my ( $code_package, $code_name ) = Class::MOP::get_code_info($code);
0.000000,0,0.000000,
0.001550,145,0.000011,return ( $code_package && $code_package eq $self->name )
0.000000,0,0.000000,|| ( $code_package eq 'constant' && $code_name eq '__ANON__' );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_method {
0.000134,78,0.000002,my ( $self, $method_name ) = @_;
0.000000,0,0.000000,
0.000134,78,0.000002,( defined $method_name && length $method_name )
0.000000,0,0.000000,|| confess "You must define a method name";
0.000000,0,0.000000,
0.000560,78,0.000007,my $method = $self->_get_maybe_raw_method($method_name)
0.000000,0,0.000000,or return;
0.000000,0,0.000000,
0.000337,28,0.000012,return defined($self->_method_map->{$method_name} = $method);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_method {
0.001069,622,0.000002,my ( $self, $method_name ) = @_;
0.000000,0,0.000000,
0.001024,622,0.000002,( defined $method_name && length $method_name )
0.000000,0,0.000000,|| confess "You must define a method name";
0.000000,0,0.000000,
0.010088,622,0.000016,my $method = $self->_get_maybe_raw_method($method_name)
0.000000,0,0.000000,or return;
0.000000,0,0.000000,
0.001912,158,0.000012,return $method if blessed($method) && $method->isa('Class::MOP::Method');
0.000000,0,0.000000,
0.001079,68,0.000016,return $self->_method_map->{$method_name} = $self->wrap_method_body(
0.000000,0,0.000000,body                 => $method,
0.000000,0,0.000000,name                 => $method_name,
0.000000,0,0.000000,associated_metaclass => $self,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_maybe_raw_method {
0.001085,700,0.000002,my ( $self, $method_name ) = @_;
0.000000,0,0.000000,
0.005784,700,0.000008,my $map_entry = $self->_method_map->{$method_name};
0.001419,700,0.000002,return $map_entry if defined $map_entry;
0.000000,0,0.000000,
0.003278,583,0.000006,my $code = $self->get_package_symbol("&$method_name");
0.000000,0,0.000000,
0.003136,583,0.000005,return unless $code && $self->_code_is_mine($code);
0.000000,0,0.000000,
0.000326,69,0.000005,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_method {
0.000000,0,0.000000,my ( $self, $method_name ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,( defined $method_name && length $method_name )
0.000000,0,0.000000,|| confess "You must define a method name";
0.000000,0,0.000000,
0.000000,0,0.000000,my $removed_method = delete $self->_method_map->{$method_name};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->remove_package_symbol("&$method_name");
0.000000,0,0.000000,
0.000000,0,0.000000,$removed_method->detach_from_class
0.000000,0,0.000000,if blessed($removed_method) && $removed_method->isa('Class::MOP::Method');
0.000000,0,0.000000,
0.000000,0,0.000000,# still valid, since we just removed the method from the map
0.000000,0,0.000000,$self->update_package_cache_flag;
0.000000,0,0.000000,
0.000000,0,0.000000,return $removed_method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_method_list {
0.000002,1,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000018,1,0.000018,return keys %{ $self->_full_method_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_local_methods {
0.000025,17,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000162,17,0.000010,return values %{ $self->_full_method_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _restore_metamethods_from {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($old_meta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $method ($old_meta->_get_local_methods) {
0.000000,0,0.000000,$method->_make_compatible_with($self->method_metaclass);
0.000000,0,0.000000,$self->add_method($method->name => $method);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reset_package_cache_flag  { (shift)->{'_package_cache_flag'} = undef }
0.000000,0,0.000000,sub update_package_cache_flag {
0.000615,397,0.000002,my $self = shift;
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we can manually update the cache number
0.000000,0,0.000000,# since we are actually adding the method
0.000000,0,0.000000,# to our cache as well. This avoids us
0.000000,0,0.000000,# having to regenerate the method_map.
0.000000,0,0.000000,# - SL
0.006398,397,0.000016,$self->{'_package_cache_flag'} = Class::MOP::check_package_cache_flag($self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _full_method_map {
0.000027,18,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000232,18,0.000013,my $pkg_gen = Class::MOP::check_package_cache_flag($self->name);
0.000000,0,0.000000,
0.000044,18,0.000002,if (($self->{_package_cache_flag_full} || -1) != $pkg_gen) {
0.000000,0,0.000000,# forcibly reify all method map entries
0.000000,0,0.000000,$self->get_method($_)
0.000453,5,0.000091,for $self->list_all_package_symbols('CODE');
0.000011,5,0.000002,$self->{_package_cache_flag_full} = $pkg_gen;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000226,18,0.000013,return $self->_method_map;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# overloading
0.000000,0,0.000000,
0.000001,1,0.000001,my $overload_operators;
0.000000,0,0.000000,sub overload_operators {
0.000000,0,0.000000,$overload_operators ||= [map { split /\s+/ } values %overload::ops];
0.000000,0,0.000000,return @$overload_operators;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_overloaded {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return overload::Overloaded($self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX this could probably stand to be cached, but i figure it should be
0.000000,0,0.000000,# uncommon enough to not particularly matter
0.000000,0,0.000000,sub _overload_map {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return {} unless $self->is_overloaded;
0.000000,0,0.000000,
0.000000,0,0.000000,my %map;
0.000000,0,0.000000,for my $op ($self->overload_operators) {
0.000000,0,0.000000,my $body = $self->_get_overloaded_operator_body($op);
0.000000,0,0.000000,next unless defined $body;
0.000000,0,0.000000,$map{$op} = $body;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \%map;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_overload_list {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return keys %{ $self->_overload_map };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_overloaded_operators {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $map = $self->_overload_map;
0.000000,0,0.000000,return map { $self->_wrap_overload($_, $map->{$_}) } keys %$map;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_overloaded_operator {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($op) = @_;
0.000000,0,0.000000,return defined $self->_get_overloaded_operator_body($op);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_overloaded_operator {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($op) = @_;
0.000000,0,0.000000,my $body = $self->_get_overloaded_operator_body($op);
0.000000,0,0.000000,return unless defined $body;
0.000000,0,0.000000,return $self->_wrap_overload($op, $body);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_overloaded_operator {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($op, $body) = @_;
0.000000,0,0.000000,$self->name->overload::OVERLOAD($op => $body);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_overloaded_operator {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($op) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $] < 5.018 ) {
0.000000,0,0.000000,# ugh, overload.pm provides no api for this - but the problem that
0.000000,0,0.000000,# makes this necessary has been fixed in 5.18
0.000000,0,0.000000,$self->get_or_add_package_symbol('%OVERLOAD')->{dummy}++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->remove_package_symbol('&(' . $op);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_overloaded_operator_body {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($op) = @_;
0.000000,0,0.000000,return overload::Method($self->name, $op);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _wrap_overload {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($op, $body) = @_;
0.000000,0,0.000000,return Class::MOP::Method::Overload->wrap(
0.000000,0,0.000000,operator             => $op,
0.000000,0,0.000000,package_name         => $self->name,
0.000000,0,0.000000,associated_metaclass => $self,
0.000000,0,0.000000,body                 => $body,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Methods for metaclasses which have methods
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
