# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Crypt::PBKDF2; 
0.000000,0,0.000000,# ABSTRACT: The PBKDF2 password hashing algorithm.
0.000002,1,0.000002,our $VERSION = '0.131750'; # VERSION
0.000002,1,0.000002,our $AUTHORITY = 'cpan:ARODLAND'; # AUTHORITY
0.000155,3,0.000052,use Moose 1;
0.000182,2,0.000091,use Method::Signatures::Simple;
0.000051,2,0.000025,use Moose::Util::TypeConstraints;
0.000119,2,0.000059,use namespace::autoclean;
0.000215,2,0.000107,use MIME::Base64 ();
0.000036,2,0.000018,use Carp qw(croak);
0.000039,2,0.000020,use Try::Tiny;
0.000000,0,0.000000,
0.000078,1,0.000078,method BUILD {
0.000000,0,0.000000,$self->hasher; # Force instantiation, so we get errors ASAP
0.000157,1,0.000157,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000006,1,0.000006,has hash_class => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => 'Str',
0.000000,0,0.000000,default => 'HMACSHA1',
0.000000,0,0.000000,predicate => 'has_hash_class',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,has hash_args => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => 'HashRef',
0.000000,0,0.000000,default => sub { +{} },
0.000009,1,0.000009,predicate => 'has_hash_args',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,has hasher => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => role_type('Crypt::PBKDF2::Hash'),
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,default => sub { shift->_lazy_hasher },
0.000012,1,0.000012,);
0.000000,0,0.000000,
0.000012,1,0.000012,has _lazy_hasher => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => role_type('Crypt::PBKDF2::Hash'),
0.000000,0,0.000000,lazy => 1,
0.000000,0,0.000000,init_arg => undef,
0.000000,0,0.000000,predicate => 'has_lazy_hasher',
0.000000,0,0.000000,builder => '_build_hasher',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000149,1,0.000149,method _build_hasher {
0.000000,0,0.000000,my $class = $self->hash_class;
0.000000,0,0.000000,if ($class !~ s/^\+//) {
0.000000,0,0.000000,$class = "Crypt::PBKDF2::Hash::$class";
0.000000,0,0.000000,}
0.000000,0,0.000000,my $hash_args = $self->hash_args;
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::load_class($class);
0.000000,0,0.000000,return $class->new( %$hash_args );
0.000080,1,0.000080,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000006,1,0.000006,has iterations => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => 'Int',
0.000000,0,0.000000,default => '1000',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000006,1,0.000006,has output_len => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => 'Int',
0.000000,0,0.000000,predicate => 'has_output_len',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000006,1,0.000006,has salt_len => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => 'Int',
0.000000,0,0.000000,default => 4,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000103,1,0.000103,method _random_salt {
0.000000,0,0.000000,my $ret = "";
0.000000,0,0.000000,for my $n (1 .. $self->salt_len) {
0.000000,0,0.000000,$ret .= chr(int rand 256);
0.000000,0,0.000000,}
0.000000,0,0.000000,return $ret;
0.000057,1,0.000057,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000006,1,0.000006,has encoding => (
0.000000,0,0.000000,is => 'ro',
0.000000,0,0.000000,isa => 'Str',
0.000000,0,0.000000,default => 'ldap',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000096,1,0.000096,method generate ($password, $salt) {
0.000000,0,0.000000,$salt = $self->_random_salt unless defined $salt;
0.000000,0,0.000000,
0.000000,0,0.000000,my $hash = $self->PBKDF2($salt, $password);
0.000000,0,0.000000,return $self->encode_string($salt, $hash);
0.000042,1,0.000042,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000204,1,0.000204,method validate ($hashed, $password) {
0.000000,0,0.000000,my $info = $self->decode_string($hashed);
0.000000,0,0.000000,
0.000000,0,0.000000,my $hasher = try {
0.000000,0,0.000000,$self->hasher_from_algorithm($info->{algorithm}, $info->{algorithm_options});
0.000000,0,0.000000,} catch {
0.000000,0,0.000000,my $opts = defined($info->{algorithm_options}) ? " (options ''$info->{algorithm_options}'')" : "";
0.000000,0,0.000000,croak "Couldn't construct hasher for ''$info->{algorithm}''$opts: $_";
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $checker = $self->clone(
0.000000,0,0.000000,hasher => $hasher,
0.000000,0,0.000000,iterations => $info->{iterations},
0.000000,0,0.000000,output_len => length($info->{hash}),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $check_hash = $checker->PBKDF2($info->{salt}, $password);
0.000000,0,0.000000,
0.000000,0,0.000000,return ($check_hash eq $info->{hash});
0.000041,1,0.000041,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000177,1,0.000177,method PBKDF2 ($salt, $password) {
0.000000,0,0.000000,my $iterations = $self->iterations;
0.000000,0,0.000000,my $hasher = $self->hasher;
0.000000,0,0.000000,my $output_len = $self->output_len || $hasher->hash_len;
0.000000,0,0.000000,
0.000000,0,0.000000,my $hLen = $hasher->hash_len;
0.000000,0,0.000000,my $l = int($output_len / $hLen);
0.000000,0,0.000000,my $r = $output_len % $hLen;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($l > 0xffffffff or $l == 0xffffffff && $r > 0) {
0.000000,0,0.000000,croak "output_len too large for PBKDF2";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $output;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $i (1 .. $l) {
0.000000,0,0.000000,$output .= $self->_PBKDF2_F($hasher, $salt, $password, $iterations, $i);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($r) {
0.000000,0,0.000000,$output .= substr( $self->_PBKDF2_F($hasher, $salt, $password, $iterations, $l + 1), 0, $r);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $output;
0.000115,1,0.000115,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub PBKDF2_base64 {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return MIME::Base64::encode( $self->PBKDF2(@_), "" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub PBKDF2_hex {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return unpack "H*", unpack "A*", $self->PBKDF2(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000129,1,0.000129,method _PBKDF2_F ($hasher, $salt, $password, $iterations, $i) {
0.000000,0,0.000000,my $result = 
0.000000,0,0.000000,my $hash = 
0.000000,0,0.000000,$hasher->generate( $salt . pack("N", $i), $password );
0.000000,0,0.000000,
0.000000,0,0.000000,for my $iter (2 .. $iterations) {
0.000000,0,0.000000,$hash = $hasher->generate( $hash, $password );
0.000000,0,0.000000,$result ^= $hash;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $result;
0.000051,1,0.000051,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000112,1,0.000112,method encode_string ($salt, $hash) {
0.000000,0,0.000000,if ($self->encoding eq 'crypt') {
0.000000,0,0.000000,return $self->_encode_string_cryptlike($salt, $hash);
0.000000,0,0.000000,} elsif ($self->encoding eq 'ldap') {
0.000000,0,0.000000,return $self->_encode_string_ldaplike($salt, $hash);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Unknown setting '", $self->encoding, "' for encoding";
0.000000,0,0.000000,}
0.000037,1,0.000037,}
0.000000,0,0.000000,
0.000188,1,0.000188,method _encode_string_cryptlike ($salt, $hash) {
0.000000,0,0.000000,my $hasher = $self->hasher;
0.000000,0,0.000000,my $hasher_class = Class::MOP::class_of($hasher)->name;
0.000000,0,0.000000,if (!defined $hasher_class || $hasher_class !~ s/^Crypt::PBKDF2::Hash:://) {
0.000000,0,0.000000,croak "Can't ''encode_string'' with a hasher class outside of Crypt::PBKDF2::Hash::*";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $algo_string = $hasher->to_algo_string;
0.000000,0,0.000000,$algo_string = defined($algo_string) ? "{$algo_string}" : "";
0.000000,0,0.000000,
0.000000,0,0.000000,return '$PBKDF2$' . "$hasher_class$algo_string:" . $self->iterations . ':'
0.000000,0,0.000000,. MIME::Base64::encode($salt, "") . '$'
0.000000,0,0.000000,. MIME::Base64::encode($hash, "");
0.000041,1,0.000041,}
0.000000,0,0.000000,
0.000189,1,0.000189,method _encode_string_ldaplike ($salt, $hash) {
0.000000,0,0.000000,my $hasher = $self->hasher;
0.000000,0,0.000000,my $hasher_class = Class::MOP::class_of($hasher)->name;
0.000000,0,0.000000,if (!defined $hasher_class || $hasher_class !~ s/^Crypt::PBKDF2::Hash:://) {
0.000000,0,0.000000,croak "Can't ''encode_string'' with a hasher class outside of Crypt::PBKDF2::Hash::*";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $algo_string = $hasher->to_algo_string;
0.000000,0,0.000000,$algo_string = defined($algo_string) ? "+$algo_string" : "";
0.000000,0,0.000000,
0.000000,0,0.000000,return '{X-PBKDF2}' . "$hasher_class$algo_string:" 
0.000000,0,0.000000,. $self->_b64_encode_int32($self->iterations) . ':'
0.000000,0,0.000000,. MIME::Base64::encode($salt, "") . ':'
0.000000,0,0.000000,. MIME::Base64::encode($hash, "");
0.000043,1,0.000043,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000124,1,0.000124,method decode_string ($hashed) {
0.000000,0,0.000000,if ($hashed =~ /^\$PBKDF2\$/) {
0.000000,0,0.000000,return $self->_decode_string_cryptlike($hashed);
0.000000,0,0.000000,} elsif ($hashed =~ /^\{X-PBKDF2}/i) {
0.000000,0,0.000000,return $self->_decode_string_ldaplike($hashed);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "Unrecognized hash";
0.000000,0,0.000000,}
0.000037,1,0.000037,}
0.000000,0,0.000000,
0.000177,1,0.000177,method _decode_string_cryptlike ($hashed) {
0.000000,0,0.000000,if ($hashed !~ /^\$PBKDF2\$/) {
0.000000,0,0.000000,croak "Unrecognized hash";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (my ($algorithm, $opts, $iterations, $salt, $hash) = $hashed =~
0.000000,0,0.000000,/^\$PBKDF2\$([^:}]+)(?:\{([^}]+)\})?:(\d+):([^\$]+)\$(.*)/) {
0.000000,0,0.000000,return {
0.000000,0,0.000000,algorithm => $algorithm,
0.000000,0,0.000000,algorithm_options => $opts,
0.000000,0,0.000000,iterations => $iterations,
0.000000,0,0.000000,salt => MIME::Base64::decode($salt),
0.000000,0,0.000000,hash => MIME::Base64::decode($hash),
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "Invalid format";
0.000000,0,0.000000,}
0.000038,1,0.000038,}
0.000000,0,0.000000,
0.000184,1,0.000184,method _decode_string_ldaplike ($hashed) {
0.000000,0,0.000000,if ($hashed !~ /^\{X-PBKDF2}/i) {
0.000000,0,0.000000,croak "Unrecognized hash";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (my ($algo_str, $iterations, $salt, $hash) = $hashed =~
0.000000,0,0.000000,/^\{X-PBKDF2}([^:]+):([^:]{6}):([^\$]+):(.*)/i) {
0.000000,0,0.000000,my ($algorithm, $opts) = split /\+/, $algo_str;
0.000000,0,0.000000,return {
0.000000,0,0.000000,algorithm => $algorithm,
0.000000,0,0.000000,algorithm_options => $opts,
0.000000,0,0.000000,iterations => $self->_b64_decode_int32($iterations),
0.000000,0,0.000000,salt => MIME::Base64::decode($salt),
0.000000,0,0.000000,hash => MIME::Base64::decode($hash),
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak "Invalid format";
0.000000,0,0.000000,}
0.000048,1,0.000048,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000130,1,0.000130,method hasher_from_algorithm ($algorithm, $args) {
0.000000,0,0.000000,if (defined $args) {
0.000000,0,0.000000,Class::MOP::load_class( "Crypt::PBKDF2::Hash::$algorithm" );
0.000000,0,0.000000,return "Crypt::PBKDF2::Hash::$algorithm"->from_algo_string($args);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,Class::MOP::load_class( "Crypt::PBKDF2::Hash::$algorithm" );
0.000000,0,0.000000,return "Crypt::PBKDF2::Hash::$algorithm"->new;
0.000000,0,0.000000,}
0.000037,1,0.000037,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000125,1,0.000125,method clone (%params) {
0.000000,0,0.000000,my $class = ref $self;
0.000000,0,0.000000,
0.000000,0,0.000000,# If the hasher was built from hash_class and hash_args, then omit it from
0.000000,0,0.000000,# the clone. But if it was set by the user, then we need to copy it. We're
0.000000,0,0.000000,# assuming that the hasher has no state, so it doesn't need a deep clone.
0.000000,0,0.000000,# This is true of all of the ones that I'm shipping, but if it's not true for
0.000000,0,0.000000,# you, let me know.
0.000000,0,0.000000,
0.000000,0,0.000000,my %new_args = (
0.000000,0,0.000000,$self->has_hash_class  ? (hash_class  => $self->hash_class) : (),
0.000000,0,0.000000,$self->has_hash_args   ? (hash_args   => $self->hash_args)  : (),
0.000000,0,0.000000,$self->has_output_len  ? (output_len  => $self->output_len) : (),
0.000000,0,0.000000,$self->has_lazy_hasher ? () : (hasher => $self->hasher),
0.000000,0,0.000000,iterations => $self->iterations,
0.000000,0,0.000000,salt_len => $self->salt_len,
0.000000,0,0.000000,%params,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $class->new(%new_args);
0.000049,1,0.000049,}
0.000000,0,0.000000,
0.000106,1,0.000106,method _b64_encode_int32 ($value) {
0.000000,0,0.000000,my $b64 = MIME::Base64::encode(pack("N", $value), "");
0.000000,0,0.000000,$b64 =~ s/==$//;
0.000000,0,0.000000,return $b64;
0.000036,1,0.000036,}
0.000000,0,0.000000,
0.000089,1,0.000089,method _b64_decode_int32 ($b64) {
0.000000,0,0.000000,$b64 .= "==";
0.000000,0,0.000000,return unpack "N", MIME::Base64::decode($b64);
0.000049,1,0.000049,}
0.000000,0,0.000000,
0.000014,1,0.000014,__PACKAGE__->meta->make_immutable;
0.000077,1,0.000077,1;
0.000000,0,0.000000,
0.000038,1,0.000038,__END__
