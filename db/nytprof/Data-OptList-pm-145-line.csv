# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000032,2,0.000016,use strict;
0.000048,2,0.000024,use warnings;
0.000000,0,0.000000,package Data::OptList;
0.000000,0,0.000000,{
0.000005,2,0.000002,$Data::OptList::VERSION = '0.108';
0.000000,0,0.000000,}
0.000000,0,0.000000,# ABSTRACT: parse and validate simple name/value option pairs
0.000000,0,0.000000,
0.000028,2,0.000014,use List::Util ();
0.000124,2,0.000062,use Params::Util ();
0.000153,3,0.000051,use Sub::Install 0.921 ();
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000001,1,0.000001,my %test_for;
0.000000,0,0.000000,BEGIN {
0.000009,1,0.000009,%test_for = (
0.000000,0,0.000000,CODE   => \&Params::Util::_CODELIKE,  ## no critic
0.000000,0,0.000000,HASH   => \&Params::Util::_HASHLIKE,  ## no critic
0.000000,0,0.000000,ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
0.000000,0,0.000000,SCALAR => \&Params::Util::_SCALAR0,   ## no critic
0.000000,0,0.000000,);
0.000421,1,0.000421,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub __is_a {
0.000124,78,0.000002,my ($got, $expected) = @_;
0.000000,0,0.000000,
0.000722,119,0.000006,return List::Util::first { __is_a($got, $_) } @$expected if ref $expected;
0.000000,0,0.000000,
0.000000,0,0.000000,return defined (
0.000477,41,0.000012,exists($test_for{$expected})
0.000000,0,0.000000,? $test_for{$expected}->($got)
0.000000,0,0.000000,: Params::Util::_INSTANCE($got, $expected) ## no critic
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkopt {
0.000058,35,0.000002,my ($opt_list) = shift;
0.000000,0,0.000000,
0.000049,35,0.000001,my ($moniker, $require_unique, $must_be); # the old positional args
0.000000,0,0.000000,my $name_test;
0.000000,0,0.000000,
0.000165,35,0.000005,if (@_ == 1 and Params::Util::_HASHLIKE($_[0])) {
0.000000,0,0.000000,my $arg = $_[0];
0.000000,0,0.000000,($moniker, $require_unique, $must_be, $name_test)
0.000000,0,0.000000,= @$arg{ qw(moniker require_unique must_be name_test) };
0.000000,0,0.000000,} else {
0.000068,35,0.000002,($moniker, $require_unique, $must_be) = @_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000056,35,0.000002,$moniker = 'unnamed' unless defined $moniker;
0.000000,0,0.000000,
0.000049,35,0.000001,return [] unless $opt_list;
0.000000,0,0.000000,
0.000663,134,0.000005,$name_test ||= sub { ! ref $_[0] };
0.000000,0,0.000000,
0.000000,0,0.000000,$opt_list = [
0.000100,35,0.000003,map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
0.000000,0,0.000000,] if ref $opt_list eq 'HASH';
0.000000,0,0.000000,
0.000050,35,0.000001,my @return;
0.000050,35,0.000001,my %seen;
0.000000,0,0.000000,
0.000509,35,0.000015,for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
0.000179,110,0.000002,my $name = $opt_list->[$i];
0.000149,110,0.000001,my $value;
0.000000,0,0.000000,
0.000177,110,0.000002,if ($require_unique) {
0.000000,0,0.000000,Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000646,110,0.000006,if    ($i == $#$opt_list)               { $value = undef;            }
0.000000,0,0.000000,elsif (not defined $opt_list->[$i+1])   { $value = undef; $i++       }
0.000000,0,0.000000,elsif ($name_test->($opt_list->[$i+1])) { $value = undef;            }
0.000063,37,0.000002,else                                    { $value = $opt_list->[++$i] }
0.000000,0,0.000000,
0.000236,110,0.000002,if ($must_be and defined $value) {
0.000188,37,0.000005,unless (__is_a($value, $must_be)) {
0.000000,0,0.000000,my $ref = ref $value;
0.000000,0,0.000000,Carp::croak "$ref-ref values are not valid in $moniker opt list";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000257,110,0.000002,push @return, [ $name => $value ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000252,35,0.000007,return \@return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub mkopt_hash {
0.000023,12,0.000002,my ($opt_list, $moniker, $must_be) = @_;
0.000030,12,0.000002,return {} unless $opt_list;
0.000000,0,0.000000,
0.000045,9,0.000005,$opt_list = mkopt($opt_list, $moniker, 1, $must_be);
0.000059,9,0.000007,my %hash = map { $_->[0] => $_->[1] } @$opt_list;
0.000058,9,0.000006,return \%hash;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000012,1,0.000012,*import = Sub::Install::exporter {
0.000000,0,0.000000,exports => [qw(mkopt mkopt_hash)],
0.000000,0,0.000000,};
0.000028,1,0.000028,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
