# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Log::Log4perl::Config::Watch;
0.000000,0,0.000000,
0.000915,2,0.000458,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000001,1,0.000001,our $NEXT_CHECK_TIME;
0.000001,1,0.000001,our $SIGNAL_CAUGHT;
0.000000,0,0.000000,
0.000001,1,0.000001,our $L4P_TEST_CHANGE_DETECTED;
0.000001,1,0.000001,our $L4P_TEST_CHANGE_CHECKED;
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($class, %options) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = { file            => "",
0.000000,0,0.000000,check_interval  => 30,
0.000000,0,0.000000,l4p_internal    => 0,
0.000000,0,0.000000,signal          => undef,
0.000000,0,0.000000,%options,
0.000000,0,0.000000,_last_checked_at => 0,
0.000000,0,0.000000,_last_timestamp  => 0,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,bless $self, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,if($self->{signal}) {
0.000000,0,0.000000,# We're in signal mode, set up the handler
0.000000,0,0.000000,print "Setting up signal handler for '$self->{signal}'\n" if
0.000000,0,0.000000,_INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# save old signal handlers; they belong to other appenders or
0.000000,0,0.000000,# possibly something else in the consuming application
0.000000,0,0.000000,my $old_sig_handler = $SIG{$self->{signal}};
0.000000,0,0.000000,$SIG{$self->{signal}} = sub { 
0.000000,0,0.000000,print "Caught $self->{signal} signal\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$self->force_next_check();
0.000000,0,0.000000,$old_sig_handler->(@_) if $old_sig_handler and ref $old_sig_handler eq 'CODE';
0.000000,0,0.000000,};
0.000000,0,0.000000,# Reset the marker. The handler is going to modify it.
0.000000,0,0.000000,$self->{signal_caught} = 0;
0.000000,0,0.000000,$SIGNAL_CAUGHT = 0 if $self->{l4p_internal};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Just called to initialize
0.000000,0,0.000000,$self->change_detected(undef, 1);
0.000000,0,0.000000,$self->file_has_moved(undef, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub force_next_check {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{signal_caught}   = 1;
0.000000,0,0.000000,$self->{next_check_time} = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if( $self->{l4p_internal} ) {
0.000000,0,0.000000,$SIGNAL_CAUGHT = 1;
0.000000,0,0.000000,$NEXT_CHECK_TIME = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub force_next_check_reset {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{signal_caught} = 0;
0.000000,0,0.000000,$SIGNAL_CAUGHT = 0 if $self->{l4p_internal};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub file {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{file};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub signal {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{signal};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub check_interval {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{check_interval};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub file_has_moved {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self, $time, $force) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $task = sub {
0.000000,0,0.000000,my @stat = stat($self->{file});
0.000000,0,0.000000,
0.000000,0,0.000000,my $has_moved = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,if(! $stat[0]) {
0.000000,0,0.000000,# The file's gone, obviously it got moved or deleted.
0.000000,0,0.000000,print "File is gone\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $current_inode = "$stat[0]:$stat[1]";
0.000000,0,0.000000,print "Current inode: $current_inode\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $self->{_file_inode} and 
0.000000,0,0.000000,$self->{_file_inode} ne $current_inode) {
0.000000,0,0.000000,print "Inode changed from $self->{_file_inode} to ",
0.000000,0,0.000000,"$current_inode\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$has_moved = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{_file_inode} = $current_inode;
0.000000,0,0.000000,return $has_moved;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->check($time, $task, $force);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub change_detected {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self, $time, $force) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $task = sub {
0.000000,0,0.000000,my @stat = stat($self->{file});
0.000000,0,0.000000,my $new_timestamp = $stat[9];
0.000000,0,0.000000,
0.000000,0,0.000000,$L4P_TEST_CHANGE_CHECKED = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if(! defined $new_timestamp) {
0.000000,0,0.000000,if($self->{l4p_internal}) {
0.000000,0,0.000000,# The file is gone? Let it slide, we don't want L4p to re-read
0.000000,0,0.000000,# the config now, it's gonna die.
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,$L4P_TEST_CHANGE_DETECTED = 1;
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($new_timestamp > $self->{_last_timestamp}) {
0.000000,0,0.000000,$self->{_last_timestamp} = $new_timestamp;
0.000000,0,0.000000,print "Change detected (file=$self->{file} store=$new_timestamp)\n"
0.000000,0,0.000000,if _INTERNAL_DEBUG;
0.000000,0,0.000000,$L4P_TEST_CHANGE_DETECTED = 1;
0.000000,0,0.000000,return 1; # Has changed
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print "$self->{file} unchanged (file=$new_timestamp ",
0.000000,0,0.000000,"stored=$self->{_last_timestamp})!\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,return "";  # Hasn't changed
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->check($time, $task, $force);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub check {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($self, $time, $task, $force) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$time = time() unless defined $time;
0.000000,0,0.000000,
0.000000,0,0.000000,if( $self->{signal_caught} or $SIGNAL_CAUGHT ) {
0.000000,0,0.000000,$force = 1;
0.000000,0,0.000000,$self->force_next_check_reset();
0.000000,0,0.000000,print "Caught signal, forcing check\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print "Soft check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# Do we need to check?
0.000000,0,0.000000,if(!$force and
0.000000,0,0.000000,$self->{_last_checked_at} + 
0.000000,0,0.000000,$self->{check_interval} > $time) {
0.000000,0,0.000000,print "No need to check\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,return ""; # don't need to check, return false
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{_last_checked_at} = $time;
0.000000,0,0.000000,
0.000000,0,0.000000,# Set global var for optimizations in case we just have one watcher
0.000000,0,0.000000,# (like in Log::Log4perl)
0.000000,0,0.000000,$self->{next_check_time} = $time + $self->{check_interval};
0.000000,0,0.000000,$NEXT_CHECK_TIME = $self->{next_check_time} if $self->{l4p_internal};
0.000000,0,0.000000,
0.000000,0,0.000000,print "Hard check (file=$self->{file} time=$time)\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,return $task->($time);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
