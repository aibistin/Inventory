# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Class::MOP::Attribute;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Class::MOP::Attribute::AUTHORITY = 'cpan:STEVAN';
0.000036,1,0.000036,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Class::MOP::Attribute::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000034,2,0.000017,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000032,2,0.000016,use Class::MOP::Method::Accessor;
0.000000,0,0.000000,
0.000036,2,0.000018,use Carp         'confess';
0.000034,2,0.000017,use Scalar::Util 'blessed', 'weaken';
0.000037,2,0.000018,use Try::Tiny;
0.000000,0,0.000000,
0.002055,2,0.001028,use base 'Class::MOP::Object', 'Class::MOP::Mixin::AttributeCore';
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: (meta-circularity)
0.000000,0,0.000000,# This method will be replaced in the
0.000000,0,0.000000,# boostrap section of Class::MOP, by
0.000000,0,0.000000,# a new version which uses the
0.000000,0,0.000000,# &Class::MOP::Class::construct_instance
0.000000,0,0.000000,# method to build an attribute meta-object
0.000000,0,0.000000,# which itself is described with attribute
0.000000,0,0.000000,# meta-objects.
0.000000,0,0.000000,#     - Ain't meta-circularity grand? :)
0.000000,0,0.000000,sub new {
0.000388,131,0.000003,my ( $class, @args ) = @_;
0.000000,0,0.000000,
0.000292,131,0.000002,unshift @args, "name" if @args % 2 == 1;
0.000411,131,0.000003,my %options = @args;
0.000000,0,0.000000,
0.000223,131,0.000002,my $name = $options{name};
0.000000,0,0.000000,
0.000191,131,0.000001,(defined $name)
0.000000,0,0.000000,|| confess "You must provide a name for the attribute";
0.000000,0,0.000000,
0.000273,131,0.000002,$options{init_arg} = $name
0.000000,0,0.000000,if not exists $options{init_arg};
0.000395,131,0.000003,if(exists $options{builder}){
0.000002,1,0.000002,confess("builder must be a defined scalar value which is a method name")
0.000000,0,0.000000,if ref $options{builder} || !(defined $options{builder});
0.000002,1,0.000002,confess("Setting both default and builder is not allowed.")
0.000000,0,0.000000,if exists $options{default};
0.000000,0,0.000000,} else {
0.000382,130,0.000003,($class->is_default_a_coderef(\%options))
0.000000,0,0.000000,|| confess("References are not allowed as default values, you must ".
0.000000,0,0.000000,"wrap the default of '$name' in a CODE reference (ex: sub { [] } and not [])")
0.000000,0,0.000000,if exists $options{default} && ref $options{default};
0.000000,0,0.000000,}
0.000199,131,0.000002,if( $options{required} and not( defined($options{builder}) || defined($options{init_arg}) || exists $options{default} ) ) {
0.000000,0,0.000000,confess("A required attribute must have either 'init_arg', 'builder', or 'default'");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001274,131,0.000010,$class->_new(\%options);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000189,123,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000205,123,0.000002,return Class::MOP::Class->initialize($class)->new_object(@_)
0.000000,0,0.000000,if $class ne __PACKAGE__;
0.000000,0,0.000000,
0.000209,122,0.000002,my $options = @_ == 1 ? $_[0] : {@_};
0.000000,0,0.000000,
0.001498,122,0.000012,bless {
0.000000,0,0.000000,'name'               => $options->{name},
0.000000,0,0.000000,'accessor'           => $options->{accessor},
0.000000,0,0.000000,'reader'             => $options->{reader},
0.000000,0,0.000000,'writer'             => $options->{writer},
0.000000,0,0.000000,'predicate'          => $options->{predicate},
0.000000,0,0.000000,'clearer'            => $options->{clearer},
0.000000,0,0.000000,'builder'            => $options->{builder},
0.000000,0,0.000000,'init_arg'           => $options->{init_arg},
0.000000,0,0.000000,exists $options->{default}
0.000000,0,0.000000,? ('default'     => $options->{default})
0.000000,0,0.000000,: (),
0.000000,0,0.000000,'initializer'        => $options->{initializer},
0.000000,0,0.000000,'definition_context' => $options->{definition_context},
0.000000,0,0.000000,# keep a weakened link to the
0.000000,0,0.000000,# class we are associated with
0.000000,0,0.000000,'associated_class' => undef,
0.000000,0,0.000000,# and a list of the methods
0.000000,0,0.000000,# associated with this attr
0.000000,0,0.000000,'associated_methods' => [],
0.000000,0,0.000000,# this let's us keep track of
0.000000,0,0.000000,# our order inside the associated
0.000000,0,0.000000,# class
0.000000,0,0.000000,'insertion_order'    => undef,
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# this is a primitive (and kludgy) clone operation
0.000000,0,0.000000,# for now, it will be replaced in the Class::MOP
0.000000,0,0.000000,# bootstrap with a proper one, however we know
0.000000,0,0.000000,# that this one will work fine for now.
0.000000,0,0.000000,sub clone {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,(blessed($self))
0.000000,0,0.000000,|| confess "Can only clone an instance";
0.000000,0,0.000000,return bless { %{$self}, %options } => ref($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub initialize_instance_slot {
0.000539,317,0.000002,my ($self, $meta_instance, $instance, $params) = @_;
0.000610,317,0.000002,my $init_arg = $self->{'init_arg'};
0.000000,0,0.000000,
0.000000,0,0.000000,# try to fetch the init arg from the %params ...
0.000000,0,0.000000,
0.000000,0,0.000000,# if nothing was in the %params, we can use the
0.000000,0,0.000000,# attribute's default value (if it has one)
0.002528,317,0.000008,if(defined $init_arg and exists $params->{$init_arg}){
0.000000,0,0.000000,$self->_set_initial_slot_value(
0.000000,0,0.000000,$meta_instance,
0.000000,0,0.000000,$instance,
0.000000,0,0.000000,$params->{$init_arg},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (exists $self->{'default'}) {
0.000000,0,0.000000,$self->_set_initial_slot_value(
0.000000,0,0.000000,$meta_instance,
0.000000,0,0.000000,$instance,
0.000000,0,0.000000,$self->default($instance),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (defined( my $builder = $self->{'builder'})) {
0.000000,0,0.000000,if ($builder = $instance->can($builder)) {
0.000000,0,0.000000,$self->_set_initial_slot_value(
0.000000,0,0.000000,$meta_instance,
0.000000,0,0.000000,$instance,
0.000000,0,0.000000,$instance->$builder,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,confess(ref($instance)." does not support builder method '". $self->{'builder'} ."' for attribute '" . $self->name . "'");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _set_initial_slot_value {
0.000394,241,0.000002,my ($self, $meta_instance, $instance, $value) = @_;
0.000000,0,0.000000,
0.001652,241,0.000007,my $slot_name = $self->name;
0.000000,0,0.000000,
0.002841,241,0.000012,return $meta_instance->set_slot_value($instance, $slot_name, $value)
0.000000,0,0.000000,unless $self->has_initializer;
0.000000,0,0.000000,
0.000000,0,0.000000,my $callback = $self->_make_initializer_writer_callback(
0.000000,0,0.000000,$meta_instance, $instance, $slot_name
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $initializer = $self->initializer;
0.000000,0,0.000000,
0.000000,0,0.000000,# most things will just want to set a value, so make it first arg
0.000000,0,0.000000,$instance->$initializer($value, $callback, $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_initializer_writer_callback {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($meta_instance, $instance, $slot_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,$meta_instance->set_slot_value($instance, $slot_name, $_[0]);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_read_method  {
0.000000,0,0.000000,my $self   = shift;
0.000000,0,0.000000,my $reader = $self->reader || $self->accessor;
0.000000,0,0.000000,# normal case ...
0.000000,0,0.000000,return $reader unless ref $reader;
0.000000,0,0.000000,# the HASH ref case
0.000000,0,0.000000,my ($name) = %$reader;
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_write_method {
0.000000,0,0.000000,my $self   = shift;
0.000000,0,0.000000,my $writer = $self->writer || $self->accessor;
0.000000,0,0.000000,# normal case ...
0.000000,0,0.000000,return $writer unless ref $writer;
0.000000,0,0.000000,# the HASH ref case
0.000000,0,0.000000,my ($name) = %$writer;
0.000000,0,0.000000,return $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_read_method_ref {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if ((my $reader = $self->get_read_method) && $self->associated_class) {
0.000000,0,0.000000,return $self->associated_class->get_method($reader);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $code = sub { $self->get_value(@_) };
0.000000,0,0.000000,if (my $class = $self->associated_class) {
0.000000,0,0.000000,return $class->method_metaclass->wrap(
0.000000,0,0.000000,$code,
0.000000,0,0.000000,package_name => $class->name,
0.000000,0,0.000000,name         => '__ANON__'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_write_method_ref {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,if ((my $writer = $self->get_write_method) && $self->associated_class) {
0.000000,0,0.000000,return $self->associated_class->get_method($writer);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $code = sub { $self->set_value(@_) };
0.000000,0,0.000000,if (my $class = $self->associated_class) {
0.000000,0,0.000000,return $class->method_metaclass->wrap(
0.000000,0,0.000000,$code,
0.000000,0,0.000000,package_name => $class->name,
0.000000,0,0.000000,name         => '__ANON__'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# slots
0.000000,0,0.000000,
0.004226,454,0.000009,sub slots { (shift)->name }
0.000000,0,0.000000,
0.000000,0,0.000000,# class association
0.000000,0,0.000000,
0.000000,0,0.000000,sub attach_to_class {
0.000196,131,0.000001,my ($self, $class) = @_;
0.001570,131,0.000012,(blessed($class) && $class->isa('Class::MOP::Class'))
0.000000,0,0.000000,|| confess "You must pass a Class::MOP::Class instance (or a subclass)";
0.001393,131,0.000011,weaken($self->{'associated_class'} = $class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub detach_from_class {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->{'associated_class'} = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# method association
0.000000,0,0.000000,
0.000000,0,0.000000,sub associate_method {
0.000426,259,0.000002,my ($self, $method) = @_;
0.001514,259,0.000006,push @{$self->{'associated_methods'}} => $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Slot management
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_initial_value {
0.000000,0,0.000000,my ($self, $instance, $value) = @_;
0.000000,0,0.000000,$self->_set_initial_slot_value(
0.000000,0,0.000000,Class::MOP::Class->initialize(ref($instance))->get_meta_instance,
0.000000,0,0.000000,$instance,
0.000000,0,0.000000,$value
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_value { shift->set_raw_value(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_raw_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($instance, $value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
0.000000,0,0.000000,return $mi->set_slot_value($instance, $self->name, $value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_set_value {
0.000608,408,0.000001,my $self = shift;
0.003485,408,0.000009,return $self->_inline_instance_set(@_) . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_instance_set {
0.000587,410,0.000001,my $self = shift;
0.000658,410,0.000002,my ($instance, $value) = @_;
0.000000,0,0.000000,
0.004094,410,0.000010,my $mi = $self->associated_class->get_meta_instance;
0.005526,410,0.000013,return $mi->inline_set_slot_value($instance, $self->name, $value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000107,12,0.000009,sub get_value { shift->get_raw_value(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_raw_value {
0.000017,12,0.000001,my $self = shift;
0.000018,12,0.000001,my ($instance) = @_;
0.000000,0,0.000000,
0.000118,12,0.000010,my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
0.000167,12,0.000014,return $mi->get_slot_value($instance, $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_get_value {
0.000112,75,0.000001,my $self = shift;
0.000646,75,0.000009,return $self->_inline_instance_get(@_) . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_instance_get {
0.000123,85,0.000001,my $self = shift;
0.000139,85,0.000002,my ($instance) = @_;
0.000000,0,0.000000,
0.000877,85,0.000010,my $mi = $self->associated_class->get_meta_instance;
0.001205,85,0.000014,return $mi->inline_get_slot_value($instance, $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_value {
0.000018,12,0.000002,my $self = shift;
0.000024,12,0.000002,my ($instance) = @_;
0.000000,0,0.000000,
0.000105,12,0.000009,my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
0.000182,12,0.000015,return $mi->is_slot_initialized($instance, $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_has_value {
0.000032,20,0.000002,my $self = shift;
0.000182,20,0.000009,return $self->_inline_instance_has(@_) . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_instance_has {
0.000033,22,0.000002,my $self = shift;
0.000037,22,0.000002,my ($instance) = @_;
0.000000,0,0.000000,
0.000232,22,0.000011,my $mi = $self->associated_class->get_meta_instance;
0.000320,22,0.000015,return $mi->inline_is_slot_initialized($instance, $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clear_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($instance) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $mi = Class::MOP::Class->initialize(ref($instance))->get_meta_instance;
0.000000,0,0.000000,return $mi->deinitialize_slot($instance, $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_clear_value {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,return $self->_inline_instance_clear(@_) . ';';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_instance_clear {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($instance) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $mi = $self->associated_class->get_meta_instance;
0.000000,0,0.000000,return $mi->inline_deinitialize_slot($instance, $self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## load em up ...
0.000000,0,0.000000,
0.001178,245,0.000005,sub accessor_metaclass { 'Class::MOP::Method::Accessor' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_accessors {
0.000502,259,0.000002,my ($self, $type, $accessor, $generate_as_inline_methods) = @_;
0.000000,0,0.000000,
0.002534,259,0.000010,my $method_ctx = { %{ $self->definition_context || {} } };
0.000000,0,0.000000,
0.000429,259,0.000002,if (ref($accessor)) {
0.000087,57,0.000002,(ref($accessor) eq 'HASH')
0.000000,0,0.000000,|| confess "bad accessor/reader/writer/predicate/clearer format, must be a HASH ref";
0.000117,57,0.000002,my ($name, $method) = %{$accessor};
0.000000,0,0.000000,
0.000332,57,0.000006,$method_ctx->{description} = $self->_accessor_description($name, $type);
0.000000,0,0.000000,
0.001378,57,0.000024,$method = $self->accessor_metaclass->wrap(
0.000000,0,0.000000,$method,
0.000000,0,0.000000,attribute    => $self,
0.000000,0,0.000000,package_name => $self->associated_class->name,
0.000000,0,0.000000,name         => $name,
0.000000,0,0.000000,associated_metaclass => $self->associated_class,
0.000000,0,0.000000,definition_context => $method_ctx,
0.000000,0,0.000000,);
0.000285,57,0.000005,$self->associate_method($method);
0.000310,57,0.000005,return ($name, $method);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.001663,202,0.000008,my $inline_me = ($generate_as_inline_methods && $self->associated_class->instance_metaclass->is_inlinable);
0.000279,202,0.000001,my $method;
0.000000,0,0.000000,try {
0.001176,202,0.000006,$method_ctx->{description} = $self->_accessor_description($accessor, $type);
0.000000,0,0.000000,
0.005263,202,0.000026,$method = $self->accessor_metaclass->new(
0.000000,0,0.000000,attribute     => $self,
0.000000,0,0.000000,is_inline     => $inline_me,
0.000000,0,0.000000,accessor_type => $type,
0.000000,0,0.000000,package_name  => $self->associated_class->name,
0.000000,0,0.000000,name          => $accessor,
0.000000,0,0.000000,associated_metaclass => $self->associated_class,
0.000000,0,0.000000,definition_context => $method_ctx,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,catch {
0.000000,0,0.000000,confess "Could not create the '$type' method for " . $self->name . " because : $_";
0.003011,202,0.000015,};
0.001107,202,0.000005,$self->associate_method($method);
0.001129,202,0.000006,return ($accessor, $method);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _accessor_description {
0.000397,259,0.000002,my $self = shift;
0.000442,259,0.000002,my ($name, $type) = @_;
0.000000,0,0.000000,
0.003243,259,0.000013,my $desc = "$type " . $self->associated_class->name . "::$name";
0.002260,259,0.000009,if ( $name ne $self->name ) {
0.000000,0,0.000000,$desc .= " of attribute " . $self->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001439,259,0.000006,return $desc;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub install_accessors {
0.000313,207,0.000002,my $self   = shift;
0.000298,207,0.000001,my $inline = shift;
0.001477,207,0.000007,my $class  = $self->associated_class;
0.000000,0,0.000000,
0.001726,207,0.000008,$class->add_method(
0.000000,0,0.000000,$self->_process_accessors('accessor' => $self->accessor(), $inline)
0.000000,0,0.000000,) if $self->has_accessor();
0.000000,0,0.000000,
0.003194,207,0.000015,$class->add_method(
0.000000,0,0.000000,$self->_process_accessors('reader' => $self->reader(), $inline)
0.000000,0,0.000000,) if $self->has_reader();
0.000000,0,0.000000,
0.001235,207,0.000006,$class->add_method(
0.000000,0,0.000000,$self->_process_accessors('writer' => $self->writer(), $inline)
0.000000,0,0.000000,) if $self->has_writer();
0.000000,0,0.000000,
0.001701,207,0.000008,$class->add_method(
0.000000,0,0.000000,$self->_process_accessors('predicate' => $self->predicate(), $inline)
0.000000,0,0.000000,) if $self->has_predicate();
0.000000,0,0.000000,
0.001093,207,0.000005,$class->add_method(
0.000000,0,0.000000,$self->_process_accessors('clearer' => $self->clearer(), $inline)
0.000000,0,0.000000,) if $self->has_clearer();
0.000000,0,0.000000,
0.001036,207,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000003,1,0.000003,my $_remove_accessor = sub {
0.000000,0,0.000000,my ($accessor, $class) = @_;
0.000000,0,0.000000,if (ref($accessor) && ref($accessor) eq 'HASH') {
0.000000,0,0.000000,($accessor) = keys %{$accessor};
0.000000,0,0.000000,}
0.000000,0,0.000000,my $method = $class->get_method($accessor);
0.000000,0,0.000000,$class->remove_method($accessor)
0.000000,0,0.000000,if (ref($method) && $method->isa('Class::MOP::Method::Accessor'));
0.000003,1,0.000003,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_accessors {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,# TODO:
0.000000,0,0.000000,# we really need to make sure to remove from the
0.000000,0,0.000000,# associates methods here as well. But this is
0.000000,0,0.000000,# such a slimly used method, I am not worried
0.000000,0,0.000000,# about it right now.
0.000000,0,0.000000,$_remove_accessor->($self->accessor(),  $self->associated_class()) if $self->has_accessor();
0.000000,0,0.000000,$_remove_accessor->($self->reader(),    $self->associated_class()) if $self->has_reader();
0.000000,0,0.000000,$_remove_accessor->($self->writer(),    $self->associated_class()) if $self->has_writer();
0.000000,0,0.000000,$_remove_accessor->($self->predicate(), $self->associated_class()) if $self->has_predicate();
0.000000,0,0.000000,$_remove_accessor->($self->clearer(),   $self->associated_class()) if $self->has_clearer();
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Attribute Meta Object
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
