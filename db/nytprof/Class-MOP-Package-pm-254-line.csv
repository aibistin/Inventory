# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Class::MOP::Package;
0.000000,0,0.000000,BEGIN {
0.000012,1,0.000012,$Class::MOP::Package::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Class::MOP::Package::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000037,2,0.000018,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000038,2,0.000019,use Scalar::Util 'blessed', 'reftype', 'weaken';
0.000034,2,0.000017,use Carp         'confess';
0.000110,2,0.000055,use Devel::GlobalDestruction 'in_global_destruction';
0.000114,2,0.000057,use Package::Stash;
0.000000,0,0.000000,
0.000286,2,0.000143,use base 'Class::MOP::Object';
0.000000,0,0.000000,
0.000000,0,0.000000,# creation ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub initialize {
0.000005,2,0.000002,my ( $class, @args ) = @_;
0.000000,0,0.000000,
0.000005,2,0.000003,unshift @args, "package" if @args % 2;
0.000000,0,0.000000,
0.000005,2,0.000002,my %options = @args;
0.000005,2,0.000002,my $package_name = delete $options{package};
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# we hand-construct the class until we can bootstrap it
0.000011,2,0.000005,if ( my $meta = Class::MOP::get_metaclass_by_name($package_name) ) {
0.000000,0,0.000000,return $meta;
0.000000,0,0.000000,} else {
0.000017,2,0.000008,my $meta = ( ref $class || $class )->_new({
0.000000,0,0.000000,'package'   => $package_name,
0.000000,0,0.000000,%options,
0.000000,0,0.000000,});
0.000010,2,0.000005,Class::MOP::store_metaclass_by_name($package_name, $meta);
0.000000,0,0.000000,
0.000003,2,0.000002,Class::MOP::weaken_metaclass($package_name) if $options{weaken};
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000019,2,0.000009,return $meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinitialize {
0.000000,0,0.000000,my ( $class, @args ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @args, "package" if @args % 2;
0.000000,0,0.000000,
0.000000,0,0.000000,my %options = @args;
0.000000,0,0.000000,my $package_name = delete $options{package};
0.000000,0,0.000000,
0.000000,0,0.000000,(defined $package_name && $package_name
0.000000,0,0.000000,&& (!blessed $package_name || $package_name->isa('Class::MOP::Package')))
0.000000,0,0.000000,|| confess "You must pass a package name or an existing Class::MOP::Package instance";
0.000000,0,0.000000,
0.000000,0,0.000000,$package_name = $package_name->name
0.000000,0,0.000000,if blessed $package_name;
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::remove_metaclass_by_name($package_name);
0.000000,0,0.000000,
0.000000,0,0.000000,$class->initialize($package_name, %options); # call with first arg form for compat
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create {
0.000003,2,0.000002,my $class = shift;
0.000004,2,0.000002,my @args = @_;
0.000000,0,0.000000,
0.000019,2,0.000009,return $class->initialize(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## ANON packages
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# this should be sufficient, if you have a
0.000000,0,0.000000,# use case where it is not, write a test and
0.000000,0,0.000000,# I will change it.
0.000004,2,0.000002,my $ANON_SERIAL = 0;
0.000000,0,0.000000,
0.000002,1,0.000002,my %ANON_PACKAGE_CACHE;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we need a sufficiently annoying prefix
0.000000,0,0.000000,# this should suffice for now, this is
0.000000,0,0.000000,# used in a couple of places below, so
0.000000,0,0.000000,# need to put it up here for now.
0.000000,0,0.000000,sub _anon_package_prefix { 'Class::MOP::Package::__ANON__::SERIAL::' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_anon {
0.000000,0,0.000000,my $self = shift;
0.000292,2,0.000146,no warnings 'uninitialized';
0.000000,0,0.000000,my $prefix = $self->_anon_package_prefix;
0.000000,0,0.000000,$self->name =~ /^\Q$prefix/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_anon {
0.000000,0,0.000000,my ($class, %options) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $cache_ok = delete $options{cache};
0.000000,0,0.000000,$options{weaken} = !$cache_ok unless exists $options{weaken};
0.000000,0,0.000000,
0.000000,0,0.000000,my $cache_key;
0.000000,0,0.000000,if ($cache_ok) {
0.000000,0,0.000000,$cache_key = $class->_anon_cache_key(%options);
0.000000,0,0.000000,undef $cache_ok if !defined($cache_key);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($cache_ok) {
0.000000,0,0.000000,if (defined $ANON_PACKAGE_CACHE{$cache_key}) {
0.000000,0,0.000000,return $ANON_PACKAGE_CACHE{$cache_key};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $package_name = $class->_anon_package_prefix . ++$ANON_SERIAL;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = $class->create($package_name, %options);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($cache_ok) {
0.000000,0,0.000000,$ANON_PACKAGE_CACHE{$cache_key} = $meta;
0.000000,0,0.000000,weaken($ANON_PACKAGE_CACHE{$cache_key});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _anon_cache_key { confess "Packages are not cacheable" }
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return if in_global_destruction(); # it'll happen soon anyway and this just makes things more complicated
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_free_anon
0.000000,0,0.000000,if $self->is_anon;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _free_anon {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $name = $self->name;
0.000000,0,0.000000,
0.000000,0,0.000000,# Moose does a weird thing where it replaces the metaclass for
0.000000,0,0.000000,# class when fixing metaclass incompatibility. In that case,
0.000000,0,0.000000,# we don't want to clean out the namespace now. We can detect
0.000000,0,0.000000,# that because Moose will explicitly update the singleton
0.000000,0,0.000000,# cache in Class::MOP using store_metaclass_by_name, which
0.000000,0,0.000000,# means that the new metaclass will already exist in the cache
0.000000,0,0.000000,# by this point.
0.000000,0,0.000000,# The other options here are that $current_meta can be undef if
0.000000,0,0.000000,# remove_metaclass_by_name is called explicitly (since the hash
0.000000,0,0.000000,# entry is removed first, and then this destructor is called),
0.000000,0,0.000000,# or that $current_meta can be the same as $self, which happens
0.000000,0,0.000000,# when the metaclass goes out of scope (since the weak reference
0.000000,0,0.000000,# in the metaclass cache won't be freed until after this
0.000000,0,0.000000,# destructor runs).
0.000000,0,0.000000,my $current_meta = Class::MOP::get_metaclass_by_name($name);
0.000000,0,0.000000,return if defined($current_meta) && $current_meta ne $self;
0.000000,0,0.000000,
0.000000,0,0.000000,my ($first_fragments, $last_fragment) = ($name =~ /^(.*)::(.*)$/);
0.000000,0,0.000000,
0.000417,2,0.000209,no strict 'refs';
0.000000,0,0.000000,# clear @ISA first, to avoid a memory leak
0.000000,0,0.000000,# see https://rt.perl.org/rt3/Public/Bug/Display.html?id=92708
0.000000,0,0.000000,@{$name . '::ISA'} = ();
0.000000,0,0.000000,%{$name . '::'}    = ();
0.000000,0,0.000000,delete ${$first_fragments . '::'}{$last_fragment . '::'};
0.000000,0,0.000000,
0.000000,0,0.000000,Class::MOP::remove_metaclass_by_name($name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000003,2,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000004,2,0.000002,return Class::MOP::Class->initialize($class)->new_object(@_)
0.000000,0,0.000000,if $class ne __PACKAGE__;
0.000000,0,0.000000,
0.000004,2,0.000002,my $params = @_ == 1 ? $_[0] : {@_};
0.000000,0,0.000000,
0.000018,2,0.000009,return bless {
0.000000,0,0.000000,# Need to quote package to avoid a problem with PPI mis-parsing this
0.000000,0,0.000000,# as a package statement.
0.000000,0,0.000000,'package' => $params->{package},
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# because of issues with the Perl API
0.000000,0,0.000000,# to the typeglob in some versions, we
0.000000,0,0.000000,# need to just always grab a new
0.000000,0,0.000000,# reference to the hash in the accessor.
0.000000,0,0.000000,# Ideally we could just store a ref and
0.000000,0,0.000000,# it would Just Work, but oh well :\
0.000000,0,0.000000,
0.000000,0,0.000000,namespace => \undef,
0.000000,0,0.000000,
0.000000,0,0.000000,} => $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Attributes
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# all these attribute readers will be bootstrapped
0.000000,0,0.000000,# away in the Class::MOP bootstrap section
0.000000,0,0.000000,
0.000000,0,0.000000,sub _package_stash {
0.014290,1117,0.000013,$_[0]->{_package_stash} ||= Package::Stash->new($_[0]->name)
0.000000,0,0.000000,}
0.000000,0,0.000000,sub namespace {
0.000000,0,0.000000,$_[0]->_package_stash->namespace
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Class attributes
0.000000,0,0.000000,
0.000000,0,0.000000,# ... these functions have to touch the symbol table itself,.. yuk
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_package_symbol {
0.000624,401,0.000002,my $self = shift;
0.012953,401,0.000032,$self->_package_stash->add_symbol(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_package_glob {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_package_stash->remove_glob(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# ... these functions deal with stuff on the namespace level
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_package_symbol {
0.000071,48,0.000001,my $self = shift;
0.000960,48,0.000020,$self->_package_stash->has_symbol(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_package_symbol {
0.000869,583,0.000001,my $self = shift;
0.011187,583,0.000019,$self->_package_stash->get_symbol(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_or_add_package_symbol {
0.000114,79,0.000001,my $self = shift;
0.002289,79,0.000029,$self->_package_stash->get_or_add_symbol(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_package_symbol {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->_package_stash->remove_symbol(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub list_all_package_symbols {
0.000008,5,0.000002,my $self = shift;
0.000138,5,0.000028,$self->_package_stash->list_all_symbols(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_package_symbols {
0.000002,1,0.000002,my $self = shift;
0.000037,1,0.000037,$self->_package_stash->get_all_symbols(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Package Meta Object
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
