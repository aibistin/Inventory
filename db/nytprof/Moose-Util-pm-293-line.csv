# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Util;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Util::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Util::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000043,2,0.000022,use strict;
0.000042,2,0.000021,use warnings;
0.000000,0,0.000000,
0.000070,3,0.000023,use Class::Load 0.07 qw(load_class load_first_existing_class);
0.000036,2,0.000018,use Data::OptList;
0.000034,2,0.000017,use Params::Util qw( _STRING );
0.000039,2,0.000019,use Sub::Exporter;
0.000036,2,0.000018,use Scalar::Util 'blessed';
0.000048,2,0.000024,use List::Util qw(first);
0.000034,2,0.000017,use List::MoreUtils qw(any all);
0.000033,2,0.000017,use overload ();
0.000034,2,0.000017,use Try::Tiny;
0.002226,2,0.001113,use Class::MOP;
0.000000,0,0.000000,
0.000005,1,0.000005,my @exports = qw[
0.000000,0,0.000000,find_meta
0.000000,0,0.000000,does_role
0.000000,0,0.000000,search_class_by_role
0.000000,0,0.000000,ensure_all_roles
0.000000,0,0.000000,apply_all_roles
0.000000,0,0.000000,with_traits
0.000000,0,0.000000,get_all_init_args
0.000000,0,0.000000,get_all_attribute_values
0.000000,0,0.000000,resolve_metatrait_alias
0.000000,0,0.000000,resolve_metaclass_alias
0.000000,0,0.000000,add_method_modifier
0.000000,0,0.000000,english_list
0.000000,0,0.000000,meta_attribute_alias
0.000000,0,0.000000,meta_class_alias
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000011,1,0.000011,Sub::Exporter::setup_exporter({
0.000000,0,0.000000,exports => \@exports,
0.000000,0,0.000000,groups  => { all => \@exports }
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,## some utils for the utils ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_meta { Class::MOP::class_of(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,## the functions ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub does_role {
0.000000,0,0.000000,my ($class_or_obj, $role) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if (try { $class_or_obj->isa('Moose::Object') }) {
0.000000,0,0.000000,return $class_or_obj->does($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = find_meta($class_or_obj);
0.000000,0,0.000000,
0.000000,0,0.000000,return unless defined $meta;
0.000000,0,0.000000,return unless $meta->can('does_role');
0.000000,0,0.000000,return 1 if $meta->does_role($role);
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub search_class_by_role {
0.000000,0,0.000000,my ($class_or_obj, $role) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = find_meta($class_or_obj);
0.000000,0,0.000000,
0.000000,0,0.000000,return unless defined $meta;
0.000000,0,0.000000,
0.000000,0,0.000000,my $role_name = blessed $role ? $role->name : $role;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $class ($meta->class_precedence_list) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $_meta = find_meta($class);
0.000000,0,0.000000,
0.000000,0,0.000000,next unless defined $_meta;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $role (@{ $_meta->roles || [] }) {
0.000000,0,0.000000,return $class if $role->name eq $role_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# this can possibly behave in unexpected ways because the roles being composed
0.000000,0,0.000000,# before being applied could differ from call to call; I'm not sure if or how
0.000000,0,0.000000,# to document this possible quirk.
0.000000,0,0.000000,sub ensure_all_roles {
0.000000,0,0.000000,my $applicant = shift;
0.000000,0,0.000000,_apply_all_roles($applicant, sub { !does_role($applicant, $_) }, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_all_roles {
0.000000,0,0.000000,my $applicant = shift;
0.000000,0,0.000000,_apply_all_roles($applicant, undef, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _apply_all_roles {
0.000000,0,0.000000,my $applicant = shift;
0.000000,0,0.000000,my $role_filter = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,unless (@_) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error("Must specify at least one role to apply to $applicant");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If @_ contains role meta objects, mkopt will think that they're values,
0.000000,0,0.000000,# because they're references.  In other words (roleobj1, roleobj2,
0.000000,0,0.000000,# roleobj3) will become [ [ roleobj1, roleobj2 ], [ roleobj3, undef ] ]
0.000000,0,0.000000,# -- this is no good.  We'll preprocess @_ first to eliminate the potential
0.000000,0,0.000000,# bug.
0.000000,0,0.000000,# -- rjbs, 2011-04-08
0.000000,0,0.000000,my $roles = Data::OptList::mkopt( [@_], {
0.000000,0,0.000000,moniker   => 'role',
0.000000,0,0.000000,name_test => sub {
0.000000,0,0.000000,! ref $_[0] or blessed($_[0]) && $_[0]->isa('Moose::Meta::Role')
0.000000,0,0.000000,}
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,my @role_metas;
0.000000,0,0.000000,foreach my $role (@$roles) {
0.000000,0,0.000000,my $meta;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( blessed $role->[0] ) {
0.000000,0,0.000000,$meta = $role->[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,load_class( $role->[0] , $role->[1] );
0.000000,0,0.000000,$meta = find_meta( $role->[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($meta && $meta->isa('Moose::Meta::Role') ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error( "You can only consume roles, "
0.000000,0,0.000000,. $role->[0]
0.000000,0,0.000000,. " is not a Moose role" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @role_metas, [ $meta, $role->[1] ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( defined $role_filter ) {
0.000000,0,0.000000,@role_metas = grep { local $_ = $_->[0]; $role_filter->() } @role_metas;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless @role_metas;
0.000000,0,0.000000,
0.000000,0,0.000000,load_class($applicant)
0.000000,0,0.000000,unless blessed($applicant)
0.000000,0,0.000000,|| Class::MOP::class_of($applicant);
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = ( blessed $applicant ? $applicant : Moose::Meta::Class->initialize($applicant) );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( scalar @role_metas == 1 ) {
0.000000,0,0.000000,my ( $role, $params ) = @{ $role_metas[0] };
0.000000,0,0.000000,$role->apply( $meta, ( defined $params ? %$params : () ) );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,Moose::Meta::Role->combine(@role_metas)->apply($meta);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub with_traits {
0.000000,0,0.000000,my ($class, @roles) = @_;
0.000000,0,0.000000,return $class unless @roles;
0.000000,0,0.000000,return Moose::Meta::Class->create_anon_class(
0.000000,0,0.000000,superclasses => [$class],
0.000000,0,0.000000,roles        => \@roles,
0.000000,0,0.000000,cache        => 1,
0.000000,0,0.000000,)->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# instance deconstruction ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_attribute_values {
0.000000,0,0.000000,my ($class, $instance) = @_;
0.000000,0,0.000000,return +{
0.000000,0,0.000000,map { $_->name => $_->get_value($instance) }
0.000000,0,0.000000,grep { $_->has_value($instance) }
0.000000,0,0.000000,$class->get_all_attributes
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_init_args {
0.000000,0,0.000000,my ($class, $instance) = @_;
0.000000,0,0.000000,return +{
0.000000,0,0.000000,map { $_->init_arg => $_->get_value($instance) }
0.000000,0,0.000000,grep { $_->has_value($instance) }
0.000000,0,0.000000,grep { defined($_->init_arg) }
0.000000,0,0.000000,$class->get_all_attributes
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub resolve_metatrait_alias {
0.000000,0,0.000000,return resolve_metaclass_alias( @_, trait => 1 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _build_alias_package_name {
0.000000,0,0.000000,my ($type, $name, $trait) = @_;
0.000000,0,0.000000,return 'Moose::Meta::'
0.000000,0,0.000000,. $type
0.000000,0,0.000000,. '::Custom::'
0.000000,0,0.000000,. ( $trait ? 'Trait::' : '' )
0.000000,0,0.000000,. $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000004,2,0.000002,my %cache;
0.000000,0,0.000000,
0.000000,0,0.000000,sub resolve_metaclass_alias {
0.000000,0,0.000000,my ( $type, $metaclass_name, %options ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
0.000000,0,0.000000,return $cache{$cache_key}{$metaclass_name}
0.000000,0,0.000000,if $cache{$cache_key}{$metaclass_name};
0.000000,0,0.000000,
0.000000,0,0.000000,my $possible_full_name = _build_alias_package_name(
0.000000,0,0.000000,$type, $metaclass_name, $options{trait}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $loaded_class = load_first_existing_class(
0.000000,0,0.000000,$possible_full_name,
0.000000,0,0.000000,$metaclass_name
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return $cache{$cache_key}{$metaclass_name}
0.000000,0,0.000000,= $loaded_class->can('register_implementation')
0.000000,0,0.000000,? $loaded_class->register_implementation
0.000000,0,0.000000,: $loaded_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_method_modifier {
0.000000,0,0.000000,my ( $class_or_obj, $modifier_name, $args ) = @_;
0.000000,0,0.000000,my $meta
0.000000,0,0.000000,= $class_or_obj->can('add_before_method_modifier')
0.000000,0,0.000000,? $class_or_obj
0.000000,0,0.000000,: find_meta($class_or_obj);
0.000000,0,0.000000,my $code                = pop @{$args};
0.000000,0,0.000000,my $add_modifier_method = 'add_' . $modifier_name . '_method_modifier';
0.000000,0,0.000000,if ( my $method_modifier_type = ref( @{$args}[0] ) ) {
0.000000,0,0.000000,if ( $method_modifier_type eq 'Regexp' ) {
0.000000,0,0.000000,my @all_methods = $meta->get_all_methods;
0.000000,0,0.000000,my @matched_methods
0.000000,0,0.000000,= grep { $_->name =~ @{$args}[0] } @all_methods;
0.000000,0,0.000000,$meta->$add_modifier_method( $_->name, $code )
0.000000,0,0.000000,for @matched_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($method_modifier_type eq 'ARRAY') {
0.000000,0,0.000000,$meta->$add_modifier_method( $_, $code ) for @{$args->[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$meta->throw_error(
0.000000,0,0.000000,sprintf(
0.000000,0,0.000000,"Methods passed to %s must be provided as a list, arrayref or regex, not %s",
0.000000,0,0.000000,$modifier_name,
0.000000,0,0.000000,$method_modifier_type,
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$meta->$add_modifier_method( $_, $code ) for @{$args};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub english_list {
0.000000,0,0.000000,my @items = sort @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $items[0] if @items == 1;
0.000000,0,0.000000,return "$items[0] and $items[1]" if @items == 2;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tail = pop @items;
0.000000,0,0.000000,my $list = join ', ', @items;
0.000000,0,0.000000,$list .= ', and ' . $tail;
0.000000,0,0.000000,
0.000000,0,0.000000,return $list;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _caller_info {
0.000013,8,0.000002,my $level = @_ ? ($_[0] + 1) : 2;
0.000012,8,0.000001,my %info;
0.000059,8,0.000007,@info{qw(package file line)} = caller($level);
0.000059,8,0.000007,return %info;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create_alias {
0.000000,0,0.000000,my ($type, $name, $trait, $for) = @_;
0.000000,0,0.000000,my $package = _build_alias_package_name($type, $name, $trait);
0.000000,0,0.000000,Class::MOP::Class->initialize($package)->add_method(
0.000000,0,0.000000,register_implementation => sub { $for }
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub meta_attribute_alias {
0.000000,0,0.000000,my ($to, $from) = @_;
0.000000,0,0.000000,$from ||= caller;
0.000000,0,0.000000,my $meta = Class::MOP::class_of($from);
0.000000,0,0.000000,my $trait = $meta->isa('Moose::Meta::Role');
0.000000,0,0.000000,_create_alias('Attribute', $to, $trait, $from);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub meta_class_alias {
0.000000,0,0.000000,my ($to, $from) = @_;
0.000000,0,0.000000,$from ||= caller;
0.000000,0,0.000000,my $meta = Class::MOP::class_of($from);
0.000000,0,0.000000,my $trait = $meta->isa('Moose::Meta::Role');
0.000000,0,0.000000,_create_alias('Class', $to, $trait, $from);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX - this should be added to Params::Util
0.000000,0,0.000000,sub _STRINGLIKE0 ($) {
0.000000,0,0.000000,return 1 if _STRING( $_[0] );
0.000000,0,0.000000,if ( blessed $_[0] ) {
0.000000,0,0.000000,return overload::Method( $_[0], q{""} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if defined $_[0] && $_[0] eq q{};
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _reconcile_roles_for_metaclass {
0.000000,0,0.000000,my ($class_meta_name, $super_meta_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @role_differences = _role_differences(
0.000000,0,0.000000,$class_meta_name, $super_meta_name,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# handle the case where we need to fix compatibility between a class and
0.000000,0,0.000000,# its parent, but all roles in the class are already also done by the
0.000000,0,0.000000,# parent
0.000000,0,0.000000,# see t/metaclasses/metaclass_compat_no_fixing_bug.t
0.000000,0,0.000000,return $super_meta_name
0.000000,0,0.000000,unless @role_differences;
0.000000,0,0.000000,
0.000000,0,0.000000,return Moose::Meta::Class->create_anon_class(
0.000000,0,0.000000,superclasses => [$super_meta_name],
0.000000,0,0.000000,roles        => [map { $_->name } @role_differences],
0.000000,0,0.000000,cache        => 1,
0.000000,0,0.000000,)->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _role_differences {
0.000000,0,0.000000,my ($class_meta_name, $super_meta_name) = @_;
0.000000,0,0.000000,my @super_role_metas = map {
0.000000,0,0.000000,$_->isa('Moose::Meta::Role::Composite')
0.000000,0,0.000000,? (@{ $_->get_roles })
0.000000,0,0.000000,: ($_)
0.000000,0,0.000000,} $super_meta_name->meta->can('_roles_with_inheritance')
0.000000,0,0.000000,? $super_meta_name->meta->_roles_with_inheritance
0.000000,0,0.000000,: $super_meta_name->meta->can('roles')
0.000000,0,0.000000,? @{ $super_meta_name->meta->roles }
0.000000,0,0.000000,:     ();
0.000000,0,0.000000,my @role_metas = map {
0.000000,0,0.000000,$_->isa('Moose::Meta::Role::Composite')
0.000000,0,0.000000,? (@{ $_->get_roles })
0.000000,0,0.000000,: ($_)
0.000000,0,0.000000,} $class_meta_name->meta->can('_roles_with_inheritance')
0.000000,0,0.000000,? $class_meta_name->meta->_roles_with_inheritance
0.000000,0,0.000000,: $class_meta_name->meta->can('roles')
0.000000,0,0.000000,? @{ $class_meta_name->meta->roles }
0.000000,0,0.000000,:     ();
0.000000,0,0.000000,my @differences;
0.000000,0,0.000000,for my $role_meta (@role_metas) {
0.000000,0,0.000000,push @differences, $role_meta
0.000000,0,0.000000,unless any { $_->name eq $role_meta->name } @super_role_metas;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @differences;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _classes_differ_by_roles_only {
0.000000,0,0.000000,my ( $self_meta_name, $super_meta_name ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $common_base_name
0.000000,0,0.000000,= _find_common_base( $self_meta_name, $super_meta_name );
0.000000,0,0.000000,
0.000000,0,0.000000,return unless defined $common_base_name;
0.000000,0,0.000000,
0.000000,0,0.000000,my @super_meta_name_ancestor_names
0.000000,0,0.000000,= _get_ancestors_until( $super_meta_name, $common_base_name );
0.000000,0,0.000000,my @class_meta_name_ancestor_names
0.000000,0,0.000000,= _get_ancestors_until( $self_meta_name, $common_base_name );
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000000,0,0.000000,unless all { _is_role_only_subclass($_) }
0.000000,0,0.000000,@super_meta_name_ancestor_names,
0.000000,0,0.000000,@class_meta_name_ancestor_names;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _find_common_base {
0.000000,0,0.000000,my ($meta1, $meta2) = map { Class::MOP::class_of($_) } @_;
0.000000,0,0.000000,return unless defined $meta1 && defined $meta2;
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME? This doesn't account for multiple inheritance (not sure
0.000000,0,0.000000,# if it needs to though). For example, if somewhere in $meta1's
0.000000,0,0.000000,# history it inherits from both ClassA and ClassB, and $meta2
0.000000,0,0.000000,# inherits from ClassB & ClassA, does it matter? And what crazy
0.000000,0,0.000000,# fool would do that anyway?
0.000000,0,0.000000,
0.000000,0,0.000000,my %meta1_parents = map { $_ => 1 } $meta1->linearized_isa;
0.000000,0,0.000000,
0.000000,0,0.000000,return first { $meta1_parents{$_} } $meta2->linearized_isa;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _get_ancestors_until {
0.000000,0,0.000000,my ($start_name, $until_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @ancestor_names;
0.000000,0,0.000000,for my $ancestor_name (Class::MOP::class_of($start_name)->linearized_isa) {
0.000000,0,0.000000,last if $ancestor_name eq $until_name;
0.000000,0,0.000000,push @ancestor_names, $ancestor_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @ancestor_names;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_role_only_subclass {
0.000000,0,0.000000,my ($meta_name) = @_;
0.000000,0,0.000000,my $meta = Class::MOP::Class->initialize($meta_name);
0.000000,0,0.000000,my @parent_names = $meta->superclasses;
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: don't feel like messing with multiple inheritance here... what would
0.000000,0,0.000000,# that even do?
0.000000,0,0.000000,return unless @parent_names == 1;
0.000000,0,0.000000,my ($parent_name) = @parent_names;
0.000000,0,0.000000,my $parent_meta = Class::MOP::Class->initialize($parent_name);
0.000000,0,0.000000,
0.000000,0,0.000000,# only get the roles attached to this particular class, don't look at
0.000000,0,0.000000,# superclasses
0.000000,0,0.000000,my @roles = $meta->can('calculate_all_roles')
0.000000,0,0.000000,? $meta->calculate_all_roles
0.000000,0,0.000000,: ();
0.000000,0,0.000000,
0.000000,0,0.000000,# it's obviously not a role-only subclass if it doesn't do any roles
0.000000,0,0.000000,return unless @roles;
0.000000,0,0.000000,
0.000000,0,0.000000,# loop over all methods that are a part of the current class
0.000000,0,0.000000,# (not inherited)
0.000000,0,0.000000,for my $method ( $meta->_get_local_methods ) {
0.000000,0,0.000000,# always ignore meta
0.000000,0,0.000000,next if $method->isa('Class::MOP::Method::Meta');
0.000000,0,0.000000,# we'll deal with attributes below
0.000000,0,0.000000,next if $method->can('associated_attribute');
0.000000,0,0.000000,# if the method comes from a role we consumed, ignore it
0.000000,0,0.000000,next if $meta->can('does_role')
0.000000,0,0.000000,&& $meta->does_role($method->original_package_name);
0.000000,0,0.000000,# FIXME - this really isn't right. Just because a modifier is
0.000000,0,0.000000,# defined in a role doesn't mean it isn't _also_ defined in the
0.000000,0,0.000000,# subclass.
0.000000,0,0.000000,next if $method->isa('Class::MOP::Method::Wrapped')
0.000000,0,0.000000,&& (
0.000000,0,0.000000,(!scalar($method->around_modifiers)
0.000000,0,0.000000,|| any { $_->has_around_method_modifiers($method->name) } @roles)
0.000000,0,0.000000,&& (!scalar($method->before_modifiers)
0.000000,0,0.000000,|| any { $_->has_before_method_modifiers($method->name) } @roles)
0.000000,0,0.000000,&& (!scalar($method->after_modifiers)
0.000000,0,0.000000,|| any { $_->has_after_method_modifiers($method->name) } @roles)
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# loop over all attributes that are a part of the current class
0.000000,0,0.000000,# (not inherited)
0.000000,0,0.000000,# FIXME - this really isn't right. Just because an attribute is
0.000000,0,0.000000,# defined in a role doesn't mean it isn't _also_ defined in the
0.000000,0,0.000000,# subclass.
0.000000,0,0.000000,for my $attr (map { $meta->get_attribute($_) } $meta->get_attribute_list) {
0.000000,0,0.000000,next if any { $_->has_attribute($attr->name) } @roles;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Utilities for working with Moose classes
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
