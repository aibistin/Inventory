# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Attribute::Handlers;
0.000051,2,0.000026,use 5.006;
0.000033,2,0.000017,use Carp;
0.000031,2,0.000015,use warnings;
0.000034,2,0.000017,use strict;
0.000087,2,0.000044,use vars qw($VERSION $AUTOLOAD);
0.000002,1,0.000002,$VERSION = '0.94'; # remember to update version in POD!
0.000000,0,0.000000,# $DB::single=1;
0.000000,0,0.000000,
0.000002,1,0.000002,my %symcache;
0.000000,0,0.000000,sub findsym {
0.000002,1,0.000002,my ($pkg, $ref, $type) = @_;
0.000003,1,0.000003,return $symcache{$pkg,$ref} if $symcache{$pkg,$ref};
0.000002,1,0.000002,$type ||= ref($ref);
0.000046,2,0.000023,no strict 'refs';
0.000004,1,0.000004,foreach my $sym ( values %{$pkg."::"} ) {
0.000575,2,0.000287,use strict;
0.000011,7,0.000002,next unless ref ( \$sym ) eq 'GLOB';
0.000000,0,0.000000,return $symcache{$pkg,$ref} = \$sym
0.000029,7,0.000004,if *{$sym}{$type} && *{$sym}{$type} == $ref;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,my %validtype = (
0.000000,0,0.000000,VAR	=> [qw[SCALAR ARRAY HASH]],
0.000000,0,0.000000,ANY	=> [qw[SCALAR ARRAY HASH CODE]],
0.000000,0,0.000000,""	=> [qw[SCALAR ARRAY HASH CODE]],
0.000000,0,0.000000,SCALAR	=> [qw[SCALAR]],
0.000000,0,0.000000,ARRAY	=> [qw[ARRAY]],
0.000000,0,0.000000,HASH	=> [qw[HASH]],
0.000000,0,0.000000,CODE	=> [qw[CODE]],
0.000000,0,0.000000,);
0.000001,1,0.000001,my %lastattr;
0.000001,1,0.000001,my @declarations;
0.000001,1,0.000001,my %raw;
0.000001,1,0.000001,my %phase;
0.000002,1,0.000002,my %sigil = (SCALAR=>'$', ARRAY=>'@', HASH=>'%');
0.000002,1,0.000002,my $global_phase = 0;
0.000004,1,0.000004,my %global_phases = (
0.000000,0,0.000000,BEGIN	=> 0,
0.000000,0,0.000000,CHECK	=> 1,
0.000000,0,0.000000,INIT	=> 2,
0.000000,0,0.000000,END	=> 3,
0.000000,0,0.000000,);
0.000002,1,0.000002,my @global_phases = qw(BEGIN CHECK INIT END);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _usage_AH_ {
0.000000,0,0.000000,croak "Usage: use $_[0] autotie => {AttrName => TieClassName,...}";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,1,0.000012,my $qual_id = qr/^[_a-z]\w*(::[_a-z]\w*)*$/i;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000002,1,0.000002,my $class = shift @_;
0.000002,1,0.000002,return unless $class eq "Attribute::Handlers";
0.000009,1,0.000009,while (@_) {
0.000000,0,0.000000,my $cmd = shift;
0.000000,0,0.000000,if ($cmd =~ /^autotie((?:ref)?)$/) {
0.000000,0,0.000000,my $tiedata = ($1 ? '$ref, ' : '') . '@$data';
0.000000,0,0.000000,my $mapping = shift;
0.000000,0,0.000000,_usage_AH_ $class unless ref($mapping) eq 'HASH';
0.000000,0,0.000000,while (my($attr, $tieclass) = each %$mapping) {
0.000000,0,0.000000,$tieclass =~ s/^([_a-z]\w*(::[_a-z]\w*)*)(.*)/$1/is;
0.000000,0,0.000000,my $args = $3||'()';
0.000000,0,0.000000,_usage_AH_ $class unless $attr =~ $qual_id
0.000000,0,0.000000,&& $tieclass =~ $qual_id
0.000000,0,0.000000,&& eval "use base q\0$tieclass\0; 1";
0.000000,0,0.000000,if ($tieclass->isa('Exporter')) {
0.000000,0,0.000000,local $Exporter::ExportLevel = 2;
0.000000,0,0.000000,$tieclass->import(eval $args);
0.000000,0,0.000000,}
0.000000,0,0.000000,$attr =~ s/__CALLER__/caller(1)/e;
0.000000,0,0.000000,$attr = caller()."::".$attr unless $attr =~ /::/;
0.000000,0,0.000000,eval qq{
0.000000,0,0.000000,sub $attr : ATTR(VAR) {
0.000000,0,0.000000,my (\$ref, \$data) = \@_[2,4];
0.000000,0,0.000000,my \$was_arrayref = ref \$data eq 'ARRAY';
0.000000,0,0.000000,\$data = [ \$data ] unless \$was_arrayref;
0.000000,0,0.000000,my \$type = ref(\$ref)||"value (".(\$ref||"<undef>").")";
0.000000,0,0.000000,(\$type eq 'SCALAR')? tie \$\$ref,'$tieclass',$tiedata
0.000000,0,0.000000,:(\$type eq 'ARRAY') ? tie \@\$ref,'$tieclass',$tiedata
0.000000,0,0.000000,:(\$type eq 'HASH')  ? tie \%\$ref,'$tieclass',$tiedata
0.000000,0,0.000000,: die "Can't autotie a \$type\n"
0.000000,0,0.000000,} 1
0.000000,0,0.000000,} or die "Internal error: $@";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "Can't understand $_"; 
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# On older perls, code attribute handlers run before the sub gets placed
0.000000,0,0.000000,# in its package.  Since the :ATTR handlers need to know the name of the
0.000000,0,0.000000,# sub they're applied to, the name lookup (via findsym) needs to be
0.000000,0,0.000000,# delayed: we do it immediately before we might need to find attribute
0.000000,0,0.000000,# handlers from their name.  However, on newer perls (which fix some
0.000000,0,0.000000,# problems relating to attribute application), a sub gets placed in its
0.000000,0,0.000000,# package before its attributes are processed.  In this case, the
0.000000,0,0.000000,# delayed name lookup might be too late, because the sub we're looking
0.000000,0,0.000000,# for might have already been replaced.  So we need to detect which way
0.000000,0,0.000000,# round this perl does things, and time the name lookup accordingly.
0.000000,0,0.000000,BEGIN {
0.000001,1,0.000001,my $delayed;
0.000000,0,0.000000,sub Attribute::Handlers::_TEST_::MODIFY_CODE_ATTRIBUTES {
0.000003,1,0.000003,$delayed = \&Attribute::Handlers::_TEST_::t != $_[1];
0.000008,1,0.000008,return ();
0.000000,0,0.000000,}
0.000261,2,0.000130,sub Attribute::Handlers::_TEST_::t :T { }
0.000037,4,0.000009,*_delayed_name_resolution = sub() { $delayed };
0.000004,1,0.000004,undef &Attribute::Handlers::_TEST_::MODIFY_CODE_ATTRIBUTES;
0.000008,1,0.000008,undef &Attribute::Handlers::_TEST_::t;
0.000097,1,0.000097,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _resolve_lastattr {
0.000002,1,0.000002,return unless $lastattr{ref};
0.000006,1,0.000006,my $sym = findsym @lastattr{'pkg','ref'}
0.000000,0,0.000000,or die "Internal error: $lastattr{pkg} symbol went missing";
0.000002,1,0.000002,my $name = *{$sym}{NAME};
0.000002,1,0.000002,warn "Declaration of $name attribute in package $lastattr{pkg} may clash with future reserved word\n"
0.000000,0,0.000000,if $^W and $name !~ /[A-Z]/;
0.000004,1,0.000004,foreach ( @{$validtype{$lastattr{type}}} ) {
0.000286,2,0.000143,no strict 'refs';
0.000007,1,0.000007,*{"$lastattr{pkg}::_ATTR_${_}_${name}"} = $lastattr{ref};
0.000000,0,0.000000,}
0.000008,1,0.000008,%lastattr = ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub AUTOLOAD {
0.000000,0,0.000000,return if $AUTOLOAD =~ /::DESTROY$/;
0.000000,0,0.000000,my ($class) = $AUTOLOAD =~ m/(.*)::/g;
0.000000,0,0.000000,$AUTOLOAD =~ m/_ATTR_(.*?)_(.*)/ or
0.000000,0,0.000000,croak "Can't locate class method '$AUTOLOAD' via package '$class'";
0.000000,0,0.000000,croak "Attribute handler '$2' doesn't handle $1 attributes";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,my $builtin = qr/lvalue|method|locked|unique|shared/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _gen_handler_AH_() {
0.000000,0,0.000000,return sub {
0.000005,1,0.000005,_resolve_lastattr if _delayed_name_resolution;
0.000002,1,0.000002,my ($pkg, $ref, @attrs) = @_;
0.000005,1,0.000005,my (undef, $filename, $linenum) = caller 2;
0.000003,1,0.000003,foreach (@attrs) {
0.000015,1,0.000015,my ($attr, $data) = /^([a-z_]\w*)(?:[(](.*)[)])?$/is or next;
0.000003,1,0.000003,if ($attr eq 'ATTR') {
0.000381,2,0.000191,no strict 'refs';
0.000001,1,0.000001,$data ||= "ANY";
0.000010,1,0.000010,$raw{$ref} = $data =~ s/\s*,?\s*RAWDATA\s*,?\s*//;
0.000011,1,0.000011,$phase{$ref}{BEGIN} = 1
0.000000,0,0.000000,if $data =~ s/\s*,?\s*(BEGIN)\s*,?\s*//;
0.000011,1,0.000011,$phase{$ref}{INIT} = 1
0.000000,0,0.000000,if $data =~ s/\s*,?\s*(INIT)\s*,?\s*//;
0.000008,1,0.000008,$phase{$ref}{END} = 1
0.000000,0,0.000000,if $data =~ s/\s*,?\s*(END)\s*,?\s*//;
0.000000,0,0.000000,$phase{$ref}{CHECK} = 1
0.000000,0,0.000000,if $data =~ s/\s*,?\s*(CHECK)\s*,?\s*//
0.000008,1,0.000008,|| ! keys %{$phase{$ref}};
0.000000,0,0.000000,# Added for cleanup to not pollute next call.
0.000002,1,0.000002,(%lastattr = ()),
0.000000,0,0.000000,croak "Can't have two ATTR specifiers on one subroutine"
0.000000,0,0.000000,if keys %lastattr;
0.000002,1,0.000002,croak "Bad attribute type: ATTR($data)"
0.000000,0,0.000000,unless $validtype{$data};
0.000010,1,0.000010,%lastattr=(pkg=>$pkg,ref=>$ref,type=>$data);
0.000009,1,0.000009,_resolve_lastattr unless _delayed_name_resolution;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $type = ref $ref;
0.000000,0,0.000000,my $handler = $pkg->can("_ATTR_${type}_${attr}");
0.000000,0,0.000000,next unless $handler;
0.000000,0,0.000000,my $decl = [$pkg, $ref, $attr, $data,
0.000000,0,0.000000,$raw{$handler}, $phase{$handler}, $filename, $linenum];
0.000000,0,0.000000,foreach my $gphase (@global_phases) {
0.000000,0,0.000000,_apply_handler_AH_($decl,$gphase)
0.000000,0,0.000000,if $global_phases{$gphase} <= $global_phase;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($global_phase != 0) {
0.000000,0,0.000000,# if _gen_handler_AH_ is being called after 
0.000000,0,0.000000,# CHECK it's for a lexical, so make sure
0.000000,0,0.000000,# it didn't want to run anything later
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = 2;
0.000000,0,0.000000,carp "Won't be able to apply END handler"
0.000000,0,0.000000,if $phase{$handler}{END};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @declarations, $decl
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000003,1,0.000003,$_ = undef;
0.000000,0,0.000000,}
0.000011,2,0.000005,return grep {defined && !/$builtin/} @attrs;
0.000000,0,0.000000,}
0.000030,4,0.000008,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000152,3,0.000051,no strict 'refs';
0.000000,0,0.000000,*{"Attribute::Handlers::UNIVERSAL::MODIFY_${_}_ATTRIBUTES"} =
0.000037,1,0.000037,_gen_handler_AH_ foreach @{$validtype{ANY}};
0.000000,0,0.000000,}
0.000010,1,0.000010,push @UNIVERSAL::ISA, 'Attribute::Handlers::UNIVERSAL'
0.000000,0,0.000000,unless grep /^Attribute::Handlers::UNIVERSAL$/, @UNIVERSAL::ISA;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _apply_handler_AH_ {
0.000000,0,0.000000,my ($declaration, $phase) = @_;
0.000000,0,0.000000,my ($pkg, $ref, $attr, $data, $raw, $handlerphase, $filename, $linenum) = @$declaration;
0.000000,0,0.000000,return unless $handlerphase->{$phase};
0.000000,0,0.000000,# print STDERR "Handling $attr on $ref in $phase with [$data]\n";
0.000000,0,0.000000,my $type = ref $ref;
0.000000,0,0.000000,my $handler = "_ATTR_${type}_${attr}";
0.000000,0,0.000000,my $sym = findsym($pkg, $ref);
0.000000,0,0.000000,$sym ||= $type eq 'CODE' ? 'ANON' : 'LEXICAL';
0.000120,2,0.000060,no warnings;
0.000000,0,0.000000,if (!$raw && defined($data)) {
0.000000,0,0.000000,if ($data ne '') {
0.000000,0,0.000000,my $evaled = eval("package $pkg; no warnings; no strict;
0.000000,0,0.000000,local \$SIG{__WARN__}=sub{die}; [$data]");
0.000000,0,0.000000,$data = $evaled unless $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,else { $data = undef }
0.000000,0,0.000000,}
0.000000,0,0.000000,$pkg->$handler($sym,
0.000000,0,0.000000,(ref $sym eq 'GLOB' ? *{$sym}{ref $ref}||$ref : $ref),
0.000000,0,0.000000,$attr,
0.000000,0,0.000000,$data,
0.000000,0,0.000000,$phase,
0.000000,0,0.000000,$filename,
0.000000,0,0.000000,$linenum,
0.000000,0,0.000000,);
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000163,3,0.000054,no warnings 'void';
0.000000,0,0.000000,CHECK {
0.000002,1,0.000002,$global_phase++;
0.000007,1,0.000007,_resolve_lastattr if _delayed_name_resolution;
0.000011,1,0.000011,foreach my $decl (@declarations) {
0.000000,0,0.000000,_apply_handler_AH_($decl, 'CHECK');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,INIT {
0.000001,1,0.000001,$global_phase++;
0.000008,1,0.000008,foreach my $decl (@declarations) {
0.000000,0,0.000000,_apply_handler_AH_($decl, 'INIT');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,END {
0.000002,1,0.000002,$global_phase++;
0.000009,1,0.000009,foreach my $decl (@declarations) {
0.000000,0,0.000000,_apply_handler_AH_($decl, 'END');
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,1,0.000014,1;
0.000000,0,0.000000,__END__
