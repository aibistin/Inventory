# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Meta::Role::Application::RoleSummation;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::Role::Application::RoleSummation::AUTHORITY = 'cpan:STEVAN';
0.000034,1,0.000034,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::Role::Application::RoleSummation::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000039,2,0.000019,use strict;
0.000033,2,0.000016,use warnings;
0.000043,2,0.000021,use metaclass;
0.000000,0,0.000000,
0.000038,2,0.000019,use Scalar::Util 'blessed';
0.000000,0,0.000000,
0.000032,2,0.000016,use Moose::Meta::Role::Composite;
0.000000,0,0.000000,
0.001250,2,0.000625,use base 'Moose::Meta::Role::Application';
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('role_params' => (
0.000000,0,0.000000,reader  => 'role_params',
0.000000,0,0.000000,default => sub { {} },
0.000015,1,0.000015,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_exclusions_for_role {
0.000000,0,0.000000,my ($self, $role) = @_;
0.000000,0,0.000000,$role = $role->name if blessed $role;
0.000000,0,0.000000,my $excludes_key = exists $self->role_params->{$role}->{'-excludes'} ?
0.000000,0,0.000000,'-excludes' : 'excludes';
0.000000,0,0.000000,if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$excludes_key}) {
0.000000,0,0.000000,if (ref $self->role_params->{$role}->{$excludes_key} eq 'ARRAY') {
0.000000,0,0.000000,return $self->role_params->{$role}->{$excludes_key};
0.000000,0,0.000000,}
0.000000,0,0.000000,return [ $self->role_params->{$role}->{$excludes_key} ];
0.000000,0,0.000000,}
0.000000,0,0.000000,return [];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_method_aliases_for_role {
0.000000,0,0.000000,my ($self, $role) = @_;
0.000000,0,0.000000,$role = $role->name if blessed $role;
0.000000,0,0.000000,my $alias_key = exists $self->role_params->{$role}->{'-alias'} ?
0.000000,0,0.000000,'-alias' : 'alias';
0.000000,0,0.000000,if ($self->role_params->{$role} && defined $self->role_params->{$role}->{$alias_key}) {
0.000000,0,0.000000,return $self->role_params->{$role}->{$alias_key};
0.000000,0,0.000000,}
0.000000,0,0.000000,return {};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_method_excluded {
0.000000,0,0.000000,my ($self, $role, $method_name) = @_;
0.000000,0,0.000000,foreach ($self->get_exclusions_for_role($role->name)) {
0.000000,0,0.000000,return 1 if $_ eq $method_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_method_aliased {
0.000000,0,0.000000,my ($self, $role, $method_name) = @_;
0.000000,0,0.000000,exists $self->get_method_aliases_for_role($role->name)->{$method_name} ? 1 : 0
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_aliased_method {
0.000000,0,0.000000,my ($self, $role, $method_name) = @_;
0.000000,0,0.000000,my %aliased_names = reverse %{$self->get_method_aliases_for_role($role->name)};
0.000000,0,0.000000,exists $aliased_names{$method_name} ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check_role_exclusions {
0.000000,0,0.000000,my ($self, $c) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %excluded_roles;
0.000000,0,0.000000,for my $role (@{ $c->get_roles }) {
0.000000,0,0.000000,my $name = $role->name;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $excluded ($role->get_excluded_roles_list) {
0.000000,0,0.000000,push @{ $excluded_roles{$excluded} }, $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $role (@{$c->get_roles}) {
0.000000,0,0.000000,foreach my $excluded (keys %excluded_roles) {
0.000000,0,0.000000,next unless $role->does_role($excluded);
0.000000,0,0.000000,
0.000000,0,0.000000,my @excluding = @{ $excluded_roles{$excluded} };
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error(sprintf "Conflict detected: Role%s %s exclude%s role '%s'", (@excluding == 1 ? '' : 's'), join(', ', @excluding), (@excluding == 1 ? 's' : ''), $excluded);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$c->add_excluded_roles(keys %excluded_roles);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check_required_methods {
0.000000,0,0.000000,my ($self, $c) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %all_required_methods =
0.000000,0,0.000000,map { $_->name => $_ }
0.000000,0,0.000000,map { $_->get_required_method_list }
0.000000,0,0.000000,@{$c->get_roles};
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $role (@{$c->get_roles}) {
0.000000,0,0.000000,foreach my $required (keys %all_required_methods) {
0.000000,0,0.000000,
0.000000,0,0.000000,delete $all_required_methods{$required}
0.000000,0,0.000000,if $role->has_method($required)
0.000000,0,0.000000,|| $self->is_aliased_method($role, $required);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$c->add_required_methods(values %all_required_methods);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check_required_attributes {
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_attributes {
0.000000,0,0.000000,my ($self, $c) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @all_attributes;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $role ( @{ $c->get_roles } ) {
0.000000,0,0.000000,push @all_attributes,
0.000000,0,0.000000,map { $role->get_attribute($_) } $role->get_attribute_list;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,foreach my $attr (@all_attributes) {
0.000000,0,0.000000,my $name = $attr->name;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( exists $seen{$name} ) {
0.000000,0,0.000000,next if $seen{$name}->is_same_as($attr);
0.000000,0,0.000000,
0.000000,0,0.000000,my $role1 = $seen{$name}->associated_role->name;
0.000000,0,0.000000,my $role2 = $attr->associated_role->name;
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error(
0.000000,0,0.000000,"We have encountered an attribute conflict with '$name' "
0.000000,0,0.000000,. "during role composition. "
0.000000,0,0.000000,. " This attribute is defined in both $role1 and $role2."
0.000000,0,0.000000,. " This is a fatal error and cannot be disambiguated." );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$seen{$name} = $attr;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attr (@all_attributes) {
0.000000,0,0.000000,$c->add_attribute( $attr->clone );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_methods {
0.000000,0,0.000000,my ($self, $c) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @all_methods = map {
0.000000,0,0.000000,my $role     = $_;
0.000000,0,0.000000,my $aliases  = $self->get_method_aliases_for_role($role);
0.000000,0,0.000000,my %excludes = map { $_ => undef } @{ $self->get_exclusions_for_role($role) };
0.000000,0,0.000000,(
0.000000,0,0.000000,(map {
0.000000,0,0.000000,exists $excludes{$_} ? () :
0.000000,0,0.000000,+{
0.000000,0,0.000000,role   => $role,
0.000000,0,0.000000,name   => $_,
0.000000,0,0.000000,method => $role->get_method($_),
0.000000,0,0.000000,}
0.000000,0,0.000000,} map { $_->name }
0.000000,0,0.000000,grep { !$_->isa('Class::MOP::Method::Meta') }
0.000000,0,0.000000,$role->_get_local_methods),
0.000000,0,0.000000,(map {
0.000000,0,0.000000,+{
0.000000,0,0.000000,role   => $role,
0.000000,0,0.000000,name   => $aliases->{$_},
0.000000,0,0.000000,method => $role->get_method($_),
0.000000,0,0.000000,}
0.000000,0,0.000000,} keys %$aliases)
0.000000,0,0.000000,);
0.000000,0,0.000000,} @{$c->get_roles};
0.000000,0,0.000000,
0.000000,0,0.000000,my (%seen, %conflicts, %method_map);
0.000000,0,0.000000,foreach my $method (@all_methods) {
0.000000,0,0.000000,next if $conflicts{$method->{name}};
0.000000,0,0.000000,my $seen = $seen{$method->{name}};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($seen) {
0.000000,0,0.000000,if ($seen->{method}->body != $method->{method}->body) {
0.000000,0,0.000000,$c->add_conflicting_method(
0.000000,0,0.000000,name  => $method->{name},
0.000000,0,0.000000,roles => [$method->{role}->name, $seen->{role}->name],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,delete $method_map{$method->{name}};
0.000000,0,0.000000,$conflicts{$method->{name}} = 1;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$seen{$method->{name}}       = $method;
0.000000,0,0.000000,$method_map{$method->{name}} = $method->{method};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$c->add_method($_ => $method_map{$_}) for keys %method_map;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_override_method_modifiers {
0.000000,0,0.000000,my ($self, $c) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @all_overrides = map {
0.000000,0,0.000000,my $role = $_;
0.000000,0,0.000000,map {
0.000000,0,0.000000,+{
0.000000,0,0.000000,name   => $_,
0.000000,0,0.000000,method => $role->get_override_method_modifier($_),
0.000000,0,0.000000,}
0.000000,0,0.000000,} $role->get_method_modifier_list('override');
0.000000,0,0.000000,} @{$c->get_roles};
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,foreach my $override (@all_overrides) {
0.000000,0,0.000000,if ( $c->has_method($override->{name}) ){
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error( "Role '" . $c->name . "' has encountered an 'override' method conflict " .
0.000000,0,0.000000,"during composition (A local method of the same name as been found). This " .
0.000000,0,0.000000,"is fatal error." )
0.000000,0,0.000000,}
0.000000,0,0.000000,if (exists $seen{$override->{name}}) {
0.000000,0,0.000000,if ( $seen{$override->{name}} != $override->{method} ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error( "We have encountered an 'override' method conflict during " .
0.000000,0,0.000000,"composition (Two 'override' methods of the same name encountered). " .
0.000000,0,0.000000,"This is fatal error.")
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$seen{$override->{name}} = $override->{method};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$c->add_override_method_modifier(
0.000000,0,0.000000,$_->{name}, $_->{method}
0.000000,0,0.000000,) for @all_overrides;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_method_modifiers {
0.000000,0,0.000000,my ($self, $modifier_type, $c) = @_;
0.000000,0,0.000000,my $add = "add_${modifier_type}_method_modifier";
0.000000,0,0.000000,my $get = "get_${modifier_type}_method_modifiers";
0.000000,0,0.000000,foreach my $role (@{$c->get_roles}) {
0.000000,0,0.000000,foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
0.000000,0,0.000000,$c->$add(
0.000000,0,0.000000,$method_name,
0.000000,0,0.000000,$_
0.000000,0,0.000000,) foreach $role->$get($method_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Combine two or more roles
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
