# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Method::Signatures::Simple;
0.000000,0,0.000000,{
0.000005,2,0.000002,$Method::Signatures::Simple::VERSION = '1.07';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000035,2,0.000017,use warnings;
0.000043,2,0.000021,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Method::Signatures::Simple - Basic method declarations with signatures, without source filters
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 VERSION
0.000000,0,0.000000,
0.000000,0,0.000000,version 1.07
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000453,2,0.000227,use base 'Devel::Declare::MethodInstaller::Simple';
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000002,1,0.000002,my $class = shift;
0.000002,1,0.000002,my %opts  = @_;
0.000002,1,0.000002,$opts{into} ||= caller;
0.000000,0,0.000000,
0.000002,1,0.000002,my $meth = delete $opts{name} || delete $opts{method_keyword};
0.000002,1,0.000002,my $func = delete $opts{function_keyword};
0.000000,0,0.000000,
0.000000,0,0.000000,# if no options are provided at all, then we supply defaults
0.000003,1,0.000003,unless (defined $meth || defined $func) {
0.000002,1,0.000002,$meth = 'method';
0.000002,1,0.000002,$func = 'func';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we only install keywords that are requested
0.000010,1,0.000010,if (defined $meth) {
0.000000,0,0.000000,$class->install_methodhandler(
0.000000,0,0.000000,name     => $meth,
0.000000,0,0.000000,invocant => '$self',
0.000000,0,0.000000,%opts,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000013,1,0.000013,if (defined $func) {
0.000000,0,0.000000,$class->install_methodhandler(
0.000000,0,0.000000,name     => $func,
0.000000,0,0.000000,%opts,
0.000000,0,0.000000,invocant => undef,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_proto {
0.000025,17,0.000001,my $self = shift;
0.000108,17,0.000006,my ($proto) = $self->SUPER::strip_proto()
0.000000,0,0.000000,or return '';
0.000000,0,0.000000,# we strip comments and newlines here, and stash the number of newlines.
0.000000,0,0.000000,# we will re-inject the newlines in strip_attrs(), because DD does not
0.000000,0,0.000000,# like it when you inject them into the following code block. it does not
0.000000,0,0.000000,# object to tacking on newlines to the code attribute spec though.
0.000000,0,0.000000,# (see the call to inject_if_block() in DD::MethodInstaller::Simple->parser)
0.000092,14,0.000007,$proto =~ s/\s*#.*$//mg;
0.000097,14,0.000007,$self->{__nls} = $proto =~ s/[\r\n]//g;
0.000069,14,0.000005,$proto;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub strip_attrs {
0.000025,17,0.000001,my $self = shift;
0.000092,17,0.000005,my ($attrs) = $self->SUPER::strip_attrs();
0.000026,17,0.000002,$attrs ||= '';
0.000027,17,0.000002,$attrs .= $/ x $self->{__nls} if $self->{__nls};
0.000080,17,0.000005,$attrs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub parse_proto {
0.000030,17,0.000002,my $self = shift;
0.000027,17,0.000002,my ($proto) = @_;
0.000024,17,0.000001,$proto ||= '';
0.000108,17,0.000006,$proto =~ s/\s*#.*$//mg;
0.000109,17,0.000006,$proto =~ s/^\s+//mg;
0.000105,17,0.000006,$proto =~ s/\s+$//mg;
0.000095,17,0.000006,$proto =~ s/[\r\n]//g;
0.000030,17,0.000002,my $invocant = $self->{invocant};
0.000000,0,0.000000,
0.000100,17,0.000006,$invocant = $1 if $proto =~ s{(\$\w+)\s*:\s*}{};
0.000000,0,0.000000,
0.000025,17,0.000001,my $inject = '';
0.000035,17,0.000002,$inject .= "my ${invocant} = shift;" if $invocant;
0.000034,17,0.000002,$inject .= "my ($proto) = \@_;"      if defined $proto and length $proto;
0.000024,17,0.000001,$inject .= '();'; # fix for empty method body
0.000000,0,0.000000,
0.000098,17,0.000006,return $inject;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,# -- a basic class -- #
0.000000,0,0.000000,package User;
0.000000,0,0.000000,use Method::Signatures::Simple;
0.000000,0,0.000000,
0.000000,0,0.000000,method new ($class: $name, $email) {
0.000000,0,0.000000,my $user = {
0.000000,0,0.000000,id    => new_id(42),
0.000000,0,0.000000,name  => $name,
0.000000,0,0.000000,email => $email,
0.000000,0,0.000000,};
0.000000,0,0.000000,bless $user, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,func new_id ($seed) {
0.000000,0,0.000000,state $id = $seed;
0.000000,0,0.000000,$id++;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,method name  { $self->{name};  }
0.000000,0,0.000000,method email { $self->{email}; }
0.000000,0,0.000000,1;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# -- other features -- #
0.000000,0,0.000000,# attributes
0.000000,0,0.000000,method foo : lvalue { $self->{foo} }
0.000000,0,0.000000,
0.000000,0,0.000000,# change invocant name
0.000000,0,0.000000,use Method::Signatures::Simple invocant => '$this';
0.000000,0,0.000000,method foo ($bar) { $this->bar($bar) }
0.000000,0,0.000000,method bar ($class: $bar) { $class->baz($bar) }
0.000000,0,0.000000,
0.000000,0,0.000000,# use a different function keyword
0.000000,0,0.000000,use Method::Signatures::Simple function_keyword => 'fun';
0.000000,0,0.000000,fun triple ($num) { 3 * $num }
0.000000,0,0.000000,
0.000000,0,0.000000,# use a different method keyword
0.000000,0,0.000000,use Method::Signatures::Simple method_keyword => 'action';
0.000000,0,0.000000,action foo { $self->bar }
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 RATIONALE
0.000000,0,0.000000,
0.000000,0,0.000000,This module provides basic C<method> and C<func> keywords with simple
0.000000,0,0.000000,signatures. It's intentionally simple, and is supposed to be a stepping stone
0.000000,0,0.000000,for its bigger brothers L<MooseX::Method::Signatures> and
0.000000,0,0.000000,L<Method::Signatures>.  It only has a small benefit over regular subs, so
0.000000,0,0.000000,if you want more features, look at those modules.  But if you're looking
0.000000,0,0.000000,for a small amount of syntactic sugar, this might just be enough.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FEATURES
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * invocant
0.000000,0,0.000000,
0.000000,0,0.000000,The C<method> keyword automatically injects the annoying C<my $self = shift;>
0.000000,0,0.000000,for you. You can rename the invocant with the first argument, followed by a
0.000000,0,0.000000,colon:
0.000000,0,0.000000,
0.000000,0,0.000000,method ($this:) {}
0.000000,0,0.000000,method ($this: $that) {}
0.000000,0,0.000000,
0.000000,0,0.000000,The C<func> keyword doesn't inject an invocant, but does do the signature
0.000000,0,0.000000,processing below:
0.000000,0,0.000000,
0.000000,0,0.000000,func ($that) {}
0.000000,0,0.000000,
0.000000,0,0.000000,=item * signature
0.000000,0,0.000000,
0.000000,0,0.000000,The signature C<($sig)> is transformed into C<"my ($sig) = \@_;">. That way, we
0.000000,0,0.000000,mimic perl's usual argument handling.
0.000000,0,0.000000,
0.000000,0,0.000000,method foo ($bar, $baz, %opts) {
0.000000,0,0.000000,func xyzzy ($plugh, @zorkmid) {
0.000000,0,0.000000,
0.000000,0,0.000000,# becomes
0.000000,0,0.000000,
0.000000,0,0.000000,sub foo {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($bar, $baz, %opts) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,sub xyzzy {
0.000000,0,0.000000,my ($plugh, @zorkmid) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 ADVANCED CONFIGURATION
0.000000,0,0.000000,
0.000000,0,0.000000,Since this module subclasses L<Devel::Declare::MethodInstaller::Simple>, you
0.000000,0,0.000000,can change the keywords and the default invocant with import arguments. These
0.000000,0,0.000000,changes affect the current scope.
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * change the invocant name
0.000000,0,0.000000,
0.000000,0,0.000000,use Method::Signatures::Simple invocant => '$this';
0.000000,0,0.000000,method x { $this->{x} }
0.000000,0,0.000000,method y { $this->{y} }
0.000000,0,0.000000,
0.000000,0,0.000000,# and this of course still works:
0.000000,0,0.000000,method z ($self:) { $self->{z} }
0.000000,0,0.000000,
0.000000,0,0.000000,=item * change the keywords
0.000000,0,0.000000,
0.000000,0,0.000000,You can install a different keyword (instead of the default 'method' and
0.000000,0,0.000000,'func'), by passing names to the C<use> line:
0.000000,0,0.000000,
0.000000,0,0.000000,use Method::Signatures::Simple method_keyword   => 'action',
0.000000,0,0.000000,function_keyword => 'thing';
0.000000,0,0.000000,
0.000000,0,0.000000,action foo ($some, $args) { ... }
0.000000,0,0.000000,thing bar ($whatever) { ... }
0.000000,0,0.000000,
0.000000,0,0.000000,One benefit of this is that you can use this module together with e.g.
0.000000,0,0.000000,L<MooseX::Declare>:
0.000000,0,0.000000,
0.000000,0,0.000000,# untested
0.000000,0,0.000000,use MooseX::Declare;
0.000000,0,0.000000,
0.000000,0,0.000000,class Foo {
0.000000,0,0.000000,use Method::Signatures::Simple method_keyword => 'routine';
0.000000,0,0.000000,method x (Int $x) { ... }    # from MooseX::Method::Signatures
0.000000,0,0.000000,routine y ($y) { ... }       # from this module
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,If you specify neither C<method_keyword> nor C<function_keyword>, then we
0.000000,0,0.000000,default to injecting C<method> and C<func>. If you only specify one of these
0.000000,0,0.000000,options, then we only inject that one keyword into your scope.
0.000000,0,0.000000,
0.000000,0,0.000000,Examples:
0.000000,0,0.000000,
0.000000,0,0.000000,# injects 'method' and 'func'
0.000000,0,0.000000,use Method::Signatures::Simple;
0.000000,0,0.000000,
0.000000,0,0.000000,# only injects 'action'
0.000000,0,0.000000,use Method::Signatures::Simple method_keyword => 'action';
0.000000,0,0.000000,
0.000000,0,0.000000,# only injects 'procedure'
0.000000,0,0.000000,use Method::Signatures::Simple function_keyword => 'procedure';
0.000000,0,0.000000,
0.000000,0,0.000000,# injects 'action' and 'function'
0.000000,0,0.000000,use Method::Signatures::Simple method_keyword   => 'action',
0.000000,0,0.000000,function_keyword => 'function';
0.000000,0,0.000000,
0.000000,0,0.000000,=item * install several keywords
0.000000,0,0.000000,
0.000000,0,0.000000,You're not limited to a single C<use> line, so you can install several keywords with the same
0.000000,0,0.000000,semantics as 'method' into the current scope:
0.000000,0,0.000000,
0.000000,0,0.000000,use Method::Signatures::Simple; # provides 'method' and 'func'
0.000000,0,0.000000,use Method::Signatures::Simple method_keyword => 'action';
0.000000,0,0.000000,
0.000000,0,0.000000,method x { ... }
0.000000,0,0.000000,func y { ... }
0.000000,0,0.000000,action z { ... }
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=begin pod-coverage
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item parse_proto
0.000000,0,0.000000,
0.000000,0,0.000000,Overridden.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=end pod-coverage
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Rhesa Rozendaal, C<< <rhesa at cpan.org> >>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 BUGS
0.000000,0,0.000000,
0.000000,0,0.000000,Please report any bugs or feature requests to C<bug-method-signatures-simple at rt.cpan.org>, or through
0.000000,0,0.000000,the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Method-Signatures-Simple>.  I will be notified, and then you'll
0.000000,0,0.000000,automatically be notified of progress on your bug as I make changes.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,You can find documentation for this module with the perldoc command.
0.000000,0,0.000000,
0.000000,0,0.000000,perldoc Method::Signatures::Simple
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,You can also look for information at:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * RT: CPAN's request tracker
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Method-Signatures-Simple>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * AnnoCPAN: Annotated CPAN documentation
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://annocpan.org/dist/Method-Signatures-Simple>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * CPAN Ratings
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://cpanratings.perl.org/d/Method-Signatures-Simple>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Search CPAN
0.000000,0,0.000000,
0.000000,0,0.000000,L<http://search.cpan.org/dist/Method-Signatures-Simple>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 ACKNOWLEDGEMENTS
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * MSTROUT
0.000000,0,0.000000,
0.000000,0,0.000000,For writing L<Devel::Declare> and providing the core concepts.
0.000000,0,0.000000,
0.000000,0,0.000000,=item * MSCHWERN
0.000000,0,0.000000,
0.000000,0,0.000000,For writing L<Method::Signatures> and publishing about it. This is what got my attention.
0.000000,0,0.000000,
0.000000,0,0.000000,=item * FLORA
0.000000,0,0.000000,
0.000000,0,0.000000,For helping me abstracting the Devel::Declare bits and suggesting improvements.
0.000000,0,0.000000,
0.000000,0,0.000000,=item * CHIPS
0.000000,0,0.000000,
0.000000,0,0.000000,For suggesting we add a 'func' keyword.
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Devel::Declare>, L<Method::Signatures>, L<MooseX::Method::Signatures>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT & LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2011 Rhesa Rozendaal, all rights reserved.
0.000000,0,0.000000,
0.000000,0,0.000000,This program is free software; you can redistribute it and/or modify it
0.000000,0,0.000000,under the same terms as Perl itself.
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000004,1,0.000004,1; # End of Method::Signatures::Simple
