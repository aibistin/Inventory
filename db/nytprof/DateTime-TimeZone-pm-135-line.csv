# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package DateTime::TimeZone;
0.000000,0,0.000000,{
0.000005,2,0.000003,$DateTime::TimeZone::VERSION = '1.60';
0.000000,0,0.000000,}
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$DateTime::TimeZone::AUTHORITY = 'cpan:DROLSKY';
0.000022,1,0.000022,}
0.000000,0,0.000000,
0.000051,2,0.000026,use 5.006;
0.000000,0,0.000000,
0.000034,2,0.000017,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000178,2,0.000089,use DateTime::TimeZone::Catalog;
0.000124,2,0.000062,use DateTime::TimeZone::Floating;
0.000122,2,0.000061,use DateTime::TimeZone::Local;
0.000037,2,0.000018,use DateTime::TimeZone::OffsetOnly;
0.000040,2,0.000020,use DateTime::TimeZone::UTC;
0.000074,3,0.000025,use Params::Validate 0.72 qw( validate validate_pos SCALAR ARRAYREF BOOLEAN );
0.000000,0,0.000000,
0.000045,2,0.000023,use constant INFINITY => 100**1000;
0.000038,2,0.000019,use constant NEG_INFINITY => -1 * ( 100**1000 );
0.000000,0,0.000000,
0.000000,0,0.000000,# the offsets for each span element
0.000036,2,0.000018,use constant UTC_START   => 0;
0.000036,2,0.000018,use constant UTC_END     => 1;
0.000035,2,0.000017,use constant LOCAL_START => 2;
0.000035,2,0.000017,use constant LOCAL_END   => 3;
0.000035,2,0.000018,use constant OFFSET      => 4;
0.000035,2,0.000017,use constant IS_DST      => 5;
0.002451,2,0.001225,use constant SHORT_NAME  => 6;
0.000000,0,0.000000,
0.000012,1,0.000012,my %SpecialName = map { $_ => 1 }
0.000000,0,0.000000,qw( EST MST HST CET EET MET WET EST5EDT CST6CDT MST7MDT PST8PDT );
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000003,2,0.000002,my $class = shift;
0.000051,2,0.000026,my %p     = validate(
0.000000,0,0.000000,@_,
0.000000,0,0.000000,{ name => { type => SCALAR } },
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000007,2,0.000004,if ( exists $DateTime::TimeZone::Catalog::LINKS{ $p{name} } ) {
0.000000,0,0.000000,$p{name} = $DateTime::TimeZone::Catalog::LINKS{ $p{name} };
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( exists $DateTime::TimeZone::Catalog::LINKS{ uc $p{name} } ) {
0.000000,0,0.000000,$p{name} = $DateTime::TimeZone::Catalog::LINKS{ uc $p{name} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000021,2,0.000010,unless ( $p{name} =~ m,/,
0.000000,0,0.000000,|| $SpecialName{ $p{name} } ) {
0.000028,2,0.000014,if ( $p{name} eq 'floating' ) {
0.000000,0,0.000000,return DateTime::TimeZone::Floating->instance;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $p{name} eq 'local' ) {
0.000000,0,0.000000,return DateTime::TimeZone::Local->TimeZone();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $p{name} eq 'UTC' || $p{name} eq 'Z' ) {
0.000000,0,0.000000,return DateTime::TimeZone::UTC->instance;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return DateTime::TimeZone::OffsetOnly->new( offset => $p{name} );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $subclass = $p{name};
0.000000,0,0.000000,$subclass =~ s/-/_/g;
0.000000,0,0.000000,$subclass =~ s{/}{::}g;
0.000000,0,0.000000,my $real_class = "DateTime::TimeZone::$subclass";
0.000000,0,0.000000,
0.000000,0,0.000000,die "The timezone '$p{name}' in an invalid name.\n"
0.000000,0,0.000000,unless $real_class =~ /^\w+(::\w+)*$/;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $real_class->can('instance') ) {
0.000000,0,0.000000,my $e = do {
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__};
0.000000,0,0.000000,eval "require $real_class";
0.000000,0,0.000000,$@;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($e) {
0.000000,0,0.000000,my $regex = join '.', split /::/, $real_class;
0.000000,0,0.000000,$regex .= '\\.pm';
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $e =~ /^Can't locate $regex/i ) {
0.000000,0,0.000000,die
0.000000,0,0.000000,"The timezone '$p{name}' could not be loaded, or is an invalid name.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die $e;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $zone = $real_class->instance( name => $p{name}, is_olson => 1 );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $zone->is_olson() ) {
0.000000,0,0.000000,my $object_version
0.000000,0,0.000000,= $zone->can('olson_version')
0.000000,0,0.000000,? $zone->olson_version()
0.000000,0,0.000000,: 'unknown';
0.000000,0,0.000000,my $catalog_version = DateTime::TimeZone::Catalog->OlsonVersion();
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $object_version ne $catalog_version ) {
0.000000,0,0.000000,warn
0.000000,0,0.000000,"Loaded $real_class, which is from an older version ($object_version) of the Olson database than this installation of DateTime::TimeZone ($catalog_version).\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $zone;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _init {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %p     = validate(
0.000000,0,0.000000,@_, {
0.000000,0,0.000000,name     => { type => SCALAR },
0.000000,0,0.000000,spans    => { type => ARRAYREF },
0.000000,0,0.000000,is_olson => { type => BOOLEAN, default => 0 },
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $self = bless {
0.000000,0,0.000000,name     => $p{name},
0.000000,0,0.000000,spans    => $p{spans},
0.000000,0,0.000000,is_olson => $p{is_olson},
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $k (qw( last_offset last_observance rules max_year )) {
0.000000,0,0.000000,my $m = "_$k";
0.000000,0,0.000000,$self->{$k} = $self->$m() if $self->can($m);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_olson { $_[0]->{is_olson} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_dst_for_datetime {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $span = $self->_span_for_datetime( 'utc', $_[0] );
0.000000,0,0.000000,
0.000000,0,0.000000,return $span->[IS_DST];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub offset_for_datetime {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $span = $self->_span_for_datetime( 'utc', $_[0] );
0.000000,0,0.000000,
0.000000,0,0.000000,return $span->[OFFSET];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub offset_for_local_datetime {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $span = $self->_span_for_datetime( 'local', $_[0] );
0.000000,0,0.000000,
0.000000,0,0.000000,return $span->[OFFSET];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub short_name_for_datetime {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $span = $self->_span_for_datetime( 'utc', $_[0] );
0.000000,0,0.000000,
0.000000,0,0.000000,return $span->[SHORT_NAME];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _span_for_datetime {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $type = shift;
0.000000,0,0.000000,my $dt   = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $method = $type . '_rd_as_seconds';
0.000000,0,0.000000,
0.000000,0,0.000000,my $end = $type eq 'utc' ? UTC_END : LOCAL_END;
0.000000,0,0.000000,
0.000000,0,0.000000,my $span;
0.000000,0,0.000000,my $seconds = $dt->$method();
0.000000,0,0.000000,if ( $seconds < $self->max_span->[$end] ) {
0.000000,0,0.000000,$span = $self->_spans_binary_search( $type, $seconds );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $until_year = $dt->utc_year + 1;
0.000000,0,0.000000,$span = $self->_generate_spans_until_match( $until_year, $seconds,
0.000000,0,0.000000,$type );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This means someone gave a local time that doesn't exist
0.000000,0,0.000000,# (like during a transition into savings time)
0.000000,0,0.000000,unless ( defined $span ) {
0.000000,0,0.000000,my $err = 'Invalid local time for date';
0.000000,0,0.000000,$err .= ' ' . $dt->iso8601 if $type eq 'utc';
0.000000,0,0.000000,$err .= " in time zone: " . $self->name;
0.000000,0,0.000000,$err .= "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,die $err;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $span;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _spans_binary_search {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $type, $seconds ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $start, $end ) = _keys_for_type($type);
0.000000,0,0.000000,
0.000000,0,0.000000,my $min = 0;
0.000000,0,0.000000,my $max = scalar @{ $self->{spans} } + 1;
0.000000,0,0.000000,my $i   = int( $max / 2 );
0.000000,0,0.000000,
0.000000,0,0.000000,# special case for when there are only 2 spans
0.000000,0,0.000000,$i++ if $max % 2 && $max != 3;
0.000000,0,0.000000,
0.000000,0,0.000000,$i = 0 if @{ $self->{spans} } == 1;
0.000000,0,0.000000,
0.000000,0,0.000000,while (1) {
0.000000,0,0.000000,my $current = $self->{spans}[$i];
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $seconds < $current->[$start] ) {
0.000000,0,0.000000,$max = $i;
0.000000,0,0.000000,my $c = int( ( $i - $min ) / 2 );
0.000000,0,0.000000,$c ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,$i -= $c;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $i < $min;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $seconds >= $current->[$end] ) {
0.000000,0,0.000000,$min = $i;
0.000000,0,0.000000,my $c = int( ( $max - $i ) / 2 );
0.000000,0,0.000000,$c ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,$i += $c;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $i >= $max;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Special case for overlapping ranges because of DST and
0.000000,0,0.000000,# other weirdness (like Alaska's change when bought from
0.000000,0,0.000000,# Russia by the US).  Always prefer latest span.
0.000000,0,0.000000,if ( $current->[IS_DST] && $type eq 'local' ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Asia/Dhaka in 2009j goes into DST without any known
0.000000,0,0.000000,# end-of-DST date (wtf, Bangladesh).
0.000000,0,0.000000,return $current if $current->[UTC_END] == INFINITY;
0.000000,0,0.000000,
0.000000,0,0.000000,my $next = $self->{spans}[ $i + 1 ];
0.000000,0,0.000000,
0.000000,0,0.000000,# Sometimes we will get here and the span we're
0.000000,0,0.000000,# looking at is the last that's been generated so far.
0.000000,0,0.000000,# We need to try to generate one more or else we run
0.000000,0,0.000000,# out.
0.000000,0,0.000000,$next ||= $self->_generate_next_span;
0.000000,0,0.000000,
0.000000,0,0.000000,die "No next span in $self->{max_year}" unless defined $next;
0.000000,0,0.000000,
0.000000,0,0.000000,if (   ( !$next->[IS_DST] )
0.000000,0,0.000000,&& $next->[$start] <= $seconds
0.000000,0,0.000000,&& $seconds <= $next->[$end] ) {
0.000000,0,0.000000,return $next;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $current;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_next_span {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $last_idx = $#{ $self->{spans} };
0.000000,0,0.000000,
0.000000,0,0.000000,my $max_span = $self->max_span;
0.000000,0,0.000000,
0.000000,0,0.000000,# Kind of a hack, but AFAIK there are no zones where it takes
0.000000,0,0.000000,# _more_ than a year for a _future_ time zone change to occur, so
0.000000,0,0.000000,# by looking two years out we can ensure that we will find at
0.000000,0,0.000000,# least one more span.  Of course, I will no doubt be proved wrong
0.000000,0,0.000000,# and this will cause errors.
0.000000,0,0.000000,$self->_generate_spans_until_match( $self->{max_year} + 2,
0.000000,0,0.000000,$max_span->[UTC_END] + ( 366 * 86400 ), 'utc' );
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{spans}[ $last_idx + 1 ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_spans_until_match {
0.000000,0,0.000000,my $self                = shift;
0.000000,0,0.000000,my $generate_until_year = shift;
0.000000,0,0.000000,my $seconds             = shift;
0.000000,0,0.000000,my $type                = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @changes;
0.000000,0,0.000000,my @rules = @{ $self->_rules };
0.000000,0,0.000000,foreach my $year ( $self->{max_year} .. $generate_until_year ) {
0.000000,0,0.000000,for ( my $x = 0; $x < @rules; $x++ ) {
0.000000,0,0.000000,my $last_offset_from_std;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @rules == 2 ) {
0.000000,0,0.000000,$last_offset_from_std
0.000000,0,0.000000,= $x
0.000000,0,0.000000,? $rules[0]->offset_from_std
0.000000,0,0.000000,: $rules[1]->offset_from_std;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( @rules == 1 ) {
0.000000,0,0.000000,$last_offset_from_std = $rules[0]->offset_from_std;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $count = scalar @rules;
0.000000,0,0.000000,die
0.000000,0,0.000000,"Cannot generate future changes for zone with $count infinite rules\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $rule = $rules[$x];
0.000000,0,0.000000,
0.000000,0,0.000000,my $next = $rule->utc_start_datetime_for_year( $year,
0.000000,0,0.000000,$self->{last_offset}, $last_offset_from_std );
0.000000,0,0.000000,
0.000000,0,0.000000,# don't bother with changes we've seen already
0.000000,0,0.000000,next if $next->utc_rd_as_seconds < $self->max_span->[UTC_END];
0.000000,0,0.000000,
0.000000,0,0.000000,push @changes,
0.000000,0,0.000000,DateTime::TimeZone::OlsonDB::Change->new(
0.000000,0,0.000000,type                 => 'rule',
0.000000,0,0.000000,utc_start_datetime   => $next,
0.000000,0,0.000000,local_start_datetime => $next + DateTime::Duration->new(
0.000000,0,0.000000,seconds => $self->{last_observance}->total_offset
0.000000,0,0.000000,+ $rule->offset_from_std
0.000000,0,0.000000,),
0.000000,0,0.000000,short_name => sprintf(
0.000000,0,0.000000,$self->{last_observance}->format, $rule->letter
0.000000,0,0.000000,),
0.000000,0,0.000000,observance => $self->{last_observance},
0.000000,0,0.000000,rule       => $rule,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{max_year} = $generate_until_year;
0.000000,0,0.000000,
0.000000,0,0.000000,my @sorted
0.000000,0,0.000000,= sort { $a->utc_start_datetime <=> $b->utc_start_datetime } @changes;
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $start, $end ) = _keys_for_type($type);
0.000000,0,0.000000,
0.000000,0,0.000000,my $match;
0.000000,0,0.000000,for ( my $x = 1; $x < @sorted; $x++ ) {
0.000000,0,0.000000,my $last_total_offset
0.000000,0,0.000000,= $x == 1
0.000000,0,0.000000,? $self->max_span->[OFFSET]
0.000000,0,0.000000,: $sorted[ $x - 2 ]->total_offset;
0.000000,0,0.000000,
0.000000,0,0.000000,my $span = DateTime::TimeZone::OlsonDB::Change::two_changes_as_span(
0.000000,0,0.000000,@sorted[ $x - 1, $x ], $last_total_offset );
0.000000,0,0.000000,
0.000000,0,0.000000,$span = _span_as_array($span);
0.000000,0,0.000000,
0.000000,0,0.000000,push @{ $self->{spans} }, $span;
0.000000,0,0.000000,
0.000000,0,0.000000,$match = $span
0.000000,0,0.000000,if $seconds >= $span->[$start] && $seconds < $span->[$end];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $match;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub max_span { $_[0]->{spans}[-1] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _keys_for_type {
0.000000,0,0.000000,$_[0] eq 'utc' ? ( UTC_START, UTC_END ) : ( LOCAL_START, LOCAL_END );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _span_as_array {
0.000000,0,0.000000,[
0.000000,0,0.000000,@{ $_[0] }{
0.000000,0,0.000000,qw( utc_start utc_end local_start local_end offset is_dst short_name )
0.000000,0,0.000000,}
0.000000,0,0.000000,];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_floating {0}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_utc {0}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_dst_changes {0}
0.000000,0,0.000000,
0.000000,0,0.000000,sub name { $_[0]->{name} }
0.000000,0,0.000000,sub category { ( split /\//, $_[0]->{name}, 2 )[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_valid_name {
0.000000,0,0.000000,my $tz;
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__};
0.000000,0,0.000000,$tz = eval { $_[0]->new( name => $_[1] ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $tz && $tz->isa('DateTime::TimeZone') ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_freeze {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_thaw {
0.000000,0,0.000000,my $self       = shift;
0.000000,0,0.000000,my $cloning    = shift;
0.000000,0,0.000000,my $serialized = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = ref $self || $self;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj;
0.000000,0,0.000000,if ( $class->isa(__PACKAGE__) ) {
0.000000,0,0.000000,$obj = __PACKAGE__->new( name => $serialized );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$obj = $class->new( name => $serialized );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$obj;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#
0.000000,0,0.000000,# Functions
0.000000,0,0.000000,#
0.000000,0,0.000000,sub offset_as_seconds {
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__};
0.000000,0,0.000000,shift if eval { $_[0]->isa('DateTime::TimeZone') };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $offset = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef unless defined $offset;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 if $offset eq '0';
0.000000,0,0.000000,
0.000000,0,0.000000,my ( $sign, $hours, $minutes, $seconds );
0.000000,0,0.000000,if ( $offset =~ /^([\+\-])?(\d\d?):(\d\d)(?::(\d\d))?$/ ) {
0.000000,0,0.000000,( $sign, $hours, $minutes, $seconds ) = ( $1, $2, $3, $4 );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( $offset =~ /^([\+\-])?(\d\d)(\d\d)(\d\d)?$/ ) {
0.000000,0,0.000000,( $sign, $hours, $minutes, $seconds ) = ( $1, $2, $3, $4 );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$sign = '+' unless defined $sign;
0.000000,0,0.000000,return undef unless $hours >= 0   && $hours <= 99;
0.000000,0,0.000000,return undef unless $minutes >= 0 && $minutes <= 59;
0.000000,0,0.000000,return undef
0.000000,0,0.000000,unless !defined($seconds) || ( $seconds >= 0 && $seconds <= 59 );
0.000000,0,0.000000,
0.000000,0,0.000000,my $total = $hours * 3600 + $minutes * 60;
0.000000,0,0.000000,$total += $seconds if $seconds;
0.000000,0,0.000000,$total *= -1 if $sign eq '-';
0.000000,0,0.000000,
0.000000,0,0.000000,return $total;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub offset_as_string {
0.000000,0,0.000000,{
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,local $SIG{__DIE__};
0.000000,0,0.000000,shift if eval { $_[0]->isa('DateTime::TimeZone') };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $offset = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return undef unless defined $offset;
0.000000,0,0.000000,return undef unless $offset >= -359999 && $offset <= 359999;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sign = $offset < 0 ? '-' : '+';
0.000000,0,0.000000,
0.000000,0,0.000000,$offset = abs($offset);
0.000000,0,0.000000,
0.000000,0,0.000000,my $hours = int( $offset / 3600 );
0.000000,0,0.000000,$offset %= 3600;
0.000000,0,0.000000,my $mins = int( $offset / 60 );
0.000000,0,0.000000,$offset %= 60;
0.000000,0,0.000000,my $secs = int($offset);
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,$secs
0.000000,0,0.000000,? sprintf( '%s%02d%02d%02d', $sign, $hours, $mins, $secs )
0.000000,0,0.000000,: sprintf( '%s%02d%02d',     $sign, $hours, $mins )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# These methods all operate on data contained in the DateTime/TimeZone/Catalog.pm file.
0.000000,0,0.000000,
0.000000,0,0.000000,sub all_names {
0.000000,0,0.000000,return
0.000000,0,0.000000,wantarray
0.000000,0,0.000000,? @DateTime::TimeZone::Catalog::ALL
0.000000,0,0.000000,: [@DateTime::TimeZone::Catalog::ALL];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub categories {
0.000000,0,0.000000,return wantarray
0.000000,0,0.000000,? @DateTime::TimeZone::Catalog::CATEGORY_NAMES
0.000000,0,0.000000,: [@DateTime::TimeZone::Catalog::CATEGORY_NAMES];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub links {
0.000000,0,0.000000,return
0.000000,0,0.000000,wantarray
0.000000,0,0.000000,? %DateTime::TimeZone::Catalog::LINKS
0.000000,0,0.000000,: {%DateTime::TimeZone::Catalog::LINKS};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub names_in_category {
0.000000,0,0.000000,shift if $_[0]->isa('DateTime::TimeZone');
0.000000,0,0.000000,return unless exists $DateTime::TimeZone::Catalog::CATEGORIES{ $_[0] };
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray
0.000000,0,0.000000,? @{ $DateTime::TimeZone::Catalog::CATEGORIES{ $_[0] } }
0.000000,0,0.000000,: $DateTime::TimeZone::Catalog::CATEGORIES{ $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub countries {
0.000000,0,0.000000,wantarray
0.000000,0,0.000000,? ( sort keys %DateTime::TimeZone::Catalog::ZONES_BY_COUNTRY )
0.000000,0,0.000000,: [ sort keys %DateTime::TimeZone::Catalog::ZONES_BY_COUNTRY ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub names_in_country {
0.000000,0,0.000000,shift if $_[0]->isa('DateTime::TimeZone');
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000000,0,0.000000,unless
0.000000,0,0.000000,exists $DateTime::TimeZone::Catalog::ZONES_BY_COUNTRY{ lc $_[0] };
0.000000,0,0.000000,
0.000000,0,0.000000,return
0.000000,0,0.000000,wantarray
0.000000,0,0.000000,? @{ $DateTime::TimeZone::Catalog::ZONES_BY_COUNTRY{ lc $_[0] } }
0.000000,0,0.000000,: $DateTime::TimeZone::Catalog::ZONES_BY_COUNTRY{ lc $_[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Time zone object base class and factory
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
