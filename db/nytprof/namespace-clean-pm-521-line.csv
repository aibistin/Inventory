# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package namespace::clean;
0.000000,0,0.000000,
0.000031,2,0.000016,use warnings;
0.000032,2,0.000016,use strict;
0.000000,0,0.000000,
0.000057,2,0.000028,use Package::Stash;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.24';
0.000002,1,0.000002,our $STORAGE_VAR = '__NAMESPACE_CLEAN_STORAGE';
0.000000,0,0.000000,
0.000095,2,0.000047,use B::Hooks::EndOfScope 'on_scope_end';
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,namespace::clean - Keep imports and functions out of your namespace
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,package Foo;
0.000000,0,0.000000,use warnings;
0.000000,0,0.000000,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,use Carp qw(croak);   # 'croak' will be removed
0.000000,0,0.000000,
0.000000,0,0.000000,sub bar { 23 }        # 'bar' will be removed
0.000000,0,0.000000,
0.000000,0,0.000000,# remove all previously defined functions
0.000000,0,0.000000,use namespace::clean;
0.000000,0,0.000000,
0.000000,0,0.000000,sub baz { bar() }     # 'baz' still defined, 'bar' still bound
0.000000,0,0.000000,
0.000000,0,0.000000,# begin to collection function names from here again
0.000000,0,0.000000,no namespace::clean;
0.000000,0,0.000000,
0.000000,0,0.000000,sub quux { baz() }    # 'quux' will be removed
0.000000,0,0.000000,
0.000000,0,0.000000,# remove all functions defined after the 'no' unimport
0.000000,0,0.000000,use namespace::clean;
0.000000,0,0.000000,
0.000000,0,0.000000,# Will print: 'No', 'No', 'Yes' and 'No'
0.000000,0,0.000000,print +(__PACKAGE__->can('croak') ? 'Yes' : 'No'), "\n";
0.000000,0,0.000000,print +(__PACKAGE__->can('bar')   ? 'Yes' : 'No'), "\n";
0.000000,0,0.000000,print +(__PACKAGE__->can('baz')   ? 'Yes' : 'No'), "\n";
0.000000,0,0.000000,print +(__PACKAGE__->can('quux')  ? 'Yes' : 'No'), "\n";
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Keeping packages clean
0.000000,0,0.000000,
0.000000,0,0.000000,When you define a function, or import one, into a Perl package, it will
0.000000,0,0.000000,naturally also be available as a method. This does not per se cause
0.000000,0,0.000000,problems, but it can complicate subclassing and, for example, plugin
0.000000,0,0.000000,classes that are included via multiple inheritance by loading them as
0.000000,0,0.000000,base classes.
0.000000,0,0.000000,
0.000000,0,0.000000,The C<namespace::clean> pragma will remove all previously declared or
0.000000,0,0.000000,imported symbols at the end of the current package's compile cycle.
0.000000,0,0.000000,Functions called in the package itself will still be bound by their
0.000000,0,0.000000,name, but they won't show up as methods on your class or instances.
0.000000,0,0.000000,
0.000000,0,0.000000,By unimporting via C<no> you can tell C<namespace::clean> to start
0.000000,0,0.000000,collecting functions for the next C<use namespace::clean;> specification.
0.000000,0,0.000000,
0.000000,0,0.000000,You can use the C<-except> flag to tell C<namespace::clean> that you
0.000000,0,0.000000,don't want it to remove a certain function or method. A common use would
0.000000,0,0.000000,be a module exporting an C<import> method along with some functions:
0.000000,0,0.000000,
0.000000,0,0.000000,use ModuleExportingImport;
0.000000,0,0.000000,use namespace::clean -except => [qw( import )];
0.000000,0,0.000000,
0.000000,0,0.000000,If you just want to C<-except> a single sub, you can pass it directly.
0.000000,0,0.000000,For more than one value you have to use an array reference.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Explicitly removing functions when your scope is compiled
0.000000,0,0.000000,
0.000000,0,0.000000,It is also possible to explicitly tell C<namespace::clean> what packages
0.000000,0,0.000000,to remove when the surrounding scope has finished compiling. Here is an
0.000000,0,0.000000,example:
0.000000,0,0.000000,
0.000000,0,0.000000,package Foo;
0.000000,0,0.000000,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,# blessed NOT available
0.000000,0,0.000000,
0.000000,0,0.000000,sub my_class {
0.000000,0,0.000000,use Scalar::Util qw( blessed );
0.000000,0,0.000000,use namespace::clean qw( blessed );
0.000000,0,0.000000,
0.000000,0,0.000000,# blessed available
0.000000,0,0.000000,return blessed shift;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# blessed NOT available
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Moose
0.000000,0,0.000000,
0.000000,0,0.000000,When using C<namespace::clean> together with L<Moose> you want to keep
0.000000,0,0.000000,the installed C<meta> method. So your classes should look like:
0.000000,0,0.000000,
0.000000,0,0.000000,package Foo;
0.000000,0,0.000000,use Moose;
0.000000,0,0.000000,use namespace::clean -except => 'meta';
0.000000,0,0.000000,...
0.000000,0,0.000000,
0.000000,0,0.000000,Same goes for L<Moose::Role>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Cleaning other packages
0.000000,0,0.000000,
0.000000,0,0.000000,You can tell C<namespace::clean> that you want to clean up another package
0.000000,0,0.000000,instead of the one importing. To do this you have to pass in the C<-cleanee>
0.000000,0,0.000000,option like this:
0.000000,0,0.000000,
0.000000,0,0.000000,package My::MooseX::namespace::clean;
0.000000,0,0.000000,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,use namespace::clean (); # no cleanup, just load
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,namespace::clean->import(
0.000000,0,0.000000,-cleanee => scalar(caller),
0.000000,0,0.000000,-except  => 'meta',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,If you don't care about C<namespace::clean>s discover-and-C<-except> logic, and
0.000000,0,0.000000,just want to remove subroutines, try L</clean_subroutines>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 METHODS
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 clean_subroutines
0.000000,0,0.000000,
0.000000,0,0.000000,This exposes the actual subroutine-removal logic.
0.000000,0,0.000000,
0.000000,0,0.000000,namespace::clean->clean_subroutines($cleanee, qw( subA subB ));
0.000000,0,0.000000,
0.000000,0,0.000000,will remove C<subA> and C<subB> from C<$cleanee>. Note that this will remove the
0.000000,0,0.000000,subroutines B<immediately> and not wait for scope end. If you want to have this
0.000000,0,0.000000,effect at a specific time (e.g. C<namespace::clean> acts on scope compile end)
0.000000,0,0.000000,it is your responsibility to make sure it runs at that time.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,# Constant to optimise away the unused code branches
0.000050,2,0.000025,use constant FIXUP_NEEDED => $] < 5.015_005_1;
0.000036,2,0.000018,use constant FIXUP_RENAME_SUB => $] > 5.008_008_9 && $] < 5.013_005_1;
0.000000,0,0.000000,{
0.001058,3,0.000353,no strict;
0.000003,1,0.000003,delete ${__PACKAGE__."::"}{FIXUP_NEEDED};
0.000002,1,0.000002,delete ${__PACKAGE__."::"}{FIXUP_RENAME_SUB};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Debugger fixup necessary before perl 5.15.5
0.000000,0,0.000000,#
0.000000,0,0.000000,# In perl 5.8.9-5.12, it assumes that sub_fullname($sub) can
0.000000,0,0.000000,# always be used to find the CV again.
0.000000,0,0.000000,# In perl 5.8.8 and 5.14, it assumes that the name of the glob
0.000000,0,0.000000,# passed to entersub can be used to find the CV.
0.000000,0,0.000000,# since we are deleting the glob where the subroutine was originally
0.000000,0,0.000000,# defined, those assumptions no longer hold.
0.000000,0,0.000000,#
0.000000,0,0.000000,# So in 5.8.9-5.12 we need to move it elsewhere and point the
0.000000,0,0.000000,# CV's name to the new glob.
0.000000,0,0.000000,#
0.000000,0,0.000000,# In 5.8.8 and 5.14 we move it elsewhere and rename the
0.000000,0,0.000000,# original glob by assigning the new glob back to it.
0.000001,1,0.000001,my $sub_utils_loaded;
0.000000,0,0.000000,my $DebuggerFixup = sub {
0.000000,0,0.000000,my ($f, $sub, $cleanee_stash, $deleted_stash) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if (FIXUP_RENAME_SUB) {
0.000000,0,0.000000,if (! defined $sub_utils_loaded ) {
0.000000,0,0.000000,$sub_utils_loaded = do {
0.000000,0,0.000000,
0.000000,0,0.000000,# when changing version also change in Makefile.PL
0.000000,0,0.000000,my $sn_ver = 0.04;
0.000000,0,0.000000,eval { require Sub::Name; Sub::Name->VERSION($sn_ver) }
0.000000,0,0.000000,or die "Sub::Name $sn_ver required when running under -d or equivalent: $@";
0.000000,0,0.000000,
0.000000,0,0.000000,# when changing version also change in Makefile.PL
0.000000,0,0.000000,my $si_ver = 0.04;
0.000000,0,0.000000,eval { require Sub::Identify; Sub::Identify->VERSION($si_ver) }
0.000000,0,0.000000,or die "Sub::Identify $si_ver required when running under -d or equivalent: $@";
0.000000,0,0.000000,
0.000000,0,0.000000,1;
0.000000,0,0.000000,} ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ( Sub::Identify::sub_fullname($sub) eq ($cleanee_stash->name . "::$f") ) {
0.000000,0,0.000000,my $new_fq = $deleted_stash->name . "::$f";
0.000000,0,0.000000,Sub::Name::subname($new_fq, $sub);
0.000000,0,0.000000,$deleted_stash->add_symbol("&$f", $sub);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$deleted_stash->add_symbol("&$f", $sub);
0.000000,0,0.000000,}
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $RemoveSubs = sub {
0.000003,2,0.000002,my $cleanee = shift;
0.000003,2,0.000002,my $store   = shift;
0.000031,2,0.000015,my $cleanee_stash = Package::Stash->new($cleanee);
0.000003,2,0.000001,my $deleted_stash;
0.000000,0,0.000000,
0.000000,0,0.000000,SYMBOL:
0.000020,2,0.000010,for my $f (@_) {
0.000000,0,0.000000,
0.000000,0,0.000000,# ignore already removed symbols
0.000065,39,0.000002,next SYMBOL if $store->{exclude}{ $f };
0.000000,0,0.000000,
0.000522,39,0.000013,my $sub = $cleanee_stash->get_symbol("&$f")
0.000000,0,0.000000,or next SYMBOL;
0.000000,0,0.000000,
0.000058,39,0.000001,my $need_debugger_fixup =
0.000000,0,0.000000,FIXUP_NEEDED
0.000000,0,0.000000,&&
0.000000,0,0.000000,$^P
0.000000,0,0.000000,&&
0.000000,0,0.000000,ref(my $globref = \$cleanee_stash->namespace->{$f}) eq 'GLOB'
0.000000,0,0.000000,;
0.000000,0,0.000000,
0.000000,0,0.000000,if (FIXUP_NEEDED && $need_debugger_fixup) {
0.000000,0,0.000000,# convince the Perl debugger to work
0.000000,0,0.000000,# see the comment on top of $DebuggerFixup
0.000000,0,0.000000,$DebuggerFixup->(
0.000000,0,0.000000,$f,
0.000000,0,0.000000,$sub,
0.000000,0,0.000000,$cleanee_stash,
0.000000,0,0.000000,$deleted_stash ||= Package::Stash->new("namespace::clean::deleted::$cleanee"),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000247,156,0.000002,my @symbols = map {
0.000307,39,0.000008,my $name = $_ . $f;
0.001878,156,0.000012,my $def = $cleanee_stash->get_symbol($name);
0.000252,156,0.000002,defined($def) ? [$name, $def] : ()
0.000000,0,0.000000,} '$', '@', '%', '';
0.000000,0,0.000000,
0.000486,39,0.000012,$cleanee_stash->remove_glob($f);
0.000000,0,0.000000,
0.000000,0,0.000000,# if this perl needs no renaming trick we need to
0.000000,0,0.000000,# rename the original glob after the fact
0.000000,0,0.000000,# (see commend of $DebuggerFixup
0.000000,0,0.000000,if (FIXUP_NEEDED && !FIXUP_RENAME_SUB && $need_debugger_fixup) {
0.000000,0,0.000000,*$globref = $deleted_stash->namespace->{$f};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000209,39,0.000005,$cleanee_stash->add_symbol(@$_) for @symbols;
0.000000,0,0.000000,}
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub clean_subroutines {
0.000004,1,0.000004,my ($nc, $cleanee, @subs) = @_;
0.000014,1,0.000014,$RemoveSubs->($cleanee, {}, @subs);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 import
0.000000,0,0.000000,
0.000000,0,0.000000,Makes a snapshot of the current defined functions and installs a
0.000000,0,0.000000,L<B::Hooks::EndOfScope> hook in the current scope to invoke the cleanups.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000002,1,0.000002,my ($pragma, @args) = @_;
0.000000,0,0.000000,
0.000001,1,0.000001,my (%args, $is_explicit);
0.000000,0,0.000000,
0.000000,0,0.000000,ARG:
0.000003,1,0.000003,while (@args) {
0.000000,0,0.000000,
0.000000,0,0.000000,if ($args[0] =~ /^\-/) {
0.000000,0,0.000000,my $key = shift @args;
0.000000,0,0.000000,my $value = shift @args;
0.000000,0,0.000000,$args{ $key } = $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$is_explicit++;
0.000000,0,0.000000,last ARG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,my $cleanee = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
0.000001,1,0.000001,if ($is_explicit) {
0.000000,0,0.000000,on_scope_end {
0.000000,0,0.000000,$RemoveSubs->($cleanee, {}, @args);
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# calling class, all current functions and our storage
0.000006,1,0.000006,my $functions = $pragma->get_functions($cleanee);
0.000006,1,0.000006,my $store     = $pragma->get_class_store($cleanee);
0.000011,1,0.000011,my $stash     = Package::Stash->new($cleanee);
0.000000,0,0.000000,
0.000000,0,0.000000,# except parameter can be array ref or single value
0.000000,0,0.000000,my %except = map {( $_ => 1 )} (
0.000000,0,0.000000,$args{ -except }
0.000000,0,0.000000,? ( ref $args{ -except } eq 'ARRAY' ? @{ $args{ -except } } : $args{ -except } )
0.000003,1,0.000003,: ()
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# register symbols for removal, if they have a CODE entry
0.000004,1,0.000004,for my $f (keys %$functions) {
0.000003,2,0.000001,next if     $except{ $f };
0.000035,2,0.000017,next unless $stash->has_symbol("&$f");
0.000008,2,0.000004,$store->{remove}{ $f } = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# register EOF handler on first call to import
0.000003,1,0.000003,unless ($store->{handler_is_installed}) {
0.000000,0,0.000000,on_scope_end {
0.000011,1,0.000011,$RemoveSubs->($cleanee, $store, keys %{ $store->{remove} });
0.000007,1,0.000007,};
0.000002,1,0.000002,$store->{handler_is_installed} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 unimport
0.000000,0,0.000000,
0.000000,0,0.000000,This method will be called when you do a
0.000000,0,0.000000,
0.000000,0,0.000000,no namespace::clean;
0.000000,0,0.000000,
0.000000,0,0.000000,It will start a new section of code that defines functions to clean up.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,my ($pragma, %args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# the calling class, the current functions and our storage
0.000000,0,0.000000,my $cleanee   = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
0.000000,0,0.000000,my $functions = $pragma->get_functions($cleanee);
0.000000,0,0.000000,my $store     = $pragma->get_class_store($cleanee);
0.000000,0,0.000000,
0.000000,0,0.000000,# register all unknown previous functions as excluded
0.000000,0,0.000000,for my $f (keys %$functions) {
0.000000,0,0.000000,next if $store->{remove}{ $f }
0.000000,0,0.000000,or $store->{exclude}{ $f };
0.000000,0,0.000000,$store->{exclude}{ $f } = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 get_class_store
0.000000,0,0.000000,
0.000000,0,0.000000,This returns a reference to a hash in a passed package containing
0.000000,0,0.000000,information about function names included and excluded from removal.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_class_store {
0.000002,1,0.000002,my ($pragma, $class) = @_;
0.000012,1,0.000012,my $stash = Package::Stash->new($class);
0.000002,1,0.000002,my $var = "%$STORAGE_VAR";
0.000039,1,0.000039,$stash->add_symbol($var, {})
0.000000,0,0.000000,unless $stash->has_symbol($var);
0.000020,1,0.000020,return $stash->get_symbol($var);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 get_functions
0.000000,0,0.000000,
0.000000,0,0.000000,Takes a class as argument and returns all currently defined functions
0.000000,0,0.000000,in it as a hash reference with the function name as key and a typeglob
0.000000,0,0.000000,reference to the symbol as value.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_functions {
0.000002,1,0.000002,my ($pragma, $class) = @_;
0.000000,0,0.000000,
0.000017,1,0.000017,my $stash = Package::Stash->new($class);
0.000000,0,0.000000,return {
0.000069,1,0.000069,map { $_ => $stash->get_symbol("&$_") }
0.000000,0,0.000000,$stash->list_all_symbols('CODE')
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 IMPLEMENTATION DETAILS
0.000000,0,0.000000,
0.000000,0,0.000000,This module works through the effect that a
0.000000,0,0.000000,
0.000000,0,0.000000,delete $SomePackage::{foo};
0.000000,0,0.000000,
0.000000,0,0.000000,will remove the C<foo> symbol from C<$SomePackage> for run time lookups
0.000000,0,0.000000,(e.g., method calls) but will leave the entry alive to be called by
0.000000,0,0.000000,already resolved names in the package itself. C<namespace::clean> will
0.000000,0,0.000000,restore and therefor in effect keep all glob slots that aren't C<CODE>.
0.000000,0,0.000000,
0.000000,0,0.000000,A test file has been added to the perl core to ensure that this behaviour
0.000000,0,0.000000,will be stable in future releases.
0.000000,0,0.000000,
0.000000,0,0.000000,Just for completeness sake, if you want to remove the symbol completely,
0.000000,0,0.000000,use C<undef> instead.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<B::Hooks::EndOfScope>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 THANKS
0.000000,0,0.000000,
0.000000,0,0.000000,Many thanks to Matt S Trout for the inspiration on the whole idea.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHORS
0.000000,0,0.000000,
0.000000,0,0.000000,=over
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,Robert 'phaylon' Sedlacek <rs@474.at>
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,Florian Ragwitz <rafl@debian.org>
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,Jesse Luehrs <doy@tozt.net>
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,Peter Rabbitson <ribasushi@cpan.org>
0.000000,0,0.000000,
0.000000,0,0.000000,=item *
0.000000,0,0.000000,
0.000000,0,0.000000,Father Chrysostomos <sprout@cpan.org>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT AND LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This software is copyright (c) 2011 by L</AUTHORS>
0.000000,0,0.000000,
0.000000,0,0.000000,This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000032,2,0.000016,no warnings;
0.000006,1,0.000006,'Danger! Laws of Thermodynamics may not apply.'
