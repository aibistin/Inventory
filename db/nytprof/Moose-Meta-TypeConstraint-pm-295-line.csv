# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Meta::TypeConstraint;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::TypeConstraint::AUTHORITY = 'cpan:STEVAN';
0.000032,1,0.000032,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::TypeConstraint::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000034,2,0.000017,use strict;
0.000033,2,0.000016,use warnings;
0.000177,2,0.000089,use metaclass;
0.000000,0,0.000000,
0.000000,0,0.000000,use overload '0+'     => sub { refaddr(shift) }, # id an object
0.000000,0,0.000000,'""'     => sub { shift->name },   # stringify to tc name
0.000483,84,0.000006,bool     => sub { 1 },
0.000042,2,0.000021,fallback => 1;
0.000000,0,0.000000,
0.000036,2,0.000018,use Carp qw(confess);
0.000034,2,0.000017,use Class::Load qw(load_class);
0.000037,2,0.000019,use Eval::Closure;
0.000035,2,0.000017,use Scalar::Util qw(blessed refaddr);
0.000034,2,0.000017,use Sub::Name qw(subname);
0.000035,2,0.000018,use Try::Tiny;
0.000000,0,0.000000,
0.001816,2,0.000908,use base qw(Class::MOP::Object);
0.000000,0,0.000000,
0.000014,1,0.000014,__PACKAGE__->meta->add_attribute('name'       => (
0.000000,0,0.000000,reader => 'name',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('parent'     => (
0.000000,0,0.000000,reader    => 'parent',
0.000000,0,0.000000,predicate => 'has_parent',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000003,1,0.000003,my $null_constraint = sub { 1 };
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('constraint' => (
0.000000,0,0.000000,reader  => 'constraint',
0.000000,0,0.000000,writer  => '_set_constraint',
0.000008,1,0.000008,default => sub { $null_constraint },
0.000014,1,0.000014,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('message'   => (
0.000000,0,0.000000,accessor  => 'message',
0.000000,0,0.000000,predicate => 'has_message',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('_default_message' => (
0.000000,0,0.000000,accessor  => '_default_message',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,# can't make this a default because it has to close over the type name, and
0.000000,0,0.000000,# cmop attributes don't have lazy
0.000000,0,0.000000,my $_default_message_generator = sub {
0.000040,23,0.000002,my $name = shift;
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my $value = shift;
0.000000,0,0.000000,# have to load it late like this, since it uses Moose itself
0.000000,0,0.000000,my $can_partialdump = try {
0.000000,0,0.000000,# versions prior to 0.14 had a potential infinite loop bug
0.000000,0,0.000000,load_class('Devel::PartialDump', { -version => 0.14 });
0.000000,0,0.000000,1;
0.000000,0,0.000000,};
0.000000,0,0.000000,if ($can_partialdump) {
0.000000,0,0.000000,$value = Devel::PartialDump->new->dump($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$value = (defined $value ? overload::StrVal($value) : 'undef');
0.000000,0,0.000000,}
0.000000,0,0.000000,return "Validation failed for '" . $name . "' with value $value";
0.000000,0,0.000000,}
0.000175,24,0.000007,};
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('coercion'   => (
0.000000,0,0.000000,accessor  => 'coercion',
0.000000,0,0.000000,predicate => 'has_coercion',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('hand_optimized_type_constraint' => (
0.000000,0,0.000000,init_arg  => 'optimized',
0.000000,0,0.000000,accessor  => 'hand_optimized_type_constraint',
0.000000,0,0.000000,predicate => 'has_hand_optimized_type_constraint',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('inlined' => (
0.000000,0,0.000000,init_arg  => 'inlined',
0.000000,0,0.000000,accessor  => 'inlined',
0.000000,0,0.000000,predicate => '_has_inlined_type_constraint',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('inline_environment' => (
0.000000,0,0.000000,init_arg => 'inline_environment',
0.000000,0,0.000000,accessor => '_inline_environment',
0.000140,23,0.000006,default  => sub { {} },
0.000014,1,0.000014,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub parents {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,$self->parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# private accessors
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('compiled_type_constraint' => (
0.000000,0,0.000000,accessor  => '_compiled_type_constraint',
0.000000,0,0.000000,predicate => '_has_compiled_type_constraint',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('package_defined_in' => (
0.000000,0,0.000000,accessor => '_package_defined_in',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000035,23,0.000002,my $class = shift;
0.000073,23,0.000003,my ($first, @rest) = @_;
0.000076,23,0.000003,my %args = ref $first ? %$first : $first ? ($first, @rest) : ();
0.000048,23,0.000002,$args{name} = $args{name} ? "$args{name}" : "__ANON__";
0.000000,0,0.000000,
0.000034,23,0.000001,if ( $args{optimized} ) {
0.000000,0,0.000000,Moose::Deprecated::deprecated(
0.000000,0,0.000000,feature => 'optimized type constraint sub ref',
0.000000,0,0.000000,message =>
0.000000,0,0.000000,'Providing an optimized subroutine ref for type constraints is deprecated.'
0.000000,0,0.000000,. ' Use the inlining feature (inline_as) instead.'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000036,23,0.000002,if ( exists $args{message}
0.000000,0,0.000000,&& (!ref($args{message}) || ref($args{message}) ne 'CODE') ) {
0.000000,0,0.000000,confess("The 'message' parameter must be a coderef");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000155,23,0.000007,my $self  = $class->_new(%args);
0.000235,23,0.000010,$self->compile_type_constraint()
0.000000,0,0.000000,unless $self->_has_compiled_type_constraint;
0.000415,23,0.000018,$self->_default_message($_default_message_generator->($self->name))
0.000000,0,0.000000,unless $self->has_message;
0.000161,23,0.000007,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $coercion = $self->coercion;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($coercion) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error("Cannot coerce without a type coercion");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $_[0] if $self->check($_[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,return $coercion->coerce(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_coerce {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $result = $self->coerce(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->assert_valid($result);
0.000000,0,0.000000,
0.000000,0,0.000000,return $result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check {
0.000000,0,0.000000,my ($self, @args) = @_;
0.000000,0,0.000000,my $constraint_subref = $self->_compiled_type_constraint;
0.000000,0,0.000000,return $constraint_subref->(@args) ? 1 : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub validate {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,if ($self->_compiled_type_constraint->($value)) {
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$self->get_message($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub can_be_inlined {
0.000169,117,0.000001,my $self = shift;
0.000000,0,0.000000,
0.001050,117,0.000009,if ( $self->has_parent && $self->constraint == $null_constraint ) {
0.000000,0,0.000000,return $self->parent->can_be_inlined;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000983,115,0.000009,return $self->_has_inlined_type_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check {
0.000096,65,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000309,65,0.000005,unless ( $self->can_be_inlined ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error( 'Cannot inline a type constraint check for ' . $self->name );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000574,65,0.000009,if ( $self->has_parent && $self->constraint == $null_constraint ) {
0.000000,0,0.000000,return $self->parent->_inline_check(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000914,64,0.000014,return '( do { ' . $self->inlined->( $self, @_ ) . ' } )';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inline_environment {
0.000068,45,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000396,45,0.000009,if ( $self->has_parent && $self->constraint == $null_constraint ) {
0.000000,0,0.000000,return $self->parent->inline_environment;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000398,44,0.000009,return $self->_inline_environment;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub assert_valid {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $error = $self->validate($value);
0.000000,0,0.000000,return 1 if ! defined $error;
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error($error);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_message {
0.000000,0,0.000000,my ($self, $value) = @_;
0.000000,0,0.000000,my $msg = $self->has_message
0.000000,0,0.000000,? $self->message
0.000000,0,0.000000,: $self->_default_message;
0.000000,0,0.000000,local $_ = $value;
0.000000,0,0.000000,return $msg->($value);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## type predicates ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub equals {
0.000000,0,0.000000,my ( $self, $type_or_name ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $other = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
0.000000,0,0.000000,
0.000000,0,0.000000,return 1 if $self == $other;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->has_hand_optimized_type_constraint and $other->has_hand_optimized_type_constraint ) {
0.000000,0,0.000000,return 1 if $self->hand_optimized_type_constraint == $other->hand_optimized_type_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $self->constraint == $other->constraint;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->has_parent ) {
0.000000,0,0.000000,return unless $other->has_parent;
0.000000,0,0.000000,return unless $self->parent->equals( $other->parent );
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return if $other->has_parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_a_type_of {
0.000000,0,0.000000,my ($self, $type_or_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
0.000000,0,0.000000,
0.000000,0,0.000000,($self->equals($type) || $self->is_subtype_of($type));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub is_subtype_of {
0.000000,0,0.000000,my ($self, $type_or_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = Moose::Util::TypeConstraints::find_type_constraint($type_or_name) or return;
0.000000,0,0.000000,
0.000000,0,0.000000,my $current = $self;
0.000000,0,0.000000,
0.000000,0,0.000000,while (my $parent = $current->parent) {
0.000000,0,0.000000,return 1 if $parent->equals($type);
0.000000,0,0.000000,$current = $parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## compiling the type constraint
0.000000,0,0.000000,
0.000000,0,0.000000,sub compile_type_constraint {
0.000038,25,0.000002,my $self = shift;
0.000322,25,0.000013,$self->_compiled_type_constraint($self->_actually_compile_type_constraint);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## type compilers ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub _actually_compile_type_constraint {
0.000035,25,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000138,25,0.000006,return $self->_compile_hand_optimized_type_constraint
0.000000,0,0.000000,if $self->has_hand_optimized_type_constraint;
0.000000,0,0.000000,
0.000509,24,0.000021,if ( $self->can_be_inlined ) {
0.000000,0,0.000000,return eval_closure(
0.000000,0,0.000000,source      => 'sub { ' . $self->_inline_check('$_[0]') . ' }',
0.000000,0,0.000000,environment => $self->inline_environment,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $check = $self->constraint;
0.000000,0,0.000000,unless ( defined $check ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error( "Could not compile type constraint '"
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. "' because no constraint check" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_compile_subtype($check)
0.000000,0,0.000000,if $self->has_parent;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_compile_type($check);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compile_hand_optimized_type_constraint {
0.000002,1,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000005,1,0.000005,my $type_constraint = $self->hand_optimized_type_constraint;
0.000000,0,0.000000,
0.000002,1,0.000002,unless ( ref $type_constraint ) {
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,Moose->throw_error("Hand optimized type constraint is not a code reference");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,return $type_constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compile_subtype {
0.000000,0,0.000000,my ($self, $check) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# gather all the parent constraints in order
0.000000,0,0.000000,my @parents;
0.000000,0,0.000000,my $optimized_parent;
0.000000,0,0.000000,foreach my $parent ($self->_collect_all_parents) {
0.000000,0,0.000000,# if a parent is optimized, the optimized constraint already includes
0.000000,0,0.000000,# all of its parents tcs, so we can break the loop
0.000000,0,0.000000,if ($parent->has_hand_optimized_type_constraint) {
0.000000,0,0.000000,push @parents => $optimized_parent = $parent->hand_optimized_type_constraint;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @parents => $parent->constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,@parents = grep { $_ != $null_constraint } reverse @parents;
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( @parents ) {
0.000000,0,0.000000,return $self->_compile_type($check);
0.000000,0,0.000000,} elsif( $optimized_parent and @parents == 1 ) {
0.000000,0,0.000000,# the case of just one optimized parent is optimized to prevent
0.000000,0,0.000000,# looping and the unnecessary localization
0.000000,0,0.000000,if ( $check == $null_constraint ) {
0.000000,0,0.000000,return $optimized_parent;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return subname($self->name, sub {
0.000000,0,0.000000,return undef unless $optimized_parent->($_[0]);
0.000000,0,0.000000,my (@args) = @_;
0.000000,0,0.000000,local $_ = $args[0];
0.000000,0,0.000000,$check->(@args);
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# general case, check all the constraints, from the first parent to ourselves
0.000000,0,0.000000,my @checks = @parents;
0.000000,0,0.000000,push @checks, $check if $check != $null_constraint;
0.000000,0,0.000000,return subname($self->name => sub {
0.000000,0,0.000000,my (@args) = @_;
0.000000,0,0.000000,local $_ = $args[0];
0.000000,0,0.000000,foreach my $check (@checks) {
0.000000,0,0.000000,return undef unless $check->(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _compile_type {
0.000000,0,0.000000,my ($self, $check) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $check if $check == $null_constraint; # Item, Any
0.000000,0,0.000000,
0.000000,0,0.000000,return subname($self->name => sub {
0.000000,0,0.000000,my (@args) = @_;
0.000000,0,0.000000,local $_ = $args[0];
0.000000,0,0.000000,$check->(@args);
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## other utils ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub _collect_all_parents {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my @parents;
0.000000,0,0.000000,my $current = $self->parent;
0.000000,0,0.000000,while (defined $current) {
0.000000,0,0.000000,push @parents => $current;
0.000000,0,0.000000,$current = $current->parent;
0.000000,0,0.000000,}
0.000000,0,0.000000,return @parents;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_child_type {
0.000045,16,0.000003,my ($self, %opts) = @_;
0.000027,16,0.000002,my $class = ref $self;
0.000157,16,0.000010,return $class->new(%opts, parent => $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000019,1,0.000019,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: The Moose Type Constraint metaclass
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
