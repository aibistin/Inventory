# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,package Log::Log4perl::Logger;
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000052,2,0.000026,use 5.006;
0.000036,2,0.000018,use strict;
0.000033,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000034,2,0.000017,use Log::Log4perl;
0.000113,2,0.000056,use Log::Log4perl::Level;
0.000117,2,0.000058,use Log::Log4perl::Layout;
0.000107,2,0.000054,use Log::Log4perl::Appender;
0.000218,2,0.000109,use Log::Log4perl::Appender::String;
0.000030,2,0.000015,use Log::Log4perl::Filter;
0.000047,2,0.000023,use Carp;
0.000000,0,0.000000,
0.000002,1,0.000002,$Carp::Internal{"Log::Log4perl"}++;
0.000003,1,0.000003,$Carp::Internal{"Log::Log4perl::Logger"}++;
0.000000,0,0.000000,
0.002912,2,0.001456,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# Initialization
0.000001,1,0.000001,our $ROOT_LOGGER;
0.000002,1,0.000002,our $LOGGERS_BY_NAME = {};
0.000002,1,0.000002,our %APPENDER_BY_NAME = ();
0.000001,1,0.000001,our $INITIALIZED = 0;
0.000001,1,0.000001,our $NON_INIT_WARNED;
0.000001,1,0.000001,our $DIE_DEBUG = 0;
0.000002,1,0.000002,our $DIE_DEBUG_BUFFER = "";
0.000000,0,0.000000,# Define the default appender that's used for formatting
0.000000,0,0.000000,# warn/die/croak etc. messages.
0.000002,1,0.000002,our $STRING_APP_NAME = "_l4p_warn";
0.000006,1,0.000006,our $STRING_APP      = Log::Log4perl::Appender->new(
0.000000,0,0.000000,"Log::Log4perl::Appender::String",
0.000000,0,0.000000,name => $STRING_APP_NAME);
0.000011,1,0.000011,$STRING_APP->layout(Log::Log4perl::Layout::PatternLayout->new("%m"));
0.000006,1,0.000006,our $STRING_APP_CODEREF = generate_coderef([[$STRING_APP_NAME, $STRING_APP]]);
0.000000,0,0.000000,
0.000006,1,0.000006,__PACKAGE__->reset();
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub warning_render {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($logger, @message) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$STRING_APP->string("");
0.000000,0,0.000000,$STRING_APP_CODEREF->($logger, 
0.000000,0,0.000000,@message, 
0.000000,0,0.000000,Log::Log4perl::Level::to_level($ALL));
0.000000,0,0.000000,return $STRING_APP->string();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub cleanup {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# warn "Logger cleanup";
0.000000,0,0.000000,
0.000000,0,0.000000,# Nuke all convenience loggers to avoid them causing cleanup to 
0.000000,0,0.000000,# be delayed until global destruction. Problem is that something like
0.000000,0,0.000000,#     *{"DEBUG"} = sub { $logger->debug };
0.000000,0,0.000000,# ties up a reference to $logger until global destruction, so we 
0.000000,0,0.000000,# need to clean up all :easy shortcuts, hence freeing the last
0.000000,0,0.000000,# logger references, to then rely on the garbage collector for cleaning
0.000000,0,0.000000,# up the loggers.
0.000007,1,0.000007,Log::Log4perl->easy_closure_global_cleanup();
0.000000,0,0.000000,
0.000000,0,0.000000,# Delete all loggers
0.000007,1,0.000007,$LOGGERS_BY_NAME = {};
0.000000,0,0.000000,
0.000000,0,0.000000,# Delete the root logger
0.000026,1,0.000026,undef $ROOT_LOGGER;
0.000000,0,0.000000,
0.000000,0,0.000000,# Delete all appenders
0.000027,1,0.000027,%APPENDER_BY_NAME   = ();
0.000000,0,0.000000,
0.000007,1,0.000007,undef $INITIALIZED;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub DESTROY {
0.000000,0,0.000000,##################################################
0.000013,2,0.000007,CORE::warn "Destroying logger $_[0] ($_[0]->{category})" 
0.000000,0,0.000000,if $Log::Log4perl::CHATTY_DESTROY_METHODS;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub reset {
0.000000,0,0.000000,##################################################
0.000012,2,0.000006,$ROOT_LOGGER        = __PACKAGE__->_new("", $OFF);
0.000000,0,0.000000,#    $LOGGERS_BY_NAME    = {};  #leave this alone, it's used by 
0.000000,0,0.000000,#reset_all_output_methods when 
0.000000,0,0.000000,#the config changes
0.000000,0,0.000000,
0.000004,2,0.000002,%APPENDER_BY_NAME   = ();
0.000003,2,0.000002,undef $INITIALIZED;
0.000009,2,0.000004,undef $NON_INIT_WARNED;
0.000012,2,0.000006,Log::Log4perl::Appender::reset();
0.000000,0,0.000000,
0.000000,0,0.000000,#clear out all the existing appenders
0.000012,2,0.000006,foreach my $logger (values %$LOGGERS_BY_NAME){
0.000007,3,0.000002,$logger->{appender_names} = [];
0.000000,0,0.000000,
0.000000,0,0.000000,#this next bit deals with an init_and_watch case where a category
0.000000,0,0.000000,#is deleted from the config file, we need to zero out the existing
0.000000,0,0.000000,#loggers so ones not in the config file not continue with their old
0.000000,0,0.000000,#behavior --kg
0.000008,3,0.000003,next if $logger eq $ROOT_LOGGER;
0.000002,1,0.000002,$logger->{level} = undef;
0.000008,1,0.000008,$logger->level();  #set it from the hierarchy
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Clear all filters
0.000020,2,0.000010,Log::Log4perl::Filter::reset();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub _new {
0.000000,0,0.000000,##################################################
0.000006,3,0.000002,my($class, $category, $level) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,print("_new: $class/$category/", defined $level ? $level : "undef",
0.000000,0,0.000000,"\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000005,3,0.000002,die "usage: __PACKAGE__->_new(category)" unless
0.000000,0,0.000000,defined $category;
0.000000,0,0.000000,
0.000026,3,0.000009,$category  =~ s/::/./g;
0.000000,0,0.000000,
0.000000,0,0.000000,# Have we created it previously?
0.000006,3,0.000002,if(exists $LOGGERS_BY_NAME->{$category}) {
0.000000,0,0.000000,print "_new: exists already\n" if _INTERNAL_DEBUG;
0.000006,1,0.000006,return $LOGGERS_BY_NAME->{$category};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,2,0.000003,my $self  = {
0.000000,0,0.000000,category  => $category,
0.000000,0,0.000000,num_appenders => 0,
0.000000,0,0.000000,additivity    => 1,
0.000000,0,0.000000,level         => $level,
0.000000,0,0.000000,layout        => undef,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000004,2,0.000002,bless $self, $class;
0.000000,0,0.000000,
0.000007,2,0.000004,$level ||= $self->level();
0.000000,0,0.000000,
0.000000,0,0.000000,# Save it in global structure
0.000004,2,0.000002,$LOGGERS_BY_NAME->{$category} = $self;
0.000000,0,0.000000,
0.000011,2,0.000006,$self->set_output_methods;
0.000000,0,0.000000,
0.000000,0,0.000000,print("Created logger $self ($category)\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000013,2,0.000007,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub category {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{ category };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub reset_all_output_methods {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,print "reset_all_output_methods: \n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000008,2,0.000004,foreach my $loggername ( keys %$LOGGERS_BY_NAME){
0.000031,4,0.000008,$LOGGERS_BY_NAME->{$loggername}->set_output_methods;
0.000000,0,0.000000,}
0.000019,2,0.000010,$ROOT_LOGGER->set_output_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub set_output_methods {
0.000000,0,0.000000,# Here's a big performance increase.  Instead of having the logger
0.000000,0,0.000000,# calculate whether to log and whom to log to every time log() is called,
0.000000,0,0.000000,# we calculcate it once when the logger is created, and recalculate
0.000000,0,0.000000,# it if the config information ever changes.
0.000000,0,0.000000,#
0.000000,0,0.000000,##################################################
0.000013,8,0.000002,my ($self) = @_;
0.000000,0,0.000000,
0.000011,8,0.000001,my (@appenders, %seen);
0.000000,0,0.000000,
0.000042,8,0.000005,my ($level) = $self->level();
0.000000,0,0.000000,
0.000000,0,0.000000,print "set_output_methods: $self->{category}/$level\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,#collect the appenders in effect for this category    
0.000000,0,0.000000,
0.000109,8,0.000014,for(my $logger = $self; $logger; $logger = parent_logger($logger)) {
0.000000,0,0.000000,
0.000038,11,0.000003,foreach my $appender_name (@{$logger->{appender_names}}){
0.000000,0,0.000000,
0.000000,0,0.000000,#only one message per appender, (configurable)
0.000006,3,0.000002,next if $seen{$appender_name} ++ && 
0.000000,0,0.000000,$Log::Log4perl::one_message_per_appender;
0.000000,0,0.000000,
0.000013,3,0.000004,push (@appenders,     
0.000000,0,0.000000,[$appender_name,
0.000000,0,0.000000,$APPENDER_BY_NAME{$appender_name},
0.000000,0,0.000000,]
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000017,11,0.000002,last unless $logger->{additivity};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#make a no-op coderef for inactive levels
0.000042,8,0.000005,my $noop = generate_noop_coderef();
0.000000,0,0.000000,
0.000000,0,0.000000,#make a coderef
0.000025,8,0.000003,my $coderef = (! @appenders ? $noop : &generate_coderef(\@appenders)); 
0.000000,0,0.000000,
0.000039,8,0.000005,my %priority = %Log::Log4perl::Level::PRIORITY; #convenience and cvs
0.000000,0,0.000000,
0.000000,0,0.000000,# changed to >= from <= as level ints were reversed
0.000075,8,0.000009,foreach my $levelname (keys %priority){
0.000420,64,0.000007,if (Log::Log4perl::Level::isGreaterOrEqual($level,
0.000000,0,0.000000,$priority{$levelname}
0.000000,0,0.000000,)) {
0.000000,0,0.000000,print "  ($priority{$levelname} <= $level)\n"
0.000000,0,0.000000,if _INTERNAL_DEBUG;
0.000070,38,0.000002,$self->{$levelname}      = $coderef;
0.000230,38,0.000006,$self->{"is_$levelname"} = generate_is_xxx_coderef("1");
0.000057,38,0.000002,print "Setting is_$levelname to 1\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,}else{
0.000000,0,0.000000,print "  ($priority{$levelname} > $level)\n" if _INTERNAL_DEBUG;
0.000046,26,0.000002,$self->{$levelname}      = $noop;
0.000156,26,0.000006,$self->{"is_$levelname"} = generate_is_xxx_coderef("0");
0.000039,26,0.000001,print "Setting is_$levelname to 0\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000188,64,0.000003,print("  Setting [$self] $self->{category}.$levelname to ",
0.000000,0,0.000000,($self->{$levelname} == $noop ? "NOOP" : 
0.000000,0,0.000000,("Coderef [$coderef]: " . scalar @appenders . " appenders")), 
0.000000,0,0.000000,"\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub generate_coderef {
0.000000,0,0.000000,##################################################
0.000006,4,0.000002,my $appenders = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,print "generate_coderef: ", scalar @$appenders, 
0.000000,0,0.000000," appenders\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000019,4,0.000005,my $watch_check_code = generate_watch_code("logger", 1);
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000003,2,0.000002,my $logger = shift;
0.000003,2,0.000002,my $level  = pop;
0.000000,0,0.000000,
0.000003,2,0.000001,my $message;
0.000003,2,0.000002,my $appenders_fired = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,# Evaluate all parameters that need to be evaluated. Two kinds:
0.000000,0,0.000000,#
0.000000,0,0.000000,# (1) It's a hash like { filter => "filtername",
0.000000,0,0.000000,#                        value  => "value" }
0.000000,0,0.000000,#     => filtername(value)
0.000000,0,0.000000,#
0.000000,0,0.000000,# (2) It's a code ref
0.000000,0,0.000000,#     => coderef()
0.000000,0,0.000000,#
0.000000,0,0.000000,
0.000012,2,0.000006,$message   = [map { ref $_ eq "HASH" && 
0.000000,0,0.000000,exists $_->{filter} && 
0.000000,0,0.000000,ref $_->{filter} eq 'CODE' ?
0.000000,0,0.000000,$_->{filter}->($_->{value}) :
0.000000,0,0.000000,ref $_ eq "CODE" ?
0.000000,0,0.000000,$_->() : $_ 
0.000000,0,0.000000,} @_];                  
0.000000,0,0.000000,
0.000000,0,0.000000,print("coderef: $logger->{category}\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000004,2,0.000002,if(defined $Log::Log4perl::Config::WATCHER) {
0.000000,0,0.000000,return unless $watch_check_code->($logger, @_, $level);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,2,0.000004,foreach my $a (@$appenders) {   #note the closure here
0.000005,2,0.000002,my ($appender_name, $appender) = @$a;
0.000000,0,0.000000,
0.000000,0,0.000000,print("  Sending message '<$message->[0]>' ($level) " .
0.000000,0,0.000000,"to $appender_name\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,$appender->log(
0.000000,0,0.000000,#these get passed through to Log::Dispatch
0.000000,0,0.000000,{ name    => $appender_name,
0.000000,0,0.000000,level   => $Log::Log4perl::Level::L4P_TO_LD{
0.000030,2,0.000015,$level},   
0.000000,0,0.000000,message => $message,
0.000000,0,0.000000,},
0.000000,0,0.000000,#these we need
0.000000,0,0.000000,$logger->{category},
0.000000,0,0.000000,$level,
0.000000,0,0.000000,) and $appenders_fired++;
0.000000,0,0.000000,# Only counting it if it returns a true value. Otherwise
0.000000,0,0.000000,# the appender threshold might have suppressed it after all.
0.000000,0,0.000000,
0.000000,0,0.000000,} #end foreach appenders
0.000000,0,0.000000,
0.000016,2,0.000008,return $appenders_fired;
0.000000,0,0.000000,
0.000032,4,0.000008,}; #end coderef
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub generate_noop_coderef {
0.000000,0,0.000000,##################################################
0.000011,8,0.000001,my $watch_delay_code;
0.000000,0,0.000000,
0.000000,0,0.000000,# This might seem crazy at first, but even in a Log4perl noop, we
0.000000,0,0.000000,# need to check if the configuration changed in a init_and_watch 
0.000000,0,0.000000,# situation. Why? Say, an application is running in a loop that
0.000000,0,0.000000,# constantly tries to issue debug() messages, but they're suppressed by
0.000000,0,0.000000,# the current Log4perl configuration. If debug() (which is a noop
0.000000,0,0.000000,# here) wasn't watching the configuration for changes, it would never
0.000000,0,0.000000,# catch the case where someone bumps up the log level and expects
0.000000,0,0.000000,# the application to pick it up and start logging debug() statements.
0.000000,0,0.000000,
0.000039,8,0.000005,my $watch_check_code = generate_watch_code("logger", 1);
0.000000,0,0.000000,
0.000011,8,0.000001,my $coderef;
0.000000,0,0.000000,
0.000035,8,0.000004,if(defined $Log::Log4perl::Config::WATCHER) {
0.000000,0,0.000000,$coderef = $watch_check_code;
0.000000,0,0.000000,} else {
0.000019,8,0.000002,$coderef = sub { undef };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000047,8,0.000006,return $coderef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub generate_is_xxx_coderef {
0.000000,0,0.000000,##################################################
0.000102,64,0.000002,my($return_token) = @_;
0.000000,0,0.000000,
0.000479,64,0.000007,return generate_watch_code("checker", $return_token);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub generate_watch_code {
0.000000,0,0.000000,##################################################
0.000126,76,0.000002,my($type, $return_token) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,print "generate_watch_code:\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# No watcher configured, return a no-op as watch code.
0.000485,76,0.000006,if(! defined $Log::Log4perl::Config::WATCHER) {
0.000000,0,0.000000,return sub { $return_token };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $cond = generate_watch_conditional();
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,print "exe_watch_code:\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,if(_INTERNAL_DEBUG) {
0.000000,0,0.000000,print "Next check: ",
0.000000,0,0.000000,"$Log::Log4perl::Config::Watch::NEXT_CHECK_TIME ",
0.000000,0,0.000000," Now: ", time(), " Mod: ",
0.000000,0,0.000000,(stat($Log::Log4perl::Config::WATCHER->file()))[9],
0.000000,0,0.000000,"\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( $cond->() ) {
0.000000,0,0.000000,my $init_permitted = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $Log::Log4perl::Config::OPTS->{ preinit_callback } ) {
0.000000,0,0.000000,print "Calling preinit_callback\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$init_permitted = 
0.000000,0,0.000000,$Log::Log4perl::Config::OPTS->{ preinit_callback }->( 
0.000000,0,0.000000,Log::Log4perl::Config->watcher()->file() );
0.000000,0,0.000000,print "Callback returned $init_permitted\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( $init_permitted ) {
0.000000,0,0.000000,Log::Log4perl->init_and_watch();
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# It was time to reinit, but init wasn't permitted.
0.000000,0,0.000000,# Return true, so that the logger continues as if
0.000000,0,0.000000,# it wasn't time to reinit.
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $logger = shift;
0.000000,0,0.000000,my $level  = pop;
0.000000,0,0.000000,
0.000000,0,0.000000,# Forward call to new configuration
0.000000,0,0.000000,if($type eq "checker") {
0.000000,0,0.000000,return $logger->$level();
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif( $type eq "logger") {
0.000000,0,0.000000,my $methodname = lc($level);
0.000000,0,0.000000,
0.000000,0,0.000000,# Bump up the caller level by three, since
0.000000,0,0.000000,# we've artifically introduced additional levels.
0.000000,0,0.000000,local $Log::Log4perl::caller_depth =
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 3;
0.000000,0,0.000000,
0.000000,0,0.000000,# Get a new logger for the same category (the old
0.000000,0,0.000000,# logger might be obsolete because of the re-init)
0.000000,0,0.000000,$logger = Log::Log4perl::get_logger( $logger->{category} );
0.000000,0,0.000000,
0.000000,0,0.000000,$logger->$methodname(@_); # send the message
0.000000,0,0.000000,# to the new configuration
0.000000,0,0.000000,return undef;     # Return false, so the logger finishes
0.000000,0,0.000000,# prematurely and doesn't log the same 
0.000000,0,0.000000,# message again.
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "internal error: unknown type";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,if(_INTERNAL_DEBUG) {
0.000000,0,0.000000,print "Conditional returned false\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,return $return_token;
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub generate_watch_conditional {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT) {
0.000000,0,0.000000,# In this mode, we just check for the variable indicating
0.000000,0,0.000000,# that the signal has been caught
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,return $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT;
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return sub {
0.000000,0,0.000000,return 
0.000000,0,0.000000,( time() > $Log::Log4perl::Config::Watch::NEXT_CHECK_TIME and 
0.000000,0,0.000000,$Log::Log4perl::Config::WATCHER->change_detected() );
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub parent_string {
0.000000,0,0.000000,##################################################
0.000012,8,0.000002,my($string) = @_;
0.000000,0,0.000000,
0.000012,8,0.000001,if($string eq "") {
0.000000,0,0.000000,return undef; # root doesn't have a parent.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000021,8,0.000003,my @components = split /\./, $string;
0.000000,0,0.000000,
0.000048,8,0.000006,if(@components == 1) {
0.000000,0,0.000000,return "";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,pop @components;
0.000000,0,0.000000,
0.000000,0,0.000000,return join('.', @components);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub level {
0.000000,0,0.000000,##################################################
0.000017,11,0.000002,my($self, $level, $dont_reset_all) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# 'Set' function
0.000016,11,0.000001,if(defined $level) {
0.000006,1,0.000006,croak "invalid level '$level'" 
0.000000,0,0.000000,unless Log::Log4perl::Level::is_valid($level);
0.000010,1,0.000010,if ($level =~ /\D/){
0.000000,0,0.000000,$level = Log::Log4perl::Level::to_priority($level);
0.000000,0,0.000000,}
0.000002,1,0.000002,$self->{level} = $level;   
0.000000,0,0.000000,
0.000006,1,0.000006,&reset_all_output_methods
0.000000,0,0.000000,unless $dont_reset_all;  #keep us from getting overworked 
0.000000,0,0.000000,#if it's the config file calling us 
0.000000,0,0.000000,
0.000006,1,0.000006,return $level;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# 'Get' function
0.000049,10,0.000005,if(defined $self->{level}) {
0.000000,0,0.000000,return $self->{level};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000050,5,0.000010,for(my $logger = $self; $logger; $logger = parent_logger($logger)) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Does the current logger have the level defined?
0.000000,0,0.000000,
0.000039,10,0.000004,if($logger->{category} eq "") {
0.000000,0,0.000000,# It's the root logger
0.000000,0,0.000000,return $ROOT_LOGGER->{level};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,5,0.000002,if(defined $LOGGERS_BY_NAME->{$logger->{category}}->{level}) {
0.000000,0,0.000000,return $LOGGERS_BY_NAME->{$logger->{category}}->{level};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We should never get here because at least the root logger should
0.000000,0,0.000000,# have a level defined
0.000000,0,0.000000,die "We should never get here.";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub parent_logger {
0.000000,0,0.000000,# Get the parent of the current logger or undef
0.000000,0,0.000000,##################################################
0.000024,16,0.000002,my($logger) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Is it the root logger?
0.000057,16,0.000004,if($logger->{category} eq "") {
0.000000,0,0.000000,# Root has no parent
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Go to the next defined (!) parent
0.000041,8,0.000005,my $parent_class = parent_string($logger->{category});
0.000000,0,0.000000,
0.000024,8,0.000003,while($parent_class ne "" and
0.000000,0,0.000000,! exists $LOGGERS_BY_NAME->{$parent_class}) {
0.000000,0,0.000000,$parent_class = parent_string($parent_class);
0.000000,0,0.000000,$logger =  $LOGGERS_BY_NAME->{$parent_class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000013,8,0.000002,if($parent_class eq "") {
0.000000,0,0.000000,$logger = $ROOT_LOGGER;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$logger = $LOGGERS_BY_NAME->{$parent_class};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000039,8,0.000005,return $logger;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub get_root_logger {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($class) = @_;
0.000000,0,0.000000,return $ROOT_LOGGER;    
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub additivity {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($self, $onoff, $no_reinit) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $onoff) {
0.000000,0,0.000000,$self->{additivity} = $onoff;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if( ! $no_reinit ) {
0.000000,0,0.000000,$self->set_output_methods();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{additivity};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub get_logger {
0.000000,0,0.000000,##################################################
0.000004,2,0.000002,my($class, $category) = @_;
0.000000,0,0.000000,
0.000003,2,0.000002,unless(defined $ROOT_LOGGER) {
0.000000,0,0.000000,Carp::confess "Internal error: Root Logger not initialized.";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,2,0.000004,return $ROOT_LOGGER if $category eq "";
0.000000,0,0.000000,
0.000006,1,0.000006,my $logger = $class->_new($category);
0.000006,1,0.000006,return $logger;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub add_appender {
0.000000,0,0.000000,##################################################
0.000002,1,0.000002,my($self, $appender, $dont_reset_all) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# We take this as an indicator that we're initialized.
0.000002,1,0.000002,$INITIALIZED = 1;
0.000000,0,0.000000,
0.000006,1,0.000006,my $appender_name = $appender->name();
0.000000,0,0.000000,
0.000002,1,0.000002,$self->{num_appenders}++;  #should this be inside the unless?
0.000000,0,0.000000,
0.000000,0,0.000000,# Add newly created appender to the end of the appender array
0.000012,1,0.000012,unless (grep{$_ eq $appender_name} @{$self->{appender_names}}){
0.000000,0,0.000000,$self->{appender_names} = [sort @{$self->{appender_names}}, 
0.000000,0,0.000000,$appender_name];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,$APPENDER_BY_NAME{$appender_name} = $appender;
0.000000,0,0.000000,
0.000005,1,0.000005,reset_all_output_methods
0.000000,0,0.000000,unless $dont_reset_all;  # keep us from getting overworked
0.000000,0,0.000000,# if it's  the config file calling us
0.000000,0,0.000000,
0.000000,0,0.000000,# For chaining calls ...
0.000007,1,0.000007,return $appender;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub remove_appender {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($self, $appender_name, $dont_reset_all, $sloppy) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %appender_names = map { $_ => 1 } @{$self->{appender_names}};
0.000000,0,0.000000,
0.000000,0,0.000000,if(!exists $appender_names{$appender_name}) {
0.000000,0,0.000000,die "No such appender: $appender_name" unless $sloppy;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,delete $appender_names{$appender_name};
0.000000,0,0.000000,$self->{num_appenders}--;
0.000000,0,0.000000,$self->{appender_names} = [sort keys %appender_names];
0.000000,0,0.000000,
0.000000,0,0.000000,&reset_all_output_methods
0.000000,0,0.000000,unless $dont_reset_all; 
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub eradicate_appender {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# If someone calls Logger->... and not Logger::...
0.000000,0,0.000000,shift if $_[0] eq __PACKAGE__;
0.000000,0,0.000000,
0.000000,0,0.000000,my($appender_name, $dont_reset_all) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return 0 unless exists 
0.000000,0,0.000000,$APPENDER_BY_NAME{$appender_name};
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove the given appender from all loggers
0.000000,0,0.000000,# and delete all references to it, causing
0.000000,0,0.000000,# its DESTROY method to be called.
0.000000,0,0.000000,foreach my $logger (values %$LOGGERS_BY_NAME){
0.000000,0,0.000000,$logger->remove_appender($appender_name, 0, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,# Also remove it from the root logger
0.000000,0,0.000000,$ROOT_LOGGER->remove_appender($appender_name, 0, 1);
0.000000,0,0.000000,
0.000000,0,0.000000,delete $APPENDER_BY_NAME{$appender_name};
0.000000,0,0.000000,
0.000000,0,0.000000,&reset_all_output_methods
0.000000,0,0.000000,unless $dont_reset_all; 
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub has_appenders {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{num_appenders};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub log {
0.000000,0,0.000000,# external api
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self, $priority, @messages) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,confess("log: No priority given!") unless defined($priority);
0.000000,0,0.000000,
0.000000,0,0.000000,# Just in case of 'init_and_watch' -- see Changes 0.21
0.000000,0,0.000000,$_[0] = $LOGGERS_BY_NAME->{$_[0]->{category}} if 
0.000000,0,0.000000,defined $Log::Log4perl::Config::WATCHER;
0.000000,0,0.000000,
0.000000,0,0.000000,init_warn() unless $INITIALIZED or $NON_INIT_WARNED;
0.000000,0,0.000000,
0.000000,0,0.000000,croak "priority $priority isn't numeric" if ($priority =~ /\D/);
0.000000,0,0.000000,
0.000000,0,0.000000,my $which = Log::Log4perl::Level::to_level($priority);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{$which}->($self, @messages, 
0.000000,0,0.000000,Log::Log4perl::Level::to_level($priority));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,######################################################################
0.000000,0,0.000000,#
0.000000,0,0.000000,# create_custom_level 
0.000000,0,0.000000,# creates a custom level
0.000000,0,0.000000,# in theory, could be used to create the default ones
0.000000,0,0.000000,######################################################################
0.000000,0,0.000000,sub create_custom_level {
0.000000,0,0.000000,######################################################################
0.000000,0,0.000000,my $level = shift || die("create_custom_level: " .
0.000000,0,0.000000,"forgot to pass in a level string!");
0.000000,0,0.000000,my $after = shift || die("create_custom_level: " .
0.000000,0,0.000000,"forgot to pass in a level after which to " .
0.000000,0,0.000000,"place the new level!");
0.000000,0,0.000000,my $syslog_equiv = shift; # can be undef
0.000000,0,0.000000,my $log_dispatch_level = shift; # optional
0.000000,0,0.000000,
0.000000,0,0.000000,## only let users create custom levels before initialization
0.000000,0,0.000000,
0.000000,0,0.000000,die("create_custom_level must be called before init or " .
0.000000,0,0.000000,"first get_logger() call") if ($INITIALIZED);
0.000000,0,0.000000,
0.000000,0,0.000000,my %PRIORITY = %Log::Log4perl::Level::PRIORITY; #convenience
0.000000,0,0.000000,
0.000000,0,0.000000,die("create_custom_level: no such level \"$after\"! Use one of: ", 
0.000000,0,0.000000,join(", ", sort keys %PRIORITY)) unless $PRIORITY{$after};
0.000000,0,0.000000,
0.000000,0,0.000000,# figure out new int value by AFTER + (AFTER+ 1) / 2
0.000000,0,0.000000,
0.000000,0,0.000000,my $next_prio = Log::Log4perl::Level::get_lower_level($PRIORITY{$after}, 1);
0.000000,0,0.000000,my $cust_prio = int(($PRIORITY{$after} + $next_prio) / 2);
0.000000,0,0.000000,
0.000000,0,0.000000,die(qq{create_custom_level: Calculated level of $cust_prio already exists!
0.000000,0,0.000000,This should only happen if you've made some insane number of custom
0.000000,0,0.000000,levels (like 15 one after another)
0.000000,0,0.000000,You can usually fix this by re-arranging your code from:
0.000000,0,0.000000,create_custom_level("cust1", X);
0.000000,0,0.000000,create_custom_level("cust2", X);
0.000000,0,0.000000,create_custom_level("cust3", X);
0.000000,0,0.000000,create_custom_level("cust4", X);
0.000000,0,0.000000,create_custom_level("cust5", X);
0.000000,0,0.000000,into:
0.000000,0,0.000000,create_custom_level("cust3", X);
0.000000,0,0.000000,create_custom_level("cust5", X);
0.000000,0,0.000000,create_custom_level("cust4", 4);
0.000000,0,0.000000,create_custom_level("cust2", cust3);
0.000000,0,0.000000,create_custom_level("cust1", cust2);
0.000000,0,0.000000,}) if (${Log::Log4perl::Level::LEVELS{$cust_prio}});
0.000000,0,0.000000,
0.000000,0,0.000000,Log::Log4perl::Level::add_priority($level, $cust_prio, $syslog_equiv,
0.000000,0,0.000000,$log_dispatch_level);
0.000000,0,0.000000,
0.000000,0,0.000000,print("Adding prio $level at $cust_prio\n") if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# get $LEVEL into namespace of Log::Log4perl::Logger to 
0.000000,0,0.000000,# create $logger->foo nd $logger->is_foo
0.000000,0,0.000000,my $name = "Log::Log4perl::Logger::";
0.000000,0,0.000000,my $key = $level;
0.000000,0,0.000000,
0.000073,2,0.000036,no strict qw(refs);
0.000000,0,0.000000,# be sure to use ${Log...} as CVS adds log entries for Log
0.000000,0,0.000000,*{"$name$key"} = \${Log::Log4perl::Level::PRIORITY{$level}};
0.000000,0,0.000000,
0.000000,0,0.000000,# now, stick it in the caller's namespace
0.000000,0,0.000000,$name = caller(0) . "::";
0.000000,0,0.000000,*{"$name$key"} = \${Log::Log4perl::Level::PRIORITY{$level}};
0.000111,2,0.000056,use strict qw(refs);
0.000000,0,0.000000,
0.000000,0,0.000000,create_log_level_methods($level);
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,########################################
0.000000,0,0.000000,#
0.000000,0,0.000000,# if we were hackin' lisp (or scheme), we'd be returning some lambda
0.000000,0,0.000000,# expressions. But we aren't. :) So we'll just create some strings and
0.000000,0,0.000000,# eval them.
0.000000,0,0.000000,########################################
0.000000,0,0.000000,sub create_log_level_methods {
0.000000,0,0.000000,########################################
0.000013,8,0.000002,my $level = shift || die("create_log_level_methods: " .
0.000000,0,0.000000,"forgot to pass in a level string!");
0.000014,8,0.000002,my $lclevel = lc($level);
0.000015,8,0.000002,my $levelint = uc($level) . "_INT";
0.000014,8,0.000002,my $initial_cap = ucfirst($lclevel);
0.000000,0,0.000000,
0.000243,2,0.000121,no strict qw(refs);
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a bit better way to create code on the fly than eval'ing strings.
0.000000,0,0.000000,# -erik
0.000000,0,0.000000,
0.000000,0,0.000000,*{__PACKAGE__ . "::$lclevel"} = sub {
0.000000,0,0.000000,if(_INTERNAL_DEBUG) {
0.000000,0,0.000000,my $level_disp = (defined $_[0]->{level} ? $_[0]->{level} 
0.000000,0,0.000000,: "[undef]");
0.000000,0,0.000000,print "$lclevel: ($_[0]->{category}/$level_disp) [@_]\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,init_warn() unless $INITIALIZED or $NON_INIT_WARNED;
0.000000,0,0.000000,$_[0]->{$level}->(@_, $level) if defined $_[0]->{$level};
0.000047,8,0.000006,};
0.000000,0,0.000000,
0.000000,0,0.000000,# Added these to have is_xxx functions as fast as xxx functions
0.000000,0,0.000000,# -ms
0.000000,0,0.000000,
0.000015,8,0.000002,my $islevel   = "is_" . $level;
0.000013,8,0.000002,my $islclevel = "is_" . $lclevel;
0.000000,0,0.000000,
0.000000,0,0.000000,*{__PACKAGE__ . "::is_$lclevel"} = sub {
0.000000,0,0.000000,$_[0]->{$islevel}->($_[0], $islclevel);
0.000043,8,0.000005,};
0.000000,0,0.000000,
0.000000,0,0.000000,# Add the isXxxEnabled() methods as identical to the is_xxx
0.000000,0,0.000000,# functions. - dviner
0.000000,0,0.000000,
0.000000,0,0.000000,*{__PACKAGE__ . "::is".$initial_cap."Enabled"} = 
0.000040,8,0.000005,\&{__PACKAGE__ . "::is_$lclevel"};
0.000000,0,0.000000,
0.001297,2,0.000649,use strict qw(refs);
0.000000,0,0.000000,
0.000046,8,0.000006,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#now lets autogenerate the logger subs based on the defined priorities
0.000005,1,0.000005,foreach my $level (keys %Log::Log4perl::Level::PRIORITY){
0.000056,8,0.000007,create_log_level_methods($level);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub init_warn {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,CORE::warn "Log4perl: Seems like no initialization happened. " .
0.000000,0,0.000000,"Forgot to call init()?\n";
0.000000,0,0.000000,# Only tell this once;
0.000000,0,0.000000,$NON_INIT_WARNED = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#######################################################
0.000000,0,0.000000,# call me from a sub-func to spew the sub-func's caller
0.000000,0,0.000000,#######################################################
0.000000,0,0.000000,sub callerline {
0.000000,0,0.000000,my $message = join ('', @_);
0.000000,0,0.000000,
0.000000,0,0.000000,my $caller_offset = 
0.000000,0,0.000000,Log::Log4perl::caller_depth_offset( 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1 );
0.000000,0,0.000000,
0.000000,0,0.000000,my ($pack, $file, $line) = caller($caller_offset);
0.000000,0,0.000000,
0.000000,0,0.000000,if (not chomp $message) {     # no newline
0.000000,0,0.000000,$message .= " at $file line $line";
0.000000,0,0.000000,
0.000000,0,0.000000,# Someday, we'll use Threads. Really.
0.000000,0,0.000000,if (defined &Thread::tid) {
0.000000,0,0.000000,my $tid = Thread->self->tid;
0.000000,0,0.000000,$message .= " thread $tid" if $tid;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ($message, "\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#######################################################
0.000000,0,0.000000,sub and_warn {
0.000000,0,0.000000,#######################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,CORE::warn(callerline($self->warning_render(@_)));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#######################################################
0.000000,0,0.000000,sub and_die {
0.000000,0,0.000000,#######################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $arg  = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my($msg) = callerline($self->warning_render(@_));
0.000000,0,0.000000,
0.000000,0,0.000000,if($DIE_DEBUG) {
0.000000,0,0.000000,$DIE_DEBUG_BUFFER = "DIE_DEBUG: $msg";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
0.000000,0,0.000000,die("$msg\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,die $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub logwarn {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_warn()) {
0.000000,0,0.000000,# Since we're one caller level off now, compensate for that.
0.000000,0,0.000000,my @chomped = @_;
0.000000,0,0.000000,chomp($chomped[-1]);
0.000000,0,0.000000,$self->warn(@chomped);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->and_warn(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub logdie {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_fatal()) {
0.000000,0,0.000000,# Since we're one caller level off now, compensate for that.
0.000000,0,0.000000,my @chomped = @_;
0.000000,0,0.000000,chomp($chomped[-1]);
0.000000,0,0.000000,$self->fatal(@chomped);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
0.000000,0,0.000000,$self->and_die(@_) : 
0.000000,0,0.000000,exit($Log::Log4perl::LOGEXIT_CODE);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub logexit {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_fatal()) {
0.000000,0,0.000000,# Since we're one caller level off now, compensate for that.
0.000000,0,0.000000,my @chomped = @_;
0.000000,0,0.000000,chomp($chomped[-1]);
0.000000,0,0.000000,$self->fatal(@chomped);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,exit $Log::Log4perl::LOGEXIT_CODE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# clucks and carps are WARN level
0.000000,0,0.000000,sub logcluck {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = 
0.000000,0,0.000000,$Carp::CarpLevel + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $msg = $self->warning_render(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_warn()) {
0.000000,0,0.000000,my $message = Carp::longmess($msg);
0.000000,0,0.000000,foreach (split(/\n/, $message)) {
0.000000,0,0.000000,$self->warn("$_\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::cluck($msg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub logcarp {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = $Carp::CarpLevel + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $msg = $self->warning_render(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_warn()) {
0.000000,0,0.000000,my $message = Carp::shortmess($msg);
0.000000,0,0.000000,foreach (split(/\n/, $message)) {
0.000000,0,0.000000,$self->warn("$_\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::carp($msg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# croaks and confess are FATAL level
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub logcroak {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $arg  = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,my $msg = $self->warning_render(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = 
0.000000,0,0.000000,$Carp::CarpLevel + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_fatal()) {
0.000000,0,0.000000,my $message = Carp::shortmess($msg);
0.000000,0,0.000000,foreach (split(/\n/, $message)) {
0.000000,0,0.000000,$self->fatal("$_\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $croak_msg = $arg;
0.000000,0,0.000000,
0.000000,0,0.000000,if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
0.000000,0,0.000000,$croak_msg = $msg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
0.000000,0,0.000000,Carp::croak($croak_msg) : 
0.000000,0,0.000000,exit($Log::Log4perl::LOGEXIT_CODE);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub logconfess {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $arg  = $_[0];
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = 
0.000000,0,0.000000,$Carp::CarpLevel + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $msg = $self->warning_render(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_fatal()) {
0.000000,0,0.000000,my $message = Carp::longmess($msg);
0.000000,0,0.000000,foreach (split(/\n/, $message)) {
0.000000,0,0.000000,$self->fatal("$_\n");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $confess_msg = $arg;
0.000000,0,0.000000,
0.000000,0,0.000000,if( $Log::Log4perl::STRINGIFY_DIE_MESSAGE ) {
0.000000,0,0.000000,$confess_msg = $msg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
0.000000,0,0.000000,confess($confess_msg) :
0.000000,0,0.000000,exit($Log::Log4perl::LOGEXIT_CODE);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# in case people prefer to use error for warning
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub error_warn {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_error()) {
0.000000,0,0.000000,$self->error(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->and_warn(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub error_die {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Log::Log4perl::caller_depth = 
0.000000,0,0.000000,$Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,my $msg = $self->warning_render(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->is_error()) {
0.000000,0,0.000000,$self->error($msg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$Log::Log4perl::LOGDIE_MESSAGE_ON_STDERR ? 
0.000000,0,0.000000,$self->and_die($msg) :
0.000000,0,0.000000,exit($Log::Log4perl::LOGEXIT_CODE);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub more_logging {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,return $self->dec_level(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub inc_level {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self, $delta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$delta ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->level(Log::Log4perl::Level::get_higher_level($self->level(), 
0.000000,0,0.000000,$delta));
0.000000,0,0.000000,
0.000000,0,0.000000,$self->set_output_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub less_logging {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self) = shift;
0.000000,0,0.000000,return $self->inc_level(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub dec_level {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self, $delta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$delta ||= 1;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->level(Log::Log4perl::Level::get_lower_level($self->level(), $delta));
0.000000,0,0.000000,
0.000000,0,0.000000,$self->set_output_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,1,0.000011,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
