# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package MRO::Compat;
0.000031,2,0.000016,use strict;
0.000193,2,0.000097,use warnings;
0.000010,1,0.000010,require 5.006_000;
0.000000,0,0.000000,
0.000000,0,0.000000,# Keep this < 1.00, so people can tell the fake
0.000000,0,0.000000,#  mro.pm from the real one
0.000002,1,0.000002,our $VERSION = '0.12';
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# Alias our private functions over to
0.000000,0,0.000000,# the mro:: namespace and load
0.000000,0,0.000000,# Class::C3 if Perl < 5.9.5
0.000010,1,0.000010,if($] < 5.009_005) {
0.000000,0,0.000000,$mro::VERSION # to fool Module::Install when generating META.yml
0.000000,0,0.000000,= $VERSION;
0.000000,0,0.000000,$INC{'mro.pm'} = __FILE__;
0.000000,0,0.000000,*mro::import            = \&__import;
0.000000,0,0.000000,*mro::get_linear_isa    = \&__get_linear_isa;
0.000000,0,0.000000,*mro::set_mro           = \&__set_mro;
0.000000,0,0.000000,*mro::get_mro           = \&__get_mro;
0.000000,0,0.000000,*mro::get_isarev        = \&__get_isarev;
0.000000,0,0.000000,*mro::is_universal      = \&__is_universal;
0.000000,0,0.000000,*mro::method_changed_in = \&__method_changed_in;
0.000000,0,0.000000,*mro::invalidate_all_method_caches
0.000000,0,0.000000,= \&__invalidate_all_method_caches;
0.000000,0,0.000000,require Class::C3;
0.000000,0,0.000000,if($Class::C3::XS::VERSION && $Class::C3::XS::VERSION > 0.03) {
0.000000,0,0.000000,*mro::get_pkg_gen   = \&__get_pkg_gen_c3xs;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,*mro::get_pkg_gen   = \&__get_pkg_gen_pp;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Load mro.pm and provide no-op Class::C3::.*initialize() funcs for 5.9.5+
0.000000,0,0.000000,else {
0.000002,1,0.000002,require mro;
0.000098,2,0.000049,no warnings 'redefine';
0.000008,1,0.000008,*Class::C3::initialize = sub { 1 };
0.000002,1,0.000002,*Class::C3::reinitialize = sub { 1 };
0.000002,1,0.000002,*Class::C3::uninitialize = sub { 1 };
0.000000,0,0.000000,}
0.000055,1,0.000055,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,MRO::Compat - mro::* interface compatibility for Perls < 5.9.5
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,package PPP;      use base qw/Exporter/;
0.000000,0,0.000000,package X;        use base qw/PPP/;
0.000000,0,0.000000,package Y;        use base qw/PPP/;
0.000000,0,0.000000,package Z;        use base qw/PPP/;
0.000000,0,0.000000,
0.000000,0,0.000000,package FooClass; use base qw/X Y Z/;
0.000000,0,0.000000,
0.000000,0,0.000000,package main;
0.000000,0,0.000000,use MRO::Compat;
0.000000,0,0.000000,my $linear = mro::get_linear_isa('FooClass');
0.000000,0,0.000000,print join(q{, }, @$linear);
0.000000,0,0.000000,
0.000000,0,0.000000,# Prints: FooClass, X, PPP, Exporter, Y, Z
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,The "mro" namespace provides several utilities for dealing
0.000000,0,0.000000,with method resolution order and method caching in general
0.000000,0,0.000000,in Perl 5.9.5 and higher.
0.000000,0,0.000000,
0.000000,0,0.000000,This module provides those interfaces for
0.000000,0,0.000000,earlier versions of Perl (back to 5.6.0 anyways).
0.000000,0,0.000000,
0.000000,0,0.000000,It is a harmless no-op to use this module on 5.9.5+.  That
0.000000,0,0.000000,is to say, code which properly uses L<MRO::Compat> will work
0.000000,0,0.000000,unmodified on both older Perls and 5.9.5+.
0.000000,0,0.000000,
0.000000,0,0.000000,If you're writing a piece of software that would like to use
0.000000,0,0.000000,the parts of 5.9.5+'s mro:: interfaces that are supported
0.000000,0,0.000000,here, and you want compatibility with older Perls, this
0.000000,0,0.000000,is the module for you.
0.000000,0,0.000000,
0.000000,0,0.000000,Some parts of this code will work better and/or faster with
0.000000,0,0.000000,L<Class::C3::XS> installed (which is an optional prereq
0.000000,0,0.000000,of L<Class::C3>, which is in turn a prereq of this
0.000000,0,0.000000,package), but it's not a requirement.
0.000000,0,0.000000,
0.000000,0,0.000000,This module never exports any functions.  All calls must
0.000000,0,0.000000,be fully qualified with the C<mro::> prefix.
0.000000,0,0.000000,
0.000000,0,0.000000,The interface documentation here serves only as a quick
0.000000,0,0.000000,reference of what the function basically does, and what
0.000000,0,0.000000,differences between L<MRO::Compat> and 5.9.5+ one should
0.000000,0,0.000000,look out for.  The main docs in 5.9.5's L<mro> are the real
0.000000,0,0.000000,interface docs, and contain a lot of other useful information.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 Functions
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::get_linear_isa($classname[, $type])
0.000000,0,0.000000,
0.000000,0,0.000000,Returns an arrayref which is the linearized "ISA" of the given class.
0.000000,0,0.000000,Uses whichever MRO is currently in effect for that class by default,
0.000000,0,0.000000,or the given MRO (either C<c3> or C<dfs> if specified as C<$type>).
0.000000,0,0.000000,
0.000000,0,0.000000,The linearized ISA of a class is a single ordered list of all of the
0.000000,0,0.000000,classes that would be visited in the process of resolving a method
0.000000,0,0.000000,on the given class, starting with itself.  It does not include any
0.000000,0,0.000000,duplicate entries.
0.000000,0,0.000000,
0.000000,0,0.000000,Note that C<UNIVERSAL> (and any members of C<UNIVERSAL>'s MRO) are not
0.000000,0,0.000000,part of the MRO of a class, even though all classes implicitly inherit
0.000000,0,0.000000,methods from C<UNIVERSAL> and its parents.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_linear_isa_dfs {
0.000384,2,0.000192,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my @lin = ($classname);
0.000000,0,0.000000,my %stored;
0.000000,0,0.000000,foreach my $parent (@{"$classname\::ISA"}) {
0.000000,0,0.000000,my $plin = __get_linear_isa_dfs($parent);
0.000000,0,0.000000,foreach (@$plin) {
0.000000,0,0.000000,next if exists $stored{$_};
0.000000,0,0.000000,push(@lin, $_);
0.000000,0,0.000000,$stored{$_} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return \@lin;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_linear_isa {
0.000000,0,0.000000,my ($classname, $type) = @_;
0.000000,0,0.000000,die "mro::get_mro requires a classname" if !defined $classname;
0.000000,0,0.000000,
0.000000,0,0.000000,$type ||= __get_mro($classname);
0.000000,0,0.000000,if($type eq 'dfs') {
0.000000,0,0.000000,return __get_linear_isa_dfs($classname);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($type eq 'c3') {
0.000000,0,0.000000,return [Class::C3::calculateMRO($classname)];
0.000000,0,0.000000,}
0.000000,0,0.000000,die "type argument must be 'dfs' or 'c3'";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::import
0.000000,0,0.000000,
0.000000,0,0.000000,This allows the C<use mro 'dfs'> and
0.000000,0,0.000000,C<use mro 'c3'> syntaxes, providing you
0.000000,0,0.000000,L<use MRO::Compat> first.  Please see the
0.000000,0,0.000000,L</USING C3> section for additional details.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __import {
0.000000,0,0.000000,if($_[1]) {
0.000000,0,0.000000,goto &Class::C3::import if $_[1] eq 'c3';
0.000000,0,0.000000,__set_mro(scalar(caller), $_[1]);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::set_mro($classname, $type)
0.000000,0,0.000000,
0.000000,0,0.000000,Sets the mro of C<$classname> to one of the types
0.000000,0,0.000000,C<dfs> or C<c3>.  Please see the L</USING C3>
0.000000,0,0.000000,section for additional details.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __set_mro {
0.000000,0,0.000000,my ($classname, $type) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if(!defined $classname || !$type) {
0.000000,0,0.000000,die q{Usage: mro::set_mro($classname, $type)};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($type eq 'c3') {
0.000000,0,0.000000,eval "package $classname; use Class::C3";
0.000000,0,0.000000,die $@ if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif($type eq 'dfs') {
0.000000,0,0.000000,# In the dfs case, check whether we need to undo C3
0.000000,0,0.000000,if(defined $Class::C3::MRO{$classname}) {
0.000000,0,0.000000,Class::C3::_remove_method_dispatch_table($classname);
0.000000,0,0.000000,}
0.000000,0,0.000000,delete $Class::C3::MRO{$classname};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die qq{Invalid mro type "$type"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::get_mro($classname)
0.000000,0,0.000000,
0.000000,0,0.000000,Returns the MRO of the given class (either C<c3> or C<dfs>).
0.000000,0,0.000000,
0.000000,0,0.000000,It considers any Class::C3-using class to have C3 MRO
0.000000,0,0.000000,even before L<Class::C3::initialize()> is called.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_mro {
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,die "mro::get_mro requires a classname" if !defined $classname;
0.000000,0,0.000000,return 'c3' if exists $Class::C3::MRO{$classname};
0.000000,0,0.000000,return 'dfs';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::get_isarev($classname)
0.000000,0,0.000000,
0.000000,0,0.000000,Returns an arrayref of classes who are subclasses of the
0.000000,0,0.000000,given classname.  In other words, classes in whose @ISA
0.000000,0,0.000000,hierarchy we appear, no matter how indirectly.
0.000000,0,0.000000,
0.000000,0,0.000000,This is much slower on pre-5.9.5 Perls with MRO::Compat
0.000000,0,0.000000,than it is on 5.9.5+, as it has to search the entire
0.000000,0,0.000000,package namespace.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_all_pkgs_with_isas {
0.000033,2,0.000017,no strict 'refs';
0.000178,2,0.000089,no warnings 'recursion';
0.000000,0,0.000000,
0.000000,0,0.000000,my @retval;
0.000000,0,0.000000,
0.000000,0,0.000000,my $search = shift;
0.000000,0,0.000000,my $pfx;
0.000000,0,0.000000,my $isa;
0.000000,0,0.000000,if(defined $search) {
0.000000,0,0.000000,$isa = \@{"$search\::ISA"};
0.000000,0,0.000000,$pfx = "$search\::";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$search = 'main';
0.000000,0,0.000000,$isa = \@main::ISA;
0.000000,0,0.000000,$pfx = '';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push(@retval, $search) if scalar(@$isa);
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $cand (keys %{"$search\::"}) {
0.000000,0,0.000000,if($cand =~ s/::$//) {
0.000000,0,0.000000,next if $cand eq $search; # skip self-reference (main?)
0.000000,0,0.000000,push(@retval, @{__get_all_pkgs_with_isas($pfx . $cand)});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return \@retval;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_isarev_recurse {
0.000376,2,0.000188,no strict 'refs';
0.000000,0,0.000000,
0.000000,0,0.000000,my ($class, $all_isas, $level) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,die "Recursive inheritance detected" if $level > 100;
0.000000,0,0.000000,
0.000000,0,0.000000,my %retval;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $cand (@$all_isas) {
0.000000,0,0.000000,my $found_me;
0.000000,0,0.000000,foreach (@{"$cand\::ISA"}) {
0.000000,0,0.000000,if($_ eq $class) {
0.000000,0,0.000000,$found_me = 1;
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,if($found_me) {
0.000000,0,0.000000,$retval{$cand} = 1;
0.000000,0,0.000000,map { $retval{$_} = 1 }
0.000000,0,0.000000,@{__get_isarev_recurse($cand, $all_isas, $level+1)};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return [keys %retval];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_isarev {
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,die "mro::get_isarev requires a classname" if !defined $classname;
0.000000,0,0.000000,
0.000000,0,0.000000,__get_isarev_recurse($classname, __get_all_pkgs_with_isas(), 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::is_universal($classname)
0.000000,0,0.000000,
0.000000,0,0.000000,Returns a boolean status indicating whether or not
0.000000,0,0.000000,the given classname is either C<UNIVERSAL> itself,
0.000000,0,0.000000,or one of C<UNIVERSAL>'s parents by C<@ISA> inheritance.
0.000000,0,0.000000,
0.000000,0,0.000000,Any class for which this function returns true is
0.000000,0,0.000000,"universal" in the sense that all classes potentially
0.000000,0,0.000000,inherit methods from it.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __is_universal {
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,die "mro::is_universal requires a classname" if !defined $classname;
0.000000,0,0.000000,
0.000000,0,0.000000,my $lin = __get_linear_isa('UNIVERSAL');
0.000000,0,0.000000,foreach (@$lin) {
0.000000,0,0.000000,return 1 if $classname eq $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::invalidate_all_method_caches
0.000000,0,0.000000,
0.000000,0,0.000000,Increments C<PL_sub_generation>, which invalidates method
0.000000,0,0.000000,caching in all packages.
0.000000,0,0.000000,
0.000000,0,0.000000,Please note that this is rarely necessary, unless you are
0.000000,0,0.000000,dealing with a situation which is known to confuse Perl's
0.000000,0,0.000000,method caching.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __invalidate_all_method_caches {
0.000000,0,0.000000,# Super secret mystery code :)
0.000000,0,0.000000,@f845a9c1ac41be33::ISA = @f845a9c1ac41be33::ISA;
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::method_changed_in($classname)
0.000000,0,0.000000,
0.000000,0,0.000000,Invalidates the method cache of any classes dependent on the
0.000000,0,0.000000,given class.  In L<MRO::Compat> on pre-5.9.5 Perls, this is
0.000000,0,0.000000,an alias for C<mro::invalidate_all_method_caches> above, as
0.000000,0,0.000000,pre-5.9.5 Perls have no other way to do this.  It will still
0.000000,0,0.000000,enforce the requirement that you pass it a classname, for
0.000000,0,0.000000,compatibility.
0.000000,0,0.000000,
0.000000,0,0.000000,Please note that this is rarely necessary, unless you are
0.000000,0,0.000000,dealing with a situation which is known to confuse Perl's
0.000000,0,0.000000,method caching.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub __method_changed_in {
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,die "mro::method_changed_in requires a classname" if !defined $classname;
0.000000,0,0.000000,
0.000000,0,0.000000,__invalidate_all_method_caches();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 mro::get_pkg_gen($classname)
0.000000,0,0.000000,
0.000000,0,0.000000,Returns an integer which is incremented every time a local
0.000000,0,0.000000,method of or the C<@ISA> of the given package changes on
0.000000,0,0.000000,Perl 5.9.5+.  On earlier Perls with this L<MRO::Compat> module,
0.000000,0,0.000000,it will probably increment a lot more often than necessary.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000005,2,0.000002,my $__pkg_gen = 2;
0.000000,0,0.000000,sub __get_pkg_gen_pp {
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,die "mro::get_pkg_gen requires a classname" if !defined $classname;
0.000000,0,0.000000,return $__pkg_gen++;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub __get_pkg_gen_c3xs {
0.000000,0,0.000000,my $classname = shift;
0.000000,0,0.000000,die "mro::get_pkg_gen requires a classname" if !defined $classname;
0.000000,0,0.000000,
0.000000,0,0.000000,return Class::C3::XS::_plsubgen();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 USING C3
0.000000,0,0.000000,
0.000000,0,0.000000,While this module makes the 5.9.5+ syntaxes
0.000000,0,0.000000,C<use mro 'c3'> and C<mro::set_mro("Foo", 'c3')> available
0.000000,0,0.000000,on older Perls, it does so merely by passing off the work
0.000000,0,0.000000,to L<Class::C3>.
0.000000,0,0.000000,
0.000000,0,0.000000,It does not remove the need for you to call
0.000000,0,0.000000,C<Class::C3::initialize()>, C<Class::C3::reinitialize()>, and/or
0.000000,0,0.000000,C<Class::C3::uninitialize()> at the appropriate times
0.000000,0,0.000000,as documented in the L<Class::C3> docs.  These three functions
0.000000,0,0.000000,are always provided by L<MRO::Compat>, either via L<Class::C3>
0.000000,0,0.000000,itself on older Perls, or directly as no-ops on 5.9.5+.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,L<Class::C3>
0.000000,0,0.000000,
0.000000,0,0.000000,L<mro>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Brandon L. Black, E<lt>blblack@gmail.comE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT AND LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright 2007-2008 Brandon L. Black E<lt>blblack@gmail.comE<gt>
0.000000,0,0.000000,
0.000000,0,0.000000,This library is free software; you can redistribute it and/or modify
0.000000,0,0.000000,it under the same terms as Perl itself. 
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000004,1,0.000004,1;
