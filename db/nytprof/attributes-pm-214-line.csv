# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package attributes;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = 0.21;
0.000000,0,0.000000,
0.000002,1,0.000002,@EXPORT_OK = qw(get reftype);
0.000002,1,0.000002,@EXPORT = ();
0.000003,1,0.000003,%EXPORT_TAGS = (ALL => [@EXPORT, @EXPORT_OK]);
0.000000,0,0.000000,
0.000613,2,0.000306,use strict;
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,goto &Carp::croak;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub carp {
0.000000,0,0.000000,require Carp;
0.000000,0,0.000000,goto &Carp::carp;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my %deprecated;
0.000014,1,0.000014,$deprecated{CODE} = qr/\A-?(locked)\z/;
0.000008,1,0.000008,$deprecated{ARRAY} = $deprecated{HASH} = $deprecated{SCALAR}
0.000000,0,0.000000,= qr/\A-?(unique)\z/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _modify_attrs_and_deprecate {
0.000003,2,0.000001,my $svtype = shift;
0.000000,0,0.000000,# Now that we've removed handling of locked from the XS code, we need to
0.000000,0,0.000000,# remove it here, else it ends up in @badattrs. (If we do the deprecation in
0.000000,0,0.000000,# XS, we can't control the warning based on *our* caller's lexical settings,
0.000000,0,0.000000,# and the warned line is in this package)
0.000000,0,0.000000,grep {
0.000030,2,0.000015,$deprecated{$svtype} && /$deprecated{$svtype}/ ? do {
0.000000,0,0.000000,require warnings;
0.000000,0,0.000000,warnings::warnif('deprecated', "Attribute \"$1\" is deprecated");
0.000000,0,0.000000,0;
0.000039,2,0.000019,} : $svtype eq 'CODE' && /^-?lvalue\z/ ? do {
0.000000,0,0.000000,require warnings;
0.000000,0,0.000000,warnings::warnif(
0.000000,0,0.000000,'misc',
0.000000,0,0.000000,"lvalue attribute "
0.000000,0,0.000000,. (/^-/ ? "removed from" : "applied to")
0.000000,0,0.000000,. " already-defined subroutine"
0.000000,0,0.000000,);
0.000000,0,0.000000,0;
0.000000,0,0.000000,} : 1
0.000000,0,0.000000,} _modify_attrs(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000004,2,0.000002,@_ > 2 && ref $_[2] or do {
0.000000,0,0.000000,require Exporter;
0.000000,0,0.000000,goto &Exporter::import;
0.000000,0,0.000000,};
0.000005,2,0.000003,my (undef,$home_stash,$svref,@attrs) = @_;
0.000000,0,0.000000,
0.000020,2,0.000010,my $svtype = uc reftype($svref);
0.000003,2,0.000001,my $pkgmeth;
0.000025,2,0.000012,$pkgmeth = UNIVERSAL::can($home_stash, "MODIFY_${svtype}_ATTRIBUTES")
0.000000,0,0.000000,if defined $home_stash && $home_stash ne '';
0.000003,2,0.000001,my @badattrs;
0.000006,2,0.000003,if ($pkgmeth) {
0.000012,2,0.000006,my @pkgattrs = _modify_attrs_and_deprecate($svtype, $svref, @attrs);
0.000011,2,0.000006,@badattrs = $pkgmeth->($home_stash, $svref, @pkgattrs);
0.000007,2,0.000003,if (!@badattrs && @pkgattrs) {
0.000003,2,0.000002,require warnings;
0.000011,2,0.000005,return unless warnings::enabled('reserved');
0.000024,4,0.000006,@pkgattrs = grep { m/\A[[:lower:]]+(?:\z|\()/ } @pkgattrs;
0.000003,2,0.000002,if (@pkgattrs) {
0.000000,0,0.000000,for my $attr (@pkgattrs) {
0.000000,0,0.000000,$attr =~ s/\(.+\z//s;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $s = ((@pkgattrs == 1) ? '' : 's');
0.000000,0,0.000000,carp "$svtype package attribute$s " .
0.000000,0,0.000000,"may clash with future reserved word$s: " .
0.000000,0,0.000000,join(' : ' , @pkgattrs);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@badattrs = _modify_attrs_and_deprecate($svtype, $svref, @attrs);
0.000000,0,0.000000,}
0.000012,2,0.000006,if (@badattrs) {
0.000000,0,0.000000,croak "Invalid $svtype attribute" .
0.000000,0,0.000000,(( @badattrs == 1 ) ? '' : 's') .
0.000000,0,0.000000,": " .
0.000000,0,0.000000,join(' : ', @badattrs);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get ($) {
0.000000,0,0.000000,@_ == 1  && ref $_[0] or
0.000000,0,0.000000,croak 'Usage: '.__PACKAGE__.'::get $ref';
0.000000,0,0.000000,my $svref = shift;
0.000000,0,0.000000,my $svtype = uc reftype($svref);
0.000000,0,0.000000,my $stash = _guess_stash($svref);
0.000000,0,0.000000,$stash = caller unless defined $stash;
0.000000,0,0.000000,my $pkgmeth;
0.000000,0,0.000000,$pkgmeth = UNIVERSAL::can($stash, "FETCH_${svtype}_ATTRIBUTES")
0.000000,0,0.000000,if defined $stash && $stash ne '';
0.000000,0,0.000000,return $pkgmeth ?
0.000000,0,0.000000,(_fetch_attrs($svref), $pkgmeth->($stash, $svref)) :
0.000000,0,0.000000,(_fetch_attrs($svref))
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub require_version { goto &UNIVERSAL::VERSION }
0.000000,0,0.000000,
0.000002,1,0.000002,require XSLoader;
0.000180,1,0.000180,XSLoader::load();
0.000000,0,0.000000,
0.000007,1,0.000007,1;
0.000000,0,0.000000,__END__
