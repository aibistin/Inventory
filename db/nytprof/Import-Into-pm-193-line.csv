# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Import::Into;
0.000000,0,0.000000,
0.000034,2,0.000017,use strict;
0.000224,2,0.000112,use warnings FATAL => 'all';
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.001001'; # 1.1.1
0.000000,0,0.000000,
0.000001,1,0.000001,my %importers;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _importer {
0.000010,6,0.000002,my $target = shift;
0.000173,6,0.000029,\($importers{$target} ||= eval qq{
0.000000,0,0.000000,package $target;
0.000000,0,0.000000,sub { my \$m = splice \@_, 1, 1; shift->\$m(\@_) };
0.000000,0,0.000000,} or die "Couldn't build importer for $target: $@")
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub import::into {
0.000014,6,0.000002,my ($class, $target, @args) = @_;
0.000079,6,0.000013,$class->${_importer($target)}(import => @args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub unimport::out_of {
0.000000,0,0.000000,my ($class, $target, @args) = @_;
0.000000,0,0.000000,$class->${_importer($target)}(unimport => @args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Import::Into - import packages into other packages 
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,package My::MultiExporter;
0.000000,0,0.000000,
0.000000,0,0.000000,use Import::Into;
0.000000,0,0.000000,
0.000000,0,0.000000,use Thing1 ();
0.000000,0,0.000000,use Thing2 ();
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,my $target = caller;
0.000000,0,0.000000,Thing1->import::into($target);
0.000000,0,0.000000,Thing2->import::into($target, qw(import arguments));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Note: you don't need to do anything more clever than this provided you
0.000000,0,0.000000,document that people wanting to re-export your module should also be using
0.000000,0,0.000000,L<Import::Into>. In fact, for a single module you can simply do:
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,...
0.000000,0,0.000000,Thing1->import::into(scalar caller);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Notably, this works:
0.000000,0,0.000000,
0.000000,0,0.000000,use base qw(Exporter);
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,shift->export_to_level(1);
0.000000,0,0.000000,Thing1->import::into(scalar caller);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,Note 2: You do B<not> need to do anything to Thing1 to be able to call
0.000000,0,0.000000,C<import::into> on it. This is a global method, and is callable on any
0.000000,0,0.000000,package (and in fact on any object as well, although it's rarer that you'd
0.000000,0,0.000000,want to do that).
0.000000,0,0.000000,
0.000000,0,0.000000,Finally, we also provide an C<unimport::out_of> to allow the exporting of the
0.000000,0,0.000000,effect of C<no>:
0.000000,0,0.000000,
0.000000,0,0.000000,# unimport::out_of was added in 1.1.0 (1.001000)
0.000000,0,0.000000,sub unimport {
0.000000,0,0.000000,Moose->unimport::out_of(scalar caller); # no MyThing == no Moose
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,If how and why this all works is of interest to you, please read on to the
0.000000,0,0.000000,description immediately below.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,Writing exporters is a pain. Some use L<Exporter>, some use L<Sub::Exporter>,
0.000000,0,0.000000,some use L<Moose::Exporter>, some use L<Exporter::Declare> ... and some things
0.000000,0,0.000000,are pragmas.
0.000000,0,0.000000,
0.000000,0,0.000000,If you want to re-export other things, you have to know which is which.
0.000000,0,0.000000,L<Exporter> subclasses provide export_to_level, but if they overrode their
0.000000,0,0.000000,import method all bets are off. L<Sub::Exporter> provides an into parameter
0.000000,0,0.000000,but figuring out something used it isn't trivial. Pragmas need to have
0.000000,0,0.000000,their C<import> method called directly since they affect the current unit of
0.000000,0,0.000000,compilation.
0.000000,0,0.000000,
0.000000,0,0.000000,It's ... annoying.
0.000000,0,0.000000,
0.000000,0,0.000000,However, there is an approach that actually works for all of these types.
0.000000,0,0.000000,
0.000000,0,0.000000,eval "package $target; use $thing;"
0.000000,0,0.000000,
0.000000,0,0.000000,will work for anything checking caller, which is everything except pragmas.
0.000000,0,0.000000,But it doesn't work for pragmas - pragmas need:
0.000000,0,0.000000,
0.000000,0,0.000000,$thing->import;
0.000000,0,0.000000,
0.000000,0,0.000000,because they're designed to affect the code currently being compiled - so
0.000000,0,0.000000,within an eval, that's the scope of the eval itself, not the module that
0.000000,0,0.000000,just C<use>d you - so
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,eval "use strict;"
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,doesn't do what you wanted, but
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000000,0,0.000000,strict->import;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,will apply L<strict> to the calling file correctly.
0.000000,0,0.000000,
0.000000,0,0.000000,Of course, now you have two new problems - first, that you still need to
0.000000,0,0.000000,know if something's a pragma, and second that you can't use either of
0.000000,0,0.000000,these approaches alone on something like L<Moose> or L<Moo> that's both
0.000000,0,0.000000,an exporter and a pragma.
0.000000,0,0.000000,
0.000000,0,0.000000,So, the complete solution is:
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = eval "package $target; sub { shift->import(\@_) }";
0.000000,0,0.000000,$sub->($thing, @import_args);
0.000000,0,0.000000,
0.000000,0,0.000000,which means that import is called from the right place for pragmas to take
0.000000,0,0.000000,effect, and from the right package for caller checking to work - and so
0.000000,0,0.000000,behaves correctly for all types of exporter, for pragmas, and for hybrids.
0.000000,0,0.000000,
0.000000,0,0.000000,Remembering all this, however, is excessively irritating. So I wrote a module
0.000000,0,0.000000,so I didn't have to anymore. Loading L<Import::Into> creates a global method
0.000000,0,0.000000,C<import::into> which you can call on any package to import it into another
0.000000,0,0.000000,package. So now you can simply write:
0.000000,0,0.000000,
0.000000,0,0.000000,use Import::Into;
0.000000,0,0.000000,
0.000000,0,0.000000,$thing->import::into($target, @import_args);
0.000000,0,0.000000,
0.000000,0,0.000000,This works because of how perl resolves method calls - a call to a simple
0.000000,0,0.000000,method name is resolved against the package of the class or object, so
0.000000,0,0.000000,
0.000000,0,0.000000,$thing->method_name(@args);
0.000000,0,0.000000,
0.000000,0,0.000000,is roughly equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,my $code_ref = $thing->can('method_name');
0.000000,0,0.000000,$code_ref->($thing, @args);
0.000000,0,0.000000,
0.000000,0,0.000000,while if a C<::> is found, the lookup is made relative to the package name
0.000000,0,0.000000,(i.e. everything before the last C<::>) so
0.000000,0,0.000000,
0.000000,0,0.000000,$thing->Package::Name::method_name(@args);
0.000000,0,0.000000,
0.000000,0,0.000000,is roughly equivalent to:
0.000000,0,0.000000,
0.000000,0,0.000000,my $code_ref = Package::Name->can('method_name');
0.000000,0,0.000000,$code_ref->($thing, @args);
0.000000,0,0.000000,
0.000000,0,0.000000,So since L<Import::Into> defines a method C<into> in package C<import>
0.000000,0,0.000000,the syntax reliably calls that.
0.000000,0,0.000000,
0.000000,0,0.000000,For more craziness of this order, have a look at the article I wrote at
0.000000,0,0.000000,L<http://shadow.cat/blog/matt-s-trout/madness-with-methods> which covers
0.000000,0,0.000000,coderef abuse and the C<${\...}> syntax.
0.000000,0,0.000000,
0.000000,0,0.000000,Final note: You do still need to ensure that you already loaded C<$thing> - if
0.000000,0,0.000000,you're receiving this from a parameter, I recommend using L<Module::Runtime>:
0.000000,0,0.000000,
0.000000,0,0.000000,use Import::Into;
0.000000,0,0.000000,use Module::Runtime qw(use_module);
0.000000,0,0.000000,
0.000000,0,0.000000,use_module($thing)->import::into($target, @import_args);
0.000000,0,0.000000,
0.000000,0,0.000000,And that's it.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 CONTRIBUTORS
0.000000,0,0.000000,
0.000000,0,0.000000,None yet - maybe this software is perfect! (ahahahahahahahahaha)
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (c) 2012 the Import::Into L</AUTHOR> and L</CONTRIBUTORS>
0.000000,0,0.000000,as listed above.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This library is free software and may be distributed under the same terms
0.000000,0,0.000000,as perl itself.
