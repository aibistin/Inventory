# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Try::Tiny;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Try::Tiny::VERSION = '0.18';
0.000000,0,0.000000,}
0.000051,2,0.000025,use 5.006;
0.000000,0,0.000000,# ABSTRACT: minimal try/catch with proper preservation of $@
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000037,2,0.000019,use warnings;
0.000000,0,0.000000,
0.000053,2,0.000026,use base 'Exporter';
0.000003,1,0.000003,our @EXPORT = our @EXPORT_OK = qw(try catch finally);
0.000000,0,0.000000,
0.000059,2,0.000030,use Carp;
0.000002,1,0.000002,$Carp::Internal{+__PACKAGE__}++;
0.000000,0,0.000000,
0.000529,1,0.000529,BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
0.000000,0,0.000000,
0.000000,0,0.000000,# Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
0.000000,0,0.000000,# Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
0.000000,0,0.000000,# context & not a scalar one
0.000000,0,0.000000,
0.000000,0,0.000000,sub try (&;@) {
0.000937,493,0.000002,my ( $try, @code_refs ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# we need to save this here, the eval block will be in scalar context due
0.000000,0,0.000000,# to $failed
0.000759,493,0.000002,my $wantarray = wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,# work around perl bug by explicitly initializing these, due to the likelyhood
0.000000,0,0.000000,# this will be used in global destruction (perl rt#119311)
0.000771,493,0.000002,my ( $catch, @finally ) = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# find labeled blocks in the argument list.
0.000000,0,0.000000,# catch and finally tag the blocks by blessing a scalar reference to them.
0.001576,493,0.000003,foreach my $code_ref (@code_refs) {
0.000000,0,0.000000,
0.002566,493,0.000005,if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
0.000668,493,0.000001,croak 'A try() may not be followed by multiple catch() blocks'
0.000000,0,0.000000,if $catch;
0.000768,493,0.000002,$catch = ${$code_ref};
0.000000,0,0.000000,} elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
0.000000,0,0.000000,push @finally, ${$code_ref};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak(
0.000000,0,0.000000,'try() encountered an unexpected argument ('
0.000000,0,0.000000,. ( defined $code_ref ? $code_ref : 'undef' )
0.000000,0,0.000000,. ') - perhaps a missing semi-colon before or'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
0.000000,0,0.000000,# not perfect, but we could provide a list of additional errors for
0.000000,0,0.000000,# $catch->();
0.000000,0,0.000000,
0.000000,0,0.000000,# name the blocks if we have Sub::Name installed
0.000843,493,0.000002,my $caller = caller;
0.010817,493,0.000022,subname("${caller}::try {...} " => $try);
0.003925,493,0.000008,subname("${caller}::catch {...} " => $catch) if $catch;
0.001623,493,0.000003,subname("${caller}::finally {...} " => $_) foreach @finally;
0.000000,0,0.000000,
0.000000,0,0.000000,# save the value of $@ so we can set $@ back to it in the beginning of the eval
0.000000,0,0.000000,# and restore $@ after the eval finishes
0.000781,493,0.000002,my $prev_error = $@;
0.000000,0,0.000000,
0.000681,493,0.000001,my ( @ret, $error );
0.000000,0,0.000000,
0.000000,0,0.000000,# failed will be true if the eval dies, because 1 will not be returned
0.000000,0,0.000000,# from the eval body
0.001595,493,0.000003,my $failed = not eval {
0.000707,493,0.000001,$@ = $prev_error;
0.000000,0,0.000000,
0.000000,0,0.000000,# evaluate the try block in the correct context
0.002022,493,0.000004,if ( $wantarray ) {
0.000000,0,0.000000,@ret = $try->();
0.000000,0,0.000000,} elsif ( defined $wantarray ) {
0.000000,0,0.000000,$ret[0] = $try->();
0.000000,0,0.000000,} else {
0.001730,337,0.000005,$try->();
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000849,493,0.000002,return 1; # properly set $fail to false
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,# preserve the current error and reset the original value of $@
0.000744,493,0.000002,$error = $@;
0.000700,493,0.000001,$@ = $prev_error;
0.000000,0,0.000000,
0.000000,0,0.000000,# set up a scope guard to invoke the finally block at the end
0.000000,0,0.000000,my @guards =
0.000933,493,0.000002,map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
0.000000,0,0.000000,@finally;
0.000000,0,0.000000,
0.000000,0,0.000000,# at this point $failed contains a true value if the eval died, even if some
0.000000,0,0.000000,# destructor overwrote $@ as the eval was unwinding.
0.000750,493,0.000002,if ( $failed ) {
0.000000,0,0.000000,# if we got an error, invoke the catch block.
0.000000,0,0.000000,if ( $catch ) {
0.000000,0,0.000000,# This works like given($error), but is backwards compatible and
0.000000,0,0.000000,# sets $_ in the dynamic scope for the body of C<$catch>
0.000000,0,0.000000,for ($error) {
0.000000,0,0.000000,return $catch->($error);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# in case when() was used without an explicit return, the C<for>
0.000000,0,0.000000,# loop will be aborted and there's no useful return value
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# no failure, $@ is back to what it was, everything is fine
0.002800,493,0.000006,return $wantarray ? @ret : $ret[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub catch (&;@) {
0.000870,493,0.000002,my ( $block, @rest ) = @_;
0.000000,0,0.000000,
0.000742,493,0.000002,croak 'Useless bare catch()' unless wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.003147,493,0.000006,bless(\$block, 'Try::Tiny::Catch'),
0.000000,0,0.000000,@rest,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub finally (&;@) {
0.000000,0,0.000000,my ( $block, @rest ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,croak 'Useless bare finally()' unless wantarray;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,bless(\$block, 'Try::Tiny::Finally'),
0.000000,0,0.000000,@rest,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000003,1,0.000003,package # hide from PAUSE
0.000000,0,0.000000,Try::Tiny::ScopeGuard;
0.000000,0,0.000000,
0.000142,2,0.000071,use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,bless [ @_ ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {
0.000000,0,0.000000,my ($code, @args) = @{ $_[0] };
0.000000,0,0.000000,
0.000000,0,0.000000,local $@ if UNSTABLE_DOLLARAT;
0.000000,0,0.000000,eval {
0.000000,0,0.000000,$code->(@args);
0.000000,0,0.000000,1;
0.000000,0,0.000000,} or do {
0.000000,0,0.000000,warn
0.000000,0,0.000000,"Execution of finally() block $code resulted in an exception, which "
0.000000,0,0.000000,. '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
0.000000,0,0.000000,. 'Your program will continue as if this event never took place. '
0.000000,0,0.000000,. "Original exception text follows:\n\n"
0.000000,0,0.000000,. (defined $@ ? $@ : '$@ left undefined...')
0.000000,0,0.000000,. "\n"
0.000000,0,0.000000,;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__
0.000000,0,0.000000,
0.000005,1,0.000005,__END__
