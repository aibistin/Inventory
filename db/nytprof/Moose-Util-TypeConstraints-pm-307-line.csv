# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Util::TypeConstraints;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Util::TypeConstraints::AUTHORITY = 'cpan:STEVAN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000006,2,0.000003,$Moose::Util::TypeConstraints::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000031,2,0.000016,use Carp ();
0.000037,2,0.000018,use List::MoreUtils qw( all any );
0.000033,2,0.000017,use Scalar::Util qw( blessed reftype );
0.000063,2,0.000032,use Moose::Exporter;
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,# Prototyped subs must be predeclared because we have a
0.000000,0,0.000000,# circular dependency with Moose::Meta::Attribute et. al.
0.000000,0,0.000000,# so in case of us being use'd first the predeclaration
0.000000,0,0.000000,# ensures the prototypes are in scope when consumers are
0.000000,0,0.000000,# compiled.
0.000000,0,0.000000,
0.000000,0,0.000000,# dah sugah!
0.000000,0,0.000000,sub where (&);
0.000000,0,0.000000,sub via (&);
0.000000,0,0.000000,sub message (&);
0.000000,0,0.000000,sub optimize_as (&);
0.000000,0,0.000000,sub inline_as (&);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000033,2,0.000017,use Moose::Deprecated;
0.000031,2,0.000015,use Moose::Meta::TypeConstraint;
0.000132,2,0.000066,use Moose::Meta::TypeConstraint::Union;
0.000120,2,0.000060,use Moose::Meta::TypeConstraint::Parameterized;
0.000031,2,0.000015,use Moose::Meta::TypeConstraint::Parameterizable;
0.000124,2,0.000062,use Moose::Meta::TypeConstraint::Class;
0.000132,2,0.000066,use Moose::Meta::TypeConstraint::Role;
0.000134,2,0.000067,use Moose::Meta::TypeConstraint::Enum;
0.000138,2,0.000069,use Moose::Meta::TypeConstraint::DuckType;
0.000036,2,0.000018,use Moose::Meta::TypeCoercion;
0.000030,2,0.000015,use Moose::Meta::TypeCoercion::Union;
0.000211,2,0.000106,use Moose::Meta::TypeConstraint::Registry;
0.000000,0,0.000000,
0.000011,1,0.000011,Moose::Exporter->setup_import_methods(
0.000000,0,0.000000,as_is => [
0.000000,0,0.000000,qw(
0.000000,0,0.000000,type subtype class_type role_type maybe_type duck_type
0.000000,0,0.000000,as where message optimize_as inline_as
0.000000,0,0.000000,coerce from via
0.000000,0,0.000000,enum union
0.000000,0,0.000000,find_type_constraint
0.000000,0,0.000000,register_type_constraint
0.000000,0,0.000000,match_on_type )
0.000000,0,0.000000,],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## type registry and some useful functions for it
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000006,1,0.000006,my $REGISTRY = Moose::Meta::TypeConstraint::Registry->new;
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_type_constraint_registry {$REGISTRY}
0.000013,1,0.000013,sub list_all_type_constraints    { keys %{ $REGISTRY->type_constraints } }
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_type_constraints_as_functions {
0.000000,0,0.000000,my $pkg = caller();
0.002311,2,0.001156,no strict 'refs';
0.000000,0,0.000000,foreach my $constraint ( keys %{ $REGISTRY->type_constraints } ) {
0.000000,0,0.000000,my $tc = $REGISTRY->get_type_constraint($constraint)
0.000000,0,0.000000,->_compiled_type_constraint;
0.000000,0,0.000000,*{"${pkg}::${constraint}"}
0.000000,0,0.000000,= sub { $tc->( $_[0] ) ? 1 : undef };    # the undef is for compat
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_type_constraint_union {
0.000000,0,0.000000,_create_type_constraint_union(\@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_named_type_constraint_union {
0.000000,0,0.000000,my $name = shift;
0.000000,0,0.000000,_create_type_constraint_union($name, \@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create_type_constraint_union {
0.000000,0,0.000000,my $name;
0.000000,0,0.000000,$name = shift if @_ > 1;
0.000000,0,0.000000,my @tcs = @{ shift() };
0.000000,0,0.000000,
0.000000,0,0.000000,my @type_constraint_names;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( scalar @tcs == 1 && _detect_type_constraint_union( $tcs[0] ) ) {
0.000000,0,0.000000,@type_constraint_names = _parse_type_constraint_union( $tcs[0] );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@type_constraint_names = @tcs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,( scalar @type_constraint_names >= 2 )
0.000000,0,0.000000,|| __PACKAGE__->_throw_error(
0.000000,0,0.000000,"You must pass in at least 2 type names to make a union");
0.000000,0,0.000000,
0.000000,0,0.000000,my @type_constraints = map {
0.000000,0,0.000000,find_or_parse_type_constraint($_)
0.000000,0,0.000000,|| __PACKAGE__->_throw_error(
0.000000,0,0.000000,"Could not locate type constraint ($_) for the union");
0.000000,0,0.000000,} @type_constraint_names;
0.000000,0,0.000000,
0.000000,0,0.000000,my %options = (
0.000000,0,0.000000,type_constraints => \@type_constraints
0.000000,0,0.000000,);
0.000000,0,0.000000,$options{name} = $name if defined $name;
0.000000,0,0.000000,
0.000000,0,0.000000,return Moose::Meta::TypeConstraint::Union->new(%options);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_parameterized_type_constraint {
0.000000,0,0.000000,my $type_constraint_name = shift;
0.000000,0,0.000000,my ( $base_type, $type_parameter )
0.000000,0,0.000000,= _parse_parameterized_type_constraint($type_constraint_name);
0.000000,0,0.000000,
0.000000,0,0.000000,( defined $base_type && defined $type_parameter )
0.000000,0,0.000000,|| __PACKAGE__->_throw_error(
0.000000,0,0.000000,"Could not parse type name ($type_constraint_name) correctly");
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $REGISTRY->has_type_constraint($base_type) ) {
0.000000,0,0.000000,my $base_type_tc = $REGISTRY->get_type_constraint($base_type);
0.000000,0,0.000000,return _create_parameterized_type_constraint(
0.000000,0,0.000000,$base_type_tc,
0.000000,0,0.000000,$type_parameter
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,__PACKAGE__->_throw_error(
0.000000,0,0.000000,"Could not locate the base type ($base_type)");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create_parameterized_type_constraint {
0.000000,0,0.000000,my ( $base_type_tc, $type_parameter ) = @_;
0.000000,0,0.000000,if ( $base_type_tc->can('parameterize') ) {
0.000000,0,0.000000,return $base_type_tc->parameterize($type_parameter);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return Moose::Meta::TypeConstraint::Parameterized->new(
0.000000,0,0.000000,name   => $base_type_tc->name . '[' . $type_parameter . ']',
0.000000,0,0.000000,parent => $base_type_tc,
0.000000,0,0.000000,type_parameter =>
0.000000,0,0.000000,find_or_create_isa_type_constraint($type_parameter),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#should we also support optimized checks?
0.000000,0,0.000000,sub create_class_type_constraint {
0.000002,1,0.000002,my ( $class, $options ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# too early for this check
0.000000,0,0.000000,#find_type_constraint("ClassName")->check($class)
0.000000,0,0.000000,#    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
0.000000,0,0.000000,
0.000002,1,0.000002,my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
0.000000,0,0.000000,
0.000006,1,0.000006,if (my $type = $REGISTRY->get_type_constraint($class)) {
0.000000,0,0.000000,if (!($type->isa('Moose::Meta::TypeConstraint::Class') && $type->class eq $class)) {
0.000000,0,0.000000,_confess(
0.000000,0,0.000000,"The type constraint '$class' has already been created in "
0.000000,0,0.000000,. $type->_package_defined_in
0.000000,0,0.000000,. " and cannot be created again in "
0.000000,0,0.000000,. $pkg_defined_in )
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %options = (
0.000000,0,0.000000,class              => $class,
0.000000,0,0.000000,name               => $class,
0.000000,0,0.000000,package_defined_in => $pkg_defined_in,
0.000004,1,0.000004,%{ $options || {} },
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,$options{name} ||= "__ANON__";
0.000000,0,0.000000,
0.000009,1,0.000009,my $tc = Moose::Meta::TypeConstraint::Class->new(%options);
0.000006,1,0.000006,$REGISTRY->add_type_constraint($tc);
0.000008,1,0.000008,return $tc;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_role_type_constraint {
0.000004,2,0.000002,my ( $role, $options ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# too early for this check
0.000000,0,0.000000,#find_type_constraint("ClassName")->check($class)
0.000000,0,0.000000,#    || __PACKAGE__->_throw_error("Can't create a class type constraint because '$class' is not a class name");
0.000000,0,0.000000,
0.000006,2,0.000003,my $pkg_defined_in = $options->{package_defined_in} || scalar( caller(1) );
0.000000,0,0.000000,
0.000033,2,0.000016,if (my $type = $REGISTRY->get_type_constraint($role)) {
0.000000,0,0.000000,if (!($type->isa('Moose::Meta::TypeConstraint::Role') && $type->role eq $role)) {
0.000000,0,0.000000,_confess(
0.000000,0,0.000000,"The type constraint '$role' has already been created in "
0.000000,0,0.000000,. $type->_package_defined_in
0.000000,0,0.000000,. " and cannot be created again in "
0.000000,0,0.000000,. $pkg_defined_in )
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000006,1,0.000006,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %options = (
0.000000,0,0.000000,role               => $role,
0.000000,0,0.000000,name               => $role,
0.000000,0,0.000000,package_defined_in => $pkg_defined_in,
0.000005,1,0.000005,%{ $options || {} },
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000002,1,0.000002,$options{name} ||= "__ANON__";
0.000000,0,0.000000,
0.000011,1,0.000011,my $tc = Moose::Meta::TypeConstraint::Role->new(%options);
0.000007,1,0.000007,$REGISTRY->add_type_constraint($tc);
0.000008,1,0.000008,return $tc;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_or_create_type_constraint {
0.000000,0,0.000000,my ( $type_constraint_name, $options_for_anon_type ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( my $constraint
0.000000,0,0.000000,= find_or_parse_type_constraint($type_constraint_name) ) {
0.000000,0,0.000000,return $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( defined $options_for_anon_type ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# if there is no $options_for_anon_type
0.000000,0,0.000000,# specified, then we assume they don't
0.000000,0,0.000000,# want to create one, and return nothing.
0.000000,0,0.000000,
0.000000,0,0.000000,# otherwise assume that we should create
0.000000,0,0.000000,# an ANON type with the $options_for_anon_type
0.000000,0,0.000000,# options which can be passed in. It should
0.000000,0,0.000000,# be noted that these don't get registered
0.000000,0,0.000000,# so we need to return it.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,return Moose::Meta::TypeConstraint->new(
0.000000,0,0.000000,name => '__ANON__',
0.000000,0,0.000000,%{$options_for_anon_type}
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_or_create_isa_type_constraint {
0.000038,22,0.000002,my ($type_constraint_name, $options) = @_;
0.000281,22,0.000013,find_or_parse_type_constraint($type_constraint_name)
0.000000,0,0.000000,|| create_class_type_constraint($type_constraint_name, $options);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_or_create_does_type_constraint {
0.000000,0,0.000000,my ($type_constraint_name, $options) = @_;
0.000000,0,0.000000,find_or_parse_type_constraint($type_constraint_name)
0.000000,0,0.000000,|| create_role_type_constraint($type_constraint_name, $options);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_or_parse_type_constraint {
0.000110,22,0.000005,my $type_constraint_name = normalize_type_constraint_name(shift);
0.000036,22,0.000002,my $constraint;
0.000000,0,0.000000,
0.000301,22,0.000014,if ( $constraint = find_type_constraint($type_constraint_name) ) {
0.000000,0,0.000000,return $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( _detect_type_constraint_union($type_constraint_name) ) {
0.000000,0,0.000000,$constraint = create_type_constraint_union($type_constraint_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( _detect_parameterized_type_constraint($type_constraint_name) ) {
0.000000,0,0.000000,$constraint
0.000000,0,0.000000,= create_parameterized_type_constraint($type_constraint_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$REGISTRY->add_type_constraint($constraint);
0.000000,0,0.000000,return $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub normalize_type_constraint_name {
0.000034,22,0.000002,my $type_constraint_name = shift;
0.000155,22,0.000007,$type_constraint_name =~ s/\s//g;
0.000113,22,0.000005,return $type_constraint_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _confess {
0.000000,0,0.000000,my $error = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,local $Carp::CarpLevel = $Carp::CarpLevel + 1;
0.000000,0,0.000000,Carp::confess($error);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## exported functions ...
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_type_constraint {
0.000047,30,0.000002,my $type = shift;
0.000000,0,0.000000,
0.000200,30,0.000007,if ( blessed $type and $type->isa("Moose::Meta::TypeConstraint") ) {
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000169,30,0.000006,return unless $REGISTRY->has_type_constraint($type);
0.000276,29,0.000010,return $REGISTRY->get_type_constraint($type);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub register_type_constraint {
0.000000,0,0.000000,my $constraint = shift;
0.000000,0,0.000000,__PACKAGE__->_throw_error("can't register an unnamed type constraint")
0.000000,0,0.000000,unless defined $constraint->name;
0.000000,0,0.000000,$REGISTRY->add_type_constraint($constraint);
0.000000,0,0.000000,return $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# type constructors
0.000000,0,0.000000,
0.000000,0,0.000000,sub type {
0.000002,1,0.000002,my $name = shift;
0.000000,0,0.000000,
0.000006,1,0.000006,my %p = map { %{$_} } @_;
0.000000,0,0.000000,
0.000012,1,0.000012,return _create_type_constraint(
0.000000,0,0.000000,$name, undef, $p{where}, $p{message},
0.000000,0,0.000000,$p{optimize_as}, $p{inline_as},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subtype {
0.000025,16,0.000002,if ( @_ == 1 && !ref $_[0] ) {
0.000000,0,0.000000,__PACKAGE__->_throw_error(
0.000000,0,0.000000,'A subtype cannot consist solely of a name, it must have a parent'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The blessed check is mostly to accommodate MooseX::Types, which
0.000000,0,0.000000,# uses an object which overloads stringification as a type name.
0.000029,16,0.000002,my $name = ref $_[0] && !blessed $_[0] ? undef : shift;
0.000000,0,0.000000,
0.000089,16,0.000006,my %p = map { %{$_} } @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# subtype Str => where { ... };
0.000026,16,0.000002,if ( !exists $p{as} ) {
0.000000,0,0.000000,$p{as} = $name;
0.000000,0,0.000000,$name = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000155,16,0.000010,return _create_type_constraint(
0.000000,0,0.000000,$name, $p{as}, $p{where}, $p{message},
0.000000,0,0.000000,$p{optimize_as}, $p{inline_as},
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub class_type {
0.000010,1,0.000010,create_class_type_constraint(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub role_type ($;$) {
0.000021,2,0.000011,create_role_type_constraint(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub maybe_type {
0.000000,0,0.000000,my ($type_parameter) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,register_type_constraint(
0.000000,0,0.000000,$REGISTRY->get_type_constraint('Maybe')->parameterize($type_parameter)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub duck_type {
0.000000,0,0.000000,my ( $type_name, @methods ) = @_;
0.000000,0,0.000000,if ( ref $type_name eq 'ARRAY' && !@methods ) {
0.000000,0,0.000000,@methods   = @$type_name;
0.000000,0,0.000000,$type_name = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( @methods == 1 && ref $methods[0] eq 'ARRAY' ) {
0.000000,0,0.000000,@methods = @{ $methods[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,register_type_constraint(
0.000000,0,0.000000,create_duck_type_constraint(
0.000000,0,0.000000,$type_name,
0.000000,0,0.000000,\@methods,
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub coerce {
0.000000,0,0.000000,my ( $type_name, @coercion_map ) = @_;
0.000000,0,0.000000,_install_type_coercions( $type_name, \@coercion_map );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The trick of returning @_ lets us avoid having to specify a
0.000000,0,0.000000,# prototype. Perl will parse this:
0.000000,0,0.000000,#
0.000000,0,0.000000,# subtype 'Foo'
0.000000,0,0.000000,#     => as 'Str'
0.000000,0,0.000000,#     => where { ... }
0.000000,0,0.000000,#
0.000000,0,0.000000,# as this:
0.000000,0,0.000000,#
0.000000,0,0.000000,# subtype( 'Foo', as( 'Str', where { ... } ) );
0.000000,0,0.000000,#
0.000000,0,0.000000,# If as() returns all its extra arguments, this just works, and
0.000000,0,0.000000,# preserves backwards compatibility.
0.000096,16,0.000006,sub as { { as => shift }, @_ }
0.000089,16,0.000006,sub where (&)       { { where       => $_[0] } }
0.000000,0,0.000000,sub message (&)     { { message     => $_[0] } }
0.000000,0,0.000000,sub optimize_as (&) { { optimize_as => $_[0] } }
0.000088,17,0.000005,sub inline_as (&)   { { inline_as   => $_[0] } }
0.000000,0,0.000000,
0.000000,0,0.000000,sub from    {@_}
0.000000,0,0.000000,sub via (&) { $_[0] }
0.000000,0,0.000000,
0.000000,0,0.000000,sub enum {
0.000000,0,0.000000,my ( $type_name, @values ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# if only an array-ref is passed then
0.000000,0,0.000000,# you get an anon-enum
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,if ( ref $type_name eq 'ARRAY' ) {
0.000000,0,0.000000,@values == 0
0.000000,0,0.000000,|| __PACKAGE__->_throw_error("enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?");
0.000000,0,0.000000,
0.000000,0,0.000000,@values    = @$type_name;
0.000000,0,0.000000,$type_name = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( @values == 1 && ref $values[0] eq 'ARRAY' ) {
0.000000,0,0.000000,@values = @{ $values[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,register_type_constraint(
0.000000,0,0.000000,create_enum_type_constraint(
0.000000,0,0.000000,$type_name,
0.000000,0,0.000000,\@values,
0.000000,0,0.000000,)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub union {
0.000000,0,0.000000,my ( $type_name, @constraints ) = @_;
0.000000,0,0.000000,if ( ref $type_name eq 'ARRAY' ) {
0.000000,0,0.000000,@constraints == 0
0.000000,0,0.000000,|| __PACKAGE__->_throw_error("union called with an array reference and additional arguments.");
0.000000,0,0.000000,@constraints = @$type_name;
0.000000,0,0.000000,$type_name   = undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( @constraints == 1 && ref $constraints[0] eq 'ARRAY' ) {
0.000000,0,0.000000,@constraints = @{ $constraints[0] };
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined $type_name ) {
0.000000,0,0.000000,return register_type_constraint(
0.000000,0,0.000000,create_named_type_constraint_union( $type_name, @constraints )
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,return create_type_constraint_union( @constraints );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_enum_type_constraint {
0.000000,0,0.000000,my ( $type_name, $values ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Enum->new(
0.000000,0,0.000000,name => $type_name || '__ANON__',
0.000000,0,0.000000,values => $values,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_duck_type_constraint {
0.000000,0,0.000000,my ( $type_name, $methods ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::TypeConstraint::DuckType->new(
0.000000,0,0.000000,name => $type_name || '__ANON__',
0.000000,0,0.000000,methods => $methods,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub match_on_type {
0.000000,0,0.000000,my ($to_match, @cases) = @_;
0.000000,0,0.000000,my $default;
0.000000,0,0.000000,if (@cases % 2 != 0) {
0.000000,0,0.000000,$default = pop @cases;
0.000000,0,0.000000,(ref $default eq 'CODE')
0.000000,0,0.000000,|| __PACKAGE__->_throw_error("Default case must be a CODE ref, not $default");
0.000000,0,0.000000,}
0.000000,0,0.000000,while (@cases) {
0.000000,0,0.000000,my ($type, $action) = splice @cases, 0, 2;
0.000000,0,0.000000,
0.000000,0,0.000000,unless (blessed $type && $type->isa('Moose::Meta::TypeConstraint')) {
0.000000,0,0.000000,$type = find_or_parse_type_constraint($type)
0.000000,0,0.000000,|| __PACKAGE__->_throw_error("Cannot find or parse the type '$type'")
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,(ref $action eq 'CODE')
0.000000,0,0.000000,|| __PACKAGE__->_throw_error("Match action must be a CODE ref, not $action");
0.000000,0,0.000000,
0.000000,0,0.000000,if ($type->check($to_match)) {
0.000000,0,0.000000,local $_ = $to_match;
0.000000,0,0.000000,return $action->($to_match);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,(defined $default)
0.000000,0,0.000000,|| __PACKAGE__->_throw_error("No cases matched for $to_match");
0.000000,0,0.000000,{
0.000000,0,0.000000,local $_ = $to_match;
0.000000,0,0.000000,return $default->($to_match);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## desugaring functions ...
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create_type_constraint ($$$;$$) {
0.000027,17,0.000002,my $name      = shift;
0.000025,17,0.000001,my $parent    = shift;
0.000025,17,0.000001,my $check     = shift;
0.000032,17,0.000002,my $message   = shift;
0.000027,17,0.000002,my $optimized = shift;
0.000024,17,0.000001,my $inlined   = shift;
0.000000,0,0.000000,
0.000031,17,0.000002,my $pkg_defined_in = scalar( caller(1) );
0.000000,0,0.000000,
0.000049,17,0.000003,if ( defined $name ) {
0.000090,17,0.000005,my $type = $REGISTRY->get_type_constraint($name);
0.000000,0,0.000000,
0.000024,17,0.000001,( $type->_package_defined_in eq $pkg_defined_in )
0.000000,0,0.000000,|| _confess(
0.000000,0,0.000000,"The type constraint '$name' has already been created in "
0.000000,0,0.000000,. $type->_package_defined_in
0.000000,0,0.000000,. " and cannot be created again in "
0.000000,0,0.000000,. $pkg_defined_in )
0.000000,0,0.000000,if defined $type;
0.000000,0,0.000000,
0.000144,17,0.000008,$name =~ /^[\w:\.]+$/
0.000000,0,0.000000,or die qq{$name contains invalid characters for a type name.}
0.000000,0,0.000000,. qq{ Names can contain alphanumeric character, ":", and "."\n};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000063,17,0.000004,my %opts = (
0.000000,0,0.000000,name               => $name,
0.000000,0,0.000000,package_defined_in => $pkg_defined_in,
0.000000,0,0.000000,
0.000000,0,0.000000,( $check     ? ( constraint => $check )     : () ),
0.000000,0,0.000000,( $message   ? ( message    => $message )   : () ),
0.000000,0,0.000000,( $optimized ? ( optimized  => $optimized ) : () ),
0.000000,0,0.000000,( $inlined   ? ( inlined    => $inlined )   : () ),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000023,17,0.000001,my $constraint;
0.000324,17,0.000019,if (
0.000000,0,0.000000,defined $parent
0.000000,0,0.000000,and $parent
0.000000,0,0.000000,= blessed $parent
0.000000,0,0.000000,? $parent
0.000000,0,0.000000,: find_or_create_isa_type_constraint($parent)
0.000000,0,0.000000,) {
0.000000,0,0.000000,$constraint = $parent->create_child_type(%opts);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000008,1,0.000008,$constraint = Moose::Meta::TypeConstraint->new(%opts);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000092,17,0.000005,$REGISTRY->add_type_constraint($constraint)
0.000000,0,0.000000,if defined $name;
0.000000,0,0.000000,
0.000099,17,0.000006,return $constraint;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_type_coercions ($$) {
0.000000,0,0.000000,my ( $type_name, $coercion_map ) = @_;
0.000000,0,0.000000,my $type = find_type_constraint($type_name);
0.000000,0,0.000000,( defined $type )
0.000000,0,0.000000,|| __PACKAGE__->_throw_error(
0.000000,0,0.000000,"Cannot find type '$type_name', perhaps you forgot to load it");
0.000000,0,0.000000,if ( $type->has_coercion ) {
0.000000,0,0.000000,$type->coercion->add_type_coercions(@$coercion_map);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $type_coercion = Moose::Meta::TypeCoercion->new(
0.000000,0,0.000000,type_coercion_map => $coercion_map,
0.000000,0,0.000000,type_constraint   => $type
0.000000,0,0.000000,);
0.000000,0,0.000000,$type->coercion($type_coercion);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,## type notation parsing ...
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,# All I have to say is mugwump++ cause I know
0.000000,0,0.000000,# do not even have enough regexp-fu to be able
0.000000,0,0.000000,# to have written this (I can only barely
0.000000,0,0.000000,# understand it as it is)
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,
0.000326,3,0.000109,use re "eval";
0.000000,0,0.000000,
0.000013,1,0.000013,my $valid_chars = qr{[\w:\.]};
0.000045,1,0.000045,my $type_atom   = qr{ (?>$valid_chars+) }x;
0.000008,1,0.000008,my $ws          = qr{ (?>\s*) }x;
0.000025,1,0.000025,my $op_union    = qr{ $ws \| $ws }x;
0.000000,0,0.000000,
0.000002,1,0.000002,my ($type, $type_capture_parts, $type_with_parameter, $union, $any);
0.000004,1,0.000004,if (Class::MOP::IS_RUNNING_ON_5_10) {
0.000002,1,0.000002,my $type_pattern
0.000000,0,0.000000,= q{  (?&type_atom)  (?: \[ (?&ws)  (?&any)  (?&ws) \] )? };
0.000002,1,0.000002,my $type_capture_parts_pattern
0.000000,0,0.000000,= q{ ((?&type_atom)) (?: \[ (?&ws) ((?&any)) (?&ws) \] )? };
0.000002,1,0.000002,my $type_with_parameter_pattern
0.000000,0,0.000000,= q{  (?&type_atom)      \[ (?&ws)  (?&any)  (?&ws) \]    };
0.000002,1,0.000002,my $union_pattern
0.000000,0,0.000000,= q{ (?&type) (?> (?: (?&op_union) (?&type) )+ ) };
0.000002,1,0.000002,my $any_pattern
0.000000,0,0.000000,= q{ (?&type) | (?&union) };
0.000000,0,0.000000,
0.000088,1,0.000088,my $defines = qr{(?(DEFINE)
0.000000,0,0.000000,(?<valid_chars>         $valid_chars)
0.000000,0,0.000000,(?<type_atom>           $type_atom)
0.000000,0,0.000000,(?<ws>                  $ws)
0.000000,0,0.000000,(?<op_union>            $op_union)
0.000000,0,0.000000,(?<type>                $type_pattern)
0.000000,0,0.000000,(?<type_capture_parts>  $type_capture_parts_pattern)
0.000000,0,0.000000,(?<type_with_parameter> $type_with_parameter_pattern)
0.000000,0,0.000000,(?<union>               $union_pattern)
0.000000,0,0.000000,(?<any>                 $any_pattern)
0.000000,0,0.000000,)}x;
0.000000,0,0.000000,
0.000073,1,0.000073,$type                = qr{ $type_pattern                $defines }x;
0.000074,1,0.000074,$type_capture_parts  = qr{ $type_capture_parts_pattern  $defines }x;
0.000079,1,0.000079,$type_with_parameter = qr{ $type_with_parameter_pattern $defines }x;
0.000074,1,0.000074,$union               = qr{ $union_pattern               $defines }x;
0.000082,1,0.000082,$any                 = qr{ $any_pattern                 $defines }x;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$type
0.000000,0,0.000000,= qr{  $type_atom  (?: \[ $ws  (??{$any})  $ws \] )? }x;
0.000000,0,0.000000,$type_capture_parts
0.000000,0,0.000000,= qr{ ($type_atom) (?: \[ $ws ((??{$any})) $ws \] )? }x;
0.000000,0,0.000000,$type_with_parameter
0.000000,0,0.000000,= qr{  $type_atom      \[ $ws  (??{$any})  $ws \]    }x;
0.000000,0,0.000000,$union
0.000000,0,0.000000,= qr{ $type (?> (?: $op_union $type )+ ) }x;
0.000000,0,0.000000,$any
0.000000,0,0.000000,= qr{ $type | $union }x;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parse_parameterized_type_constraint {
0.000076,2,0.000038,{ no warnings 'void'; $any; }  # force capture of interpolated lexical
0.000000,0,0.000000,$_[0] =~ m{ $type_capture_parts }x;
0.000000,0,0.000000,return ( $1, $2 );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _detect_parameterized_type_constraint {
0.000066,2,0.000033,{ no warnings 'void'; $any; }  # force capture of interpolated lexical
0.000000,0,0.000000,$_[0] =~ m{ ^ $type_with_parameter $ }x;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _parse_type_constraint_union {
0.000115,2,0.000057,{ no warnings 'void'; $any; }  # force capture of interpolated lexical
0.000000,0,0.000000,my $given = shift;
0.000000,0,0.000000,my @rv;
0.000000,0,0.000000,while ( $given =~ m{ \G (?: $op_union )? ($type) }gcx ) {
0.000000,0,0.000000,push @rv => $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,( pos($given) eq length($given) )
0.000000,0,0.000000,|| __PACKAGE__->_throw_error( "'$given' didn't parse (parse-pos="
0.000000,0,0.000000,. pos($given)
0.000000,0,0.000000,. " and str-length="
0.000000,0,0.000000,. length($given)
0.000000,0,0.000000,. ")" );
0.000000,0,0.000000,@rv;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _detect_type_constraint_union {
0.000290,2,0.000145,{ no warnings 'void'; $any; }  # force capture of interpolated lexical
0.000000,0,0.000000,$_[0] =~ m{^ $type $op_union $type ( $op_union .* )? $}x;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,# define some basic built-in types
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,# By making these classes immutable before creating all the types in
0.000000,0,0.000000,# Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow
0.000000,0,0.000000,# MOP-based accessors.
0.000000,0,0.000000,$_->make_immutable(
0.000044,9,0.000005,inline_constructor => 1,
0.000000,0,0.000000,constructor_name   => "_new",
0.000000,0,0.000000,
0.000000,0,0.000000,# these are Class::MOP accessors, so they need inlining
0.000000,0,0.000000,inline_accessors => 1
0.000133,10,0.000013,) for grep { $_->is_mutable }
0.000000,0,0.000000,map { Class::MOP::class_of($_) }
0.000000,0,0.000000,qw(
0.000000,0,0.000000,Moose::Meta::TypeConstraint
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Union
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Parameterized
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Parameterizable
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Class
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Role
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Enum
0.000000,0,0.000000,Moose::Meta::TypeConstraint::DuckType
0.000000,0,0.000000,Moose::Meta::TypeConstraint::Registry
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000112,1,0.000112,require Moose::Util::TypeConstraints::Builtins;
0.000006,1,0.000006,Moose::Util::TypeConstraints::Builtins::define_builtins($REGISTRY);
0.000000,0,0.000000,
0.000000,0,0.000000,my @PARAMETERIZABLE_TYPES
0.000031,5,0.000006,= map { $REGISTRY->get_type_constraint($_) } qw[ScalarRef ArrayRef HashRef Maybe];
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_parameterizable_types {@PARAMETERIZABLE_TYPES}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_parameterizable_type {
0.000000,0,0.000000,my $type = shift;
0.000000,0,0.000000,( blessed $type
0.000000,0,0.000000,&& $type->isa('Moose::Meta::TypeConstraint::Parameterizable') )
0.000000,0,0.000000,|| __PACKAGE__->_throw_error(
0.000000,0,0.000000,"Type must be a Moose::Meta::TypeConstraint::Parameterizable not $type"
0.000000,0,0.000000,);
0.000000,0,0.000000,push @PARAMETERIZABLE_TYPES => $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,# end of built-in types ...
0.000000,0,0.000000,## --------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000016,2,0.000008,my @BUILTINS = list_all_type_constraints();
0.000000,0,0.000000,sub list_all_builtin_type_constraints {@BUILTINS}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _throw_error {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,require Moose;
0.000000,0,0.000000,unshift @_, 'Moose';
0.000000,0,0.000000,goto &Moose::throw_error;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000041,1,0.000041,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Type constraint system for Moose
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
