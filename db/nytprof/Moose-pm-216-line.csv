# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::AUTHORITY = 'cpan:STEVAN';
0.000029,1,0.000029,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Moose::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000032,2,0.000016,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000058,2,0.000029,use 5.008;
0.000000,0,0.000000,
0.000038,2,0.000019,use Scalar::Util 'blessed';
0.000035,2,0.000018,use Carp         'carp', 'confess';
0.000043,2,0.000022,use Class::Load  'is_class_loaded';
0.000000,0,0.000000,
0.000123,2,0.000061,use Moose::Deprecated;
0.000106,2,0.000053,use Moose::Exporter;
0.000000,0,0.000000,
0.000051,2,0.000026,use Class::MOP;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000007,1,0.000007,die "Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION"
0.000000,0,0.000000,if $Moose::VERSION && $Class::MOP::VERSION ne $Moose::VERSION;
0.000022,1,0.000022,}
0.000000,0,0.000000,
0.000142,2,0.000071,use Moose::Meta::Class;
0.000160,2,0.000080,use Moose::Meta::TypeConstraint;
0.000153,2,0.000076,use Moose::Meta::TypeCoercion;
0.000030,2,0.000015,use Moose::Meta::Attribute;
0.000140,2,0.000070,use Moose::Meta::Instance;
0.000000,0,0.000000,
0.000116,2,0.000058,use Moose::Object;
0.000000,0,0.000000,
0.000151,2,0.000076,use Moose::Meta::Role;
0.000168,2,0.000084,use Moose::Meta::Role::Composite;
0.000140,2,0.000070,use Moose::Meta::Role::Application;
0.000125,2,0.000063,use Moose::Meta::Role::Application::RoleSummation;
0.000122,2,0.000061,use Moose::Meta::Role::Application::ToClass;
0.000142,2,0.000071,use Moose::Meta::Role::Application::ToRole;
0.000108,2,0.000054,use Moose::Meta::Role::Application::ToInstance;
0.000000,0,0.000000,
0.000046,2,0.000023,use Moose::Util::TypeConstraints;
0.000031,2,0.000016,use Moose::Util ();
0.000000,0,0.000000,
0.001037,2,0.000519,use Moose::Meta::Attribute::Native;
0.000000,0,0.000000,
0.000000,0,0.000000,sub throw_error {
0.000000,0,0.000000,# FIXME This
0.000000,0,0.000000,shift;
0.000000,0,0.000000,goto \&confess
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub extends {
0.000000,0,0.000000,my $meta = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,Moose->throw_error("Must derive at least one class") unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# this checks the metaclass to make sure
0.000000,0,0.000000,# it is correct, sometimes it can get out
0.000000,0,0.000000,# of sync when the classes are being built
0.000000,0,0.000000,$meta->superclasses(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub with {
0.000000,0,0.000000,Moose::Util::apply_all_roles(shift, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has {
0.000012,8,0.000002,my $meta = shift;
0.000013,8,0.000002,my $name = shift;
0.000000,0,0.000000,
0.000016,8,0.000002,Moose->throw_error('Usage: has \'name\' => ( key => value, ... )')
0.000000,0,0.000000,if @_ % 2 == 1;
0.000000,0,0.000000,
0.000057,8,0.000007,my %context = Moose::Util::_caller_info;
0.000016,8,0.000002,$context{context} = 'has declaration';
0.000014,8,0.000002,$context{type} = 'class';
0.000034,8,0.000004,my %options = ( definition_context => \%context, @_ );
0.000019,8,0.000002,my $attrs = ( ref($name) eq 'ARRAY' ) ? $name : [ ($name) ];
0.000134,8,0.000017,$meta->add_attribute( $_, %options ) for @$attrs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub before {
0.000000,0,0.000000,Moose::Util::add_method_modifier(shift, 'before', \@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub after {
0.000000,0,0.000000,Moose::Util::add_method_modifier(shift, 'after', \@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub around {
0.000000,0,0.000000,Moose::Util::add_method_modifier(shift, 'around', \@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,our $SUPER_PACKAGE;
0.000001,1,0.000001,our $SUPER_BODY;
0.000002,1,0.000002,our @SUPER_ARGS;
0.000000,0,0.000000,
0.000000,0,0.000000,sub super {
0.000000,0,0.000000,if (@_) {
0.000000,0,0.000000,carp 'Arguments passed to super() are ignored';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This check avoids a recursion loop - see
0.000000,0,0.000000,# t/bugs/super_recursion.t
0.000000,0,0.000000,return if defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
0.000000,0,0.000000,return unless $SUPER_BODY; $SUPER_BODY->(@SUPER_ARGS);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub override {
0.000000,0,0.000000,my $meta = shift;
0.000000,0,0.000000,my ( $name, $method ) = @_;
0.000000,0,0.000000,$meta->add_override_method_modifier( $name => $method );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub inner {
0.000000,0,0.000000,my $pkg = caller();
0.000000,0,0.000000,our ( %INNER_BODY, %INNER_ARGS );
0.000000,0,0.000000,
0.000000,0,0.000000,if ( my $body = $INNER_BODY{$pkg} ) {
0.000000,0,0.000000,my @args = @{ $INNER_ARGS{$pkg} };
0.000000,0,0.000000,local $INNER_ARGS{$pkg};
0.000000,0,0.000000,local $INNER_BODY{$pkg};
0.000000,0,0.000000,return $body->(@args);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub augment {
0.000000,0,0.000000,my $meta = shift;
0.000000,0,0.000000,my ( $name, $method ) = @_;
0.000000,0,0.000000,$meta->add_augment_method_modifier( $name => $method );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,1,0.000010,Moose::Exporter->setup_import_methods(
0.000000,0,0.000000,with_meta => [
0.000000,0,0.000000,qw( extends with has before after around override augment )
0.000000,0,0.000000,],
0.000000,0,0.000000,as_is => [
0.000000,0,0.000000,qw( super inner ),
0.000000,0,0.000000,\&Carp::confess,
0.000000,0,0.000000,\&Scalar::Util::blessed,
0.000000,0,0.000000,],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub init_meta {
0.000002,1,0.000002,shift;
0.000004,1,0.000004,my %args = @_;
0.000000,0,0.000000,
0.000002,1,0.000002,my $class = $args{for_class}
0.000000,0,0.000000,or Moose->throw_error("Cannot call init_meta without specifying a for_class");
0.000002,1,0.000002,my $base_class = $args{base_class} || 'Moose::Object';
0.000002,1,0.000002,my $metaclass  = $args{metaclass}  || 'Moose::Meta::Class';
0.000002,1,0.000002,my $meta_name  = exists $args{meta_name} ? $args{meta_name} : 'meta';
0.000000,0,0.000000,
0.000011,1,0.000011,Moose->throw_error("The Metaclass $metaclass must be loaded. (Perhaps you forgot to 'use $metaclass'?)")
0.000000,0,0.000000,unless is_class_loaded($metaclass);
0.000000,0,0.000000,
0.000010,1,0.000010,Moose->throw_error("The Metaclass $metaclass must be a subclass of Moose::Meta::Class.")
0.000000,0,0.000000,unless $metaclass->isa('Moose::Meta::Class');
0.000000,0,0.000000,
0.000000,0,0.000000,# make a subtype for each Moose class
0.000011,1,0.000011,class_type($class)
0.000000,0,0.000000,unless find_type_constraint($class);
0.000000,0,0.000000,
0.000002,1,0.000002,my $meta;
0.000000,0,0.000000,
0.000007,1,0.000007,if ( $meta = Class::MOP::get_metaclass_by_name($class) ) {
0.000000,0,0.000000,unless ( $meta->isa("Moose::Meta::Class") ) {
0.000000,0,0.000000,my $error_message = "$class already has a metaclass, but it does not inherit $metaclass ($meta).";
0.000000,0,0.000000,if ( $meta->isa('Moose::Meta::Role') ) {
0.000000,0,0.000000,Moose->throw_error($error_message . ' You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.');
0.000000,0,0.000000,} else {
0.000000,0,0.000000,Moose->throw_error($error_message);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# no metaclass
0.000000,0,0.000000,
0.000000,0,0.000000,# now we check whether our ancestors have metaclass, and if so borrow that
0.000012,1,0.000012,my ( undef, @isa ) = @{ mro::get_linear_isa($class) };
0.000000,0,0.000000,
0.000003,1,0.000003,foreach my $ancestor ( @isa ) {
0.000000,0,0.000000,my $ancestor_meta = Class::MOP::get_metaclass_by_name($ancestor) || next;
0.000000,0,0.000000,
0.000000,0,0.000000,my $ancestor_meta_class = $ancestor_meta->_real_ref_name;
0.000000,0,0.000000,
0.000000,0,0.000000,# if we have an ancestor metaclass that inherits $metaclass, we use
0.000000,0,0.000000,# that. This is like _fix_metaclass_incompatibility, but we can do it now.
0.000000,0,0.000000,
0.000000,0,0.000000,# the case of having an ancestry is not very common, but arises in
0.000000,0,0.000000,# e.g. Reaction
0.000000,0,0.000000,unless ( $metaclass->isa( $ancestor_meta_class ) ) {
0.000000,0,0.000000,if ( $ancestor_meta_class->isa($metaclass) ) {
0.000000,0,0.000000,$metaclass = $ancestor_meta_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,1,0.000007,$meta = $metaclass->initialize($class);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,if (defined $meta_name) {
0.000000,0,0.000000,# also check for inherited non moose 'meta' method?
0.000006,1,0.000006,my $existing = $meta->get_method($meta_name);
0.000001,1,0.000001,if ($existing && !$existing->isa('Class::MOP::Method::Meta')) {
0.000000,0,0.000000,Carp::cluck "Moose is overwriting an existing method named "
0.000000,0,0.000000,. "$meta_name in class $class with a method "
0.000000,0,0.000000,. "which returns the class's metaclass. If this is "
0.000000,0,0.000000,. "actually what you want, you should remove the "
0.000000,0,0.000000,. "existing method, otherwise, you should rename or "
0.000000,0,0.000000,. "disable this generated method using the "
0.000000,0,0.000000,. "'-meta_name' option to 'use Moose'.";
0.000000,0,0.000000,}
0.000006,1,0.000006,$meta->_add_meta_method($meta_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# make sure they inherit from Moose::Object
0.000010,1,0.000010,$meta->superclasses($base_class)
0.000000,0,0.000000,unless $meta->superclasses();
0.000000,0,0.000000,
0.000009,1,0.000009,return $meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This may be used in some older MooseX extensions.
0.000000,0,0.000000,sub _get_caller {
0.000000,0,0.000000,goto &Moose::Exporter::_get_caller;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## make 'em all immutable
0.000000,0,0.000000,
0.000117,21,0.000006,$_->make_immutable(
0.000000,0,0.000000,inline_constructor => 1,
0.000000,0,0.000000,constructor_name   => "_new",
0.000000,0,0.000000,# these are Class::MOP accessors, so they need inlining
0.000000,0,0.000000,inline_accessors => 1
0.000366,22,0.000017,) for grep { $_->is_mutable }
0.000000,0,0.000000,map { $_->meta }
0.000000,0,0.000000,qw(
0.000000,0,0.000000,Moose::Meta::Attribute
0.000000,0,0.000000,Moose::Meta::Class
0.000000,0,0.000000,Moose::Meta::Instance
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::TypeCoercion
0.000000,0,0.000000,Moose::Meta::TypeCoercion::Union
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::Method
0.000000,0,0.000000,Moose::Meta::Method::Constructor
0.000000,0,0.000000,Moose::Meta::Method::Destructor
0.000000,0,0.000000,Moose::Meta::Method::Overridden
0.000000,0,0.000000,Moose::Meta::Method::Augmented
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::Role
0.000000,0,0.000000,Moose::Meta::Role::Attribute
0.000000,0,0.000000,Moose::Meta::Role::Method
0.000000,0,0.000000,Moose::Meta::Role::Method::Required
0.000000,0,0.000000,Moose::Meta::Role::Method::Conflicting
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::Role::Composite
0.000000,0,0.000000,
0.000000,0,0.000000,Moose::Meta::Role::Application
0.000000,0,0.000000,Moose::Meta::Role::Application::RoleSummation
0.000000,0,0.000000,Moose::Meta::Role::Application::ToClass
0.000000,0,0.000000,Moose::Meta::Role::Application::ToRole
0.000000,0,0.000000,Moose::Meta::Role::Application::ToInstance
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000015,3,0.000005,$_->make_immutable(
0.000000,0,0.000000,inline_constructor => 0,
0.000000,0,0.000000,constructor_name   => undef,
0.000000,0,0.000000,# these are Class::MOP accessors, so they need inlining
0.000000,0,0.000000,inline_accessors => 1
0.000063,4,0.000016,) for grep { $_->is_mutable }
0.000000,0,0.000000,map { $_->meta }
0.000000,0,0.000000,qw(
0.000000,0,0.000000,Moose::Meta::Method::Accessor
0.000000,0,0.000000,Moose::Meta::Method::Delegation
0.000000,0,0.000000,Moose::Meta::Mixin::AttributeCore
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000016,1,0.000016,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: A postmodern object system for Perl 5
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
