# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Moose::Meta::Class;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::Class::AUTHORITY = 'cpan:STEVAN';
0.000030,1,0.000030,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::Class::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000032,2,0.000016,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000034,2,0.000017,use Class::Load qw(load_class);
0.000032,2,0.000016,use Class::MOP;
0.000033,2,0.000017,use Carp qw( confess );
0.000035,2,0.000017,use Data::OptList;
0.000037,2,0.000018,use List::Util qw( first );
0.000035,2,0.000018,use List::MoreUtils qw( any all uniq first_index );
0.000040,2,0.000020,use Scalar::Util 'blessed';
0.000000,0,0.000000,
0.000137,2,0.000069,use Moose::Meta::Method::Overridden;
0.000114,2,0.000057,use Moose::Meta::Method::Augmented;
0.000111,2,0.000056,use Moose::Error::Default;
0.000127,2,0.000064,use Moose::Meta::Class::Immutable::Trait;
0.000115,2,0.000058,use Moose::Meta::Method::Constructor;
0.000117,2,0.000059,use Moose::Meta::Method::Destructor;
0.000108,2,0.000054,use Moose::Meta::Method::Meta;
0.000114,2,0.000057,use Moose::Util;
0.000033,2,0.000017,use Class::MOP::MiniTrait;
0.000000,0,0.000000,
0.003528,2,0.001764,use base 'Class::MOP::Class';
0.000000,0,0.000000,
0.000006,1,0.000006,Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('roles' => (
0.000000,0,0.000000,reader  => 'roles',
0.000013,2,0.000007,default => sub { [] },
0.000027,1,0.000027,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,__PACKAGE__->meta->add_attribute('role_applications' => (
0.000000,0,0.000000,reader  => '_get_role_applications',
0.000013,2,0.000007,default => sub { [] },
0.000018,1,0.000018,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000018,1,0.000018,__PACKAGE__->meta->add_attribute(
0.000000,0,0.000000,Class::MOP::Attribute->new('immutable_trait' => (
0.000000,0,0.000000,accessor => "immutable_trait",
0.000000,0,0.000000,default  => 'Moose::Meta::Class::Immutable::Trait',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,))
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('constructor_class' => (
0.000000,0,0.000000,accessor => 'constructor_class',
0.000000,0,0.000000,default  => 'Moose::Meta::Method::Constructor',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('destructor_class' => (
0.000000,0,0.000000,accessor => 'destructor_class',
0.000000,0,0.000000,default  => 'Moose::Meta::Method::Destructor',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('error_class' => (
0.000000,0,0.000000,accessor => 'error_class',
0.000000,0,0.000000,default  => 'Moose::Error::Default',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub initialize {
0.000004,2,0.000002,my $class = shift;
0.000005,2,0.000002,my @args = @_;
0.000005,2,0.000002,unshift @args, 'package' if @args % 2;
0.000005,2,0.000002,my %opts = @args;
0.000004,2,0.000002,my $package = delete $opts{package};
0.000035,2,0.000017,return Class::MOP::get_metaclass_by_name($package)
0.000000,0,0.000000,|| $class->SUPER::initialize($package,
0.000000,0,0.000000,'attribute_metaclass' => 'Moose::Meta::Attribute',
0.000000,0,0.000000,'method_metaclass'    => 'Moose::Meta::Method',
0.000000,0,0.000000,'instance_metaclass'  => 'Moose::Meta::Instance',
0.000000,0,0.000000,%opts,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my @args = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @args, 'package' if @args % 2 == 1;
0.000000,0,0.000000,my %options = @args;
0.000000,0,0.000000,
0.000000,0,0.000000,(ref $options{roles} eq 'ARRAY')
0.000000,0,0.000000,|| $class->throw_error("You must pass an ARRAY ref of roles", data => $options{roles})
0.000000,0,0.000000,if exists $options{roles};
0.000000,0,0.000000,
0.000000,0,0.000000,my $package = delete $options{package};
0.000000,0,0.000000,my $roles   = delete $options{roles};
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_meta = $class->SUPER::create($package, %options);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($roles) {
0.000000,0,0.000000,Moose::Util::apply_all_roles( $new_meta, @$roles );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $new_meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,2,0.000006,sub _meta_method_class { 'Moose::Meta::Method::Meta' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _anon_package_prefix { 'Moose::Meta::Class::__ANON__::SERIAL::' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _anon_cache_key {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $superclass_key = join('|',
0.000000,0,0.000000,map { $_->[0] } @{ Data::OptList::mkopt($options{superclasses} || []) }
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $roles = Data::OptList::mkopt(($options{roles} || []), {
0.000000,0,0.000000,moniker  => 'role',
0.000000,0,0.000000,val_test => sub { ref($_[0]) eq 'HASH' },
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,my @role_keys;
0.000000,0,0.000000,for my $role_spec (@$roles) {
0.000000,0,0.000000,my ($role, $params) = @$role_spec;
0.000000,0,0.000000,$params = { %$params } if $params;
0.000000,0,0.000000,
0.000000,0,0.000000,my $key = blessed($role) ? $role->name : $role;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($params && %$params) {
0.000000,0,0.000000,my $alias    = delete $params->{'-alias'}
0.000000,0,0.000000,|| delete $params->{'alias'}
0.000000,0,0.000000,|| {};
0.000000,0,0.000000,my $excludes = delete $params->{'-excludes'}
0.000000,0,0.000000,|| delete $params->{'excludes'}
0.000000,0,0.000000,|| [];
0.000000,0,0.000000,$excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,if (%$params) {
0.000000,0,0.000000,warn "Roles with parameters cannot be cached. Consider "
0.000000,0,0.000000,. "applying the parameters before calling "
0.000000,0,0.000000,. "create_anon_class, or using 'weaken => 0' instead";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $alias_key = join('%',
0.000000,0,0.000000,map { $_ => $alias->{$_} } sort keys %$alias
0.000000,0,0.000000,);
0.000000,0,0.000000,my $excludes_key = join('%',
0.000000,0,0.000000,sort @$excludes
0.000000,0,0.000000,);
0.000000,0,0.000000,$key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @role_keys, $key;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $role_key = join('|', sort @role_keys);
0.000000,0,0.000000,
0.000000,0,0.000000,# Makes something like Super::Class|Super::Class::2=Role|Role::1
0.000000,0,0.000000,return join('=', $superclass_key, $role_key);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinitialize {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $pkg  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
0.000000,0,0.000000,
0.000000,0,0.000000,my %existing_classes;
0.000000,0,0.000000,if ($meta) {
0.000000,0,0.000000,%existing_classes = map { $_ => $meta->$_() } qw(
0.000000,0,0.000000,attribute_metaclass
0.000000,0,0.000000,method_metaclass
0.000000,0,0.000000,wrapped_method_metaclass
0.000000,0,0.000000,instance_metaclass
0.000000,0,0.000000,constructor_class
0.000000,0,0.000000,destructor_class
0.000000,0,0.000000,error_class
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->SUPER::reinitialize(
0.000000,0,0.000000,$pkg,
0.000000,0,0.000000,%existing_classes,
0.000000,0,0.000000,@_,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_role {
0.000000,0,0.000000,my ($self, $role) = @_;
0.000000,0,0.000000,(blessed($role) && $role->isa('Moose::Meta::Role'))
0.000000,0,0.000000,|| $self->throw_error("Roles must be instances of Moose::Meta::Role", data => $role);
0.000000,0,0.000000,push @{$self->roles} => $role;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub role_applications {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return @{$self->_get_role_applications};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_role_application {
0.000000,0,0.000000,my ($self, $application) = @_;
0.000000,0,0.000000,(blessed($application) && $application->isa('Moose::Meta::Role::Application::ToClass'))
0.000000,0,0.000000,|| $self->throw_error("Role applications must be instances of Moose::Meta::Role::Application::ToClass", data => $application);
0.000000,0,0.000000,push @{$self->_get_role_applications} => $application;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub calculate_all_roles {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,grep { !$seen{$_->name}++ } map { $_->calculate_all_roles } @{ $self->roles };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _roles_with_inheritance {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,grep { !$seen{$_->name}++ }
0.000000,0,0.000000,map { Class::MOP::class_of($_)->can('roles')
0.000000,0,0.000000,? @{ Class::MOP::class_of($_)->roles }
0.000000,0,0.000000,: () }
0.000000,0,0.000000,$self->linearized_isa;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub calculate_all_roles_with_inheritance {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,grep { !$seen{$_->name}++ }
0.000000,0,0.000000,map { Class::MOP::class_of($_)->can('calculate_all_roles')
0.000000,0,0.000000,? Class::MOP::class_of($_)->calculate_all_roles
0.000000,0,0.000000,: () }
0.000000,0,0.000000,$self->linearized_isa;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub does_role {
0.000000,0,0.000000,my ($self, $role_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,(defined $role_name)
0.000000,0,0.000000,|| $self->throw_error("You must supply a role name to look for");
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $class ($self->class_precedence_list) {
0.000000,0,0.000000,my $meta = Class::MOP::class_of($class);
0.000000,0,0.000000,# when a Moose metaclass is itself extended with a role,
0.000000,0,0.000000,# this check needs to be done since some items in the
0.000000,0,0.000000,# class_precedence_list might in fact be Class::MOP
0.000000,0,0.000000,# based still.
0.000000,0,0.000000,next unless $meta && $meta->can('roles');
0.000000,0,0.000000,foreach my $role (@{$meta->roles}) {
0.000000,0,0.000000,return 1 if $role->does_role($role_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub excludes_role {
0.000000,0,0.000000,my ($self, $role_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,(defined $role_name)
0.000000,0,0.000000,|| $self->throw_error("You must supply a role name to look for");
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $class ($self->class_precedence_list) {
0.000000,0,0.000000,my $meta = Class::MOP::class_of($class);
0.000000,0,0.000000,# when a Moose metaclass is itself extended with a role,
0.000000,0,0.000000,# this check needs to be done since some items in the
0.000000,0,0.000000,# class_precedence_list might in fact be Class::MOP
0.000000,0,0.000000,# based still.
0.000000,0,0.000000,next unless $meta && $meta->can('roles');
0.000000,0,0.000000,foreach my $role (@{$meta->roles}) {
0.000000,0,0.000000,return 1 if $role->excludes_role($role_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_object {
0.000000,0,0.000000,my $self   = shift;
0.000000,0,0.000000,my $params = @_ == 1 ? $_[0] : {@_};
0.000000,0,0.000000,my $object = $self->SUPER::new_object($params);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_call_all_triggers($object, $params);
0.000000,0,0.000000,
0.000000,0,0.000000,$object->BUILDALL($params) if $object->can('BUILDALL');
0.000000,0,0.000000,
0.000000,0,0.000000,return $object;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _call_all_triggers {
0.000000,0,0.000000,my ($self, $object, $params) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attr ( $self->get_all_attributes() ) {
0.000000,0,0.000000,
0.000000,0,0.000000,next unless $attr->can('has_trigger') && $attr->has_trigger;
0.000000,0,0.000000,
0.000000,0,0.000000,my $init_arg = $attr->init_arg;
0.000000,0,0.000000,next unless defined $init_arg;
0.000000,0,0.000000,next unless exists $params->{$init_arg};
0.000000,0,0.000000,
0.000000,0,0.000000,$attr->trigger->(
0.000000,0,0.000000,$object,
0.000000,0,0.000000,(
0.000000,0,0.000000,$attr->should_coerce
0.000000,0,0.000000,? $attr->get_read_method_ref->($object)
0.000000,0,0.000000,: $params->{$init_arg}
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_fallback_constructor {
0.000001,1,0.000001,my $self = shift;
0.000002,1,0.000002,my ($class) = @_;
0.000008,1,0.000008,return $class . '->Moose::Object::new(@_)'
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_params {
0.000002,1,0.000002,my $self = shift;
0.000002,1,0.000002,my ($params, $class) = @_;
0.000000,0,0.000000,return (
0.000012,1,0.000012,'my ' . $params . ' = ',
0.000000,0,0.000000,$self->_inline_BUILDARGS($class, '@_'),
0.000000,0,0.000000,';',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_BUILDARGS {
0.000002,1,0.000002,my $self = shift;
0.000002,1,0.000002,my ($class, $args) = @_;
0.000000,0,0.000000,
0.000007,1,0.000007,my $buildargs = $self->find_method_by_name("BUILDARGS");
0.000000,0,0.000000,
0.000029,1,0.000029,if ($args eq '@_'
0.000000,0,0.000000,&& (!$buildargs or $buildargs->body == \&Moose::Object::BUILDARGS)) {
0.000000,0,0.000000,return (
0.000000,0,0.000000,'do {',
0.000000,0,0.000000,'my $params;',
0.000000,0,0.000000,'if (scalar @_ == 1) {',
0.000000,0,0.000000,'if (!defined($_[0]) || ref($_[0]) ne \'HASH\') {',
0.000000,0,0.000000,$self->_inline_throw_error(
0.000000,0,0.000000,'"Single parameters to new() must be a HASH ref"',
0.000000,0,0.000000,'data => $_[0]',
0.000000,0,0.000000,) . ';',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,'$params = { %{ $_[0] } };',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,'elsif (@_ % 2) {',
0.000000,0,0.000000,'Carp::carp(',
0.000000,0,0.000000,'"The new() method for ' . $class . ' expects a '
0.000000,0,0.000000,. 'hash reference or a key/value list. You passed an '
0.000000,0,0.000000,. 'odd number of arguments"',
0.000000,0,0.000000,');',
0.000000,0,0.000000,'$params = {@_, undef};',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,'else {',
0.000000,0,0.000000,'$params = {@_};',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,'$params;',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return $class . '->BUILDARGS(' . $args . ')';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_slot_initializer {
0.000012,8,0.000001,my $self  = shift;
0.000013,8,0.000002,my ($attr, $idx) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000151,8,0.000019,'## ' . $attr->name,
0.000000,0,0.000000,$self->_inline_check_required_attr($attr),
0.000000,0,0.000000,$self->SUPER::_inline_slot_initializer(@_),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_check_required_attr {
0.000012,8,0.000001,my $self = shift;
0.000012,8,0.000002,my ($attr) = @_;
0.000000,0,0.000000,
0.000064,8,0.000008,return unless defined $attr->init_arg;
0.000102,7,0.000015,return unless $attr->can('is_required') && $attr->is_required;
0.000000,0,0.000000,return if $attr->has_default || $attr->has_builder;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000000,0,0.000000,'if (!exists $params->{\'' . $attr->init_arg . '\'}) {',
0.000000,0,0.000000,$self->_inline_throw_error(
0.000000,0,0.000000,'"Attribute (' . quotemeta($attr->name) . ') is required"'
0.000000,0,0.000000,) . ';',
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: these two are duplicated from cmop, because we have to pass the tc stuff
0.000000,0,0.000000,# through to _inline_set_value - this should probably be fixed, but i'm not
0.000000,0,0.000000,# quite sure how. -doy
0.000000,0,0.000000,sub _inline_init_attr_from_constructor {
0.000010,7,0.000001,my $self = shift;
0.000011,7,0.000002,my ($attr, $idx) = @_;
0.000000,0,0.000000,
0.000085,7,0.000012,my @initial_value = $attr->_inline_set_value(
0.000000,0,0.000000,'$instance',
0.000000,0,0.000000,'$params->{\'' . $attr->init_arg . '\'}',
0.000000,0,0.000000,'$type_constraint_bodies[' . $idx . ']',
0.000000,0,0.000000,'$type_coercions[' . $idx . ']',
0.000000,0,0.000000,'$type_constraint_messages[' . $idx . ']',
0.000000,0,0.000000,'for constructor',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000037,7,0.000005,push @initial_value, (
0.000000,0,0.000000,'$attrs->[' . $idx . ']->set_initial_value(',
0.000000,0,0.000000,'$instance,',
0.000000,0,0.000000,$attr->_inline_instance_get('$instance'),
0.000000,0,0.000000,');',
0.000000,0,0.000000,) if $attr->has_initializer;
0.000000,0,0.000000,
0.000047,7,0.000007,return @initial_value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_init_attr_from_default {
0.000012,8,0.000002,my $self = shift;
0.000012,8,0.000002,my ($attr, $idx) = @_;
0.000000,0,0.000000,
0.000096,8,0.000012,return if $attr->can('is_lazy') && $attr->is_lazy;
0.000036,6,0.000006,my $default = $self->_inline_default_value($attr, $idx);
0.000012,6,0.000002,return unless $default;
0.000000,0,0.000000,
0.000037,5,0.000007,my @initial_value = (
0.000000,0,0.000000,'my $default = ' . $default . ';',
0.000000,0,0.000000,$attr->_inline_set_value(
0.000000,0,0.000000,'$instance',
0.000000,0,0.000000,'$default',
0.000000,0,0.000000,'$type_constraint_bodies[' . $idx . ']',
0.000000,0,0.000000,'$type_coercions[' . $idx . ']',
0.000000,0,0.000000,'$type_constraint_messages[' . $idx . ']',
0.000000,0,0.000000,'for constructor',
0.000000,0,0.000000,),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000026,5,0.000005,push @initial_value, (
0.000000,0,0.000000,'$attrs->[' . $idx . ']->set_initial_value(',
0.000000,0,0.000000,'$instance,',
0.000000,0,0.000000,$attr->_inline_instance_get('$instance'),
0.000000,0,0.000000,');',
0.000000,0,0.000000,) if $attr->has_initializer;
0.000000,0,0.000000,
0.000035,5,0.000007,return @initial_value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_extra_init {
0.000002,1,0.000002,my $self = shift;
0.000000,0,0.000000,return (
0.000015,1,0.000015,$self->_inline_triggers,
0.000000,0,0.000000,$self->_inline_BUILDALL,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_triggers {
0.000002,1,0.000002,my $self = shift;
0.000002,1,0.000002,my @trigger_calls;
0.000000,0,0.000000,
0.000202,18,0.000011,my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
0.000017,1,0.000017,for my $i (0 .. $#attrs) {
0.000012,8,0.000002,my $attr = $attrs[$i];
0.000000,0,0.000000,
0.000085,8,0.000011,next unless $attr->can('has_trigger') && $attr->has_trigger;
0.000000,0,0.000000,
0.000000,0,0.000000,my $init_arg = $attr->init_arg;
0.000000,0,0.000000,next unless defined $init_arg;
0.000000,0,0.000000,
0.000000,0,0.000000,push @trigger_calls,
0.000000,0,0.000000,'if (exists $params->{\'' . $init_arg . '\'}) {',
0.000000,0,0.000000,'$triggers->[' . $i . ']->(',
0.000000,0,0.000000,'$instance,',
0.000000,0,0.000000,$attr->_inline_instance_get('$instance') . ',',
0.000000,0,0.000000,');',
0.000000,0,0.000000,'}';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,1,0.000011,return @trigger_calls;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_BUILDALL {
0.000002,1,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000009,1,0.000009,my @methods = reverse $self->find_all_methods_by_name('BUILD');
0.000002,1,0.000002,my @BUILD_calls;
0.000000,0,0.000000,
0.000003,1,0.000003,foreach my $method (@methods) {
0.000005,1,0.000005,push @BUILD_calls,
0.000000,0,0.000000,'$instance->' . $method->{class} . '::BUILD($params);';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000012,1,0.000012,return @BUILD_calls;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_environment {
0.000002,1,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000171,16,0.000011,my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
0.000000,0,0.000000,
0.000082,8,0.000010,my $triggers = [
0.000017,1,0.000017,map { $_->can('has_trigger') && $_->has_trigger ? $_->trigger : undef }
0.000000,0,0.000000,@attrs
0.000000,0,0.000000,];
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to check if the attribute ->can('type_constraint')
0.000000,0,0.000000,# since we may be trying to immutabilize a Moose meta class,
0.000000,0,0.000000,# which in turn has attributes which are Class::MOP::Attribute
0.000000,0,0.000000,# objects, rather than Moose::Meta::Attribute. And
0.000000,0,0.000000,# Class::MOP::Attribute attributes have no type constraints.
0.000000,0,0.000000,# However we need to make sure we leave an undef value there
0.000000,0,0.000000,# because the inlined code is using the index of the attributes
0.000000,0,0.000000,# to determine where to find the type constraint
0.000000,0,0.000000,
0.000081,8,0.000010,my @type_constraints = map {
0.000016,1,0.000016,$_->can('type_constraint') ? $_->type_constraint : undef
0.000000,0,0.000000,} @attrs;
0.000000,0,0.000000,
0.000042,8,0.000005,my @type_constraint_bodies = map {
0.000016,1,0.000016,defined $_ ? $_->_compiled_type_constraint : undef;
0.000000,0,0.000000,} @type_constraints;
0.000000,0,0.000000,
0.000042,8,0.000005,my @type_coercions = map {
0.000016,1,0.000016,defined $_ && $_->has_coercion
0.000000,0,0.000000,? $_->coercion->_compiled_type_coercion
0.000000,0,0.000000,: undef
0.000000,0,0.000000,} @type_constraints;
0.000000,0,0.000000,
0.000071,8,0.000009,my @type_constraint_messages = map {
0.000016,1,0.000016,defined $_
0.000000,0,0.000000,? ($_->has_message ? $_->message : $_->_default_message)
0.000000,0,0.000000,: undef
0.000000,0,0.000000,} @type_constraints;
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000000,0,0.000000,%{ $self->SUPER::_eval_environment },
0.000101,16,0.000006,((any { defined && $_->has_initializer } @attrs)
0.000000,0,0.000000,? ('$attrs' => \[@attrs])
0.000000,0,0.000000,: ()),
0.000000,0,0.000000,'$triggers' => \$triggers,
0.000000,0,0.000000,'@type_coercions' => \@type_coercions,
0.000000,0,0.000000,'@type_constraint_bodies' => \@type_constraint_bodies,
0.000000,0,0.000000,'@type_constraint_messages' => \@type_constraint_messages,
0.000073,9,0.000008,( map { defined($_) ? %{ $_->inline_environment } : () }
0.000000,0,0.000000,@type_constraints ),
0.000000,0,0.000000,# pretty sure this is only going to be closed over if you use a custom
0.000000,0,0.000000,# error class at this point, but we should still get rid of this
0.000000,0,0.000000,# at some point
0.000000,0,0.000000,'$meta'  => \$self,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub superclasses {
0.000009,6,0.000002,my $self = shift;
0.000034,6,0.000006,my $supers = Data::OptList::mkopt(\@_);
0.000021,6,0.000003,foreach my $super (@{ $supers }) {
0.000002,1,0.000002,my ($name, $opts) = @{ $super };
0.000006,1,0.000006,load_class($name, $opts);
0.000006,1,0.000006,my $meta = Class::MOP::class_of($name);
0.000018,1,0.000018,$self->throw_error("You cannot inherit from a Moose Role ($name)")
0.000000,0,0.000000,if $meta && $meta->isa('Moose::Meta::Role')
0.000000,0,0.000000,}
0.000066,6,0.000011,return $self->SUPER::superclasses(map { $_->[0] } @{ $supers });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,### ---------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_attribute {
0.000013,8,0.000002,my $self = shift;
0.000111,8,0.000014,my $attr =
0.000000,0,0.000000,(blessed $_[0] && $_[0]->isa('Class::MOP::Attribute')
0.000000,0,0.000000,? $_[0]
0.000000,0,0.000000,: $self->_process_attribute(@_));
0.000054,8,0.000007,$self->SUPER::add_attribute($attr);
0.000000,0,0.000000,# it may be a Class::MOP::Attribute, theoretically, which doesn't have
0.000000,0,0.000000,# 'bare' and doesn't implement this method
0.000097,8,0.000012,if ($attr->can('_check_associated_methods')) {
0.000000,0,0.000000,$attr->_check_associated_methods;
0.000000,0,0.000000,}
0.000042,8,0.000005,return $attr;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_override_method_modifier {
0.000000,0,0.000000,my ($self, $name, $method, $_super_package) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,(!$self->has_method($name))
0.000000,0,0.000000,|| $self->throw_error("Cannot add an override method if a local method is already present");
0.000000,0,0.000000,
0.000000,0,0.000000,$self->add_method($name => Moose::Meta::Method::Overridden->new(
0.000000,0,0.000000,method  => $method,
0.000000,0,0.000000,class   => $self,
0.000000,0,0.000000,package => $_super_package, # need this for roles
0.000000,0,0.000000,name    => $name,
0.000000,0,0.000000,));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_augment_method_modifier {
0.000000,0,0.000000,my ($self, $name, $method) = @_;
0.000000,0,0.000000,(!$self->has_method($name))
0.000000,0,0.000000,|| $self->throw_error("Cannot add an augment method if a local method is already present");
0.000000,0,0.000000,
0.000000,0,0.000000,$self->add_method($name => Moose::Meta::Method::Augmented->new(
0.000000,0,0.000000,method  => $method,
0.000000,0,0.000000,class   => $self,
0.000000,0,0.000000,name    => $name,
0.000000,0,0.000000,));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Private Utility methods ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub _find_next_method_by_name_which_is_not_overridden {
0.000000,0,0.000000,my ($self, $name) = @_;
0.000000,0,0.000000,foreach my $method ($self->find_all_methods_by_name($name)) {
0.000000,0,0.000000,return $method->{code}
0.000000,0,0.000000,if blessed($method->{code}) && !$method->{code}->isa('Moose::Meta::Method::Overridden');
0.000000,0,0.000000,}
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Metaclass compatibility
0.000000,0,0.000000,
0.000000,0,0.000000,sub _base_metaclasses {
0.000003,2,0.000002,my $self = shift;
0.000017,2,0.000008,my %metaclasses = $self->SUPER::_base_metaclasses;
0.000008,2,0.000004,for my $class (keys %metaclasses) {
0.000111,12,0.000009,$metaclasses{$class} =~ s/^Class::MOP/Moose::Meta/;
0.000000,0,0.000000,}
0.000000,0,0.000000,return (
0.000019,2,0.000009,%metaclasses,
0.000000,0,0.000000,error_class => 'Moose::Error::Default',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fix_class_metaclass_incompatibility {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($super_meta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::_fix_class_metaclass_incompatibility(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
0.000000,0,0.000000,($self->is_pristine)
0.000000,0,0.000000,|| confess "Can't fix metaclass incompatibility for "
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. " because it is not pristine.";
0.000000,0,0.000000,my $super_meta_name = $super_meta->_real_ref_name;
0.000000,0,0.000000,my $class_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass(blessed($self), $super_meta_name);
0.000000,0,0.000000,my $new_self = $class_meta_subclass_meta_name->reinitialize(
0.000000,0,0.000000,$self->name,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_replace_self( $new_self, $class_meta_subclass_meta_name );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fix_single_metaclass_incompatibility {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($metaclass_type, $super_meta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::_fix_single_metaclass_incompatibility(@_);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
0.000000,0,0.000000,($self->is_pristine)
0.000000,0,0.000000,|| confess "Can't fix metaclass incompatibility for "
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. " because it is not pristine.";
0.000000,0,0.000000,my $super_meta_name = $super_meta->_real_ref_name;
0.000000,0,0.000000,my $class_specific_meta_subclass_meta_name = Moose::Util::_reconcile_roles_for_metaclass($self->$metaclass_type, $super_meta->$metaclass_type);
0.000000,0,0.000000,my $new_self = $super_meta->reinitialize(
0.000000,0,0.000000,$self->name,
0.000000,0,0.000000,$metaclass_type => $class_specific_meta_subclass_meta_name,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_replace_self( $new_self, $super_meta_name );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _replace_self {
0.000000,0,0.000000,my $self      = shift;
0.000000,0,0.000000,my ( $new_self, $new_class)   = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$new_self;
0.000000,0,0.000000,bless $self, $new_class;
0.000000,0,0.000000,
0.000000,0,0.000000,# We need to replace the cached metaclass instance or else when it goes
0.000000,0,0.000000,# out of scope Class::MOP::Class destroy's the namespace for the
0.000000,0,0.000000,# metaclass's class, causing much havoc.
0.000000,0,0.000000,my $weaken = Class::MOP::metaclass_is_weak( $self->name );
0.000000,0,0.000000,Class::MOP::store_metaclass_by_name( $self->name, $self );
0.000000,0,0.000000,Class::MOP::weaken_metaclass( $self->name ) if $weaken;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_attribute {
0.000025,8,0.000003,my ( $self, $name, @args ) = @_;
0.000000,0,0.000000,
0.000014,8,0.000002,@args = %{$args[0]} if scalar @args == 1 && ref($args[0]) eq 'HASH';
0.000000,0,0.000000,
0.000066,8,0.000008,if (($name || '') =~ /^\+(.*)/) {
0.000000,0,0.000000,return $self->_process_inherited_attribute($1, @args);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000080,8,0.000010,return $self->_process_new_attribute($name, @args);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_new_attribute {
0.000024,8,0.000003,my ( $self, $name, @args ) = @_;
0.000000,0,0.000000,
0.000139,8,0.000017,$self->attribute_metaclass->interpolate_class_and_new($name, @args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _process_inherited_attribute {
0.000000,0,0.000000,my ($self, $attr_name, %options) = @_;
0.000000,0,0.000000,my $inherited_attr = $self->find_attribute_by_name($attr_name);
0.000000,0,0.000000,(defined $inherited_attr)
0.000000,0,0.000000,|| $self->throw_error("Could not find an attribute by the name of '$attr_name' to inherit from in ${\$self->name}", data => $attr_name);
0.000000,0,0.000000,if ($inherited_attr->isa('Moose::Meta::Attribute')) {
0.000000,0,0.000000,return $inherited_attr->clone_and_inherit_options(%options);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# kind of a kludge to handle Class::MOP::Attributes
0.000000,0,0.000000,return $inherited_attr->Moose::Meta::Attribute::clone_and_inherit_options(%options);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# reinitialization support
0.000000,0,0.000000,
0.000000,0,0.000000,sub _restore_metaobjects_from {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($old_meta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::_restore_metaobjects_from($old_meta);
0.000000,0,0.000000,
0.000000,0,0.000000,for my $role ( @{ $old_meta->roles } ) {
0.000000,0,0.000000,$self->add_role($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $application ( @{ $old_meta->_get_role_applications } ) {
0.000000,0,0.000000,$application->class($self);
0.000000,0,0.000000,$self->add_role_application ($application);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Immutability
0.000000,0,0.000000,
0.000000,0,0.000000,sub _immutable_options {
0.000002,1,0.000002,my ( $self, @args ) = @_;
0.000000,0,0.000000,
0.000013,1,0.000013,$self->SUPER::_immutable_options(
0.000000,0,0.000000,inline_destructor => 1,
0.000000,0,0.000000,
0.000000,0,0.000000,# Moose always does this when an attribute is created
0.000000,0,0.000000,inline_accessors => 0,
0.000000,0,0.000000,
0.000000,0,0.000000,@args,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fixup_attributes_after_rebless {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($instance, $rebless_from, %params) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::_fixup_attributes_after_rebless(
0.000000,0,0.000000,$instance,
0.000000,0,0.000000,$rebless_from,
0.000000,0,0.000000,%params
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_call_all_triggers( $instance, \%params );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## -------------------------------------------------
0.000000,0,0.000000,
0.000001,1,0.000001,our $error_level;
0.000000,0,0.000000,
0.000000,0,0.000000,sub throw_error {
0.000000,0,0.000000,my ( $self, @args ) = @_;
0.000000,0,0.000000,local $error_level = ($error_level || 0) + 1;
0.000000,0,0.000000,$self->raise_error($self->create_error(@args));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_throw_error {
0.000066,26,0.000003,my ( $self, @args ) = @_;
0.000334,26,0.000013,$self->_inline_raise_error($self->_inline_create_error(@args));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub raise_error {
0.000000,0,0.000000,my ( $self, @args ) = @_;
0.000000,0,0.000000,die @args;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_raise_error {
0.000050,26,0.000002,my ( $self, $message ) = @_;
0.000000,0,0.000000,
0.000149,26,0.000006,return 'die ' . $message;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_error {
0.000000,0,0.000000,my ( $self, @args ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,require Carp::Heavy;
0.000000,0,0.000000,
0.000000,0,0.000000,local $error_level = ($error_level || 0 ) + 1;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( @args % 2 == 1 ) {
0.000000,0,0.000000,unshift @args, "message";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %args = ( metaclass => $self, last_error => $@, @args );
0.000000,0,0.000000,
0.000000,0,0.000000,$args{depth} += $error_level;
0.000000,0,0.000000,
0.000000,0,0.000000,my $class = ref $self ? $self->error_class : "Moose::Error::Default";
0.000000,0,0.000000,
0.000000,0,0.000000,load_class($class);
0.000000,0,0.000000,
0.000000,0,0.000000,$class->new(
0.000000,0,0.000000,Carp::caller_info($args{depth}),
0.000000,0,0.000000,%args
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_create_error {
0.000050,26,0.000002,my ( $self, $msg, $args ) = @_;
0.000000,0,0.000000,# XXX ignore $args for now, nothing currently uses it anyway
0.000000,0,0.000000,
0.000048,26,0.000002,require Carp::Heavy;
0.000000,0,0.000000,
0.000086,26,0.000003,my %args = (
0.000000,0,0.000000,metaclass  => $self,
0.000000,0,0.000000,last_error => $@,
0.000000,0,0.000000,message    => $msg,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000155,26,0.000006,my $class = ref $self ? $self->error_class : "Moose::Error::Default";
0.000000,0,0.000000,
0.000152,26,0.000006,load_class($class);
0.000000,0,0.000000,
0.000000,0,0.000000,# don't check inheritance here - the intention is that the class needs
0.000000,0,0.000000,# to provide a non-inherited inlining method, because falling back to
0.000000,0,0.000000,# the default inlining method is most likely going to be wrong
0.000000,0,0.000000,# yes, this is a huge hack, but so is the entire error system, so.
0.000000,0,0.000000,return
0.000251,26,0.000010,'$meta->create_error('
0.000000,0,0.000000,. $msg
0.000000,0,0.000000,. ( defined $args ? ', ' . $args : q{} ) . ');'
0.000000,0,0.000000,unless $class->meta->has_method('_inline_new');
0.000000,0,0.000000,
0.000261,26,0.000010,$class->_inline_new(
0.000000,0,0.000000,# XXX ignore this for now too
0.000000,0,0.000000,# Carp::caller_info($args{depth}),
0.000000,0,0.000000,%args
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000014,1,0.000014,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: The Moose metaclass
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
