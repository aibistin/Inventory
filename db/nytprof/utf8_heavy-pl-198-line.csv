# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package utf8;
0.000034,2,0.000017,use strict;
0.000035,2,0.000018,use warnings;
0.000563,2,0.000282,use re "/aa";  # So we won't even try to look at above Latin1, potentially
0.000000,0,0.000000,# resulting in a recursive call
0.000000,0,0.000000,
0.000000,0,0.000000,sub DEBUG () { 0 }
0.000000,0,0.000000,$|=1 if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,sub DESTROY {}
0.000000,0,0.000000,
0.000002,1,0.000002,my %Cache;
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak { require Carp; Carp::croak(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _loose_name ($) {
0.000000,0,0.000000,# Given a lowercase property or property-value name, return its
0.000000,0,0.000000,# standardized version that is expected for look-up in the 'loose' hashes
0.000000,0,0.000000,# in Heavy.pl (hence, this depends on what mktables does).  This squeezes
0.000000,0,0.000000,# out blanks, underscores and dashes.  The complication stems from the
0.000000,0,0.000000,# grandfathered-in 'L_', which retains a single trailing underscore.
0.000000,0,0.000000,
0.000015,2,0.000007,my $loose = $_[0] =~ s/[-\s_]//rg;
0.000000,0,0.000000,
0.000021,2,0.000011,return $loose if $loose !~ / ^ (?: is | to )? l $/x;
0.000000,0,0.000000,return 'l_' if $_[0] =~ / l .* _ /x;    # If original had a trailing '_'
0.000000,0,0.000000,return $loose;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## "SWASH" == "SWATCH HASH". A "swatch" is a swatch of the Unicode landscape.
0.000000,0,0.000000,## It's a data structure that encodes a set of Unicode characters.
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000000,0,0.000000,# If a floating point number is within this distance from the value of a
0.000000,0,0.000000,# fraction, it is considered to be that fraction, even if many more digits
0.000000,0,0.000000,# are specified that don't exactly match.
0.000004,2,0.000002,my $min_floating_slop;
0.000000,0,0.000000,
0.000000,0,0.000000,# To guard against this program calling something that in turn ends up
0.000000,0,0.000000,# calling this program with the same inputs, and hence infinitely
0.000000,0,0.000000,# recursing, we keep a stack of the properties that are currently in
0.000000,0,0.000000,# progress, pushed upon entry, popped upon return.
0.000002,1,0.000002,my @recursed;
0.000000,0,0.000000,
0.000000,0,0.000000,sub SWASHNEW {
0.000013,6,0.000002,my ($class, $type, $list, $minbits, $none) = @_;
0.000009,6,0.000001,my $user_defined = 0;
0.000010,6,0.000002,local $^D = 0 if $^D;
0.000000,0,0.000000,
0.000009,6,0.000002,$class = "" unless defined $class;
0.000000,0,0.000000,print STDERR __LINE__, ": class=$class, type=$type, list=",
0.000000,0,0.000000,(defined $list) ? $list : ':undef:',
0.000000,0,0.000000,", minbits=$minbits, none=$none\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## Get the list of codepoints for the type.
0.000000,0,0.000000,## Called from swash_init (see utf8.c) or SWASHNEW itself.
0.000000,0,0.000000,##
0.000000,0,0.000000,## Callers of swash_init:
0.000000,0,0.000000,##     op.c:pmtrans             -- for tr/// and y///
0.000000,0,0.000000,##     regexec.c:regclass_swash -- for /[]/, \p, and \P
0.000000,0,0.000000,##     utf8.c:is_utf8_common    -- for common Unicode properties
0.000000,0,0.000000,##     utf8.c:to_utf8_case      -- for lc, uc, ucfirst, etc. and //i
0.000000,0,0.000000,##     Unicode::UCD::prop_invlist
0.000000,0,0.000000,##     Unicode::UCD::prop_invmap
0.000000,0,0.000000,##
0.000000,0,0.000000,## Given a $type, our goal is to fill $list with the set of codepoint
0.000000,0,0.000000,## ranges. If $type is false, $list passed is used.
0.000000,0,0.000000,##
0.000000,0,0.000000,## $minbits:
0.000000,0,0.000000,##     For binary properties, $minbits must be 1.
0.000000,0,0.000000,##     For character mappings (case and transliteration), $minbits must
0.000000,0,0.000000,##     be a number except 1.
0.000000,0,0.000000,##
0.000000,0,0.000000,## $list (or that filled according to $type):
0.000000,0,0.000000,##     Refer to perlunicode.pod, "User-Defined Character Properties."
0.000000,0,0.000000,##     
0.000000,0,0.000000,##     For binary properties, only characters with the property value
0.000000,0,0.000000,##     of True should be listed. The 3rd column, if any, will be ignored
0.000000,0,0.000000,##
0.000000,0,0.000000,## $none is undocumented, so I'm (khw) trying to do some documentation
0.000000,0,0.000000,## of it now.  It appears to be if there is a mapping in an input file
0.000000,0,0.000000,## that maps to 'XXXX', then that is replaced by $none+1, expressed in
0.000000,0,0.000000,## hexadecimal.  It is used somehow in tr///.
0.000000,0,0.000000,##
0.000000,0,0.000000,## To make the parsing of $type clear, this code takes the a rather
0.000000,0,0.000000,## unorthodox approach of last'ing out of the block once we have the
0.000000,0,0.000000,## info we need. Were this to be a subroutine, the 'last' would just
0.000000,0,0.000000,## be a 'return'.
0.000000,0,0.000000,##
0.000000,0,0.000000,#   If a problem is found $type is returned;
0.000000,0,0.000000,#   Upon success, a new (or cached) blessed object is returned with
0.000000,0,0.000000,#   keys TYPE, BITS, EXTRAS, LIST, and NONE with values having the
0.000000,0,0.000000,#   same meanings as the input parameters.
0.000000,0,0.000000,#   SPECIALS contains a reference to any special-treatment hash in the
0.000000,0,0.000000,#   INVERT_IT is non-zero if the result should be inverted before use
0.000000,0,0.000000,#   USER_DEFINED is non-zero if the result came from a user-defined
0.000000,0,0.000000,#       property.
0.000008,6,0.000001,my $file; ## file to load data from, and also part of the %Cache key.
0.000000,0,0.000000,
0.000000,0,0.000000,# Change this to get a different set of Unicode tables
0.000009,6,0.000002,my $unicore_dir = 'unicore';
0.000008,6,0.000001,my $invert_it = 0;
0.000008,6,0.000001,my $list_is_from_mktables = 0;  # Is $list returned from a mktables
0.000000,0,0.000000,# generated file?  If so, we know it's
0.000000,0,0.000000,# well behaved.
0.000000,0,0.000000,
0.000017,6,0.000003,if ($type)
0.000000,0,0.000000,{
0.000000,0,0.000000,# Verify that this isn't a recursive call for this property.
0.000000,0,0.000000,# Can't use croak, as it may try to recurse to here itself.
0.000012,6,0.000002,my $class_type = $class . "::$type";
0.000010,6,0.000002,if (grep { $_ eq $class_type } @recursed) {
0.000000,0,0.000000,CORE::die "panic: Infinite recursion in SWASHNEW for '$type'\n";
0.000000,0,0.000000,}
0.000011,6,0.000002,push @recursed, $class_type;
0.000000,0,0.000000,
0.000053,6,0.000009,$type =~ s/^\s+//;
0.000046,6,0.000008,$type =~ s/\s+$//;
0.000000,0,0.000000,
0.000000,0,0.000000,# regcomp.c surrounds the property name with '__" and '_i' if this
0.000000,0,0.000000,# is to be caseless matching.
0.000035,6,0.000006,my $caseless = $type =~ s/^(.*)__(.*)_i$/$1$2/;
0.000000,0,0.000000,
0.000000,0,0.000000,print STDERR __LINE__, ": type=$type, caseless=$caseless\n" if DEBUG;
0.000000,0,0.000000,
0.000013,6,0.000002,GETFILE:
0.000000,0,0.000000,{
0.000000,0,0.000000,##
0.000000,0,0.000000,## It could be a user-defined property.  Look in current
0.000000,0,0.000000,## package if no package given
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000008,6,0.000001,my $caller0 = caller(0);
0.000037,6,0.000006,my $caller1 = $type =~ s/(.+)::// ? $1 : $caller0 eq 'main' ?
0.000000,0,0.000000,'main' : caller(1);
0.000000,0,0.000000,
0.000038,6,0.000006,if (defined $caller1 && $type =~ /^I[ns]\w+$/) {
0.000000,0,0.000000,my $prop = "${caller1}::$type";
0.000000,0,0.000000,if (exists &{$prop}) {
0.000000,0,0.000000,# stolen from Scalar::Util::PP::tainted()
0.000000,0,0.000000,my $tainted;
0.000000,0,0.000000,{
0.000000,0,0.000000,local($@, $SIG{__DIE__}, $SIG{__WARN__});
0.000000,0,0.000000,local $^W = 0;
0.000083,2,0.000041,no warnings;
0.000000,0,0.000000,eval { kill 0 * $prop };
0.000000,0,0.000000,$tainted = 1 if $@ =~ /^Insecure/;
0.000000,0,0.000000,}
0.000000,0,0.000000,die "Insecure user-defined property \\p{$prop}\n"
0.000000,0,0.000000,if $tainted;
0.000071,2,0.000035,no strict 'refs';
0.000000,0,0.000000,$list = &{$prop}($caseless);
0.000000,0,0.000000,$user_defined = 1;
0.000000,0,0.000000,last GETFILE;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# During Perl's compilation, this routine may be called before
0.000000,0,0.000000,# the tables are constructed.  If so, we have a chicken/egg
0.000000,0,0.000000,# problem.  If we die, the tables never get constructed, so
0.000000,0,0.000000,# keep going, but return an empty table so only what the code
0.000000,0,0.000000,# has compiled in internally (currently ASCII/Latin1 range
0.000000,0,0.000000,# matching) will work.
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,# Poor man's constant, to avoid a run-time check.
0.000012,1,0.000012,$utf8::{miniperl}
0.000000,0,0.000000,= \! defined &DynaLoader::boot_DynaLoader;
0.000077,1,0.000077,}
0.000019,6,0.000003,if (miniperl) {
0.000000,0,0.000000,eval "require '$unicore_dir/Heavy.pl'";
0.000000,0,0.000000,last GETFILE if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.006327,6,0.001055,require "$unicore_dir/Heavy.pl";
0.000000,0,0.000000,}
0.001584,1,0.001584,BEGIN { delete $utf8::{miniperl} }
0.000000,0,0.000000,
0.000000,0,0.000000,# All property names are matched caselessly
0.000012,6,0.000002,my $property_and_table = CORE::lc $type;
0.000000,0,0.000000,print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# See if is of the compound form 'property=value', where the
0.000000,0,0.000000,# value indicates the table we should use.
0.000022,6,0.000004,my ($property, $table, @remainder) =
0.000000,0,0.000000,split /\s*[:=]\s*/, $property_and_table, -1;
0.000010,6,0.000002,if (@remainder) {
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,6,0.000001,my $prefix;
0.000018,6,0.000003,if (! defined $table) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, is the single form.  The property becomes empty, and
0.000000,0,0.000000,# the whole value is the table.
0.000009,6,0.000001,$table = $property;
0.000010,6,0.000002,$prefix = $property = "";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,print STDERR __LINE__, ": $property\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# Here it is the compound property=table form.  The property
0.000000,0,0.000000,# name is always loosely matched, and always can have an
0.000000,0,0.000000,# optional 'is' prefix (which isn't true in the single
0.000000,0,0.000000,# form).
0.000000,0,0.000000,$property = _loose_name($property) =~ s/^is//r;
0.000000,0,0.000000,
0.000000,0,0.000000,# And convert to canonical form.  Quit if not valid.
0.000000,0,0.000000,$property = $utf8::loose_property_name_of{$property};
0.000000,0,0.000000,if (! defined $property) {
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$prefix = "$property=";
0.000000,0,0.000000,
0.000000,0,0.000000,# If the rhs looks like it is a number...
0.000000,0,0.000000,print STDERR __LINE__, ": table=$table\n" if DEBUG;
0.000000,0,0.000000,if ($table =~ qr{ ^ [ \s 0-9 _  + / . -]+ $ }x) {
0.000000,0,0.000000,print STDERR __LINE__, ": table=$table\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# Don't allow leading nor trailing slashes 
0.000000,0,0.000000,if ($table =~ / ^ \/ | \/ $ /x) {
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Split on slash, in case it is a rational, like \p{1/5}
0.000000,0,0.000000,my @parts = split qr{ \s* / \s* }x, $table, -1;
0.000000,0,0.000000,print __LINE__, ": $type\n" if @parts > 2 && DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# Can have maximum of one slash
0.000000,0,0.000000,if (@parts > 2) {
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $part (@parts) {
0.000000,0,0.000000,print __LINE__, ": part=$part\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,$part =~ s/^\+\s*//;    # Remove leading plus
0.000000,0,0.000000,$part =~ s/^-\s*/-/;    # Remove blanks after unary
0.000000,0,0.000000,# minus
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove underscores between digits.
0.000000,0,0.000000,$part =~ s/(?<= [0-9] ) _ (?= [0-9] ) //xg;
0.000000,0,0.000000,
0.000000,0,0.000000,# No leading zeros (but don't make a single '0'
0.000000,0,0.000000,# into a null string)
0.000000,0,0.000000,$part =~ s/ ^ ( -? ) 0+ /$1/x;
0.000000,0,0.000000,$part .= '0' if $part eq '-' || $part eq "";
0.000000,0,0.000000,
0.000000,0,0.000000,# No trailing zeros after a decimal point
0.000000,0,0.000000,$part =~ s/ ( \. .*? ) 0+ $ /$1/x;
0.000000,0,0.000000,
0.000000,0,0.000000,# Begin with a 0 if a leading decimal point
0.000000,0,0.000000,$part =~ s/ ^ ( -? ) \. /${1}0./x;
0.000000,0,0.000000,
0.000000,0,0.000000,# Ensure not a trailing decimal point: turn into an
0.000000,0,0.000000,# integer
0.000000,0,0.000000,$part =~ s/ \. $ //x;
0.000000,0,0.000000,
0.000000,0,0.000000,print STDERR __LINE__, ": part=$part\n" if DEBUG;
0.000000,0,0.000000,#return $type if $part eq "";
0.000000,0,0.000000,
0.000000,0,0.000000,# Result better look like a number.  (This test is
0.000000,0,0.000000,# needed because, for example could have a plus in
0.000000,0,0.000000,# the middle.)
0.000000,0,0.000000,if ($part !~ / ^ -? [0-9]+ ( \. [0-9]+)? $ /x) {
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#  If a rational...
0.000000,0,0.000000,if (@parts == 2) {
0.000000,0,0.000000,
0.000000,0,0.000000,# If denominator is negative, get rid of it, and ...
0.000000,0,0.000000,if ($parts[1] =~ s/^-//) {
0.000000,0,0.000000,
0.000000,0,0.000000,# If numerator is also negative, convert the
0.000000,0,0.000000,# whole thing to positive, or move the minus to
0.000000,0,0.000000,# the numerator
0.000000,0,0.000000,if ($parts[0] !~ s/^-//) {
0.000000,0,0.000000,$parts[0] = '-' . $parts[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$table = join '/', @parts;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($property ne 'nv' || $parts[0] !~ /\./) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here is not numeric value, or doesn't have a
0.000000,0,0.000000,# decimal point.  No further manipulation is
0.000000,0,0.000000,# necessary.  (Note the hard-coded property name.
0.000000,0,0.000000,# This could fail if other properties eventually
0.000000,0,0.000000,# had fractions as well; perhaps the cjk ones
0.000000,0,0.000000,# could evolve to do that.  This hard-coding could
0.000000,0,0.000000,# be fixed by mktables generating a list of
0.000000,0,0.000000,# properties that could have fractions.)
0.000000,0,0.000000,$table = $parts[0];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here is a floating point numeric_value.  Try to
0.000000,0,0.000000,# convert to rational.  First see if is in the list
0.000000,0,0.000000,# of known ones.
0.000000,0,0.000000,if (exists $utf8::nv_floating_to_rational{$parts[0]}) {
0.000000,0,0.000000,$table = $utf8::nv_floating_to_rational{$parts[0]};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here not in the list.  See if is close
0.000000,0,0.000000,# enough to something in the list.  First
0.000000,0,0.000000,# determine what 'close enough' means.  It has
0.000000,0,0.000000,# to be as tight as what mktables says is the
0.000000,0,0.000000,# maximum slop, and as tight as how many
0.000000,0,0.000000,# digits we were passed.  That is, if the user
0.000000,0,0.000000,# said .667, .6667, .66667, etc.  we match as
0.000000,0,0.000000,# many digits as they passed until get to
0.000000,0,0.000000,# where it doesn't matter any more due to the
0.000000,0,0.000000,# machine's precision.  If they said .6666668,
0.000000,0,0.000000,# we fail.
0.000000,0,0.000000,(my $fraction = $parts[0]) =~ s/^.*\.//;
0.000000,0,0.000000,my $epsilon = 10 ** - (length($fraction));
0.000000,0,0.000000,if ($epsilon > $utf8::max_floating_slop) {
0.000000,0,0.000000,$epsilon = $utf8::max_floating_slop;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# But it can't be tighter than the minimum
0.000000,0,0.000000,# precision for this machine.  If haven't
0.000000,0,0.000000,# already calculated that minimum, do so now.
0.000000,0,0.000000,if (! defined $min_floating_slop) {
0.000000,0,0.000000,
0.000000,0,0.000000,# Keep going down an order of magnitude
0.000000,0,0.000000,# until find that adding this quantity to
0.000000,0,0.000000,# 1 remains 1; but put an upper limit on
0.000000,0,0.000000,# this so in case this algorithm doesn't
0.000000,0,0.000000,# work properly on some platform, that we
0.000000,0,0.000000,# won't loop forever.
0.000000,0,0.000000,my $count = 0;
0.000000,0,0.000000,$min_floating_slop = 1;
0.000000,0,0.000000,while (1+ $min_floating_slop != 1
0.000000,0,0.000000,&& $count++ < 50)
0.000000,0,0.000000,{
0.000000,0,0.000000,my $next = $min_floating_slop / 10;
0.000000,0,0.000000,last if $next == 0; # If underflows,
0.000000,0,0.000000,# use previous one
0.000000,0,0.000000,$min_floating_slop = $next;
0.000000,0,0.000000,print STDERR __LINE__, ": min_float_slop=$min_floating_slop\n" if DEBUG;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Back off a couple orders of magnitude,
0.000000,0,0.000000,# just to be safe.
0.000000,0,0.000000,$min_floating_slop *= 100;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($epsilon < $min_floating_slop) {
0.000000,0,0.000000,$epsilon = $min_floating_slop;
0.000000,0,0.000000,}
0.000000,0,0.000000,print STDERR __LINE__, ": fraction=.$fraction; epsilon=$epsilon\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,undef $table;
0.000000,0,0.000000,
0.000000,0,0.000000,# And for each possible rational in the table,
0.000000,0,0.000000,# see if it is within epsilon of the input.
0.000000,0,0.000000,foreach my $official
0.000000,0,0.000000,(keys %utf8::nv_floating_to_rational)
0.000000,0,0.000000,{
0.000000,0,0.000000,print STDERR __LINE__, ": epsilon=$epsilon, official=$official, diff=", abs($parts[0] - $official), "\n" if DEBUG;
0.000000,0,0.000000,if (abs($parts[0] - $official) < $epsilon) {
0.000000,0,0.000000,$table =
0.000000,0,0.000000,$utf8::nv_floating_to_rational{$official};
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Quit if didn't find one.
0.000000,0,0.000000,if (! defined $table) {
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,print STDERR __LINE__, ": $property=$table\n" if DEBUG;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Combine lhs (if any) and rhs to get something that matches
0.000000,0,0.000000,# the syntax of the lookups.
0.000010,6,0.000002,$property_and_table = "$prefix$table";
0.000000,0,0.000000,print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# First try stricter matching.
0.000012,6,0.000002,$file = $utf8::stricter_to_file_of{$property_and_table};
0.000000,0,0.000000,
0.000000,0,0.000000,# If didn't find it, try again with looser matching by editing
0.000000,0,0.000000,# out the applicable characters on the rhs and looking up
0.000000,0,0.000000,# again.
0.000011,6,0.000002,if (! defined $file) {
0.000011,2,0.000005,$table = _loose_name($table);
0.000003,2,0.000002,$property_and_table = "$prefix$table";
0.000000,0,0.000000,print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
0.000004,2,0.000002,$file = $utf8::loose_to_file_of{$property_and_table};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Add the constant and go fetch it in.
0.000009,6,0.000002,if (defined $file) {
0.000000,0,0.000000,
0.000000,0,0.000000,# A beginning ! means to invert.  The 0+ makes sure is
0.000000,0,0.000000,# numeric
0.000049,6,0.000008,$invert_it = 0 + $file =~ s/^!//;
0.000000,0,0.000000,
0.000010,6,0.000002,if ($utf8::why_deprecated{$file}) {
0.000000,0,0.000000,warnings::warnif('deprecated', "Use of '$type' in \\p{} or \\P{} is deprecated because: $utf8::why_deprecated{$file};");
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,6,0.000001,if ($caseless
0.000000,0,0.000000,&& exists $utf8::caseless_equivalent{$property_and_table})
0.000000,0,0.000000,{
0.000000,0,0.000000,$file = $utf8::caseless_equivalent{$property_and_table};
0.000000,0,0.000000,}
0.000012,6,0.000002,$file= "$unicore_dir/lib/$file.pl";
0.000016,6,0.000003,last GETFILE;
0.000000,0,0.000000,}
0.000000,0,0.000000,print STDERR __LINE__, ": didn't find $property_and_table\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## Last attempt -- see if it's a standard "To" name
0.000000,0,0.000000,## (e.g. "ToLower")  ToTitle is used by ucfirst().
0.000000,0,0.000000,## The user-level way to access ToDigit() and ToFold()
0.000000,0,0.000000,## is to use Unicode::UCD.
0.000000,0,0.000000,##
0.000000,0,0.000000,# Only check if caller wants non-binary
0.000000,0,0.000000,my $retried = 0;
0.000000,0,0.000000,if ($minbits != 1 && $property_and_table =~ s/^to//) {{
0.000000,0,0.000000,# Look input up in list of properties for which we have
0.000000,0,0.000000,# mapping files.
0.000000,0,0.000000,if (defined ($file =
0.000000,0,0.000000,$utf8::loose_property_to_file_of{$property_and_table}))
0.000000,0,0.000000,{
0.000000,0,0.000000,$type = $utf8::file_to_swash_name{$file};
0.000000,0,0.000000,print STDERR __LINE__, ": type set to $type\n" if DEBUG;
0.000000,0,0.000000,$file = "$unicore_dir/$file.pl";
0.000000,0,0.000000,last GETFILE;
0.000000,0,0.000000,}   # If that fails see if there is a corresponding binary
0.000000,0,0.000000,# property file
0.000000,0,0.000000,elsif (defined ($file =
0.000000,0,0.000000,$utf8::loose_to_file_of{$property_and_table}))
0.000000,0,0.000000,{
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, there is no map file for the property we are
0.000000,0,0.000000,# trying to get the map of, but this is a binary
0.000000,0,0.000000,# property, and there is a file for it that can easily
0.000000,0,0.000000,# be translated to a mapping.
0.000000,0,0.000000,
0.000000,0,0.000000,# In the case of properties that are forced to binary,
0.000000,0,0.000000,# they are a combination.  We return the actual
0.000000,0,0.000000,# mapping instead of the binary.  If the input is
0.000000,0,0.000000,# something like 'Tocjkkiicore', it will be found in
0.000000,0,0.000000,# %loose_property_to_file_of above as => 'To/kIICore'.
0.000000,0,0.000000,# But the form like ToIskiicore won't be.  To fix
0.000000,0,0.000000,# this, it was easiest to do it here.  These
0.000000,0,0.000000,# properties are the complements of the default
0.000000,0,0.000000,# property, so there is an entry in %loose_to_file_of
0.000000,0,0.000000,# that is 'iskiicore' => '!kIICore/N', If we find such
0.000000,0,0.000000,# an entry, strip off things and try again, which
0.000000,0,0.000000,# should find the entry in %loose_property_to_file_of.
0.000000,0,0.000000,# Actual binary properties that are of this form, such
0.000000,0,0.000000,# as this entry: 'ishrkt' => '!Perl/Any' will also be
0.000000,0,0.000000,# retried, but won't be in %loose_property_to_file_of,
0.000000,0,0.000000,# and instead the next time through, it will find
0.000000,0,0.000000,# 'hrkt' => '!Perl/Any' and proceed.
0.000000,0,0.000000,redo if ! $retried
0.000000,0,0.000000,&& $file =~ /^!/
0.000000,0,0.000000,&& $property_and_table =~ s/^is//;
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a binary property.  Setting this here causes
0.000000,0,0.000000,# it to be stored as such in the cache, so if someone
0.000000,0,0.000000,# comes along later looking for just a binary, they
0.000000,0,0.000000,# get it.
0.000000,0,0.000000,$minbits = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# The 0+ makes sure is numeric
0.000000,0,0.000000,$invert_it = 0 + $file =~ s/^!//;
0.000000,0,0.000000,$file = "$unicore_dir/lib/$file.pl";
0.000000,0,0.000000,last GETFILE;
0.000000,0,0.000000,}
0.000000,0,0.000000,} }
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## If we reach this line, it's because we couldn't figure
0.000000,0,0.000000,## out what to do with $type. Ouch.
0.000000,0,0.000000,##
0.000000,0,0.000000,
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $type;
0.000000,0,0.000000,} # end of GETFILE block
0.000000,0,0.000000,
0.000019,6,0.000003,if (defined $file) {
0.000000,0,0.000000,print STDERR __LINE__, ": found it (file='$file')\n" if DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## If we reach here, it was due to a 'last GETFILE' above
0.000000,0,0.000000,## (exception: user-defined properties and mappings), so we
0.000000,0,0.000000,## have a filename, so now we load it if we haven't already.
0.000000,0,0.000000,## If we have, return the cached results. The cache key is the
0.000000,0,0.000000,## class and file to load, and whether the results need to be
0.000000,0,0.000000,## inverted.
0.000000,0,0.000000,##
0.000016,6,0.000003,my $found = $Cache{$class, $file, $invert_it};
0.000008,6,0.000001,if ($found and ref($found) eq $class) {
0.000000,0,0.000000,print STDERR __LINE__, ": Returning cached swash for '$class,$file,$invert_it' for \\p{$type}\n" if DEBUG;
0.000000,0,0.000000,pop @recursed if @recursed;
0.000000,0,0.000000,return $found;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,6,0.000002,local $@;
0.000016,6,0.000003,local $!;
0.001703,12,0.000142,$list = do $file; die $@ if $@;
0.000016,6,0.000003,$list_is_from_mktables = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,} # End of $type is non-null
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, either $type was null, or we found the requested property and
0.000000,0,0.000000,# read it into $list
0.000000,0,0.000000,
0.000009,6,0.000002,my $extras = "";
0.000000,0,0.000000,
0.000008,6,0.000001,my $bits = $minbits;
0.000000,0,0.000000,
0.000000,0,0.000000,# mktables lists don't have extras, like '&utf8::prop', so don't need
0.000000,0,0.000000,# to separate them; also lists are already sorted, so don't need to do
0.000000,0,0.000000,# that.
0.000009,6,0.000002,if ($list && ! $list_is_from_mktables) {
0.000000,0,0.000000,my $taint = substr($list,0,0); # maintain taint
0.000000,0,0.000000,
0.000000,0,0.000000,# Separate the extras from the code point list, and make sure
0.000000,0,0.000000,# user-defined properties and tr/// are well-behaved for
0.000000,0,0.000000,# downstream code.
0.000000,0,0.000000,if ($user_defined || $none) {
0.000000,0,0.000000,my @tmp = split(/^/m, $list);
0.000000,0,0.000000,my %seen;
0.000849,2,0.000424,no warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,# The extras are anything that doesn't begin with a hex digit.
0.000000,0,0.000000,$extras = join '', $taint, grep /^[^0-9a-fA-F]/, @tmp;
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove the extras, and sort the remaining entries by the
0.000000,0,0.000000,# numeric value of their beginning hex digits, removing any
0.000000,0,0.000000,# duplicates.
0.000000,0,0.000000,$list = join '', $taint,
0.000000,0,0.000000,map  { $_->[1] }
0.000000,0,0.000000,sort { $a->[0] <=> $b->[0] }
0.000000,0,0.000000,map  { /^([0-9a-fA-F]+)/; [ CORE::hex($1), $_ ] }
0.000000,0,0.000000,grep { /^([0-9a-fA-F]+)/ and not $seen{$1}++ } @tmp; # XXX doesn't do ranges right
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# mktables has gone to some trouble to make non-user defined
0.000000,0,0.000000,# properties well-behaved, so we can skip the effort we do for
0.000000,0,0.000000,# user-defined ones.  Any extras are at the very beginning of
0.000000,0,0.000000,# the string.
0.000000,0,0.000000,
0.000000,0,0.000000,# This regex splits out the first lines of $list into $1 and
0.000000,0,0.000000,# strips them off from $list, until we get one that begins
0.000000,0,0.000000,# with a hex number, alone on the line, or followed by a tab.
0.000000,0,0.000000,# Either portion may be empty.
0.000000,0,0.000000,$list =~ s/ \A ( .*? )
0.000000,0,0.000000,(?: \z | (?= ^ [0-9a-fA-F]+ (?: \t | $) ) )
0.000000,0,0.000000,//msx;
0.000000,0,0.000000,
0.000000,0,0.000000,$extras = "$taint$1";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,6,0.000001,if ($none) {
0.000000,0,0.000000,my $hextra = sprintf "%04x", $none + 1;
0.000000,0,0.000000,$list =~ s/\tXXXX$/\t$hextra/mg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,6,0.000001,if ($minbits != 1 && $minbits < 32) { # not binary property
0.000000,0,0.000000,my $top = 0;
0.000000,0,0.000000,while ($list =~ /^([0-9a-fA-F]+)(?:[\t]([0-9a-fA-F]+)?)(?:[ \t]([0-9a-fA-F]+))?/mg) {
0.000000,0,0.000000,my $min = CORE::hex $1;
0.000000,0,0.000000,my $max = defined $2 ? CORE::hex $2 : $min;
0.000000,0,0.000000,my $val = defined $3 ? CORE::hex $3 : 0;
0.000000,0,0.000000,$val += $max - $min if defined $3;
0.000000,0,0.000000,$top = $val if $val > $top;
0.000000,0,0.000000,}
0.000000,0,0.000000,my $topbits =
0.000000,0,0.000000,$top > 0xffff ? 32 :
0.000000,0,0.000000,$top > 0xff ? 16 : 8;
0.000000,0,0.000000,$bits = $topbits if $bits < $topbits;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,6,0.000001,my @extras;
0.000008,6,0.000001,if ($extras) {
0.000000,0,0.000000,for my $x ($extras) {
0.000000,0,0.000000,my $taint = substr($x,0,0); # maintain taint
0.000000,0,0.000000,pos $x = 0;
0.000000,0,0.000000,while ($x =~ /^([^0-9a-fA-F\n])(.*)/mg) {
0.000000,0,0.000000,my $char = "$1$taint";
0.000000,0,0.000000,my $name = "$2$taint";
0.000000,0,0.000000,print STDERR __LINE__, ": char [$char] => name [$name]\n"
0.000000,0,0.000000,if DEBUG;
0.000000,0,0.000000,if ($char =~ /[-+!&]/) {
0.000000,0,0.000000,my ($c,$t) = split(/::/, $name, 2);	# bogus use of ::, really
0.000000,0,0.000000,my $subobj;
0.000000,0,0.000000,if ($c eq 'utf8') {
0.000000,0,0.000000,$subobj = utf8->SWASHNEW($t, "", $minbits, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (exists &$name) {
0.000000,0,0.000000,$subobj = utf8->SWASHNEW($name, "", $minbits, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($c =~ /^([0-9a-fA-F]+)/) {
0.000000,0,0.000000,$subobj = utf8->SWASHNEW("", $c, $minbits, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,print STDERR __LINE__, ": returned from getting sub object for $name\n" if DEBUG;
0.000000,0,0.000000,if (! ref $subobj) {
0.000000,0,0.000000,pop @recursed if @recursed && $type;
0.000000,0,0.000000,return $subobj;
0.000000,0,0.000000,}
0.000000,0,0.000000,push @extras, $name => $subobj;
0.000000,0,0.000000,$bits = $subobj->{BITS} if $bits < $subobj->{BITS};
0.000000,0,0.000000,$user_defined = $subobj->{USER_DEFINED}
0.000000,0,0.000000,if $subobj->{USER_DEFINED};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (DEBUG) {
0.000000,0,0.000000,print STDERR __LINE__, ": CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none, INVERT_IT => $invert_it, USER_DEFINED => $user_defined";
0.000000,0,0.000000,print STDERR "\nLIST =>\n$list" if defined $list;
0.000000,0,0.000000,print STDERR "\nEXTRAS =>\n$extras" if defined $extras;
0.000000,0,0.000000,print STDERR "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000037,6,0.000006,my $SWASH = bless {
0.000000,0,0.000000,TYPE => $type,
0.000000,0,0.000000,BITS => $bits,
0.000000,0,0.000000,EXTRAS => $extras,
0.000000,0,0.000000,LIST => $list,
0.000000,0,0.000000,NONE => $none,
0.000000,0,0.000000,USER_DEFINED => $user_defined,
0.000000,0,0.000000,@extras,
0.000000,0,0.000000,} => $class;
0.000000,0,0.000000,
0.000017,6,0.000003,if ($file) {
0.000016,6,0.000003,$Cache{$class, $file, $invert_it} = $SWASH;
0.000010,6,0.000002,if ($type
0.000000,0,0.000000,&& exists $utf8::SwashInfo{$type}
0.000000,0,0.000000,&& exists $utf8::SwashInfo{$type}{'specials_name'})
0.000000,0,0.000000,{
0.000000,0,0.000000,my $specials_name = $utf8::SwashInfo{$type}{'specials_name'};
0.000177,2,0.000088,no strict "refs";
0.000000,0,0.000000,print STDERR "\nspecials_name => $specials_name\n" if DEBUG;
0.000000,0,0.000000,$SWASH->{'SPECIALS'} = \%$specials_name;
0.000000,0,0.000000,}
0.000017,6,0.000003,$SWASH->{'INVERT_IT'} = $invert_it;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000011,6,0.000002,pop @recursed if @recursed && $type;
0.000000,0,0.000000,
0.000044,6,0.000007,return $SWASH;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now SWASHGET is recasted into a C function S_swatch_get (see utf8.c).
0.000000,0,0.000000,
0.000004,1,0.000004,1;
