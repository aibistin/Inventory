# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Eval::Closure;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Eval::Closure::AUTHORITY = 'cpan:DOY';
0.000030,1,0.000030,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Eval::Closure::VERSION = '0.10';
0.000000,0,0.000000,}
0.000031,2,0.000015,use strict;
0.001391,2,0.000695,use warnings;
0.000000,0,0.000000,# ABSTRACT: safely and cleanly create closures via string eval
0.000000,0,0.000000,
0.000067,2,0.000033,use Exporter 'import';
0.000003,1,0.000003,@Eval::Closure::EXPORT = @Eval::Closure::EXPORT_OK = 'eval_closure';
0.000000,0,0.000000,
0.000034,2,0.000017,use Carp;
0.000031,2,0.000016,use overload ();
0.000079,2,0.000039,use Scalar::Util qw(reftype);
0.000041,2,0.000021,use Try::Tiny;
0.000000,0,0.000000,
0.000915,2,0.000458,use constant HAS_LEXICAL_SUBS => $] >= 5.018;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub eval_closure {
0.000489,164,0.000003,my (%args) = @_;
0.000000,0,0.000000,
0.000912,164,0.000006,$args{source} = _canonicalize_source($args{source});
0.000852,164,0.000005,_validate_env($args{environment} ||= {});
0.000000,0,0.000000,
0.000375,164,0.000002,$args{source} = _line_directive(@args{qw(line description)})
0.000000,0,0.000000,. $args{source}
0.000000,0,0.000000,if defined $args{description} && !($^P & 0x10);
0.000000,0,0.000000,
0.000980,164,0.000006,my ($code, $e) = _clean_eval_closure(@args{qw(source environment)});
0.000000,0,0.000000,
0.000239,164,0.000001,if (!$code) {
0.000000,0,0.000000,if ($args{terse_error}) {
0.000000,0,0.000000,die "$e\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak("Failed to compile source: $e\n\nsource:\n$args{source}")
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000920,164,0.000006,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _canonicalize_source {
0.000253,164,0.000002,my ($source) = @_;
0.000000,0,0.000000,
0.000250,164,0.000002,if (defined($source)) {
0.000262,164,0.000002,if (ref($source)) {
0.001880,140,0.000013,if (reftype($source) eq 'ARRAY'
0.000000,0,0.000000,|| overload::Method($source, '@{}')) {
0.000000,0,0.000000,return join "\n", @$source;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (overload::Method($source, '""')) {
0.000000,0,0.000000,return "$source";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak("The 'source' parameter to eval_closure must be a "
0.000000,0,0.000000,. "string or array reference");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000131,24,0.000005,return $source;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak("The 'source' parameter to eval_closure is required");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _validate_env {
0.000260,164,0.000002,my ($env) = @_;
0.000000,0,0.000000,
0.001065,164,0.000006,croak("The 'environment' parameter must be a hashref")
0.000000,0,0.000000,unless reftype($env) eq 'HASH';
0.000000,0,0.000000,
0.001200,164,0.000007,for my $var (keys %$env) {
0.000194,70,0.000003,if (HAS_LEXICAL_SUBS) {
0.000525,70,0.000007,croak("Environment key '$var' should start with \@, \%, \$, or \&")
0.000000,0,0.000000,unless $var =~ /^([\@\%\$\&])/;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak("Environment key '$var' should start with \@, \%, or \$")
0.000000,0,0.000000,unless $var =~ /^([\@\%\$])/;
0.000000,0,0.000000,}
0.000252,70,0.000004,croak("Environment values must be references, not $env->{$var}")
0.000000,0,0.000000,unless ref($env->{$var});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _line_directive {
0.000000,0,0.000000,my ($line, $description) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$line = 1 unless defined($line);
0.000000,0,0.000000,
0.000000,0,0.000000,return qq{#line $line "$description"\n};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clean_eval_closure {
0.000335,164,0.000002,my ($source, $captures) = @_;
0.000000,0,0.000000,
0.001171,164,0.000007,my @capture_keys = sort keys %$captures;
0.000000,0,0.000000,
0.000300,164,0.000002,if ($ENV{EVAL_CLOSURE_PRINT_SOURCE}) {
0.000000,0,0.000000,_dump_source(_make_compiler_source($source, @capture_keys));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000990,164,0.000006,my ($compiler, $e) = _make_compiler($source, @capture_keys);
0.000238,164,0.000001,my $code;
0.001014,164,0.000006,if (defined $compiler) {
0.000000,0,0.000000,$code = $compiler->(@$captures{@capture_keys});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000359,164,0.000002,if (defined($code) && (!ref($code) || ref($code) ne 'CODE')) {
0.000000,0,0.000000,$e = "The 'source' parameter must return a subroutine reference, "
0.000000,0,0.000000,. "not $code";
0.000000,0,0.000000,undef $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000943,164,0.000006,return ($code, $e);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_compiler {
0.000878,164,0.000005,my $source = _make_compiler_source(@_);
0.000000,0,0.000000,
0.001536,164,0.000009,return @{ _clean_eval($source) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clean_eval {
0.000247,164,0.000002,local $@;
0.000507,164,0.000003,local $SIG{__DIE__};
0.034381,164,0.000210,my $compiler = eval $_[0];
0.000254,164,0.000002,my $e = $@;
0.001316,164,0.000008,[ $compiler, $e ];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,$Eval::Closure::SANDBOX_ID = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_compiler_source {
0.000310,164,0.000002,my ($source, @capture_keys) = @_;
0.000234,164,0.000001,$Eval::Closure::SANDBOX_ID++;
0.000240,164,0.000001,my $i = 0;
0.000377,70,0.000005,return join "\n", (
0.000000,0,0.000000,"package Eval::Closure::Sandbox_$Eval::Closure::SANDBOX_ID;",
0.000000,0,0.000000,'sub {',
0.001296,164,0.000008,(map { _make_lexical_assignment($_, $i++) } @capture_keys),
0.000000,0,0.000000,$source,
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_lexical_assignment {
0.000110,70,0.000002,my ($key, $index) = @_;
0.000130,70,0.000002,my $sigil = substr($key, 0, 1);
0.000116,70,0.000002,my $name = substr($key, 1);
0.000114,70,0.000002,if (HAS_LEXICAL_SUBS && $sigil eq '&') {
0.000000,0,0.000000,my $tmpname = '$__' . $name . '__' . $index;
0.000000,0,0.000000,return 'use feature "lexical_subs"; '
0.000000,0,0.000000,. 'no warnings "experimental::lexical_subs"; '
0.000000,0,0.000000,. 'my ' . $tmpname . ' = $_[' . $index . ']; '
0.000000,0,0.000000,. 'my sub ' . $name . ' { goto ' . $tmpname . ' }';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000462,70,0.000007,return 'my ' . $key . ' = ' . $sigil . '{$_[' . $index . ']};';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _dump_source {
0.000000,0,0.000000,my ($source) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $output;
0.000000,0,0.000000,if (try { require Perl::Tidy }) {
0.000000,0,0.000000,Perl::Tidy::perltidy(
0.000000,0,0.000000,source      => \$source,
0.000000,0,0.000000,destination => \$output,
0.000000,0,0.000000,argv        => [],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$output = $source;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,warn "$output\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000005,1,0.000005,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
