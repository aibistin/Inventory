# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Meta::Role;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Moose::Meta::Role::AUTHORITY = 'cpan:STEVAN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Moose::Meta::Role::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000017,use strict;
0.000032,2,0.000016,use warnings;
0.000039,2,0.000019,use metaclass;
0.000000,0,0.000000,
0.000036,2,0.000018,use Class::Load qw(load_class);
0.000035,2,0.000018,use Scalar::Util 'blessed';
0.000036,2,0.000018,use Carp         'confess';
0.000042,2,0.000021,use Devel::GlobalDestruction 'in_global_destruction';
0.000000,0,0.000000,
0.000034,2,0.000017,use Moose::Meta::Class;
0.000145,2,0.000072,use Moose::Meta::Role::Attribute;
0.000148,2,0.000074,use Moose::Meta::Role::Method;
0.000115,2,0.000057,use Moose::Meta::Role::Method::Required;
0.000123,2,0.000061,use Moose::Meta::Role::Method::Conflicting;
0.000300,2,0.000150,use Moose::Meta::Method::Meta;
0.000037,2,0.000018,use Moose::Util qw( ensure_all_roles );
0.000036,2,0.000018,use Class::MOP::MiniTrait;
0.000000,0,0.000000,
0.000010,1,0.000010,use base 'Class::MOP::Module',
0.000000,0,0.000000,'Class::MOP::Mixin::HasAttributes',
0.002668,1,0.002668,'Class::MOP::Mixin::HasMethods';
0.000000,0,0.000000,
0.000006,1,0.000006,Class::MOP::MiniTrait::apply(__PACKAGE__, 'Moose::Meta::Object::Trait');
0.000000,0,0.000000,
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,## NOTE:
0.000000,0,0.000000,## I normally don't do this, but I am doing
0.000000,0,0.000000,## a whole bunch of meta-programmin' in this
0.000000,0,0.000000,## module, so it just makes sense. For a clearer
0.000000,0,0.000000,## picture of what is going on in the next
0.000000,0,0.000000,## several lines of code, look at the really
0.000000,0,0.000000,## big comment at the end of this file (right
0.000000,0,0.000000,## before the POD).
0.000000,0,0.000000,## - SL
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,
0.000006,1,0.000006,my $META = __PACKAGE__->meta;
0.000000,0,0.000000,
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,## attributes ...
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# since roles are lazy, we hold all the attributes
0.000000,0,0.000000,# of the individual role in 'stasis' until which
0.000000,0,0.000000,# time when it is applied to a class. This means
0.000000,0,0.000000,# keeping a lot of things in hash maps, so we are
0.000000,0,0.000000,# using a little of that meta-programmin' magic
0.000000,0,0.000000,# here and saving lots of extra typin'. And since
0.000000,0,0.000000,# many of these attributes above require similar
0.000000,0,0.000000,# functionality to support them, so we again use
0.000000,0,0.000000,# the wonders of meta-programmin' to deliver a
0.000000,0,0.000000,# very compact solution to this normally verbose
0.000000,0,0.000000,# problem.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,
0.000010,1,0.000010,foreach my $action (
0.000000,0,0.000000,{
0.000000,0,0.000000,name        => 'excluded_roles_map',
0.000000,0,0.000000,attr_reader => 'get_excluded_roles_map' ,
0.000000,0,0.000000,methods     => {
0.000000,0,0.000000,add       => 'add_excluded_roles',
0.000000,0,0.000000,get_keys  => 'get_excluded_roles_list',
0.000000,0,0.000000,existence => 'excludes_role',
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,{
0.000000,0,0.000000,name        => 'required_methods',
0.000000,0,0.000000,attr_reader => 'get_required_methods_map',
0.000000,0,0.000000,methods     => {
0.000000,0,0.000000,remove     => 'remove_required_methods',
0.000000,0,0.000000,get_values => 'get_required_method_list',
0.000000,0,0.000000,existence  => 'requires_method',
0.000000,0,0.000000,}
0.000000,0,0.000000,},
0.000000,0,0.000000,) {
0.000000,0,0.000000,
0.000004,2,0.000002,my $attr_reader = $action->{attr_reader};
0.000003,2,0.000002,my $methods     = $action->{methods};
0.000000,0,0.000000,
0.000000,0,0.000000,# create the attribute
0.000000,0,0.000000,$META->add_attribute($action->{name} => (
0.000000,0,0.000000,reader  => $attr_reader,
0.000000,0,0.000000,default => sub { {} },
0.000022,2,0.000011,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,# create some helper methods
0.000000,0,0.000000,$META->add_method($methods->{add} => sub {
0.000000,0,0.000000,my ($self, @values) = @_;
0.000000,0,0.000000,$self->$attr_reader->{$_} = undef foreach @values;
0.000009,2,0.000005,}) if exists $methods->{add};
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method($methods->{get_keys} => sub {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,keys %{$self->$attr_reader};
0.000009,2,0.000004,}) if exists $methods->{get_keys};
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method($methods->{get_values} => sub {
0.000000,0,0.000000,my ($self) = @_;
0.000000,0,0.000000,values %{$self->$attr_reader};
0.000009,2,0.000004,}) if exists $methods->{get_values};
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method($methods->{get} => sub {
0.000000,0,0.000000,my ($self, $name) = @_;
0.000000,0,0.000000,$self->$attr_reader->{$name}
0.000003,2,0.000002,}) if exists $methods->{get};
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method($methods->{existence} => sub {
0.000000,0,0.000000,my ($self, $name) = @_;
0.000000,0,0.000000,exists $self->$attr_reader->{$name} ? 1 : 0;
0.000014,2,0.000007,}) if exists $methods->{existence};
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method($methods->{remove} => sub {
0.000000,0,0.000000,my ($self, @values) = @_;
0.000000,0,0.000000,delete $self->$attr_reader->{$_} foreach @values;
0.000013,2,0.000006,}) if exists $methods->{remove};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_attribute(
0.000009,1,0.000009,'method_metaclass',
0.000000,0,0.000000,reader  => 'method_metaclass',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Method',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000009,1,0.000009,$META->add_attribute(
0.000000,0,0.000000,'required_method_metaclass',
0.000000,0,0.000000,reader  => 'required_method_metaclass',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Method::Required',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000009,1,0.000009,$META->add_attribute(
0.000000,0,0.000000,'conflicting_method_metaclass',
0.000000,0,0.000000,reader  => 'conflicting_method_metaclass',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Method::Conflicting',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000009,1,0.000009,$META->add_attribute(
0.000000,0,0.000000,'application_to_class_class',
0.000000,0,0.000000,reader  => 'application_to_class_class',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Application::ToClass',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000009,1,0.000009,$META->add_attribute(
0.000000,0,0.000000,'application_to_role_class',
0.000000,0,0.000000,reader  => 'application_to_role_class',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Application::ToRole',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000009,1,0.000009,$META->add_attribute(
0.000000,0,0.000000,'application_to_instance_class',
0.000000,0,0.000000,reader  => 'application_to_instance_class',
0.000000,0,0.000000,default => 'Moose::Meta::Role::Application::ToInstance',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000009,1,0.000009,$META->add_attribute(
0.000000,0,0.000000,'applied_attribute_metaclass',
0.000000,0,0.000000,reader  => 'applied_attribute_metaclass',
0.000000,0,0.000000,default => 'Moose::Meta::Attribute',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# More or less copied from Moose::Meta::Class
0.000000,0,0.000000,sub initialize {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my @args = @_;
0.000000,0,0.000000,unshift @args, 'package' if @args % 2;
0.000000,0,0.000000,my %opts = @args;
0.000000,0,0.000000,my $package = delete $opts{package};
0.000000,0,0.000000,return Class::MOP::get_metaclass_by_name($package)
0.000000,0,0.000000,|| $class->SUPER::initialize($package,
0.000000,0,0.000000,'attribute_metaclass' => 'Moose::Meta::Role::Attribute',
0.000000,0,0.000000,%opts,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinitialize {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $pkg  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = blessed $pkg ? $pkg : Class::MOP::class_of($pkg);
0.000000,0,0.000000,
0.000000,0,0.000000,my %existing_classes;
0.000000,0,0.000000,if ($meta) {
0.000000,0,0.000000,%existing_classes = map { $_ => $meta->$_() } qw(
0.000000,0,0.000000,attribute_metaclass
0.000000,0,0.000000,method_metaclass
0.000000,0,0.000000,wrapped_method_metaclass
0.000000,0,0.000000,required_method_metaclass
0.000000,0,0.000000,conflicting_method_metaclass
0.000000,0,0.000000,application_to_class_class
0.000000,0,0.000000,application_to_role_class
0.000000,0,0.000000,application_to_instance_class
0.000000,0,0.000000,applied_attribute_metaclass
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,$options{weaken} = Class::MOP::metaclass_is_weak($meta->name)
0.000000,0,0.000000,if !exists $options{weaken}
0.000000,0,0.000000,&& blessed($meta)
0.000000,0,0.000000,&& $meta->isa('Moose::Meta::Role');
0.000000,0,0.000000,
0.000000,0,0.000000,# don't need to remove generated metaobjects here yet, since we don't
0.000000,0,0.000000,# yet generate anything in roles. this may change in the future though...
0.000000,0,0.000000,# keep an eye on that
0.000000,0,0.000000,my $new_meta = $self->SUPER::reinitialize(
0.000000,0,0.000000,$pkg,
0.000000,0,0.000000,%existing_classes,
0.000000,0,0.000000,%options,
0.000000,0,0.000000,);
0.000000,0,0.000000,$new_meta->_restore_metaobjects_from($meta)
0.000000,0,0.000000,if $meta && $meta->isa('Moose::Meta::Role');
0.000000,0,0.000000,return $new_meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _restore_metaobjects_from {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($old_meta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_restore_metamethods_from($old_meta);
0.000000,0,0.000000,$self->_restore_metaattributes_from($old_meta);
0.000000,0,0.000000,
0.000000,0,0.000000,for my $role ( @{ $old_meta->get_roles } ) {
0.000000,0,0.000000,$self->add_role($role);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_attribute {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if (blessed $_[0] && ! $_[0]->isa('Moose::Meta::Role::Attribute') ) {
0.000000,0,0.000000,my $class = ref $_[0];
0.000000,0,0.000000,Moose->throw_error( "Cannot add a $class as an attribute to a role" );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (!blessed($_[0]) && defined($_[0]) && $_[0] =~ /^\+(.*)/) {
0.000000,0,0.000000,Moose->throw_error( "has '+attr' is not supported in roles" );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->SUPER::add_attribute(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _attach_attribute {
0.000000,0,0.000000,my ( $self, $attribute ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$attribute->attach_to_role($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_required_methods {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,for (@_) {
0.000000,0,0.000000,my $method = $_;
0.000000,0,0.000000,if (!blessed($method)) {
0.000000,0,0.000000,$method = $self->required_method_metaclass->new(
0.000000,0,0.000000,name => $method,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,$self->get_required_methods_map->{$method->name} = $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_conflicting_method {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $method;
0.000000,0,0.000000,if (@_ == 1 && blessed($_[0])) {
0.000000,0,0.000000,$method = shift;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$method = $self->conflicting_method_metaclass->new(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->add_required_methods($method);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,## method modifiers
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# the before/around/after method modifiers are
0.000000,0,0.000000,# stored by name, but there can be many methods
0.000000,0,0.000000,# then associated with that name. So again we have
0.000000,0,0.000000,# lots of similar functionality, so we can do some
0.000000,0,0.000000,# meta-programmin' and save some time.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,
0.000003,1,0.000003,foreach my $modifier_type (qw[ before around after ]) {
0.000000,0,0.000000,
0.000007,3,0.000002,my $attr_reader = "get_${modifier_type}_method_modifiers_map";
0.000000,0,0.000000,
0.000000,0,0.000000,# create the attribute ...
0.000000,0,0.000000,$META->add_attribute("${modifier_type}_method_modifiers" => (
0.000000,0,0.000000,reader  => $attr_reader,
0.000000,0,0.000000,default => sub { {} },
0.000031,3,0.000010,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,# and some helper methods ...
0.000000,0,0.000000,$META->add_method("get_${modifier_type}_method_modifiers" => sub {
0.000000,0,0.000000,my ($self, $method_name) = @_;
0.000000,0,0.000000,#return () unless exists $self->$attr_reader->{$method_name};
0.000000,0,0.000000,my $mm = $self->$attr_reader->{$method_name};
0.000000,0,0.000000,$mm ? @$mm : ();
0.000022,3,0.000007,});
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method("has_${modifier_type}_method_modifiers" => sub {
0.000000,0,0.000000,my ($self, $method_name) = @_;
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# for now we assume that if it exists,..
0.000000,0,0.000000,# it has at least one modifier in it
0.000000,0,0.000000,(exists $self->$attr_reader->{$method_name}) ? 1 : 0;
0.000031,3,0.000010,});
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_method("add_${modifier_type}_method_modifier" => sub {
0.000000,0,0.000000,my ($self, $method_name, $method) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->$attr_reader->{$method_name} = []
0.000000,0,0.000000,unless exists $self->$attr_reader->{$method_name};
0.000000,0,0.000000,
0.000000,0,0.000000,my $modifiers = $self->$attr_reader->{$method_name};
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# check to see that we aren't adding the
0.000000,0,0.000000,# same code twice. We err in favor of the
0.000000,0,0.000000,# first on here, this may not be as expected
0.000000,0,0.000000,foreach my $modifier (@{$modifiers}) {
0.000000,0,0.000000,return if $modifier == $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @{$modifiers} => $method;
0.000028,3,0.000009,});
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,## override method modifiers
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_attribute('override_method_modifiers' => (
0.000000,0,0.000000,reader  => 'get_override_method_modifiers_map',
0.000000,0,0.000000,default => sub { {} },
0.000010,1,0.000010,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# these are a little different because there
0.000000,0,0.000000,# can only be one per name, whereas the other
0.000000,0,0.000000,# method modifiers can have multiples.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_override_method_modifier {
0.000000,0,0.000000,my ($self, $method_name, $method) = @_;
0.000000,0,0.000000,(!$self->has_method($method_name))
0.000000,0,0.000000,|| Moose->throw_error("Cannot add an override of method '$method_name' " .
0.000000,0,0.000000,"because there is a local version of '$method_name'");
0.000000,0,0.000000,$self->get_override_method_modifiers_map->{$method_name} = $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub has_override_method_modifier {
0.000000,0,0.000000,my ($self, $method_name) = @_;
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# for now we assume that if it exists,..
0.000000,0,0.000000,# it has at least one modifier in it
0.000000,0,0.000000,(exists $self->get_override_method_modifiers_map->{$method_name}) ? 1 : 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_override_method_modifier {
0.000000,0,0.000000,my ($self, $method_name) = @_;
0.000000,0,0.000000,$self->get_override_method_modifiers_map->{$method_name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## general list accessor ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_method_modifier_list {
0.000000,0,0.000000,my ($self, $modifier_type) = @_;
0.000000,0,0.000000,my $accessor = "get_${modifier_type}_method_modifiers_map";
0.000000,0,0.000000,keys %{$self->$accessor};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _meta_method_class { 'Moose::Meta::Method::Meta' }
0.000000,0,0.000000,
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,## subroles
0.000000,0,0.000000,
0.000000,0,0.000000,$META->add_attribute('roles' => (
0.000000,0,0.000000,reader  => 'get_roles',
0.000000,0,0.000000,default => sub { [] },
0.000011,1,0.000011,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_role {
0.000000,0,0.000000,my ($self, $role) = @_;
0.000000,0,0.000000,(blessed($role) && $role->isa('Moose::Meta::Role'))
0.000000,0,0.000000,|| Moose->throw_error("Roles must be instances of Moose::Meta::Role");
0.000000,0,0.000000,push @{$self->get_roles} => $role;
0.000000,0,0.000000,$self->reset_package_cache_flag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub calculate_all_roles {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,grep {
0.000000,0,0.000000,!$seen{$_->name}++
0.000000,0,0.000000,} ($self, map {
0.000000,0,0.000000,$_->calculate_all_roles
0.000000,0,0.000000,} @{ $self->get_roles });
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub does_role {
0.000000,0,0.000000,my ($self, $role) = @_;
0.000000,0,0.000000,(defined $role)
0.000000,0,0.000000,|| Moose->throw_error("You must supply a role name to look for");
0.000000,0,0.000000,my $role_name = blessed $role ? $role->name : $role;
0.000000,0,0.000000,# if we are it,.. then return true
0.000000,0,0.000000,return 1 if $role_name eq $self->name;
0.000000,0,0.000000,# otherwise.. check our children
0.000000,0,0.000000,foreach my $role (@{$self->get_roles}) {
0.000000,0,0.000000,return 1 if $role->does_role($role_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_method_by_name { (shift)->get_method(@_) }
0.000000,0,0.000000,
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,## role construction
0.000000,0,0.000000,## ------------------------------------------------------------------
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply {
0.000000,0,0.000000,my ($self, $other, %args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,(blessed($other))
0.000000,0,0.000000,|| Moose->throw_error("You must pass in an blessed instance");
0.000000,0,0.000000,
0.000000,0,0.000000,my $application_class;
0.000000,0,0.000000,if ($other->isa('Moose::Meta::Role')) {
0.000000,0,0.000000,$application_class = $self->application_to_role_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($other->isa('Moose::Meta::Class')) {
0.000000,0,0.000000,$application_class = $self->application_to_class_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$application_class = $self->application_to_instance_class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,load_class($application_class);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( exists $args{'-excludes'} ) {
0.000000,0,0.000000,# I wish we had coercion here :)
0.000000,0,0.000000,$args{'-excludes'} = (
0.000000,0,0.000000,ref $args{'-excludes'} eq 'ARRAY'
0.000000,0,0.000000,? $args{'-excludes'}
0.000000,0,0.000000,: [ $args{'-excludes'} ]
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $application_class->new(%args)->apply($self, $other, \%args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub composition_class_roles { }
0.000000,0,0.000000,
0.000000,0,0.000000,sub combine {
0.000000,0,0.000000,my ($class, @role_specs) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,require Moose::Meta::Role::Composite;
0.000000,0,0.000000,
0.000000,0,0.000000,my (@roles, %role_params);
0.000000,0,0.000000,while (@role_specs) {
0.000000,0,0.000000,my ($role, $params) = @{ splice @role_specs, 0, 1 };
0.000000,0,0.000000,my $requested_role
0.000000,0,0.000000,= blessed $role
0.000000,0,0.000000,? $role
0.000000,0,0.000000,: Class::MOP::class_of($role);
0.000000,0,0.000000,
0.000000,0,0.000000,my $actual_role = $requested_role->_role_for_combination($params);
0.000000,0,0.000000,push @roles => $actual_role;
0.000000,0,0.000000,
0.000000,0,0.000000,next unless defined $params;
0.000000,0,0.000000,$role_params{$actual_role->name} = $params;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $c = Moose::Meta::Role::Composite->new(roles => \@roles);
0.000000,0,0.000000,return $c->apply_params(\%role_params);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _role_for_combination {
0.000000,0,0.000000,my ($self, $params) = @_;
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub create {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my @args = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,unshift @args, 'package' if @args % 2 == 1;
0.000000,0,0.000000,my %options = @args;
0.000000,0,0.000000,
0.000000,0,0.000000,(ref $options{attributes} eq 'HASH')
0.000000,0,0.000000,|| confess "You must pass a HASH ref of attributes"
0.000000,0,0.000000,if exists $options{attributes};
0.000000,0,0.000000,
0.000000,0,0.000000,(ref $options{methods} eq 'HASH')
0.000000,0,0.000000,|| confess "You must pass a HASH ref of methods"
0.000000,0,0.000000,if exists $options{methods};
0.000000,0,0.000000,
0.000000,0,0.000000,(ref $options{roles} eq 'ARRAY')
0.000000,0,0.000000,|| confess "You must pass an ARRAY ref of roles"
0.000000,0,0.000000,if exists $options{roles};
0.000000,0,0.000000,
0.000000,0,0.000000,my $package      = delete $options{package};
0.000000,0,0.000000,my $roles        = delete $options{roles};
0.000000,0,0.000000,my $attributes   = delete $options{attributes};
0.000000,0,0.000000,my $methods      = delete $options{methods};
0.000000,0,0.000000,my $meta_name    = exists $options{meta_name}
0.000000,0,0.000000,? delete $options{meta_name}
0.000000,0,0.000000,: 'meta';
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta = $class->SUPER::create($package => %options);
0.000000,0,0.000000,
0.000000,0,0.000000,$meta->_add_meta_method($meta_name)
0.000000,0,0.000000,if defined $meta_name;
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $attributes) {
0.000000,0,0.000000,foreach my $attribute_name (keys %{$attributes}) {
0.000000,0,0.000000,my $attr = $attributes->{$attribute_name};
0.000000,0,0.000000,$meta->add_attribute(
0.000000,0,0.000000,$attribute_name => blessed $attr ? $attr : %{$attr} );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (defined $methods) {
0.000000,0,0.000000,foreach my $method_name (keys %{$methods}) {
0.000000,0,0.000000,$meta->add_method($method_name, $methods->{$method_name});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($roles) {
0.000000,0,0.000000,Moose::Util::apply_all_roles($meta, @$roles);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub consumers {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my @consumers;
0.000000,0,0.000000,for my $meta (Class::MOP::get_all_metaclass_instances) {
0.000000,0,0.000000,next if $meta->name eq $self->name;
0.000000,0,0.000000,next unless $meta->isa('Moose::Meta::Class')
0.000000,0,0.000000,|| $meta->isa('Moose::Meta::Role');
0.000000,0,0.000000,push @consumers, $meta->name
0.000000,0,0.000000,if $meta->does_role($self->name);
0.000000,0,0.000000,}
0.000000,0,0.000000,return @consumers;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: something more intelligent here?
0.000000,0,0.000000,sub _anon_package_prefix { 'Moose::Meta::Role::__ANON__::SERIAL::' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_anon_role { shift->create_anon(@_) }
0.000000,0,0.000000,sub is_anon_role     { shift->is_anon(@_)     }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _anon_cache_key {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX fix this duplication (see MMC::_anon_cache_key
0.000000,0,0.000000,my $roles = Data::OptList::mkopt(($options{roles} || []), {
0.000000,0,0.000000,moniker  => 'role',
0.000000,0,0.000000,val_test => sub { ref($_[0]) eq 'HASH' },
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,my @role_keys;
0.000000,0,0.000000,for my $role_spec (@$roles) {
0.000000,0,0.000000,my ($role, $params) = @$role_spec;
0.000000,0,0.000000,$params = { %$params };
0.000000,0,0.000000,
0.000000,0,0.000000,my $key = blessed($role) ? $role->name : $role;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($params && %$params) {
0.000000,0,0.000000,my $alias    = delete $params->{'-alias'}
0.000000,0,0.000000,|| delete $params->{'alias'}
0.000000,0,0.000000,|| {};
0.000000,0,0.000000,my $excludes = delete $params->{'-excludes'}
0.000000,0,0.000000,|| delete $params->{'excludes'}
0.000000,0,0.000000,|| [];
0.000000,0,0.000000,$excludes = [$excludes] unless ref($excludes) eq 'ARRAY';
0.000000,0,0.000000,
0.000000,0,0.000000,if (%$params) {
0.000000,0,0.000000,warn "Roles with parameters cannot be cached. Consider "
0.000000,0,0.000000,. "applying the parameters before calling "
0.000000,0,0.000000,. "create_anon_class, or using 'weaken => 0' instead";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $alias_key = join('%',
0.000000,0,0.000000,map { $_ => $alias->{$_} } sort keys %$alias
0.000000,0,0.000000,);
0.000000,0,0.000000,my $excludes_key = join('%',
0.000000,0,0.000000,sort @$excludes
0.000000,0,0.000000,);
0.000000,0,0.000000,$key .= '<' . join('+', 'a', $alias_key, 'e', $excludes_key) . '>';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,push @role_keys, $key;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Makes something like Role|Role::1
0.000000,0,0.000000,return join('|', sort @role_keys);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,## NOTE:
0.000000,0,0.000000,## This is Moose::Meta::Role as defined by Moose (plus the use of
0.000000,0,0.000000,## MooseX::AttributeHelpers module). It is here as a reference to
0.000000,0,0.000000,## make it easier to see what is happening above with all the meta
0.000000,0,0.000000,## programming. - SL
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'roles' => (
0.000000,0,0.000000,#     metaclass => 'Array',
0.000000,0,0.000000,#     reader    => 'get_roles',
0.000000,0,0.000000,#     isa       => 'ArrayRef[Moose::Meta::Role]',
0.000000,0,0.000000,#     default   => sub { [] },
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         'push' => 'add_role',
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'excluded_roles_map' => (
0.000000,0,0.000000,#     metaclass => 'Hash',
0.000000,0,0.000000,#     reader    => 'get_excluded_roles_map',
0.000000,0,0.000000,#     isa       => 'HashRef[Str]',
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         # Not exactly set, cause it sets multiple
0.000000,0,0.000000,#         'set'    => 'add_excluded_roles',
0.000000,0,0.000000,#         'keys'   => 'get_excluded_roles_list',
0.000000,0,0.000000,#         'exists' => 'excludes_role',
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'required_methods' => (
0.000000,0,0.000000,#     metaclass => 'Hash',
0.000000,0,0.000000,#     reader    => 'get_required_methods_map',
0.000000,0,0.000000,#     isa       => 'HashRef[Moose::Meta::Role::Method::Required]',
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         # not exactly set, or delete since it works for multiple
0.000000,0,0.000000,#         'set'    => 'add_required_methods',
0.000000,0,0.000000,#         'delete' => 'remove_required_methods',
0.000000,0,0.000000,#         'keys'   => 'get_required_method_list',
0.000000,0,0.000000,#         'exists' => 'requires_method',
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,# # the before, around and after modifiers are
0.000000,0,0.000000,# # HASH keyed by method-name, with ARRAY of
0.000000,0,0.000000,# # CODE refs to apply in that order
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'before_method_modifiers' => (
0.000000,0,0.000000,#     metaclass => 'Hash',
0.000000,0,0.000000,#     reader    => 'get_before_method_modifiers_map',
0.000000,0,0.000000,#     isa       => 'HashRef[ArrayRef[CodeRef]]',
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         'keys'   => 'get_before_method_modifiers',
0.000000,0,0.000000,#         'exists' => 'has_before_method_modifiers',
0.000000,0,0.000000,#         # This actually makes sure there is an
0.000000,0,0.000000,#         # ARRAY at the given key, and pushed onto
0.000000,0,0.000000,#         # it. It also checks for duplicates as well
0.000000,0,0.000000,#         # 'add'  => 'add_before_method_modifier'
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'after_method_modifiers' => (
0.000000,0,0.000000,#     metaclass => 'Hash',
0.000000,0,0.000000,#     reader    =>'get_after_method_modifiers_map',
0.000000,0,0.000000,#     isa       => 'HashRef[ArrayRef[CodeRef]]',
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         'keys'   => 'get_after_method_modifiers',
0.000000,0,0.000000,#         'exists' => 'has_after_method_modifiers',
0.000000,0,0.000000,#         # This actually makes sure there is an
0.000000,0,0.000000,#         # ARRAY at the given key, and pushed onto
0.000000,0,0.000000,#         # it. It also checks for duplicates as well
0.000000,0,0.000000,#         # 'add'  => 'add_after_method_modifier'
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'around_method_modifiers' => (
0.000000,0,0.000000,#     metaclass => 'Hash',
0.000000,0,0.000000,#     reader    =>'get_around_method_modifiers_map',
0.000000,0,0.000000,#     isa       => 'HashRef[ArrayRef[CodeRef]]',
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         'keys'   => 'get_around_method_modifiers',
0.000000,0,0.000000,#         'exists' => 'has_around_method_modifiers',
0.000000,0,0.000000,#         # This actually makes sure there is an
0.000000,0,0.000000,#         # ARRAY at the given key, and pushed onto
0.000000,0,0.000000,#         # it. It also checks for duplicates as well
0.000000,0,0.000000,#         # 'add'  => 'add_around_method_modifier'
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,# # override is similar to the other modifiers
0.000000,0,0.000000,# # except that it is not an ARRAY of code refs
0.000000,0,0.000000,# # but instead just a single name->code mapping
0.000000,0,0.000000,#
0.000000,0,0.000000,# has 'override_method_modifiers' => (
0.000000,0,0.000000,#     metaclass => 'Hash',
0.000000,0,0.000000,#     reader    =>'get_override_method_modifiers_map',
0.000000,0,0.000000,#     isa       => 'HashRef[CodeRef]',
0.000000,0,0.000000,#     provides  => {
0.000000,0,0.000000,#         'keys'   => 'get_override_method_modifier',
0.000000,0,0.000000,#         'exists' => 'has_override_method_modifier',
0.000000,0,0.000000,#         'add'    => 'add_override_method_modifier', # checks for local method ..
0.000000,0,0.000000,#     }
0.000000,0,0.000000,# );
0.000000,0,0.000000,#
0.000000,0,0.000000,#####################################################################
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000033,1,0.000033,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: The Moose Role metaclass
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
