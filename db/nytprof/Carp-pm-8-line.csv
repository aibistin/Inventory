# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Carp;
0.000000,0,0.000000,
0.000058,3,0.000019,{ use 5.006; }
0.000030,2,0.000015,use strict;
0.000038,2,0.000019,use warnings;
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000087,2,0.000043,no strict "refs";
0.000010,1,0.000010,if(exists($::{"utf8::"}) && exists(*{$::{"utf8::"}}{HASH}->{"is_utf8"}) &&
0.000000,0,0.000000,defined(*{*{$::{"utf8::"}}{HASH}->{"is_utf8"}}{CODE})) {
0.000000,0,0.000000,*is_utf8 = \&{"utf8::is_utf8"};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*is_utf8 = sub { 0 };
0.000000,0,0.000000,}
0.000029,1,0.000029,}
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000081,2,0.000040,no strict "refs";
0.000009,1,0.000009,if(exists($::{"utf8::"}) && exists(*{$::{"utf8::"}}{HASH}->{"downgrade"}) &&
0.000000,0,0.000000,defined(*{*{$::{"utf8::"}}{HASH}->{"downgrade"}}{CODE})) {
0.000000,0,0.000000,*downgrade = \&{"utf8::downgrade"};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*downgrade = sub {};
0.000000,0,0.000000,}
0.000180,1,0.000180,}
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '1.26';
0.000000,0,0.000000,
0.000002,1,0.000002,our $MaxEvalLen = 0;
0.000001,1,0.000001,our $Verbose    = 0;
0.000001,1,0.000001,our $CarpLevel  = 0;
0.000001,1,0.000001,our $MaxArgLen  = 64;    # How much of each argument to print. 0 = all.
0.000001,1,0.000001,our $MaxArgNums = 8;     # How many arguments to print. 0 = all.
0.000000,0,0.000000,
0.000676,1,0.000676,require Exporter;
0.000009,1,0.000009,our @ISA       = ('Exporter');
0.000002,1,0.000002,our @EXPORT    = qw(confess croak carp);
0.000002,1,0.000002,our @EXPORT_OK = qw(cluck verbose longmess shortmess);
0.000002,1,0.000002,our @EXPORT_FAIL = qw(verbose);    # hook to enable verbose mode
0.000000,0,0.000000,
0.000000,0,0.000000,# The members of %Internal are packages that are internal to perl.
0.000000,0,0.000000,# Carp will not report errors from within these packages if it
0.000000,0,0.000000,# can.  The members of %CarpInternal are internal to Perl's warning
0.000000,0,0.000000,# system.  Carp will not report errors from within these packages
0.000000,0,0.000000,# either, and will not report calls *to* these packages for carp and
0.000000,0,0.000000,# croak.  They replace $CarpLevel, which is deprecated.    The
0.000000,0,0.000000,# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
0.000000,0,0.000000,# text and function arguments should be formatted when printed.
0.000000,0,0.000000,
0.000002,1,0.000002,our %CarpInternal;
0.000001,1,0.000001,our %Internal;
0.000000,0,0.000000,
0.000000,0,0.000000,# disable these by default, so they can live w/o require Carp
0.000002,1,0.000002,$CarpInternal{Carp}++;
0.000002,1,0.000002,$CarpInternal{warnings}++;
0.000002,1,0.000002,$Internal{Exporter}++;
0.000002,1,0.000002,$Internal{'Exporter::Heavy'}++;
0.000000,0,0.000000,
0.000000,0,0.000000,# if the caller specifies verbose usage ("perl -MCarp=verbose script.pl")
0.000000,0,0.000000,# then the following method will be called by the Exporter which knows
0.000000,0,0.000000,# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word
0.000000,0,0.000000,# 'verbose'.
0.000000,0,0.000000,
0.000000,0,0.000000,sub export_fail { shift; $Verbose = shift if $_[0] eq 'verbose'; @_ }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _cgc {
0.000329,2,0.000164,no strict 'refs';
0.000045,13,0.000003,return \&{"CORE::GLOBAL::caller"} if defined &{"CORE::GLOBAL::caller"};
0.000062,13,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub longmess {
0.000000,0,0.000000,# Icky backwards compatibility wrapper. :-(
0.000000,0,0.000000,#
0.000000,0,0.000000,# The story is that the original implementation hard-coded the
0.000000,0,0.000000,# number of call levels to go back, so calls to longmess were off
0.000000,0,0.000000,# by one.  Other code began calling longmess and expecting this
0.000000,0,0.000000,# behaviour, so the replacement has to emulate that behaviour.
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,my $call_pack = $cgc ? $cgc->() : caller();
0.000000,0,0.000000,if ( $Internal{$call_pack} or $CarpInternal{$call_pack} ) {
0.000000,0,0.000000,return longmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,local $CarpLevel = $CarpLevel + 1;
0.000000,0,0.000000,return longmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000001,1,0.000001,our @CARP_NOT;
0.000000,0,0.000000,
0.000000,0,0.000000,sub shortmess {
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,
0.000000,0,0.000000,# Icky backwards compatibility wrapper. :-(
0.000000,0,0.000000,local @CARP_NOT = $cgc ? $cgc->() : caller();
0.000000,0,0.000000,shortmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak   { die shortmess @_ }
0.000000,0,0.000000,sub confess { die longmess @_ }
0.000000,0,0.000000,sub carp    { warn shortmess @_ }
0.000000,0,0.000000,sub cluck   { warn longmess @_ }
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000016,1,0.000016,if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015) ||
0.000000,0,0.000000,("$]" >= 5.012005 && "$]" < 5.013)) {
0.000000,0,0.000000,*CALLER_OVERRIDE_CHECK_OK = sub () { 1 };
0.000000,0,0.000000,} else {
0.000000,0,0.000000,*CALLER_OVERRIDE_CHECK_OK = sub () { 0 };
0.000000,0,0.000000,}
0.001392,1,0.001392,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub caller_info {
0.000000,0,0.000000,my $i = shift(@_) + 1;
0.000000,0,0.000000,my %call_info;
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,{
0.000000,0,0.000000,# Some things override caller() but forget to implement the
0.000000,0,0.000000,# @DB::args part of it, which we need.  We check for this by
0.000000,0,0.000000,# pre-populating @DB::args with a sentinel which no-one else
0.000000,0,0.000000,# has the address of, so that we can detect whether @DB::args
0.000000,0,0.000000,# has been properly populated.  However, on earlier versions
0.000000,0,0.000000,# of perl this check tickles a bug in CORE::caller() which
0.000000,0,0.000000,# leaks memory.  So we only check on fixed perls.
0.000000,0,0.000000,@DB::args = \$i if CALLER_OVERRIDE_CHECK_OK;
0.000000,0,0.000000,package DB;
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( defined $call_info{pack} ) {
0.000000,0,0.000000,return ();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub_name = Carp::get_subname( \%call_info );
0.000000,0,0.000000,if ( $call_info{has_args} ) {
0.000000,0,0.000000,my @args;
0.000000,0,0.000000,if (CALLER_OVERRIDE_CHECK_OK && @DB::args == 1
0.000000,0,0.000000,&& ref $DB::args[0] eq ref \$i
0.000000,0,0.000000,&& $DB::args[0] == \$i ) {
0.000000,0,0.000000,@DB::args = ();    # Don't let anyone see the address of $i
0.000000,0,0.000000,local $@;
0.000000,0,0.000000,my $where = eval {
0.000000,0,0.000000,my $func    = $cgc or return '';
0.000000,0,0.000000,my $gv      =
0.000000,0,0.000000,*{
0.000000,0,0.000000,( $::{"B::"} || return '')       # B stash
0.000000,0,0.000000,->{svref_2object} || return '' # entry in stash
0.000000,0,0.000000,}{CODE}                             # coderef in entry
0.000000,0,0.000000,->($func)->GV;
0.000000,0,0.000000,my $package = $gv->STASH->NAME;
0.000000,0,0.000000,my $subname = $gv->NAME;
0.000000,0,0.000000,return unless defined $package && defined $subname;
0.000000,0,0.000000,
0.000000,0,0.000000,# returning CORE::GLOBAL::caller isn't useful for tracing the cause:
0.000000,0,0.000000,return if $package eq 'CORE::GLOBAL' && $subname eq 'caller';
0.000000,0,0.000000," in &${package}::$subname";
0.000000,0,0.000000,} || '';
0.000000,0,0.000000,@args
0.000000,0,0.000000,= "** Incomplete caller override detected$where; \@DB::args were not set **";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,@args = map { Carp::format_arg($_) } @DB::args;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( $MaxArgNums and @args > $MaxArgNums )
0.000000,0,0.000000,{    # More than we want to show?
0.000000,0,0.000000,$#args = $MaxArgNums;
0.000000,0,0.000000,push @args, '...';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Push the args onto the subroutine
0.000000,0,0.000000,$sub_name .= '(' . join( ', ', @args ) . ')';
0.000000,0,0.000000,}
0.000000,0,0.000000,$call_info{sub_name} = $sub_name;
0.000000,0,0.000000,return wantarray() ? %call_info : \%call_info;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Transform an argument to a function into a string.
0.000000,0,0.000000,sub format_arg {
0.000000,0,0.000000,my $arg = shift;
0.000000,0,0.000000,if ( ref($arg) ) {
0.000000,0,0.000000,$arg = defined($overload::VERSION) ? overload::StrVal($arg) : "$arg";
0.000000,0,0.000000,}
0.000000,0,0.000000,if ( defined($arg) ) {
0.000000,0,0.000000,$arg =~ s/'/\\'/g;
0.000000,0,0.000000,$arg = str_len_trim( $arg, $MaxArgLen );
0.000000,0,0.000000,
0.000000,0,0.000000,# Quote it?
0.000000,0,0.000000,# Downgrade, and use [0-9] rather than \d, to avoid loading
0.000000,0,0.000000,# Unicode tables, which would be liable to fail if we're
0.000000,0,0.000000,# processing a syntax error.
0.000000,0,0.000000,downgrade($arg, 1);
0.000000,0,0.000000,$arg = "'$arg'" unless $arg =~ /^-?[0-9.]+\z/;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$arg = 'undef';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# The following handling of "control chars" is direct from
0.000000,0,0.000000,# the original code - it is broken on Unicode though.
0.000000,0,0.000000,# Suggestions?
0.000000,0,0.000000,is_utf8($arg)
0.000000,0,0.000000,or $arg =~ s/([[:cntrl:]]|[[:^ascii:]])/sprintf("\\x{%x}",ord($1))/eg;
0.000000,0,0.000000,return $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes an inheritance cache and a package and returns
0.000000,0,0.000000,# an anon hash of known inheritances and anon array of
0.000000,0,0.000000,# inheritances which consequences have not been figured
0.000000,0,0.000000,# for.
0.000000,0,0.000000,sub get_status {
0.000028,20,0.000001,my $cache = shift;
0.000029,20,0.000001,my $pkg   = shift;
0.000115,20,0.000006,$cache->{$pkg} ||= [ { $pkg => $pkg }, [ trusts_directly($pkg) ] ];
0.000101,20,0.000005,return @{ $cache->{$pkg} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes the info from caller() and figures out the name of
0.000000,0,0.000000,# the sub/require/eval
0.000000,0,0.000000,sub get_subname {
0.000000,0,0.000000,my $info = shift;
0.000000,0,0.000000,if ( defined( $info->{evaltext} ) ) {
0.000000,0,0.000000,my $eval = $info->{evaltext};
0.000000,0,0.000000,if ( $info->{is_require} ) {
0.000000,0,0.000000,return "require $eval";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$eval =~ s/([\\\'])/\\$1/g;
0.000000,0,0.000000,return "eval '" . str_len_trim( $eval, $MaxEvalLen ) . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return ( $info->{sub} eq '(eval)' ) ? 'eval {...}' : $info->{sub};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Figures out what call (from the point of view of the caller)
0.000000,0,0.000000,# the long error backtrace should start at.
0.000000,0,0.000000,sub long_error_loc {
0.000000,0,0.000000,my $i;
0.000000,0,0.000000,my $lvl = $CarpLevel;
0.000000,0,0.000000,{
0.000000,0,0.000000,++$i;
0.000000,0,0.000000,my $cgc = _cgc();
0.000000,0,0.000000,my $pkg = $cgc ? $cgc->($i) : caller($i);
0.000000,0,0.000000,unless ( defined($pkg) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# This *shouldn't* happen.
0.000000,0,0.000000,if (%Internal) {
0.000000,0,0.000000,local %Internal;
0.000000,0,0.000000,$i = long_error_loc();
0.000000,0,0.000000,last;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# OK, now I am irritated.
0.000000,0,0.000000,return 2;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,redo if $CarpInternal{$pkg};
0.000000,0,0.000000,redo unless 0 > --$lvl;
0.000000,0,0.000000,redo if $Internal{$pkg};
0.000000,0,0.000000,}
0.000000,0,0.000000,return $i - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub longmess_heavy {
0.000000,0,0.000000,return @_ if ref( $_[0] );    # don't break references as exceptions
0.000000,0,0.000000,my $i = long_error_loc();
0.000000,0,0.000000,return ret_backtrace( $i, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns a full stack backtrace starting from where it is
0.000000,0,0.000000,# told.
0.000000,0,0.000000,sub ret_backtrace {
0.000000,0,0.000000,my ( $i, @error ) = @_;
0.000000,0,0.000000,my $mess;
0.000000,0,0.000000,my $err = join '', @error;
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tid_msg = '';
0.000000,0,0.000000,if ( defined &threads::tid ) {
0.000000,0,0.000000,my $tid = threads->tid;
0.000000,0,0.000000,$tid_msg = " thread $tid" if $tid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %i = caller_info($i);
0.000000,0,0.000000,$mess = "$err at $i{file} line $i{line}$tid_msg";
0.000000,0,0.000000,if( defined $. ) {
0.000000,0,0.000000,local $@ = '';
0.000000,0,0.000000,local $SIG{__DIE__};
0.000000,0,0.000000,eval {
0.000000,0,0.000000,CORE::die;
0.000000,0,0.000000,};
0.000000,0,0.000000,if($@ =~ /^Died at .*(, <.*?> line \d+).$/ ) {
0.000000,0,0.000000,$mess .= $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$mess .= "\.\n";
0.000000,0,0.000000,
0.000000,0,0.000000,while ( my %i = caller_info( ++$i ) ) {
0.000000,0,0.000000,$mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $mess;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub ret_summary {
0.000000,0,0.000000,my ( $i, @error ) = @_;
0.000000,0,0.000000,my $err = join '', @error;
0.000000,0,0.000000,$i++;
0.000000,0,0.000000,
0.000000,0,0.000000,my $tid_msg = '';
0.000000,0,0.000000,if ( defined &threads::tid ) {
0.000000,0,0.000000,my $tid = threads->tid;
0.000000,0,0.000000,$tid_msg = " thread $tid" if $tid;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %i = caller_info($i);
0.000000,0,0.000000,return "$err at $i{file} line $i{line}$tid_msg\.\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub short_error_loc {
0.000000,0,0.000000,# You have to create your (hash)ref out here, rather than defaulting it
0.000000,0,0.000000,# inside trusts *on a lexical*, as you want it to persist across calls.
0.000000,0,0.000000,# (You can default it on $_[2], but that gets messy)
0.000010,5,0.000002,my $cache = {};
0.000007,5,0.000001,my $i     = 1;
0.000008,5,0.000002,my $lvl   = $CarpLevel;
0.000000,0,0.000000,{
0.000080,18,0.000004,my $cgc = _cgc();
0.000024,13,0.000002,my $called = $cgc ? $cgc->($i) : caller($i);
0.000018,13,0.000001,$i++;
0.000020,13,0.000002,my $caller = $cgc ? $cgc->($i) : caller($i);
0.000000,0,0.000000,
0.000018,13,0.000001,return 0 unless defined($caller);    # What happened?
0.000022,13,0.000002,redo if $Internal{$caller};
0.000017,11,0.000002,redo if $CarpInternal{$caller};
0.000018,11,0.000002,redo if $CarpInternal{$called};
0.000038,7,0.000005,redo if trusts( $called, $caller, $cache );
0.000037,7,0.000005,redo if trusts( $caller, $called, $cache );
0.000010,5,0.000002,redo unless 0 > --$lvl;
0.000000,0,0.000000,}
0.000037,5,0.000007,return $i - 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub shortmess_heavy {
0.000000,0,0.000000,return longmess_heavy(@_) if $Verbose;
0.000000,0,0.000000,return @_ if ref( $_[0] );    # don't break references as exceptions
0.000000,0,0.000000,my $i = short_error_loc();
0.000000,0,0.000000,if ($i) {
0.000000,0,0.000000,ret_summary( $i, @_ );
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,longmess_heavy(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# If a string is too long, trims it with ...
0.000000,0,0.000000,sub str_len_trim {
0.000000,0,0.000000,my $str = shift;
0.000000,0,0.000000,my $max = shift || 0;
0.000000,0,0.000000,if ( 2 < $max and $max < length($str) ) {
0.000000,0,0.000000,substr( $str, $max - 3 ) = '...';
0.000000,0,0.000000,}
0.000000,0,0.000000,return $str;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes two packages and an optional cache.  Says whether the
0.000000,0,0.000000,# first inherits from the second.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Recursive versions of this have to work to avoid certain
0.000000,0,0.000000,# possible endless loops, and when following long chains of
0.000000,0,0.000000,# inheritance are less efficient.
0.000000,0,0.000000,sub trusts {
0.000028,14,0.000002,my $child  = shift;
0.000020,14,0.000001,my $parent = shift;
0.000020,14,0.000001,my $cache  = shift;
0.000071,14,0.000005,my ( $known, $partial ) = get_status( $cache, $child );
0.000000,0,0.000000,
0.000000,0,0.000000,# Figure out consequences until we have an answer
0.000044,14,0.000003,while ( @$partial and not exists $known->{$parent} ) {
0.000010,6,0.000002,my $anc = shift @$partial;
0.000010,6,0.000002,next if exists $known->{$anc};
0.000011,6,0.000002,$known->{$anc}++;
0.000032,6,0.000005,my ( $anc_knows, $anc_partial ) = get_status( $cache, $anc );
0.000016,6,0.000003,my @found = keys %$anc_knows;
0.000011,6,0.000002,@$known{@found} = ();
0.000021,6,0.000003,push @$partial, @$anc_partial;
0.000000,0,0.000000,}
0.000075,14,0.000005,return exists $known->{$parent};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Takes a package and gives a list of those trusted directly
0.000000,0,0.000000,sub trusts_directly {
0.000023,16,0.000001,my $class = shift;
0.000034,2,0.000017,no strict 'refs';
0.000079,2,0.000039,no warnings 'once';
0.000000,0,0.000000,return @{"$class\::CARP_NOT"}
0.000000,0,0.000000,? @{"$class\::CARP_NOT"}
0.000157,16,0.000010,: @{"$class\::ISA"};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,if(!defined($warnings::VERSION) ||
0.000051,3,0.000017,do { no warnings "numeric"; $warnings::VERSION < 1.03 }) {
0.000000,0,0.000000,# Very old versions of warnings.pm import from Carp.  This can go
0.000000,0,0.000000,# wrong due to the circular dependency.  If Carp is invoked before
0.000000,0,0.000000,# warnings, then Carp starts by loading warnings, then warnings
0.000000,0,0.000000,# tries to import from Carp, and gets nothing because Carp is in
0.000000,0,0.000000,# the process of loading and hasn't defined its import method yet.
0.000000,0,0.000000,# So we work around that by manually exporting to warnings here.
0.000070,2,0.000035,no strict "refs";
0.000000,0,0.000000,*{"warnings::$_"} = \&$_ foreach @EXPORT;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,1,0.000010,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
