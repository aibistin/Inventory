# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,package Log::Log4perl::Config;
0.000000,0,0.000000,##################################################
0.000060,2,0.000030,use 5.006;
0.000032,2,0.000016,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000034,2,0.000017,use Log::Log4perl::Logger;
0.000035,2,0.000017,use Log::Log4perl::Level;
0.000117,2,0.000058,use Log::Log4perl::Config::PropertyConfigurator;
0.000113,2,0.000057,use Log::Log4perl::JavaMap;
0.000107,2,0.000054,use Log::Log4perl::Filter;
0.000105,2,0.000053,use Log::Log4perl::Filter::Boolean;
0.000113,2,0.000056,use Log::Log4perl::Config::Watch;
0.000000,0,0.000000,
0.004018,2,0.002009,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000002,1,0.000002,our $CONFIG_FILE_READS       = 0;
0.000001,1,0.000001,our $CONFIG_INTEGRITY_CHECK  = 1;
0.000002,1,0.000002,our $CONFIG_INTEGRITY_ERROR  = undef;
0.000000,0,0.000000,
0.000001,1,0.000001,our $WATCHER;
0.000001,1,0.000001,our $DEFAULT_WATCH_DELAY = 60; # seconds
0.000002,1,0.000002,our $OPTS = {};
0.000001,1,0.000001,our $OLD_CONFIG;
0.000001,1,0.000001,our $LOGGERS_DEFINED;
0.000001,1,0.000001,our $UTF8 = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub init {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,Log::Log4perl::Logger->reset();
0.000000,0,0.000000,
0.000000,0,0.000000,undef $WATCHER; # just in case there's a one left over (e.g. test cases)
0.000000,0,0.000000,
0.000000,0,0.000000,return _init(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub utf8 {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my( $class, $flag ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$UTF8 = $flag if defined $flag;
0.000000,0,0.000000,
0.000000,0,0.000000,return $UTF8;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub watcher {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,return $WATCHER;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub init_and_watch {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my ($class, $config, $delay, $opts) = @_;
0.000000,0,0.000000,# delay can be a signal name - in this case we're gonna
0.000000,0,0.000000,# set up a signal handler.
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $WATCHER) {
0.000000,0,0.000000,$config = $WATCHER->file();
0.000000,0,0.000000,if(defined $Log::Log4perl::Config::Watch::SIGNAL_CAUGHT) {
0.000000,0,0.000000,$delay  = $WATCHER->signal();
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$delay  = $WATCHER->check_interval();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print "init_and_watch ($config-$delay). Resetting.\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,Log::Log4perl::Logger->reset();
0.000000,0,0.000000,
0.000000,0,0.000000,defined ($delay) or $delay = $DEFAULT_WATCH_DELAY;  
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $config) {
0.000000,0,0.000000,die "Log4perl can only watch a file, not a string of " .
0.000000,0,0.000000,"configuration information";
0.000000,0,0.000000,}elsif ($config =~ m!^(https?|ftp|wais|gopher|file):!){
0.000000,0,0.000000,die "Log4perl can only watch a file, not a url like $config";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if($delay =~ /\D/) {
0.000000,0,0.000000,$WATCHER = Log::Log4perl::Config::Watch->new(
0.000000,0,0.000000,file         => $config,
0.000000,0,0.000000,signal       => $delay,
0.000000,0,0.000000,l4p_internal => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$WATCHER = Log::Log4perl::Config::Watch->new(
0.000000,0,0.000000,file           => $config,
0.000000,0,0.000000,check_interval => $delay,
0.000000,0,0.000000,l4p_internal   => 1,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $opts) {
0.000000,0,0.000000,die "Parameter $opts needs to be a hash ref" if ref($opts) ne "HASH";
0.000000,0,0.000000,$OPTS = $opts;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,eval { _init($class, $config); };
0.000000,0,0.000000,
0.000000,0,0.000000,if($@) {
0.000000,0,0.000000,die "$@" unless defined $OLD_CONFIG;
0.000000,0,0.000000,# Call _init with a pre-parsed config to go back to old setting
0.000000,0,0.000000,_init($class, undef, $OLD_CONFIG);
0.000000,0,0.000000,warn "Loading new config failed, reverted to old one\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub _init {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($class, $config, $data) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my %additivity = ();
0.000000,0,0.000000,
0.000000,0,0.000000,$LOGGERS_DEFINED = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,print "Calling _init\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,#keep track so we don't create the same one twice
0.000000,0,0.000000,my %appenders_created = ();
0.000000,0,0.000000,
0.000000,0,0.000000,#some appenders need to run certain subroutines right at the
0.000000,0,0.000000,#end of the configuration phase, when all settings are in place.
0.000000,0,0.000000,my @post_config_subs  = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# This logic is probably suited to win an obfuscated programming
0.000000,0,0.000000,# contest. It desperately needs to be rewritten.
0.000000,0,0.000000,# Basically, it works like this:
0.000000,0,0.000000,# config_read() reads the entire config file into a hash of hashes:
0.000000,0,0.000000,#     log4j.logger.foo.bar.baz: WARN, A1
0.000000,0,0.000000,# gets transformed into
0.000000,0,0.000000,#     $data->{log4j}->{logger}->{foo}->{bar}->{baz} = "WARN, A1";
0.000000,0,0.000000,# The code below creates the necessary loggers, sets the appenders
0.000000,0,0.000000,# and the layouts etc.
0.000000,0,0.000000,# In order to transform parts of this tree back into identifiers
0.000000,0,0.000000,# (like "foo.bar.baz"), we're using the leaf_paths functions below.
0.000000,0,0.000000,# Pretty scary. But it allows the lines of the config file to be
0.000000,0,0.000000,# in *arbitrary* order.
0.000000,0,0.000000,
0.000000,0,0.000000,$data = config_read($config) unless defined $data;
0.000000,0,0.000000,
0.000000,0,0.000000,if(_INTERNAL_DEBUG) {
0.000000,0,0.000000,require Data::Dumper;
0.000000,0,0.000000,Data::Dumper->import();
0.000000,0,0.000000,print Data::Dumper::Dumper($data);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @loggers      = ();
0.000000,0,0.000000,my %filter_names = ();
0.000000,0,0.000000,
0.000000,0,0.000000,my $system_wide_threshold;
0.000000,0,0.000000,
0.000000,0,0.000000,# Autocorrect the rootlogger/rootLogger typo
0.000000,0,0.000000,if(exists $data->{rootlogger} and 
0.000000,0,0.000000,! exists $data->{rootLogger}) {
0.000000,0,0.000000,$data->{rootLogger} = $data->{rootlogger};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Find all logger definitions in the conf file. Start
0.000000,0,0.000000,# with root loggers.
0.000000,0,0.000000,if(exists $data->{rootLogger}) {
0.000000,0,0.000000,$LOGGERS_DEFINED++;
0.000000,0,0.000000,push @loggers, ["", $data->{rootLogger}->{value}];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if we've got a system-wide threshold setting
0.000000,0,0.000000,if(exists $data->{threshold}) {
0.000000,0,0.000000,# yes, we do.
0.000000,0,0.000000,$system_wide_threshold = $data->{threshold}->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if (exists $data->{oneMessagePerAppender}){
0.000000,0,0.000000,$Log::Log4perl::one_message_per_appender = 
0.000000,0,0.000000,$data->{oneMessagePerAppender}->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Boolean filters 
0.000000,0,0.000000,my %boolean_filters = ();
0.000000,0,0.000000,
0.000000,0,0.000000,# Continue with lower level loggers. Both 'logger' and 'category'
0.000000,0,0.000000,# are valid keywords. Also 'additivity' is one, having a logger
0.000000,0,0.000000,# attached. We'll differenciate between the two further down.
0.000000,0,0.000000,for my $key (qw(logger category additivity PatternLayout filter)) {
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $data->{$key}) {
0.000000,0,0.000000,
0.000000,0,0.000000,for my $path (@{leaf_paths($data->{$key})}) {
0.000000,0,0.000000,
0.000000,0,0.000000,print "Path before: @$path\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,my $value = boolean_to_perlish(pop @$path);
0.000000,0,0.000000,
0.000000,0,0.000000,pop @$path; # Drop the 'value' keyword part
0.000000,0,0.000000,
0.000000,0,0.000000,if($key eq "additivity") {
0.000000,0,0.000000,# This isn't a logger but an additivity setting.
0.000000,0,0.000000,# Save it in a hash under the logger's name for later.
0.000000,0,0.000000,$additivity{join('.', @$path)} = $value;
0.000000,0,0.000000,
0.000000,0,0.000000,#a global user-defined conversion specifier (cspec)
0.000000,0,0.000000,}elsif ($key eq "PatternLayout"){
0.000000,0,0.000000,&add_global_cspec(@$path[-1], $value);
0.000000,0,0.000000,
0.000000,0,0.000000,}elsif ($key eq "filter"){
0.000000,0,0.000000,print "Found entry @$path\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$filter_names{@$path[0]}++;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref($value) eq "ARRAY") {
0.000000,0,0.000000,die "Multiple definitions of logger ".join('.',@$path)." in log4perl config";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# This is a regular logger
0.000000,0,0.000000,$LOGGERS_DEFINED++;
0.000000,0,0.000000,push @loggers, [join('.', @$path), $value];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now go over all filters found by name
0.000000,0,0.000000,for my $filter_name (keys %filter_names) {
0.000000,0,0.000000,
0.000000,0,0.000000,print "Checking filter $filter_name\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,# The boolean filter needs all other filters already
0.000000,0,0.000000,# initialized, defer its initialization
0.000000,0,0.000000,if($data->{filter}->{$filter_name}->{value} eq
0.000000,0,0.000000,"Log::Log4perl::Filter::Boolean") {
0.000000,0,0.000000,print "Boolean filter ($filter_name)\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$boolean_filters{$filter_name}++;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $type = $data->{filter}->{$filter_name}->{value};
0.000000,0,0.000000,if(my $code = compile_if_perl($type)) {
0.000000,0,0.000000,$type = $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print "Filter $filter_name is of type $type\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,my $filter;
0.000000,0,0.000000,
0.000000,0,0.000000,if(ref($type) eq "CODE") {
0.000000,0,0.000000,# Subroutine - map into generic Log::Log4perl::Filter class
0.000000,0,0.000000,$filter = Log::Log4perl::Filter->new($filter_name, $type);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Filter class
0.000000,0,0.000000,die "Filter class '$type' doesn't exist" unless
0.000000,0,0.000000,Log::Log4perl::Util::module_available($type);
0.000000,0,0.000000,eval "require $type" or die "Require of $type failed ($!)";
0.000000,0,0.000000,
0.000000,0,0.000000,# Invoke with all defined parameter
0.000000,0,0.000000,# key/values (except the key 'value' which is the entry 
0.000000,0,0.000000,# for the class)
0.000000,0,0.000000,$filter = $type->new(name => $filter_name,
0.000000,0,0.000000,map { $_ => $data->{filter}->{$filter_name}->{$_}->{value} } 
0.000000,0,0.000000,grep { $_ ne "value" } 
0.000000,0,0.000000,keys %{$data->{filter}->{$filter_name}});
0.000000,0,0.000000,}
0.000000,0,0.000000,# Register filter with the global filter registry
0.000000,0,0.000000,$filter->register();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Initialize boolean filters (they need the other filters to be
0.000000,0,0.000000,# initialized to be able to compile their logic)
0.000000,0,0.000000,for my $name (keys %boolean_filters) {
0.000000,0,0.000000,my $logic = $data->{filter}->{$name}->{logic}->{value};
0.000000,0,0.000000,die "No logic defined for boolean filter $name" unless defined $logic;
0.000000,0,0.000000,my $filter = Log::Log4perl::Filter::Boolean->new(
0.000000,0,0.000000,name  => $name, 
0.000000,0,0.000000,logic => $logic);
0.000000,0,0.000000,$filter->register();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for (@loggers) {
0.000000,0,0.000000,my($name, $value) = @$_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $logger = Log::Log4perl::Logger->get_logger($name);
0.000000,0,0.000000,my ($level, @appnames) = split /\s*,\s*/, $value;
0.000000,0,0.000000,
0.000000,0,0.000000,$logger->level(
0.000000,0,0.000000,Log::Log4perl::Level::to_priority($level),
0.000000,0,0.000000,'dont_reset_all');
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $additivity{$name}) {
0.000000,0,0.000000,$logger->additivity($additivity{$name}, 1);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,for my $appname (@appnames) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $appender = create_appender_instance(
0.000000,0,0.000000,$data, $appname, \%appenders_created, \@post_config_subs,
0.000000,0,0.000000,$system_wide_threshold);
0.000000,0,0.000000,
0.000000,0,0.000000,$logger->add_appender($appender, 'dont_reset_all');
0.000000,0,0.000000,set_appender_by_name($appname, $appender, \%appenders_created);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#run post_config subs
0.000000,0,0.000000,for(@post_config_subs) {
0.000000,0,0.000000,$_->();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#now we're done, set up all the output methods (e.g. ->debug('...'))
0.000000,0,0.000000,Log::Log4perl::Logger::reset_all_output_methods();
0.000000,0,0.000000,
0.000000,0,0.000000,#Run a sanity test on the config not disabled
0.000000,0,0.000000,if($Log::Log4perl::Config::CONFIG_INTEGRITY_CHECK and
0.000000,0,0.000000,!config_is_sane()) {
0.000000,0,0.000000,warn "Log::Log4perl configuration looks suspicious: ",
0.000000,0,0.000000,"$CONFIG_INTEGRITY_ERROR";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Successful init(), save config for later
0.000000,0,0.000000,$OLD_CONFIG = $data;
0.000000,0,0.000000,
0.000000,0,0.000000,$Log::Log4perl::Logger::INITIALIZED = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub config_is_sane {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,if(! $LOGGERS_DEFINED) {
0.000000,0,0.000000,$CONFIG_INTEGRITY_ERROR = "No loggers defined";
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}    
0.000000,0,0.000000,
0.000000,0,0.000000,if(scalar keys %Log::Log4perl::Logger::APPENDER_BY_NAME == 0) {
0.000000,0,0.000000,$CONFIG_INTEGRITY_ERROR = "No appenders defined";
0.000000,0,0.000000,return 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub create_appender_instance {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my($data, $appname, $appenders_created, $post_config_subs,
0.000000,0,0.000000,$system_wide_threshold) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $appenderclass = get_appender_by_name(
0.000000,0,0.000000,$data, $appname, $appenders_created);
0.000000,0,0.000000,
0.000000,0,0.000000,print "appenderclass=$appenderclass\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,my $appender;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $appenderclass) {
0.000000,0,0.000000,$appender = $appenderclass;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "ERROR: you didn't tell me how to " .
0.000000,0,0.000000,"implement your appender '$appname'"
0.000000,0,0.000000,unless $appenderclass;
0.000000,0,0.000000,
0.000000,0,0.000000,if (Log::Log4perl::JavaMap::translate($appenderclass)){
0.000000,0,0.000000,# It's Java. Try to map
0.000000,0,0.000000,print "Trying to map Java $appname\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$appender = Log::Log4perl::JavaMap::get($appname, 
0.000000,0,0.000000,$data->{appender}->{$appname});
0.000000,0,0.000000,
0.000000,0,0.000000,}else{
0.000000,0,0.000000,# It's Perl
0.000000,0,0.000000,my @params = grep { $_ ne "layout" and
0.000000,0,0.000000,$_ ne "value"
0.000000,0,0.000000,} keys %{$data->{appender}->{$appname}};
0.000000,0,0.000000,
0.000000,0,0.000000,my %param = ();
0.000000,0,0.000000,foreach my $pname (@params){
0.000000,0,0.000000,#this could be simple value like 
0.000000,0,0.000000,#{appender}{myAppender}{file}{value} => 'log.txt'
0.000000,0,0.000000,#or a structure like
0.000000,0,0.000000,#{appender}{myAppender}{login} => 
0.000000,0,0.000000,#                         { name => {value => 'bob'},
0.000000,0,0.000000,#                           pwd  => {value => 'xxx'},
0.000000,0,0.000000,#                         }
0.000000,0,0.000000,#in the latter case we send a hashref to the appender
0.000000,0,0.000000,if (exists $data->{appender}{$appname}
0.000000,0,0.000000,{$pname}{value}      ) {
0.000000,0,0.000000,$param{$pname} = $data->{appender}{$appname}
0.000000,0,0.000000,{$pname}{value};
0.000000,0,0.000000,}else{
0.000000,0,0.000000,$param{$pname} = {map {$_ => $data->{appender}
0.000000,0,0.000000,{$appname}
0.000000,0,0.000000,{$pname}
0.000000,0,0.000000,{$_}
0.000000,0,0.000000,{value}} 
0.000000,0,0.000000,keys %{$data->{appender}
0.000000,0,0.000000,{$appname}
0.000000,0,0.000000,{$pname}}
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $depends_on = [];
0.000000,0,0.000000,
0.000000,0,0.000000,$appender = Log::Log4perl::Appender->new(
0.000000,0,0.000000,$appenderclass, 
0.000000,0,0.000000,name                 => $appname,
0.000000,0,0.000000,l4p_post_config_subs => $post_config_subs,
0.000000,0,0.000000,l4p_depends_on       => $depends_on,
0.000000,0,0.000000,%param,
0.000000,0,0.000000,); 
0.000000,0,0.000000,
0.000000,0,0.000000,for my $dependency (@$depends_on) {
0.000000,0,0.000000,# If this appender indicates that it needs other appenders
0.000000,0,0.000000,# to exist (e.g. because it's a composite appender that
0.000000,0,0.000000,# relays messages on to its appender-refs) then we're 
0.000000,0,0.000000,# creating their instances here. Reason for this is that 
0.000000,0,0.000000,# these appenders are not attached to any logger and are
0.000000,0,0.000000,# therefore missed by the config parser which goes through
0.000000,0,0.000000,# the defined loggers and just creates *their* attached
0.000000,0,0.000000,# appenders.
0.000000,0,0.000000,$appender->composite(1);
0.000000,0,0.000000,next if exists $appenders_created->{$appname};
0.000000,0,0.000000,my $app = create_appender_instance($data, $dependency, 
0.000000,0,0.000000,$appenders_created,
0.000000,0,0.000000,$post_config_subs);
0.000000,0,0.000000,# If the appender appended a subroutine to $post_config_subs
0.000000,0,0.000000,# (a reference to an array of subroutines)
0.000000,0,0.000000,# here, the configuration parser will later execute this
0.000000,0,0.000000,# method. This is used by a composite appender which needs
0.000000,0,0.000000,# to make sure all of its appender-refs are available when
0.000000,0,0.000000,# all configuration settings are done.
0.000000,0,0.000000,
0.000000,0,0.000000,# Smuggle this sub-appender into the hash of known appenders 
0.000000,0,0.000000,# without attaching it to any logger directly.
0.000000,0,0.000000,$
0.000000,0,0.000000,Log::Log4perl::Logger::APPENDER_BY_NAME{$dependency} = $app;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,add_layout_by_name($data, $appender, $appname) unless
0.000000,0,0.000000,$appender->composite();
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for appender thresholds
0.000000,0,0.000000,my $threshold = 
0.000000,0,0.000000,$data->{appender}->{$appname}->{Threshold}->{value};
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $system_wide_threshold and
0.000000,0,0.000000,!defined $threshold) {
0.000000,0,0.000000,$threshold = $system_wide_threshold;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $threshold) {
0.000000,0,0.000000,# Need to split into two lines because of CVS
0.000000,0,0.000000,$appender->threshold($
0.000000,0,0.000000,Log::Log4perl::Level::PRIORITY{$threshold});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for custom filters attached to the appender
0.000000,0,0.000000,my $filtername = 
0.000000,0,0.000000,$data->{appender}->{$appname}->{Filter}->{value};
0.000000,0,0.000000,if(defined $filtername) {
0.000000,0,0.000000,# Need to split into two lines because of CVS
0.000000,0,0.000000,my $filter = Log::Log4perl::Filter::by_name($filtername);
0.000000,0,0.000000,die "Filter $filtername doesn't exist" unless defined $filter;
0.000000,0,0.000000,$appender->filter($filter);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $system_wide_threshold and
0.000000,0,0.000000,defined $threshold and
0.000000,0,0.000000,$
0.000000,0,0.000000,Log::Log4perl::Level::PRIORITY{$system_wide_threshold} > 
0.000000,0,0.000000,$
0.000000,0,0.000000,Log::Log4perl::Level::PRIORITY{$threshold}
0.000000,0,0.000000,) {
0.000000,0,0.000000,$appender->threshold($
0.000000,0,0.000000,Log::Log4perl::Level::PRIORITY{$system_wide_threshold});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $data->{appender}->{$appname}->{threshold}) {
0.000000,0,0.000000,die "invalid keyword 'threshold' - perhaps you meant 'Threshold'?";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $appender;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub add_layout_by_name {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($data, $appender, $appender_name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $layout_class = $data->{appender}->{$appender_name}->{layout}->{value};
0.000000,0,0.000000,
0.000000,0,0.000000,die "Layout not specified for appender $appender_name" unless $layout_class;
0.000000,0,0.000000,
0.000000,0,0.000000,$layout_class =~ s/org.apache.log4j./Log::Log4perl::Layout::/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if we have this layout class
0.000000,0,0.000000,if(!Log::Log4perl::Util::module_available($layout_class)) {
0.000000,0,0.000000,if(Log::Log4perl::Util::module_available(
0.000000,0,0.000000,"Log::Log4perl::Layout::$layout_class")) {
0.000000,0,0.000000,# Someone used the layout shortcut, use the fully qualified
0.000000,0,0.000000,# module name instead.
0.000000,0,0.000000,$layout_class = "Log::Log4perl::Layout::$layout_class";
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "ERROR: trying to set layout for $appender_name to " .
0.000000,0,0.000000,"'$layout_class' failed";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,eval "require $layout_class" or 
0.000000,0,0.000000,die "Require to $layout_class failed ($!)";
0.000000,0,0.000000,
0.000000,0,0.000000,$appender->layout($layout_class->new(
0.000000,0,0.000000,$data->{appender}->{$appender_name}->{layout},
0.000000,0,0.000000,));
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub get_appender_by_name {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($data, $name, $appenders_created) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if (exists $appenders_created->{$name}) {
0.000000,0,0.000000,return $appenders_created->{$name};
0.000000,0,0.000000,} else {
0.000000,0,0.000000,return $data->{appender}->{$name}->{value};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub set_appender_by_name {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,# keep track of appenders we've already created
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($appname, $appender, $appenders_created) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$appenders_created->{$appname} ||= $appender;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub add_global_cspec {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# the config file said
0.000000,0,0.000000,# log4j.PatternLayout.cspec.Z=sub {return $$*2}
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($letter, $perlcode) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,die "error: only single letters allowed in log4j.PatternLayout.cspec.$letter"
0.000000,0,0.000000,unless ($letter =~ /^[a-zA-Z]$/);
0.000000,0,0.000000,
0.000000,0,0.000000,Log::Log4perl::Layout::PatternLayout::add_global_cspec($letter, $perlcode);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,my $LWP_USER_AGENT;
0.000000,0,0.000000,sub set_LWP_UserAgent
0.000000,0,0.000000,{
0.000000,0,0.000000,$LWP_USER_AGENT = shift;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub config_read {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,# Read the lib4j configuration and store the
0.000000,0,0.000000,# values into a nested hash structure.
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($config) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,die "Configuration not defined" unless defined $config;
0.000000,0,0.000000,
0.000000,0,0.000000,my @text;
0.000000,0,0.000000,my $parser;
0.000000,0,0.000000,
0.000000,0,0.000000,$CONFIG_FILE_READS++;  # Count for statistical purposes
0.000000,0,0.000000,
0.000000,0,0.000000,my $base_configurator = Log::Log4perl::Config::BaseConfigurator->new(
0.000000,0,0.000000,utf8 => $UTF8,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,my $data = {};
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref($config) eq 'HASH') {   # convert the hashref into a list 
0.000000,0,0.000000,# of name/value pairs
0.000000,0,0.000000,print "Reading config from hash\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,@text = ();
0.000000,0,0.000000,for my $key ( keys %$config ) {
0.000000,0,0.000000,if( ref( $config->{$key} ) eq "CODE" ) {
0.000000,0,0.000000,$config->{$key} = $config->{$key}->();
0.000000,0,0.000000,}
0.000000,0,0.000000,push @text, $key . '=' . $config->{$key} . "\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,} elsif (ref $config eq 'SCALAR') {
0.000000,0,0.000000,print "Reading config from scalar\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,@text = split(/\n/,$$config);
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif (ref $config eq 'GLOB' or 
0.000000,0,0.000000,ref $config eq 'IO::File') {
0.000000,0,0.000000,# If we have a file handle, just call the reader
0.000000,0,0.000000,print "Reading config from file handle\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,@text = @{ $base_configurator->file_h_read( $config ) };
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif (ref $config) {
0.000000,0,0.000000,# Caller provided a config parser object, which already
0.000000,0,0.000000,# knows which file (or DB or whatever) to parse.
0.000000,0,0.000000,print "Reading config from parser object\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$data = $config->parse();
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif ($config =~ m|^ldap://|){
0.000000,0,0.000000,if(! Log::Log4perl::Util::module_available("Net::LDAP")) {
0.000000,0,0.000000,die "Log4perl: missing Net::LDAP needed to parse LDAP urls\n$@\n";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,require Net::LDAP;
0.000000,0,0.000000,require Log::Log4perl::Config::LDAPConfigurator;
0.000000,0,0.000000,
0.000000,0,0.000000,return Log::Log4perl::Config::LDAPConfigurator->new->parse($config);
0.000000,0,0.000000,
0.000000,0,0.000000,} else {
0.000000,0,0.000000,
0.000000,0,0.000000,if ($config =~ /^(https?|ftp|wais|gopher|file):/){
0.000000,0,0.000000,my ($result, $ua);
0.000000,0,0.000000,
0.000000,0,0.000000,die "LWP::UserAgent not available" unless
0.000000,0,0.000000,Log::Log4perl::Util::module_available("LWP::UserAgent");
0.000000,0,0.000000,
0.000000,0,0.000000,require LWP::UserAgent;
0.000000,0,0.000000,unless (defined $LWP_USER_AGENT) {
0.000000,0,0.000000,$LWP_USER_AGENT = LWP::UserAgent->new;
0.000000,0,0.000000,
0.000000,0,0.000000,# Load proxy settings from environment variables, i.e.:
0.000000,0,0.000000,# http_proxy, ftp_proxy, no_proxy etc (see LWP::UserAgent)
0.000000,0,0.000000,# You need these to go thru firewalls.
0.000000,0,0.000000,$LWP_USER_AGENT->env_proxy;
0.000000,0,0.000000,}
0.000000,0,0.000000,$ua = $LWP_USER_AGENT;
0.000000,0,0.000000,
0.000000,0,0.000000,my $req = new HTTP::Request GET => $config;
0.000000,0,0.000000,my $res = $ua->request($req);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($res->is_success) {
0.000000,0,0.000000,@text = split(/\n/, $res->content);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,die "Log4perl couln't get $config, ".
0.000000,0,0.000000,$res->message." ";
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,print "Reading config from file '$config'\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,print "Reading ", -s $config, " bytes.\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,# Use the BaseConfigurator's file reader to avoid duplicating
0.000000,0,0.000000,# utf8 handling here.
0.000000,0,0.000000,$base_configurator->file( $config );
0.000000,0,0.000000,@text = @{ $base_configurator->text() };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,print "Reading $config: [@text]\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,if(! grep /\S/, @text) {
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($text[0] =~ /^<\?xml /) {
0.000000,0,0.000000,
0.000000,0,0.000000,die "XML::DOM not available" unless
0.000000,0,0.000000,Log::Log4perl::Util::module_available("XML::DOM");
0.000000,0,0.000000,
0.000000,0,0.000000,require XML::DOM; 
0.000000,0,0.000000,require Log::Log4perl::Config::DOMConfigurator;
0.000000,0,0.000000,
0.000000,0,0.000000,XML::DOM->VERSION($Log::Log4perl::DOM_VERSION_REQUIRED);
0.000000,0,0.000000,$parser = Log::Log4perl::Config::DOMConfigurator->new();
0.000000,0,0.000000,$data = $parser->parse(\@text);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$parser = Log::Log4perl::Config::PropertyConfigurator->new();
0.000000,0,0.000000,$data = $parser->parse(\@text);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$data = $parser->parse_post_process( $data, leaf_paths($data) );
0.000000,0,0.000000,
0.000000,0,0.000000,return $data;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub unlog4j {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my ($string) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$string =~ s#^org\.apache\.##;
0.000000,0,0.000000,$string =~ s#^log4j\.##;
0.000000,0,0.000000,$string =~ s#^l4p\.##;
0.000000,0,0.000000,$string =~ s#^log4perl\.##i;
0.000000,0,0.000000,
0.000000,0,0.000000,$string =~ s#\.#::#g;
0.000000,0,0.000000,
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,############################################################
0.000000,0,0.000000,sub leaf_paths {
0.000000,0,0.000000,############################################################
0.000000,0,0.000000,# Takes a reference to a hash of hashes structure of 
0.000000,0,0.000000,# arbitrary depth, walks the tree and returns a reference
0.000000,0,0.000000,# to an array of all possible leaf paths (each path is an 
0.000000,0,0.000000,# array again).
0.000000,0,0.000000,# Example: { a => { b => { c => d }, e => f } } would generate
0.000000,0,0.000000,#          [ [a, b, c, d], [a, e, f] ]
0.000000,0,0.000000,############################################################
0.000000,0,0.000000,my ($root) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @stack  = ();
0.000000,0,0.000000,my @result = ();
0.000000,0,0.000000,
0.000000,0,0.000000,push @stack, [$root, []];  
0.000000,0,0.000000,
0.000000,0,0.000000,while(@stack) {
0.000000,0,0.000000,my $item = pop @stack;
0.000000,0,0.000000,
0.000000,0,0.000000,my($node, $path) = @$item;
0.000000,0,0.000000,
0.000000,0,0.000000,if(ref($node) eq "HASH") { 
0.000000,0,0.000000,for(keys %$node) {
0.000000,0,0.000000,push @stack, [$node->{$_}, [@$path, $_]];
0.000000,0,0.000000,}
0.000000,0,0.000000,} else {
0.000000,0,0.000000,push @result, [@$path, $node];
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return \@result;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub leaf_path_to_hash {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($leaf_path, $data) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my $ref = \$data;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $part ( @$leaf_path[0..$#$leaf_path-1] ) {
0.000000,0,0.000000,$ref = \$$ref->{ $part };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $ref;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub eval_if_perl {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if(my $cref = compile_if_perl($value)) {
0.000000,0,0.000000,return $cref->();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub compile_if_perl {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if($value =~ /^\s*sub\s*{/ ) {
0.000000,0,0.000000,my $mask;
0.000000,0,0.000000,unless( Log::Log4perl::Config->allow_code() ) {
0.000000,0,0.000000,die "\$Log::Log4perl::Config->allow_code() setting " .
0.000000,0,0.000000,"prohibits Perl code in config file";
0.000000,0,0.000000,}
0.000000,0,0.000000,if( defined( $mask = Log::Log4perl::Config->allowed_code_ops() ) ) {
0.000000,0,0.000000,return compile_in_safe_cpt($value, $mask );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( $mask = Log::Log4perl::Config->allowed_code_ops_convenience_map(
0.000000,0,0.000000,Log::Log4perl::Config->allow_code()
0.000000,0,0.000000,) ) {
0.000000,0,0.000000,return compile_in_safe_cpt($value, $mask );
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( Log::Log4perl::Config->allow_code() == 1 ) {
0.000000,0,0.000000,
0.000000,0,0.000000,# eval without restriction
0.000000,0,0.000000,my $cref = eval "package main; $value" or 
0.000000,0,0.000000,die "Can't evaluate '$value' ($@)";
0.000000,0,0.000000,return $cref;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,die "Invalid value for \$Log::Log4perl::Config->allow_code(): '".
0.000000,0,0.000000,Log::Log4perl::Config->allow_code() . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub compile_in_safe_cpt {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($value, $allowed_ops) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# set up a Safe compartment
0.000000,0,0.000000,require Safe;
0.000000,0,0.000000,my $safe = Safe->new();
0.000000,0,0.000000,$safe->permit_only( @{ $allowed_ops } );
0.000000,0,0.000000,
0.000000,0,0.000000,# share things with the compartment
0.000000,0,0.000000,for( keys %{ Log::Log4perl::Config->vars_shared_with_safe_compartment() } ) {
0.000000,0,0.000000,my $toshare = Log::Log4perl::Config->vars_shared_with_safe_compartment($_);
0.000000,0,0.000000,$safe->share_from( $_, $toshare )
0.000000,0,0.000000,or die "Can't share @{ $toshare } with Safe compartment";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# evaluate with restrictions
0.000000,0,0.000000,my $cref = $safe->reval("package main; $value") or
0.000000,0,0.000000,die "Can't evaluate '$value' in Safe compartment ($@)";
0.000000,0,0.000000,return $cref;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub boolean_to_perlish {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($value) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Translate boolean to perlish
0.000000,0,0.000000,$value = 1 if $value =~ /^true$/i;
0.000000,0,0.000000,$value = 0 if $value =~ /^false$/i;
0.000000,0,0.000000,
0.000000,0,0.000000,return $value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub vars_shared_with_safe_compartment {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow both for ...::Config::foo() and ...::Config->foo()
0.000000,0,0.000000,if(defined $class and $class ne __PACKAGE__) {
0.000000,0,0.000000,unshift @args, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# handle different invocation styles
0.000000,0,0.000000,if(@args == 1 && ref $args[0] eq 'HASH' ) {
0.000000,0,0.000000,# replace entire hash of vars
0.000000,0,0.000000,%Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT = %{$args[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( @args == 1 ) {
0.000000,0,0.000000,# return vars for given package
0.000000,0,0.000000,return $Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{
0.000000,0,0.000000,$args[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( @args == 2 ) {
0.000000,0,0.000000,# add/replace package/var pair
0.000000,0,0.000000,$Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT{
0.000000,0,0.000000,$args[0]} = $args[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray ? %Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT
0.000000,0,0.000000,: \%Log::Log4perl::VARS_SHARED_WITH_SAFE_COMPARTMENT;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub allowed_code_ops {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow both for ...::Config::foo() and ...::Config->foo()
0.000000,0,0.000000,if(defined $class and $class ne __PACKAGE__) {
0.000000,0,0.000000,unshift @args, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@args) {
0.000000,0,0.000000,@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE = @args;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# give back 'undef' instead of an empty arrayref
0.000000,0,0.000000,unless( @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE ) {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray ? @Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE
0.000000,0,0.000000,: \@Log::Log4perl::ALLOWED_CODE_OPS_IN_CONFIG_FILE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub allowed_code_ops_convenience_map {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow both for ...::Config::foo() and ...::Config->foo()
0.000000,0,0.000000,if(defined $class and $class ne __PACKAGE__) {
0.000000,0,0.000000,unshift @args, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# handle different invocation styles
0.000000,0,0.000000,if( @args == 1 && ref $args[0] eq 'HASH' ) {
0.000000,0,0.000000,# replace entire map
0.000000,0,0.000000,%Log::Log4perl::ALLOWED_CODE_OPS = %{$args[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( @args == 1 ) {
0.000000,0,0.000000,# return single opcode mask
0.000000,0,0.000000,return $Log::Log4perl::ALLOWED_CODE_OPS{
0.000000,0,0.000000,$args[0]};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif( @args == 2 ) {
0.000000,0,0.000000,# make sure the mask is an array ref
0.000000,0,0.000000,if( ref $args[1] ne 'ARRAY' ) {
0.000000,0,0.000000,die "invalid mask (not an array ref) for convenience name '$args[0]'";
0.000000,0,0.000000,}
0.000000,0,0.000000,# add name/mask pair
0.000000,0,0.000000,$Log::Log4perl::ALLOWED_CODE_OPS{
0.000000,0,0.000000,$args[0]} = $args[1];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return wantarray ? %Log::Log4perl::ALLOWED_CODE_OPS
0.000000,0,0.000000,: \%Log::Log4perl::ALLOWED_CODE_OPS
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub allow_code {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my($class, @args) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow both for ...::Config::foo() and ...::Config->foo()
0.000000,0,0.000000,if(defined $class and $class ne __PACKAGE__) {
0.000000,0,0.000000,unshift @args, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if(@args) {
0.000000,0,0.000000,$Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE = 
0.000000,0,0.000000,$args[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $Log::Log4perl::ALLOW_CODE_IN_CONFIG_FILE;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,################################################
0.000000,0,0.000000,sub var_subst {
0.000000,0,0.000000,################################################
0.000000,0,0.000000,my($varname, $subst_hash) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Throw out blanks
0.000000,0,0.000000,$varname =~ s/\s+//g;
0.000000,0,0.000000,
0.000000,0,0.000000,if(exists $subst_hash->{$varname}) {
0.000000,0,0.000000,print "Replacing variable: '$varname' => '$subst_hash->{$varname}'\n" 
0.000000,0,0.000000,if _INTERNAL_DEBUG;
0.000000,0,0.000000,return $subst_hash->{$varname};
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif(exists $ENV{$varname}) {
0.000000,0,0.000000,print "Replacing ENV variable: '$varname' => '$ENV{$varname}'\n" 
0.000000,0,0.000000,if _INTERNAL_DEBUG;
0.000000,0,0.000000,return $ENV{$varname};
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "Undefined Variable '$varname'";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
