# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Moose::Meta::Role::Application::ToClass;
0.000000,0,0.000000,BEGIN {
0.000009,1,0.000009,$Moose::Meta::Role::Application::ToClass::AUTHORITY = 'cpan:STEVAN';
0.000034,1,0.000034,}
0.000000,0,0.000000,{
0.000005,2,0.000003,$Moose::Meta::Role::Application::ToClass::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000046,2,0.000023,use strict;
0.000034,2,0.000017,use warnings;
0.000039,2,0.000019,use metaclass;
0.000000,0,0.000000,
0.000037,2,0.000019,use List::MoreUtils 'firstval';
0.000053,2,0.000026,use Moose::Util  'english_list';
0.000039,2,0.000020,use Scalar::Util 'weaken', 'blessed';
0.000000,0,0.000000,
0.000902,2,0.000451,use base 'Moose::Meta::Role::Application';
0.000000,0,0.000000,
0.000014,1,0.000014,__PACKAGE__->meta->add_attribute('role' => (
0.000000,0,0.000000,reader => 'role',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000013,1,0.000013,__PACKAGE__->meta->add_attribute('class' => (
0.000000,0,0.000000,accessor => 'class',
0.000000,0,0.000000,Class::MOP::_definition_context(),
0.000000,0,0.000000,));
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply {
0.000000,0,0.000000,my ($self, $role, $class) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# We need weak_ref in CMOP :(
0.000000,0,0.000000,weaken($self->{role}  = $role);
0.000000,0,0.000000,weaken($self->{class} = $class);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->SUPER::apply($role, $class);
0.000000,0,0.000000,
0.000000,0,0.000000,$class->add_role($role);
0.000000,0,0.000000,$class->add_role_application($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check_role_exclusions {
0.000000,0,0.000000,my ($self, $role, $class) = @_;
0.000000,0,0.000000,if ($class->excludes_role($role->name)) {
0.000000,0,0.000000,$class->throw_error("Conflict detected: " . $class->name . " excludes role '" . $role->name . "'");
0.000000,0,0.000000,}
0.000000,0,0.000000,foreach my $excluded_role_name ($role->get_excluded_roles_list) {
0.000000,0,0.000000,if ($class->does_role($excluded_role_name)) {
0.000000,0,0.000000,$class->throw_error("The class " . $class->name . " does the excluded role '$excluded_role_name'");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check_required_methods {
0.000000,0,0.000000,my ($self, $role, $class) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @missing;
0.000000,0,0.000000,my @is_attr;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we might need to move this down below the
0.000000,0,0.000000,# the attributes so that we can require any
0.000000,0,0.000000,# attribute accessors. However I am thinking
0.000000,0,0.000000,# that maybe those are somehow exempt from
0.000000,0,0.000000,# the require methods stuff.
0.000000,0,0.000000,foreach my $required_method ($role->get_required_method_list) {
0.000000,0,0.000000,my $required_method_name = $required_method->name;
0.000000,0,0.000000,
0.000000,0,0.000000,if (!$class->find_method_by_name($required_method_name)) {
0.000000,0,0.000000,
0.000000,0,0.000000,next if $self->is_aliased_method($required_method_name);
0.000000,0,0.000000,
0.000000,0,0.000000,push @missing, $required_method;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return unless @missing;
0.000000,0,0.000000,
0.000000,0,0.000000,my $error = '';
0.000000,0,0.000000,
0.000000,0,0.000000,@missing = sort { $a->name cmp $b->name } @missing;
0.000000,0,0.000000,my @conflicts = grep { $_->isa('Moose::Meta::Role::Method::Conflicting') } @missing;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@conflicts) {
0.000000,0,0.000000,my $conflict = $conflicts[0];
0.000000,0,0.000000,my $roles = $conflict->roles_as_english_list;
0.000000,0,0.000000,
0.000000,0,0.000000,my @same_role_conflicts = grep { $_->roles_as_english_list eq $roles } @conflicts;
0.000000,0,0.000000,
0.000000,0,0.000000,if (@same_role_conflicts == 1) {
0.000000,0,0.000000,$error
0.000000,0,0.000000,.= "Due to a method name conflict in roles "
0.000000,0,0.000000,.  $roles
0.000000,0,0.000000,. ", the method '"
0.000000,0,0.000000,. $conflict->name
0.000000,0,0.000000,. "' must be implemented or excluded by '"
0.000000,0,0.000000,. $class->name
0.000000,0,0.000000,. q{'};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my $methods
0.000000,0,0.000000,= Moose::Util::english_list( map { q{'} . $_->name . q{'} } @same_role_conflicts );
0.000000,0,0.000000,
0.000000,0,0.000000,$error
0.000000,0,0.000000,.= "Due to method name conflicts in roles "
0.000000,0,0.000000,.  $roles
0.000000,0,0.000000,. ", the methods "
0.000000,0,0.000000,. $methods
0.000000,0,0.000000,. " must be implemented or excluded by '"
0.000000,0,0.000000,. $class->name
0.000000,0,0.000000,. q{'};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (@missing) {
0.000000,0,0.000000,my $noun = @missing == 1 ? 'method' : 'methods';
0.000000,0,0.000000,
0.000000,0,0.000000,my $list
0.000000,0,0.000000,= Moose::Util::english_list( map { q{'} . $_ . q{'} } @missing );
0.000000,0,0.000000,
0.000000,0,0.000000,$error
0.000000,0,0.000000,.= q{'}
0.000000,0,0.000000,. $role->name
0.000000,0,0.000000,. "' requires the $noun $list "
0.000000,0,0.000000,. "to be implemented by '"
0.000000,0,0.000000,. $class->name . q{'};
0.000000,0,0.000000,
0.000000,0,0.000000,if (my $meth = firstval { $class->name->can($_) } @missing) {
0.000000,0,0.000000,$error .= ". If you imported functions intending to use them as "
0.000000,0,0.000000,. "methods, you need to explicitly mark them as such, via "
0.000000,0,0.000000,. $class->name . "->meta->add_method($meth => \\\&$meth)";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$class->throw_error($error);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub check_required_attributes {
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_attributes {
0.000000,0,0.000000,my ($self, $role, $class) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attribute_name ($role->get_attribute_list) {
0.000000,0,0.000000,# it if it has one already
0.000000,0,0.000000,if ($class->has_attribute($attribute_name) &&
0.000000,0,0.000000,# make sure we haven't seen this one already too
0.000000,0,0.000000,$class->get_attribute($attribute_name) != $role->get_attribute($attribute_name)) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$class->add_attribute(
0.000000,0,0.000000,$role->get_attribute($attribute_name)->attribute_for_class
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_methods {
0.000000,0,0.000000,my ( $self, $role, $class ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $method ( $role->_get_local_methods ) {
0.000000,0,0.000000,my $method_name = $method->name;
0.000000,0,0.000000,
0.000000,0,0.000000,next if $method->isa('Class::MOP::Method::Meta');
0.000000,0,0.000000,
0.000000,0,0.000000,unless ( $self->is_method_excluded($method_name) ) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $class_method = $class->get_method($method_name);
0.000000,0,0.000000,
0.000000,0,0.000000,next if $class_method && $class_method->body != $method->body;
0.000000,0,0.000000,
0.000000,0,0.000000,$class->add_method(
0.000000,0,0.000000,$method_name,
0.000000,0,0.000000,$method,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,next unless $self->is_method_aliased($method_name);
0.000000,0,0.000000,
0.000000,0,0.000000,my $aliased_method_name = $self->get_method_aliases->{$method_name};
0.000000,0,0.000000,
0.000000,0,0.000000,my $class_method = $class->get_method($aliased_method_name);
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $class_method && $class_method->body != $method->body ) {
0.000000,0,0.000000,$class->throw_error(
0.000000,0,0.000000,"Cannot create a method alias if a local method of the same name exists"
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$class->add_method(
0.000000,0,0.000000,$aliased_method_name,
0.000000,0,0.000000,$method,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# we must reset the cache here since
0.000000,0,0.000000,# we are just aliasing methods, otherwise
0.000000,0,0.000000,# the modifiers go wonky.
0.000000,0,0.000000,$class->reset_package_cache_flag;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_override_method_modifiers {
0.000000,0,0.000000,my ($self, $role, $class) = @_;
0.000000,0,0.000000,foreach my $method_name ($role->get_method_modifier_list('override')) {
0.000000,0,0.000000,# it if it has one already then ...
0.000000,0,0.000000,if ($class->has_method($method_name)) {
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# if this is not a role, then we need to
0.000000,0,0.000000,# find the original package of the method
0.000000,0,0.000000,# so that we can tell the class were to
0.000000,0,0.000000,# find the right super() method
0.000000,0,0.000000,my $method = $role->get_override_method_modifier($method_name);
0.000000,0,0.000000,my ($package) = Class::MOP::get_code_info($method);
0.000000,0,0.000000,# if it is a class, we just add it
0.000000,0,0.000000,$class->add_override_method_modifier($method_name, $method, $package);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply_method_modifiers {
0.000000,0,0.000000,my ($self, $modifier_type, $role, $class) = @_;
0.000000,0,0.000000,my $add = "add_${modifier_type}_method_modifier";
0.000000,0,0.000000,my $get = "get_${modifier_type}_method_modifiers";
0.000000,0,0.000000,foreach my $method_name ($role->get_method_modifier_list($modifier_type)) {
0.000000,0,0.000000,$class->$add(
0.000000,0,0.000000,$method_name,
0.000000,0,0.000000,$_
0.000000,0,0.000000,) foreach $role->$get($method_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000006,1,0.000006,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Compose a role into a class
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
