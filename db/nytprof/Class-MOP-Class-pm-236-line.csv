# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Class::MOP::Class;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Class::MOP::Class::AUTHORITY = 'cpan:STEVAN';
0.000031,1,0.000031,}
0.000000,0,0.000000,{
0.000006,2,0.000003,$Class::MOP::Class::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000033,2,0.000016,use strict;
0.000033,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000109,2,0.000054,use Class::MOP::Instance;
0.000113,2,0.000056,use Class::MOP::Method::Wrapped;
0.000136,2,0.000068,use Class::MOP::Method::Accessor;
0.000131,2,0.000065,use Class::MOP::Method::Constructor;
0.000109,2,0.000055,use Class::MOP::MiniTrait;
0.000000,0,0.000000,
0.000036,2,0.000018,use Carp         'confess';
0.000036,2,0.000018,use Class::Load  'is_class_loaded', 'load_class';
0.000034,2,0.000017,use Scalar::Util 'blessed', 'reftype', 'weaken';
0.000033,2,0.000017,use Sub::Name    'subname';
0.000034,2,0.000017,use Try::Tiny;
0.000037,2,0.000019,use List::MoreUtils 'all';
0.000000,0,0.000000,
0.000010,1,0.000010,use base 'Class::MOP::Module',
0.000000,0,0.000000,'Class::MOP::Mixin::HasAttributes',
0.005962,1,0.005962,'Class::MOP::Mixin::HasMethods';
0.000000,0,0.000000,
0.000000,0,0.000000,# Creation
0.000000,0,0.000000,
0.000000,0,0.000000,sub initialize {
0.002306,1470,0.000002,my $class = shift;
0.000000,0,0.000000,
0.002011,1470,0.000001,my $package_name;
0.000000,0,0.000000,
0.002596,1470,0.000002,if ( @_ % 2 ) {
0.000000,0,0.000000,$package_name = shift;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,$package_name = $options{package};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002214,1470,0.000002,($package_name && !ref($package_name))
0.000000,0,0.000000,|| confess "You must pass a package name and it cannot be blessed";
0.000000,0,0.000000,
0.018205,1470,0.000012,return Class::MOP::get_metaclass_by_name($package_name)
0.000000,0,0.000000,|| $class->_construct_class_instance(package => $package_name, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub reinitialize {
0.000000,0,0.000000,my ( $class, @args ) = @_;
0.000000,0,0.000000,unshift @args, "package" if @args % 2;
0.000000,0,0.000000,my %options = @args;
0.000000,0,0.000000,my $old_metaclass = blessed($options{package})
0.000000,0,0.000000,? $options{package}
0.000000,0,0.000000,: Class::MOP::get_metaclass_by_name($options{package});
0.000000,0,0.000000,$options{weaken} = Class::MOP::metaclass_is_weak($old_metaclass->name)
0.000000,0,0.000000,if !exists $options{weaken}
0.000000,0,0.000000,&& blessed($old_metaclass)
0.000000,0,0.000000,&& $old_metaclass->isa('Class::MOP::Class');
0.000000,0,0.000000,$old_metaclass->_remove_generated_metaobjects
0.000000,0,0.000000,if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
0.000000,0,0.000000,my $new_metaclass = $class->SUPER::reinitialize(%options);
0.000000,0,0.000000,$new_metaclass->_restore_metaobjects_from($old_metaclass)
0.000000,0,0.000000,if $old_metaclass && $old_metaclass->isa('Class::MOP::Class');
0.000000,0,0.000000,return $new_metaclass;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: (meta-circularity)
0.000000,0,0.000000,# this is a special form of _construct_instance
0.000000,0,0.000000,# (see below), which is used to construct class
0.000000,0,0.000000,# meta-object instances for any Class::MOP::*
0.000000,0,0.000000,# class. All other classes will use the more
0.000000,0,0.000000,# normal &construct_instance.
0.000000,0,0.000000,sub _construct_class_instance {
0.000111,69,0.000002,my $class        = shift;
0.000211,69,0.000003,my $options      = @_ == 1 ? $_[0] : {@_};
0.000122,69,0.000002,my $package_name = $options->{package};
0.000105,69,0.000002,(defined $package_name && $package_name)
0.000000,0,0.000000,|| confess "You must pass a package name";
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# return the metaclass if we have it cached,
0.000000,0,0.000000,# and it is still defined (it has not been
0.000000,0,0.000000,# reaped by DESTROY yet, which can happen
0.000000,0,0.000000,# annoyingly enough during global destruction)
0.000000,0,0.000000,
0.000352,69,0.000005,if (defined(my $meta = Class::MOP::get_metaclass_by_name($package_name))) {
0.000000,0,0.000000,return $meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$class
0.000154,69,0.000002,= ref $class
0.000000,0,0.000000,? $class->_real_ref_name
0.000000,0,0.000000,: $class;
0.000000,0,0.000000,
0.000000,0,0.000000,# now create the metaclass
0.000096,69,0.000001,my $meta;
0.000413,69,0.000006,if ($class eq 'Class::MOP::Class') {
0.000000,0,0.000000,$meta = $class->_new($options);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# it is safe to use meta here because
0.000000,0,0.000000,# class will always be a subclass of
0.000000,0,0.000000,# Class::MOP::Class, which defines meta
0.000022,2,0.000011,$meta = $class->meta->_construct_instance($options)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# and check the metaclass compatibility
0.000462,69,0.000007,$meta->_check_metaclass_compatibility();
0.000000,0,0.000000,
0.000363,69,0.000005,Class::MOP::store_metaclass_by_name($package_name, $meta);
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we need to weaken any anon classes
0.000000,0,0.000000,# so that they can call DESTROY properly
0.000120,69,0.000002,Class::MOP::weaken_metaclass($package_name) if $options->{weaken};
0.000000,0,0.000000,
0.000374,69,0.000005,$meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _real_ref_name {
0.000087,60,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE: we need to deal with the possibility of class immutability here,
0.000000,0,0.000000,# and then get the name of the class appropriately
0.000681,60,0.000011,return $self->is_immutable
0.000000,0,0.000000,? $self->_get_mutable_metaclass_name()
0.000000,0,0.000000,: ref $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _new {
0.000105,67,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000105,67,0.000002,return Class::MOP::Class->initialize($class)->new_object(@_)
0.000000,0,0.000000,if $class ne __PACKAGE__;
0.000000,0,0.000000,
0.000122,67,0.000002,my $options = @_ == 1 ? $_[0] : {@_};
0.000000,0,0.000000,
0.000972,67,0.000015,return bless {
0.000000,0,0.000000,# inherited from Class::MOP::Package
0.000000,0,0.000000,'package' => $options->{package},
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# since the following attributes will
0.000000,0,0.000000,# actually be loaded from the symbol
0.000000,0,0.000000,# table, and actually bypass the instance
0.000000,0,0.000000,# entirely, we can just leave these things
0.000000,0,0.000000,# listed here for reference, because they
0.000000,0,0.000000,# should not actually have a value associated
0.000000,0,0.000000,# with the slot.
0.000000,0,0.000000,'namespace' => \undef,
0.000000,0,0.000000,'methods'   => {},
0.000000,0,0.000000,
0.000000,0,0.000000,# inherited from Class::MOP::Module
0.000000,0,0.000000,'version'   => \undef,
0.000000,0,0.000000,'authority' => \undef,
0.000000,0,0.000000,
0.000000,0,0.000000,# defined in Class::MOP::Class
0.000000,0,0.000000,'superclasses' => \undef,
0.000000,0,0.000000,
0.000000,0,0.000000,'attributes' => {},
0.000000,0,0.000000,'attribute_metaclass' =>
0.000000,0,0.000000,( $options->{'attribute_metaclass'} || 'Class::MOP::Attribute' ),
0.000000,0,0.000000,'method_metaclass' =>
0.000000,0,0.000000,( $options->{'method_metaclass'} || 'Class::MOP::Method' ),
0.000000,0,0.000000,'wrapped_method_metaclass' => (
0.000000,0,0.000000,$options->{'wrapped_method_metaclass'}
0.000000,0,0.000000,|| 'Class::MOP::Method::Wrapped'
0.000000,0,0.000000,),
0.000000,0,0.000000,'instance_metaclass' =>
0.000000,0,0.000000,( $options->{'instance_metaclass'} || 'Class::MOP::Instance' ),
0.000000,0,0.000000,'immutable_trait' => (
0.000000,0,0.000000,$options->{'immutable_trait'}
0.000000,0,0.000000,|| 'Class::MOP::Class::Immutable::Trait'
0.000000,0,0.000000,),
0.000000,0,0.000000,'constructor_name' => ( $options->{constructor_name} || 'new' ),
0.000000,0,0.000000,'constructor_class' => (
0.000000,0,0.000000,$options->{constructor_class} || 'Class::MOP::Method::Constructor'
0.000000,0,0.000000,),
0.000000,0,0.000000,'destructor_class' => $options->{destructor_class},
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Metaclass compatibility
0.000000,0,0.000000,{
0.000008,2,0.000004,my %base_metaclass = (
0.000000,0,0.000000,attribute_metaclass      => 'Class::MOP::Attribute',
0.000000,0,0.000000,method_metaclass         => 'Class::MOP::Method',
0.000000,0,0.000000,wrapped_method_metaclass => 'Class::MOP::Method::Wrapped',
0.000000,0,0.000000,instance_metaclass       => 'Class::MOP::Instance',
0.000000,0,0.000000,constructor_class        => 'Class::MOP::Method::Constructor',
0.000000,0,0.000000,destructor_class         => 'Class::MOP::Method::Destructor',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000582,84,0.000007,sub _base_metaclasses { %base_metaclass }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_metaclass_compatibility {
0.000108,72,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000568,72,0.000008,my @superclasses = $self->superclasses
0.000000,0,0.000000,or return;
0.000000,0,0.000000,
0.000209,37,0.000006,$self->_fix_metaclass_incompatibility(@superclasses);
0.000000,0,0.000000,
0.000261,37,0.000007,my %base_metaclass = $self->_base_metaclasses;
0.000000,0,0.000000,
0.000000,0,0.000000,# this is always okay ...
0.000000,0,0.000000,return
0.000000,0,0.000000,if ref($self) eq 'Class::MOP::Class'
0.000000,0,0.000000,&& all {
0.001518,216,0.000007,my $meta = $self->$_;
0.000967,216,0.000004,!defined($meta) || $meta eq $base_metaclass{$_};
0.000000,0,0.000000,}
0.000304,37,0.000008,keys %base_metaclass;
0.000000,0,0.000000,
0.000003,1,0.000003,for my $superclass (@superclasses) {
0.000011,1,0.000011,$self->_check_class_metaclass_compatibility($superclass);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,for my $metaclass_type ( keys %base_metaclass ) {
0.000050,7,0.000007,next unless defined $self->$metaclass_type;
0.000032,7,0.000005,for my $superclass (@superclasses) {
0.000052,7,0.000007,$self->_check_single_metaclass_compatibility( $metaclass_type,
0.000000,0,0.000000,$superclass );
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_class_metaclass_compatibility {
0.000002,1,0.000002,my $self = shift;
0.000002,1,0.000002,my ( $superclass_name ) = @_;
0.000000,0,0.000000,
0.000013,1,0.000013,if (!$self->_class_metaclass_is_compatible($superclass_name)) {
0.000000,0,0.000000,my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
0.000000,0,0.000000,
0.000000,0,0.000000,my $super_meta_type = $super_meta->_real_ref_name;
0.000000,0,0.000000,
0.000000,0,0.000000,confess "The metaclass of " . $self->name . " ("
0.000000,0,0.000000,. (ref($self)) . ")" .  " is not compatible with "
0.000000,0,0.000000,. "the metaclass of its superclass, "
0.000000,0,0.000000,. $superclass_name . " (" . ($super_meta_type) . ")";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _class_metaclass_is_compatible {
0.000002,1,0.000002,my $self = shift;
0.000006,1,0.000006,my ( $superclass_name ) = @_;
0.000000,0,0.000000,
0.000005,1,0.000005,my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
0.000000,0,0.000000,|| return 1;
0.000000,0,0.000000,
0.000006,1,0.000006,my $super_meta_name = $super_meta->_real_ref_name;
0.000000,0,0.000000,
0.000010,1,0.000010,return $self->_is_compatible_with($super_meta_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _check_single_metaclass_compatibility {
0.000011,7,0.000002,my $self = shift;
0.000012,7,0.000002,my ( $metaclass_type, $superclass_name ) = @_;
0.000000,0,0.000000,
0.000058,7,0.000008,if (!$self->_single_metaclass_is_compatible($metaclass_type, $superclass_name)) {
0.000000,0,0.000000,my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name);
0.000000,0,0.000000,my $metaclass_type_name = $metaclass_type;
0.000000,0,0.000000,$metaclass_type_name =~ s/_(?:meta)?class$//;
0.000000,0,0.000000,$metaclass_type_name =~ s/_/ /g;
0.000000,0,0.000000,confess "The $metaclass_type_name metaclass for "
0.000000,0,0.000000,. $self->name . " (" . ($self->$metaclass_type)
0.000000,0,0.000000,. ")" . " is not compatible with the "
0.000000,0,0.000000,. "$metaclass_type_name metaclass of its "
0.000000,0,0.000000,. "superclass, $superclass_name ("
0.000000,0,0.000000,. ($super_meta->$metaclass_type) . ")";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _single_metaclass_is_compatible {
0.000010,7,0.000001,my $self = shift;
0.000011,7,0.000002,my ( $metaclass_type, $superclass_name ) = @_;
0.000000,0,0.000000,
0.000034,7,0.000005,my $super_meta = Class::MOP::get_metaclass_by_name($superclass_name)
0.000000,0,0.000000,|| return 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# for instance, Moose::Meta::Class has a error_class attribute, but
0.000000,0,0.000000,# Class::MOP::Class doesn't - this shouldn't be an error
0.000052,7,0.000007,return 1 unless $super_meta->can($metaclass_type);
0.000000,0,0.000000,# for instance, Moose::Meta::Class has a destructor_class, but
0.000000,0,0.000000,# Class::MOP::Class doesn't - this shouldn't be an error
0.000046,7,0.000007,return 1 unless defined $super_meta->$metaclass_type;
0.000000,0,0.000000,# if metaclass is defined in superclass but not here, it's not compatible
0.000000,0,0.000000,# this is a really odd case
0.000047,7,0.000007,return 0 unless defined $self->$metaclass_type;
0.000000,0,0.000000,
0.000132,7,0.000019,return $self->$metaclass_type->_is_compatible_with($super_meta->$metaclass_type);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fix_metaclass_incompatibility {
0.000057,37,0.000002,my $self = shift;
0.000426,84,0.000005,my @supers = map { Class::MOP::Class->initialize($_) } @_;
0.000000,0,0.000000,
0.000056,37,0.000002,my $necessary = 0;
0.000120,37,0.000003,for my $super (@supers) {
0.000341,47,0.000007,$necessary = 1
0.000000,0,0.000000,if $self->_can_fix_metaclass_incompatibility($super);
0.000000,0,0.000000,}
0.000188,37,0.000005,return unless $necessary;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $super (@supers) {
0.000000,0,0.000000,if (!$self->_class_metaclass_is_compatible($super->name)) {
0.000000,0,0.000000,$self->_fix_class_metaclass_incompatibility($super);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my %base_metaclass = $self->_base_metaclasses;
0.000000,0,0.000000,for my $metaclass_type (keys %base_metaclass) {
0.000000,0,0.000000,for my $super (@supers) {
0.000000,0,0.000000,if (!$self->_single_metaclass_is_compatible($metaclass_type, $super->name)) {
0.000000,0,0.000000,$self->_fix_single_metaclass_incompatibility(
0.000000,0,0.000000,$metaclass_type, $super
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _can_fix_metaclass_incompatibility {
0.000069,47,0.000001,my $self = shift;
0.000073,47,0.000002,my ($super_meta) = @_;
0.000000,0,0.000000,
0.000250,47,0.000005,return 1 if $self->_class_metaclass_can_be_made_compatible($super_meta);
0.000000,0,0.000000,
0.000326,47,0.000007,my %base_metaclass = $self->_base_metaclasses;
0.000189,47,0.000004,for my $metaclass_type (keys %base_metaclass) {
0.001914,283,0.000007,return 1 if $self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000270,47,0.000006,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _class_metaclass_can_be_made_compatible {
0.000066,47,0.000001,my $self = shift;
0.000068,47,0.000001,my ($super_meta) = @_;
0.000000,0,0.000000,
0.000624,47,0.000013,return $self->_can_be_made_compatible_with($super_meta->_real_ref_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _single_metaclass_can_be_made_compatible {
0.000419,283,0.000001,my $self = shift;
0.000448,283,0.000002,my ($super_meta, $metaclass_type) = @_;
0.000000,0,0.000000,
0.002182,283,0.000008,my $specific_meta = $self->$metaclass_type;
0.000000,0,0.000000,
0.001939,283,0.000007,return unless $super_meta->can($metaclass_type);
0.001868,283,0.000007,my $super_specific_meta = $super_meta->$metaclass_type;
0.000000,0,0.000000,
0.000000,0,0.000000,# for instance, Moose::Meta::Class has a destructor_class, but
0.000000,0,0.000000,# Class::MOP::Class doesn't - this shouldn't be an error
0.000569,283,0.000002,return unless defined $super_specific_meta;
0.000000,0,0.000000,
0.000000,0,0.000000,# if metaclass is defined in superclass but not here, it's fixable
0.000000,0,0.000000,# this is a really odd case
0.000319,237,0.000001,return 1 unless defined $specific_meta;
0.000000,0,0.000000,
0.009493,237,0.000040,return 1 if $specific_meta->_can_be_made_compatible_with($super_specific_meta);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fix_class_metaclass_incompatibility {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $super_meta ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->_class_metaclass_can_be_made_compatible($super_meta)) {
0.000000,0,0.000000,($self->is_pristine)
0.000000,0,0.000000,|| confess "Can't fix metaclass incompatibility for "
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. " because it is not pristine.";
0.000000,0,0.000000,
0.000000,0,0.000000,my $super_meta_name = $super_meta->_real_ref_name;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_make_compatible_with($super_meta_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fix_single_metaclass_incompatibility {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ( $metaclass_type, $super_meta ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($self->_single_metaclass_can_be_made_compatible($super_meta, $metaclass_type)) {
0.000000,0,0.000000,($self->is_pristine)
0.000000,0,0.000000,|| confess "Can't fix metaclass incompatibility for "
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. " because it is not pristine.";
0.000000,0,0.000000,
0.000000,0,0.000000,my $new_metaclass = $self->$metaclass_type
0.000000,0,0.000000,? $self->$metaclass_type->_get_compatible_metaclass($super_meta->$metaclass_type)
0.000000,0,0.000000,: $super_meta->$metaclass_type;
0.000000,0,0.000000,$self->{$metaclass_type} = $new_metaclass;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _restore_metaobjects_from {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($old_meta) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_restore_metamethods_from($old_meta);
0.000000,0,0.000000,$self->_restore_metaattributes_from($old_meta);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remove_generated_metaobjects {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $attr (map { $self->get_attribute($_) } $self->get_attribute_list) {
0.000000,0,0.000000,$attr->remove_accessors;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# creating classes with MOP ...
0.000000,0,0.000000,
0.000000,0,0.000000,sub create {
0.000003,2,0.000002,my $class = shift;
0.000005,2,0.000002,my @args = @_;
0.000000,0,0.000000,
0.000005,2,0.000003,unshift @args, 'package' if @args % 2 == 1;
0.000006,2,0.000003,my %options = @args;
0.000000,0,0.000000,
0.000005,2,0.000003,(ref $options{superclasses} eq 'ARRAY')
0.000000,0,0.000000,|| confess "You must pass an ARRAY ref of superclasses"
0.000000,0,0.000000,if exists $options{superclasses};
0.000000,0,0.000000,
0.000003,2,0.000002,(ref $options{attributes} eq 'ARRAY')
0.000000,0,0.000000,|| confess "You must pass an ARRAY ref of attributes"
0.000000,0,0.000000,if exists $options{attributes};
0.000000,0,0.000000,
0.000004,2,0.000002,(ref $options{methods} eq 'HASH')
0.000000,0,0.000000,|| confess "You must pass a HASH ref of methods"
0.000000,0,0.000000,if exists $options{methods};
0.000000,0,0.000000,
0.000005,2,0.000002,my $package      = delete $options{package};
0.000003,2,0.000002,my $superclasses = delete $options{superclasses};
0.000003,2,0.000002,my $attributes   = delete $options{attributes};
0.000003,2,0.000002,my $methods      = delete $options{methods};
0.000004,2,0.000002,my $meta_name    = exists $options{meta_name}
0.000000,0,0.000000,? delete $options{meta_name}
0.000000,0,0.000000,: 'meta';
0.000000,0,0.000000,
0.000018,2,0.000009,my $meta = $class->SUPER::create($package => %options);
0.000000,0,0.000000,
0.000016,2,0.000008,$meta->_add_meta_method($meta_name)
0.000000,0,0.000000,if defined $meta_name;
0.000000,0,0.000000,
0.000012,2,0.000006,$meta->superclasses(@{$superclasses})
0.000000,0,0.000000,if defined $superclasses;
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# process attributes first, so that they can
0.000000,0,0.000000,# install accessors, but locally defined methods
0.000000,0,0.000000,# can then overwrite them. It is maybe a little odd, but
0.000000,0,0.000000,# I think this should be the order of things.
0.000003,2,0.000002,if (defined $attributes) {
0.000000,0,0.000000,foreach my $attr (@{$attributes}) {
0.000000,0,0.000000,$meta->add_attribute($attr);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000003,2,0.000002,if (defined $methods) {
0.000000,0,0.000000,foreach my $method_name (keys %{$methods}) {
0.000000,0,0.000000,$meta->add_method($method_name, $methods->{$method_name});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000013,2,0.000007,return $meta;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: something more intelligent here?
0.000000,0,0.000000,sub _anon_package_prefix { 'Class::MOP::Class::__ANON__::SERIAL::' }
0.000000,0,0.000000,
0.000000,0,0.000000,sub create_anon_class { shift->create_anon(@_) }
0.000000,0,0.000000,sub is_anon_class     { shift->is_anon(@_)     }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _anon_cache_key {
0.000000,0,0.000000,my $class = shift;
0.000000,0,0.000000,my %options = @_;
0.000000,0,0.000000,# Makes something like Super::Class|Super::Class::2
0.000000,0,0.000000,return join '=' => (
0.000000,0,0.000000,join( '|', sort @{ $options{superclasses} || [] } ),
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Instance Construction & Cloning
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_object {
0.000065,41,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we need to protect the integrity of the
0.000000,0,0.000000,# Class::MOP::Class singletons here, so we
0.000000,0,0.000000,# delegate this to &construct_class_instance
0.000000,0,0.000000,# which will deal with the singletons
0.000622,41,0.000015,return $class->_construct_class_instance(@_)
0.000000,0,0.000000,if $class->name->isa('Class::MOP::Class');
0.000357,41,0.000009,return $class->_construct_instance(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _construct_instance {
0.000067,43,0.000002,my $class = shift;
0.000080,43,0.000002,my $params = @_ == 1 ? $_[0] : {@_};
0.000231,43,0.000005,my $meta_instance = $class->get_meta_instance();
0.000000,0,0.000000,# FIXME:
0.000000,0,0.000000,# the code below is almost certainly incorrect
0.000000,0,0.000000,# but this is foreign inheritance, so we might
0.000000,0,0.000000,# have to kludge it in the end.
0.000061,43,0.000001,my $instance;
0.000485,43,0.000011,if (my $instance_class = blessed($params->{__INSTANCE__})) {
0.000000,0,0.000000,($instance_class eq $class->name)
0.000000,0,0.000000,|| confess "Objects passed as the __INSTANCE__ parameter must "
0.000000,0,0.000000,. "already be blessed into the correct class, but "
0.000000,0,0.000000,. "$params->{__INSTANCE__} is not a " . $class->name;
0.000000,0,0.000000,$instance = $params->{__INSTANCE__};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (exists $params->{__INSTANCE__}) {
0.000000,0,0.000000,confess "The __INSTANCE__ parameter must be a blessed reference, not "
0.000000,0,0.000000,. $params->{__INSTANCE__};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000264,43,0.000006,$instance = $meta_instance->create_instance();
0.000000,0,0.000000,}
0.000322,43,0.000007,foreach my $attr ($class->get_all_attributes()) {
0.002155,317,0.000007,$attr->initialize_instance_slot($meta_instance, $instance, $params);
0.000000,0,0.000000,}
0.000456,43,0.000011,if (Class::MOP::metaclass_is_weak($class->name)) {
0.000000,0,0.000000,$meta_instance->_set_mop_slot($instance, $class);
0.000000,0,0.000000,}
0.000222,43,0.000005,return $instance;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_new_object {
0.000054,31,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.000924,31,0.000030,'my $class = shift;',
0.000000,0,0.000000,'$class = Scalar::Util::blessed($class) || $class;',
0.000000,0,0.000000,$self->_inline_fallback_constructor('$class'),
0.000000,0,0.000000,$self->_inline_params('$params', '$class'),
0.000000,0,0.000000,$self->_inline_generate_instance('$instance', '$class'),
0.000000,0,0.000000,$self->_inline_slot_initializers,
0.000000,0,0.000000,$self->_inline_preserve_weak_metaclasses,
0.000000,0,0.000000,$self->_inline_extra_init,
0.000000,0,0.000000,'return $instance',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_fallback_constructor {
0.000044,31,0.000001,my $self = shift;
0.000052,31,0.000002,my ($class) = @_;
0.000000,0,0.000000,return (
0.000472,31,0.000015,'return ' . $self->_generate_fallback_constructor($class),
0.000000,0,0.000000,'if ' . $class . ' ne \'' . $self->name . '\';',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_fallback_constructor {
0.000044,30,0.000001,my $self = shift;
0.000046,30,0.000002,my ($class) = @_;
0.000184,30,0.000006,return 'Class::MOP::Class->initialize(' . $class . ')->new_object(@_)',
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_params {
0.000049,30,0.000002,my $self = shift;
0.000053,30,0.000002,my ($params, $class) = @_;
0.000000,0,0.000000,return (
0.000166,30,0.000006,'my ' . $params . ' = @_ == 1 ? $_[0] : {@_};',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_generate_instance {
0.000048,31,0.000002,my $self = shift;
0.000052,31,0.000002,my ($inst, $class) = @_;
0.000000,0,0.000000,return (
0.000275,31,0.000009,'my ' . $inst . ' = ' . $self->_inline_create_instance($class) . ';',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_create_instance {
0.000043,31,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000374,31,0.000012,return $self->get_meta_instance->inline_create_instance(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_slot_initializers {
0.000048,31,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000045,31,0.000001,my $idx = 0;
0.000000,0,0.000000,
0.017098,1062,0.000016,return map { $self->_inline_slot_initializer($_, $idx++) }
0.000897,31,0.000029,sort { $a->name cmp $b->name } $self->get_all_attributes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_slot_initializer {
0.000442,294,0.000002,my $self  = shift;
0.000450,294,0.000002,my ($attr, $idx) = @_;
0.000000,0,0.000000,
0.002200,294,0.000007,if (defined(my $init_arg = $attr->init_arg)) {
0.001715,282,0.000006,my @source = (
0.000000,0,0.000000,'if (exists $params->{\'' . $init_arg . '\'}) {',
0.000000,0,0.000000,$self->_inline_init_attr_from_constructor($attr, $idx),
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.001628,282,0.000006,if (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
0.000000,0,0.000000,push @source, (
0.000000,0,0.000000,'else {',
0.000000,0,0.000000,@default,
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.001739,282,0.000006,return @source;
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (my @default = $self->_inline_init_attr_from_default($attr, $idx)) {
0.000000,0,0.000000,return (
0.000000,0,0.000000,'{',
0.000000,0,0.000000,@default,
0.000000,0,0.000000,'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000012,2,0.000006,return ();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_init_attr_from_constructor {
0.000396,275,0.000001,my $self = shift;
0.000416,275,0.000002,my ($attr, $idx) = @_;
0.000000,0,0.000000,
0.002969,275,0.000011,my @initial_value = $attr->_inline_set_value(
0.000000,0,0.000000,'$instance', '$params->{\'' . $attr->init_arg . '\'}',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.001409,275,0.000005,push @initial_value, (
0.000000,0,0.000000,'$attrs->[' . $idx . ']->set_initial_value(',
0.000000,0,0.000000,'$instance,',
0.000000,0,0.000000,$attr->_inline_instance_get('$instance'),
0.000000,0,0.000000,');',
0.000000,0,0.000000,) if $attr->has_initializer;
0.000000,0,0.000000,
0.001502,275,0.000005,return @initial_value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_init_attr_from_default {
0.000423,286,0.000001,my $self = shift;
0.000438,286,0.000002,my ($attr, $idx) = @_;
0.000000,0,0.000000,
0.001433,286,0.000005,my $default = $self->_inline_default_value($attr, $idx);
0.000984,286,0.000003,return unless $default;
0.000000,0,0.000000,
0.000544,96,0.000006,my @initial_value = $attr->_inline_set_value('$instance', $default);
0.000000,0,0.000000,
0.000487,96,0.000005,push @initial_value, (
0.000000,0,0.000000,'$attrs->[' . $idx . ']->set_initial_value(',
0.000000,0,0.000000,'$instance,',
0.000000,0,0.000000,$attr->_inline_instance_get('$instance'),
0.000000,0,0.000000,');',
0.000000,0,0.000000,) if $attr->has_initializer;
0.000000,0,0.000000,
0.000525,96,0.000005,return @initial_value;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_default_value {
0.000408,292,0.000001,my $self = shift;
0.000421,292,0.000001,my ($attr, $index) = @_;
0.000000,0,0.000000,
0.002736,292,0.000009,if ($attr->has_default) {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# default values can either be CODE refs
0.000000,0,0.000000,# in which case we need to call them. Or
0.000000,0,0.000000,# they can be scalars (strings/numbers)
0.000000,0,0.000000,# in which case we can just deal with them
0.000000,0,0.000000,# in the code we eval.
0.000000,0,0.000000,if ($attr->is_default_a_coderef) {
0.000000,0,0.000000,return '$defaults->[' . $index . ']->($instance)';
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000190,34,0.000006,return '$defaults->[' . $index . ']';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($attr->has_builder) {
0.000000,0,0.000000,return '$instance->' . $attr->builder;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000882,191,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_preserve_weak_metaclasses {
0.000050,31,0.000002,my $self = shift;
0.000327,31,0.000011,if (Class::MOP::metaclass_is_weak($self->name)) {
0.000000,0,0.000000,return (
0.000000,0,0.000000,$self->_inline_set_mop_slot(
0.000000,0,0.000000,'$instance', 'Class::MOP::class_of($class)'
0.000000,0,0.000000,) . ';'
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000152,31,0.000005,return ();
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000133,30,0.000004,sub _inline_extra_init { }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _eval_environment {
0.000048,31,0.000002,my $self = shift;
0.000000,0,0.000000,
0.013850,807,0.000017,my @attrs = sort { $a->name cmp $b->name } $self->get_all_attributes;
0.000000,0,0.000000,
0.002017,325,0.000006,my $defaults = [map { $_->default } @attrs];
0.000000,0,0.000000,
0.000000,0,0.000000,return {
0.000220,31,0.000007,'$defaults' => \$defaults,
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_meta_instance {
0.000484,334,0.000001,my $self = shift;
0.001923,334,0.000006,$self->{'_meta_instance'} ||= $self->_create_meta_instance();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _create_meta_instance {
0.000079,55,0.000001,my $self = shift;
0.000000,0,0.000000,
0.000884,55,0.000016,my $instance = $self->instance_metaclass->new(
0.000000,0,0.000000,associated_metaclass => $self,
0.000000,0,0.000000,attributes => [ $self->get_all_attributes() ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000314,55,0.000006,$self->add_meta_instance_dependencies()
0.000000,0,0.000000,if $instance->is_dependent_on_superclasses();
0.000000,0,0.000000,
0.000267,55,0.000005,return $instance;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# TODO: this is actually not being used!
0.000000,0,0.000000,sub _inline_rebless_instance {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->get_meta_instance->inline_rebless_instance_structure(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_get_mop_slot {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->get_meta_instance->_inline_get_mop_slot(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_set_mop_slot {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->get_meta_instance->_inline_set_mop_slot(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_clear_mop_slot {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->get_meta_instance->_inline_clear_mop_slot(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub clone_object {
0.000000,0,0.000000,my $class    = shift;
0.000000,0,0.000000,my $instance = shift;
0.000000,0,0.000000,(blessed($instance) && $instance->isa($class->name))
0.000000,0,0.000000,|| confess "You must pass an instance of the metaclass (" . (ref $class ? $class->name : $class) . "), not ($instance)";
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we need to protect the integrity of the
0.000000,0,0.000000,# Class::MOP::Class singletons here, they
0.000000,0,0.000000,# should not be cloned.
0.000000,0,0.000000,return $instance if $instance->isa('Class::MOP::Class');
0.000000,0,0.000000,$class->_clone_instance($instance, @_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _clone_instance {
0.000000,0,0.000000,my ($class, $instance, %params) = @_;
0.000000,0,0.000000,(blessed($instance))
0.000000,0,0.000000,|| confess "You can only clone instances, ($instance) is not a blessed instance";
0.000000,0,0.000000,my $meta_instance = $class->get_meta_instance();
0.000000,0,0.000000,my $clone = $meta_instance->clone_instance($instance);
0.000000,0,0.000000,foreach my $attr ($class->get_all_attributes()) {
0.000000,0,0.000000,if ( defined( my $init_arg = $attr->init_arg ) ) {
0.000000,0,0.000000,if (exists $params{$init_arg}) {
0.000000,0,0.000000,$attr->set_value($clone, $params{$init_arg});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,return $clone;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _force_rebless_instance {
0.000000,0,0.000000,my ($self, $instance, %params) = @_;
0.000000,0,0.000000,my $old_metaclass = Class::MOP::class_of($instance);
0.000000,0,0.000000,
0.000000,0,0.000000,$old_metaclass->rebless_instance_away($instance, $self, %params)
0.000000,0,0.000000,if $old_metaclass;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meta_instance = $self->get_meta_instance;
0.000000,0,0.000000,
0.000000,0,0.000000,if (Class::MOP::metaclass_is_weak($old_metaclass->name)) {
0.000000,0,0.000000,$meta_instance->_clear_mop_slot($instance);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# rebless!
0.000000,0,0.000000,# we use $_[1] here because of t/cmop/rebless_overload.t regressions
0.000000,0,0.000000,# on 5.8.8
0.000000,0,0.000000,$meta_instance->rebless_instance_structure($_[1], $self);
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_fixup_attributes_after_rebless($instance, $old_metaclass, %params);
0.000000,0,0.000000,
0.000000,0,0.000000,if (Class::MOP::metaclass_is_weak($self->name)) {
0.000000,0,0.000000,$meta_instance->_set_mop_slot($instance, $self);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub rebless_instance {
0.000000,0,0.000000,my ($self, $instance, %params) = @_;
0.000000,0,0.000000,my $old_metaclass = Class::MOP::class_of($instance);
0.000000,0,0.000000,
0.000000,0,0.000000,my $old_class = $old_metaclass ? $old_metaclass->name : blessed($instance);
0.000000,0,0.000000,$self->name->isa($old_class)
0.000000,0,0.000000,|| confess "You may rebless only into a subclass of ($old_class), of which (". $self->name .") isn't.";
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_force_rebless_instance($_[1], %params);
0.000000,0,0.000000,
0.000000,0,0.000000,return $instance;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub rebless_instance_back {
0.000000,0,0.000000,my ( $self, $instance ) = @_;
0.000000,0,0.000000,my $old_metaclass = Class::MOP::class_of($instance);
0.000000,0,0.000000,
0.000000,0,0.000000,my $old_class
0.000000,0,0.000000,= $old_metaclass ? $old_metaclass->name : blessed($instance);
0.000000,0,0.000000,$old_class->isa( $self->name )
0.000000,0,0.000000,|| confess
0.000000,0,0.000000,"You may rebless only into a superclass of ($old_class), of which ("
0.000000,0,0.000000,. $self->name
0.000000,0,0.000000,. ") isn't.";
0.000000,0,0.000000,
0.000000,0,0.000000,$self->_force_rebless_instance($_[1]);
0.000000,0,0.000000,
0.000000,0,0.000000,return $instance;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub rebless_instance_away {
0.000000,0,0.000000,# this intentionally does nothing, it is just a hook
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _fixup_attributes_after_rebless {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($instance, $rebless_from, %params) = @_;
0.000000,0,0.000000,my $meta_instance = $self->get_meta_instance;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $attr ( $rebless_from->get_all_attributes ) {
0.000000,0,0.000000,next if $self->find_attribute_by_name( $attr->name );
0.000000,0,0.000000,$meta_instance->deinitialize_slot( $instance, $_ ) for $attr->slots;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attr ( $self->get_all_attributes ) {
0.000000,0,0.000000,if ( $attr->has_value($instance) ) {
0.000000,0,0.000000,if ( defined( my $init_arg = $attr->init_arg ) ) {
0.000000,0,0.000000,$params{$init_arg} = $attr->get_value($instance)
0.000000,0,0.000000,unless exists $params{$init_arg};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$attr->set_value($instance, $attr->get_value($instance));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $attr ($self->get_all_attributes) {
0.000000,0,0.000000,$attr->initialize_instance_slot($meta_instance, $instance, \%params);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _attach_attribute {
0.000214,131,0.000002,my ($self, $attribute) = @_;
0.001037,131,0.000008,$attribute->attach_to_class($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _post_add_attribute {
0.000217,131,0.000002,my ( $self, $attribute ) = @_;
0.000000,0,0.000000,
0.000651,131,0.000005,$self->invalidate_meta_instances;
0.000000,0,0.000000,
0.000000,0,0.000000,# invalidate package flag here
0.000000,0,0.000000,try {
0.000380,131,0.000003,local $SIG{__DIE__};
0.001201,131,0.000009,$attribute->install_accessors;
0.000000,0,0.000000,}
0.000000,0,0.000000,catch {
0.000000,0,0.000000,$self->remove_attribute( $attribute->name );
0.000000,0,0.000000,die $_;
0.001913,131,0.000015,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_attribute {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $removed_attribute = $self->SUPER::remove_attribute(@_)
0.000000,0,0.000000,or return;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->invalidate_meta_instances;
0.000000,0,0.000000,
0.000000,0,0.000000,$removed_attribute->remove_accessors;
0.000000,0,0.000000,$removed_attribute->detach_from_class;
0.000000,0,0.000000,
0.000000,0,0.000000,return$removed_attribute;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_attribute_by_name {
0.000093,54,0.000002,my ( $self, $attr_name ) = @_;
0.000000,0,0.000000,
0.000282,54,0.000005,foreach my $class ( $self->linearized_isa ) {
0.000000,0,0.000000,# fetch the meta-class ...
0.000295,54,0.000005,my $meta = Class::MOP::Class->initialize($class);
0.000697,54,0.000013,return $meta->get_attribute($attr_name)
0.000000,0,0.000000,if $meta->has_attribute($attr_name);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_attributes {
0.000197,134,0.000001,my $self = shift;
0.008681,1088,0.000008,my %attrs = map { %{ Class::MOP::Class->initialize($_)->_attribute_map } }
0.000000,0,0.000000,reverse $self->linearized_isa;
0.000914,134,0.000007,return values %attrs;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Inheritance
0.000000,0,0.000000,
0.000000,0,0.000000,sub superclasses {
0.000116,79,0.000001,my $self     = shift;
0.000000,0,0.000000,
0.000471,79,0.000006,my $isa = $self->get_or_add_package_symbol('@ISA');
0.000000,0,0.000000,
0.000129,79,0.000002,if (@_) {
0.000007,3,0.000002,my @supers = @_;
0.000042,3,0.000014,@{$isa} = @supers;
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# on 5.8 and below, we need to call
0.000000,0,0.000000,# a method to get Perl to detect
0.000000,0,0.000000,# a cycle in the class hierarchy
0.000025,3,0.000008,my $class = $self->name;
0.000050,3,0.000017,$class->isa($class);
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we need to check the metaclass
0.000000,0,0.000000,# compatibility here so that we can
0.000000,0,0.000000,# be sure that the superclass is
0.000000,0,0.000000,# not potentially creating an issues
0.000000,0,0.000000,# we don't know about
0.000000,0,0.000000,
0.000019,3,0.000006,$self->_check_metaclass_compatibility();
0.000021,3,0.000007,$self->_superclasses_updated();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000450,79,0.000006,return @{$isa};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _superclasses_updated {
0.000005,3,0.000002,my $self = shift;
0.000019,3,0.000006,$self->update_meta_instance_dependencies();
0.000000,0,0.000000,# keep strong references to all our parents, so they don't disappear if
0.000000,0,0.000000,# they are anon classes and don't have any direct instances
0.000018,3,0.000006,$self->_superclass_metas(
0.000048,3,0.000016,map { Class::MOP::class_of($_) } $self->superclasses
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _superclass_metas {
0.000005,3,0.000002,my $self = shift;
0.000019,3,0.000006,$self->{_superclass_metas} = [@_];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub subclasses {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $super_class = $self->name;
0.000000,0,0.000000,
0.000000,0,0.000000,return @{ $super_class->mro::get_isarev() };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub direct_subclasses {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $super_class = $self->name;
0.000000,0,0.000000,
0.000000,0,0.000000,return grep {
0.000000,0,0.000000,grep {
0.000000,0,0.000000,$_ eq $super_class
0.000000,0,0.000000,} Class::MOP::Class->initialize($_)->superclasses
0.000000,0,0.000000,} $self->subclasses;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub linearized_isa {
0.005346,316,0.000017,return @{ mro::get_linear_isa( (shift)->name ) };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub class_precedence_list {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $name = $self->name;
0.000000,0,0.000000,
0.000000,0,0.000000,unless (Class::MOP::IS_RUNNING_ON_5_10()) {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# We need to check for circular inheritance here
0.000000,0,0.000000,# if we are not on 5.10, cause 5.8 detects it late.
0.000000,0,0.000000,# This will do nothing if all is well, and blow up
0.000000,0,0.000000,# otherwise. Yes, it's an ugly hack, better
0.000000,0,0.000000,# suggestions are welcome.
0.000000,0,0.000000,# - SL
0.000000,0,0.000000,($name || return)->isa('This is a test for circular inheritance')
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# if our mro is c3, we can
0.000000,0,0.000000,# just grab the linear_isa
0.000000,0,0.000000,if (mro::get_mro($name) eq 'c3') {
0.000000,0,0.000000,return @{ mro::get_linear_isa($name) }
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# we can't grab the linear_isa for dfs
0.000000,0,0.000000,# since it has all the duplicates
0.000000,0,0.000000,# already removed.
0.000000,0,0.000000,return (
0.000000,0,0.000000,$name,
0.000000,0,0.000000,map {
0.000000,0,0.000000,Class::MOP::Class->initialize($_)->class_precedence_list()
0.000000,0,0.000000,} $self->superclasses()
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _method_lookup_order {
0.001477,178,0.000008,return (shift->linearized_isa, 'UNIVERSAL');
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Methods
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000003,1,0.000003,my $fetch_and_prepare_method = sub {
0.000071,44,0.000002,my ($self, $method_name) = @_;
0.000337,44,0.000008,my $wrapped_metaclass = $self->wrapped_method_metaclass;
0.000000,0,0.000000,# fetch it locally
0.000221,44,0.000005,my $method = $self->get_method($method_name);
0.000000,0,0.000000,# if we don't have local ...
0.000142,44,0.000003,unless ($method) {
0.000000,0,0.000000,# try to find the next method
0.000238,44,0.000005,$method = $self->find_next_method_by_name($method_name);
0.000000,0,0.000000,# die if it does not exist
0.000063,44,0.000001,(defined $method)
0.000000,0,0.000000,|| confess "The method '$method_name' was not found in the inheritance hierarchy for " . $self->name;
0.000000,0,0.000000,# and now make sure to wrap it
0.000000,0,0.000000,# even if it is already wrapped
0.000000,0,0.000000,# because we need a new sub ref
0.000508,44,0.000012,$method = $wrapped_metaclass->wrap($method,
0.000000,0,0.000000,package_name => $self->name,
0.000000,0,0.000000,name         => $method_name,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# now make sure we wrap it properly
0.000000,0,0.000000,$method = $wrapped_metaclass->wrap($method,
0.000000,0,0.000000,package_name => $self->name,
0.000000,0,0.000000,name         => $method_name,
0.000000,0,0.000000,) unless $method->isa($wrapped_metaclass);
0.000000,0,0.000000,}
0.000237,44,0.000005,$self->add_method($method_name => $method);
0.000281,44,0.000006,return $method;
0.000004,1,0.000004,};
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_before_method_modifier {
0.000000,0,0.000000,my ($self, $method_name, $method_modifier) = @_;
0.000000,0,0.000000,(defined $method_name && length $method_name)
0.000000,0,0.000000,|| confess "You must pass in a method name";
0.000000,0,0.000000,my $method = $fetch_and_prepare_method->($self, $method_name);
0.000000,0,0.000000,$method->add_before_modifier(
0.000000,0,0.000000,subname(':before' => $method_modifier)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_after_method_modifier {
0.000000,0,0.000000,my ($self, $method_name, $method_modifier) = @_;
0.000000,0,0.000000,(defined $method_name && length $method_name)
0.000000,0,0.000000,|| confess "You must pass in a method name";
0.000000,0,0.000000,my $method = $fetch_and_prepare_method->($self, $method_name);
0.000000,0,0.000000,$method->add_after_modifier(
0.000000,0,0.000000,subname(':after' => $method_modifier)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_around_method_modifier {
0.000084,44,0.000002,my ($self, $method_name, $method_modifier) = @_;
0.000073,44,0.000002,(defined $method_name && length $method_name)
0.000000,0,0.000000,|| confess "You must pass in a method name";
0.000236,44,0.000005,my $method = $fetch_and_prepare_method->($self, $method_name);
0.000698,44,0.000016,$method->add_around_modifier(
0.000000,0,0.000000,subname(':around' => $method_modifier)
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# NOTE:
0.000000,0,0.000000,# the methods above used to be named like this:
0.000000,0,0.000000,#    ${pkg}::${method}:(before|after|around)
0.000000,0,0.000000,# but this proved problematic when using one modifier
0.000000,0,0.000000,# to wrap multiple methods (something which is likely
0.000000,0,0.000000,# to happen pretty regularly IMO). So instead of naming
0.000000,0,0.000000,# it like this, I have chosen to just name them purely
0.000000,0,0.000000,# with their modifier names, like so:
0.000000,0,0.000000,#    :(before|after|around)
0.000000,0,0.000000,# The fact is that in a stack trace, it will be fairly
0.000000,0,0.000000,# evident from the context what method they are attached
0.000000,0,0.000000,# to, and so don't need the fully qualified name.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_method_by_name {
0.000157,92,0.000002,my ($self, $method_name) = @_;
0.000155,92,0.000002,(defined $method_name && length $method_name)
0.000000,0,0.000000,|| confess "You must define a method name to find";
0.000576,92,0.000006,foreach my $class ($self->_method_lookup_order) {
0.003053,336,0.000009,my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
0.001161,336,0.000003,return $method if defined $method;
0.000000,0,0.000000,}
0.000210,44,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_methods {
0.000013,8,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000012,8,0.000002,my %methods;
0.000062,8,0.000008,for my $class ( reverse $self->_method_lookup_order ) {
0.000089,17,0.000005,my $meta = Class::MOP::Class->initialize($class);
0.000000,0,0.000000,
0.000826,17,0.000049,$methods{ $_->name } = $_ for $meta->_get_local_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000062,8,0.000008,return values %methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub get_all_method_names {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,map { $_->name } $self->get_all_methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_all_methods_by_name {
0.000004,2,0.000002,my ($self, $method_name) = @_;
0.000004,2,0.000002,(defined $method_name && length $method_name)
0.000000,0,0.000000,|| confess "You must define a method name to find";
0.000003,2,0.000002,my @methods;
0.000015,2,0.000007,foreach my $class ($self->_method_lookup_order) {
0.000000,0,0.000000,# fetch the meta-class ...
0.000032,6,0.000005,my $meta = Class::MOP::Class->initialize($class);
0.000048,6,0.000008,push @methods => {
0.000000,0,0.000000,name  => $method_name,
0.000000,0,0.000000,class => $class,
0.000000,0,0.000000,code  => $meta->get_method($method_name)
0.000000,0,0.000000,} if $meta->has_method($method_name);
0.000000,0,0.000000,}
0.000013,2,0.000007,return @methods;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub find_next_method_by_name {
0.000132,76,0.000002,my ($self, $method_name) = @_;
0.000149,76,0.000002,(defined $method_name && length $method_name)
0.000000,0,0.000000,|| confess "You must define a method name to find";
0.000473,76,0.000006,my @cpl = ($self->_method_lookup_order);
0.000119,76,0.000002,shift @cpl; # discard ourselves
0.000136,76,0.000002,foreach my $class (@cpl) {
0.001382,150,0.000009,my $method = Class::MOP::Class->initialize($class)->get_method($method_name);
0.000654,150,0.000004,return $method if defined $method;
0.000000,0,0.000000,}
0.000010,2,0.000005,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub update_meta_instance_dependencies {
0.000005,3,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000019,3,0.000006,if ( $self->{meta_instance_dependencies} ) {
0.000000,0,0.000000,return $self->add_meta_instance_dependencies;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_meta_instance_dependencies {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->remove_meta_instance_dependencies;
0.000000,0,0.000000,
0.000000,0,0.000000,my @attrs = $self->get_all_attributes();
0.000000,0,0.000000,
0.000000,0,0.000000,my %seen;
0.000000,0,0.000000,my @classes = grep { not $seen{ $_->name }++ }
0.000000,0,0.000000,map { $_->associated_class } @attrs;
0.000000,0,0.000000,
0.000000,0,0.000000,foreach my $class (@classes) {
0.000000,0,0.000000,$class->add_dependent_meta_instance($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{meta_instance_dependencies} = \@classes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_meta_instance_dependencies {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( my $classes = delete $self->{meta_instance_dependencies} ) {
0.000000,0,0.000000,foreach my $class (@$classes) {
0.000000,0,0.000000,$class->remove_dependent_meta_instance($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $classes;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub add_dependent_meta_instance {
0.000000,0,0.000000,my ( $self, $metaclass ) = @_;
0.000000,0,0.000000,push @{ $self->{dependent_meta_instances} }, $metaclass;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub remove_dependent_meta_instance {
0.000000,0,0.000000,my ( $self, $metaclass ) = @_;
0.000000,0,0.000000,my $name = $metaclass->name;
0.000000,0,0.000000,@$_ = grep { $_->name ne $name } @$_
0.000000,0,0.000000,for $self->{dependent_meta_instances};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub invalidate_meta_instances {
0.000192,131,0.000001,my $self = shift;
0.000000,0,0.000000,$_->invalidate_meta_instance()
0.001624,131,0.000012,for $self, @{ $self->{dependent_meta_instances} };
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub invalidate_meta_instance {
0.000186,131,0.000001,my $self = shift;
0.000716,131,0.000005,undef $self->{_meta_instance};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# check if we can reinitialize
0.000000,0,0.000000,sub is_pristine {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# if any local attr is defined
0.000000,0,0.000000,return if $self->get_attribute_list;
0.000000,0,0.000000,
0.000000,0,0.000000,# or any non-declared methods
0.000000,0,0.000000,for my $method ( map { $self->get_method($_) } $self->get_method_list ) {
0.000000,0,0.000000,return if $method->isa("Class::MOP::Method::Generated");
0.000000,0,0.000000,# FIXME do we need to enforce this too? return unless $method->isa( $self->method_metaclass );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Class closing
0.000000,0,0.000000,
0.000414,87,0.000005,sub is_mutable   { 1 }
0.000174,34,0.000005,sub is_immutable { 0 }
0.000000,0,0.000000,
0.000000,0,0.000000,sub immutable_options { %{ $_[0]{__immutable}{options} || {} } }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _immutable_options {
0.000131,54,0.000002,my ( $self, @args ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,return (
0.001536,54,0.000028,inline_accessors   => 1,
0.000000,0,0.000000,inline_constructor => 1,
0.000000,0,0.000000,inline_destructor  => 0,
0.000000,0,0.000000,debug              => 0,
0.000000,0,0.000000,immutable_trait    => $self->immutable_trait,
0.000000,0,0.000000,constructor_name   => $self->constructor_name,
0.000000,0,0.000000,constructor_class  => $self->constructor_class,
0.000000,0,0.000000,destructor_class   => $self->destructor_class,
0.000000,0,0.000000,@args,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_immutable {
0.000146,54,0.000003,my ( $self, @args ) = @_;
0.000000,0,0.000000,
0.000266,54,0.000005,return $self unless $self->is_mutable;
0.000000,0,0.000000,
0.000176,54,0.000003,my ($file, $line) = (caller)[1..2];
0.000000,0,0.000000,
0.000590,54,0.000011,$self->_initialize_immutable(
0.000000,0,0.000000,file => $file,
0.000000,0,0.000000,line => $line,
0.000000,0,0.000000,$self->_immutable_options(@args),
0.000000,0,0.000000,);
0.000309,54,0.000006,$self->_rebless_as_immutable(@args);
0.000000,0,0.000000,
0.000291,54,0.000005,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub make_mutable {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,if ( $self->is_immutable ) {
0.000000,0,0.000000,my @args = $self->immutable_options;
0.000000,0,0.000000,$self->_rebless_as_mutable();
0.000000,0,0.000000,$self->_remove_inlined_code(@args);
0.000000,0,0.000000,delete $self->{__immutable};
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _rebless_as_immutable {
0.000142,54,0.000003,my ( $self, @args ) = @_;
0.000000,0,0.000000,
0.000128,54,0.000002,$self->{__immutable}{original_class} = ref $self;
0.000000,0,0.000000,
0.000516,54,0.000010,bless $self => $self->_immutable_metaclass(@args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _immutable_metaclass {
0.000141,54,0.000003,my ( $self, %args ) = @_;
0.000000,0,0.000000,
0.000090,54,0.000002,if ( my $class = $args{immutable_metaclass} ) {
0.000000,0,0.000000,return $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000427,54,0.000008,my $trait = $args{immutable_trait} = $self->immutable_trait
0.000000,0,0.000000,|| confess "no immutable trait specified for $self";
0.000000,0,0.000000,
0.000303,54,0.000006,my $meta      = $self->meta;
0.000317,54,0.000006,my $meta_attr = $meta->find_attribute_by_name("immutable_trait");
0.000000,0,0.000000,
0.000076,54,0.000001,my $class_name;
0.000000,0,0.000000,
0.000347,54,0.000006,if ( $meta_attr and $trait eq $meta_attr->default ) {
0.000000,0,0.000000,# if the trait is the same as the default we try and pick a
0.000000,0,0.000000,# predictable name for the immutable metaclass
0.000000,0,0.000000,$class_name = 'Class::MOP::Class::Immutable::' . ref($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$class_name = join '::', 'Class::MOP::Class::Immutable::CustomTrait',
0.000000,0,0.000000,$trait, 'ForMetaClass', ref($self);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000798,54,0.000015,return $class_name
0.000000,0,0.000000,if is_class_loaded($class_name);
0.000000,0,0.000000,
0.000000,0,0.000000,# If the metaclass is a subclass of CMOP::Class which has had
0.000000,0,0.000000,# metaclass roles applied (via Moose), then we want to make sure
0.000000,0,0.000000,# that we preserve that anonymous class (see Fey::ORM for an
0.000000,0,0.000000,# example of where this matters).
0.000012,2,0.000006,my $meta_name = $meta->_real_ref_name;
0.000000,0,0.000000,
0.000015,2,0.000007,my $immutable_meta = $meta_name->create(
0.000000,0,0.000000,$class_name,
0.000000,0,0.000000,superclasses => [ ref $self ],
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000016,2,0.000008,Class::MOP::MiniTrait::apply( $immutable_meta, $trait );
0.000000,0,0.000000,
0.000015,2,0.000008,$immutable_meta->make_immutable(
0.000000,0,0.000000,inline_constructor => 0,
0.000000,0,0.000000,inline_accessors   => 0,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000013,2,0.000006,return $class_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _remove_inlined_code {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->remove_method( $_->name ) for $self->_inlined_methods;
0.000000,0,0.000000,
0.000000,0,0.000000,delete $self->{__immutable}{inlined_methods};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inlined_methods { @{ $_[0]{__immutable}{inlined_methods} || [] } }
0.000000,0,0.000000,
0.000000,0,0.000000,sub _add_inlined_method {
0.000052,32,0.000002,my ( $self, $method ) = @_;
0.000000,0,0.000000,
0.000220,32,0.000007,push @{ $self->{__immutable}{inlined_methods} ||= [] }, $method;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _initialize_immutable {
0.000346,54,0.000006,my ( $self, %args ) = @_;
0.000000,0,0.000000,
0.000139,54,0.000003,$self->{__immutable}{options} = \%args;
0.000524,54,0.000010,$self->_install_inlined_code(%args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _install_inlined_code {
0.000211,54,0.000004,my ( $self, %args ) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# FIXME
0.000257,54,0.000005,$self->_inline_accessors(%args)   if $args{inline_accessors};
0.000283,54,0.000005,$self->_inline_constructor(%args) if $args{inline_constructor};
0.000345,54,0.000006,$self->_inline_destructor(%args)  if $args{inline_destructor};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _rebless_as_mutable {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,bless $self, $self->_get_mutable_metaclass_name;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_accessors {
0.000051,33,0.000002,my $self = shift;
0.000000,0,0.000000,
0.000357,33,0.000011,foreach my $attr_name ( $self->get_attribute_list ) {
0.000804,76,0.000011,$self->get_attribute($attr_name)->install_accessors(1);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_constructor {
0.000144,31,0.000005,my ( $self, %args ) = @_;
0.000000,0,0.000000,
0.000052,31,0.000002,my $name = $args{constructor_name};
0.000000,0,0.000000,# A class may not even have a constructor, and that's okay.
0.000047,31,0.000002,return unless defined $name;
0.000000,0,0.000000,
0.000169,31,0.000005,if ( $self->has_method($name) && !$args{replace_constructor} ) {
0.000000,0,0.000000,my $class = $self->name;
0.000000,0,0.000000,warn "Not inlining a constructor for $class since it defines"
0.000000,0,0.000000,. " its own constructor.\n"
0.000000,0,0.000000,. "If you are certain you don't need to inline your"
0.000000,0,0.000000,. " constructor, specify inline_constructor => 0 in your"
0.000000,0,0.000000,. " call to $class->meta->make_immutable\n";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000056,31,0.000002,my $constructor_class = $args{constructor_class};
0.000000,0,0.000000,
0.000174,31,0.000006,load_class($constructor_class);
0.000000,0,0.000000,
0.000582,31,0.000019,my $constructor = $constructor_class->new(
0.000000,0,0.000000,options      => \%args,
0.000000,0,0.000000,metaclass    => $self,
0.000000,0,0.000000,is_inline    => 1,
0.000000,0,0.000000,package_name => $self->name,
0.000000,0,0.000000,name         => $name,
0.000000,0,0.000000,definition_context => {
0.000000,0,0.000000,description => "constructor " . $self->name . "::" . $name,
0.000000,0,0.000000,file        => $args{file},
0.000000,0,0.000000,line        => $args{line},
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000370,31,0.000012,if ( $args{replace_constructor} or $constructor->can_be_inlined ) {
0.000159,31,0.000005,$self->add_method( $name => $constructor );
0.000178,31,0.000006,$self->_add_inlined_method($constructor);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _inline_destructor {
0.000006,1,0.000006,my ( $self, %args ) = @_;
0.000000,0,0.000000,
0.000003,1,0.000003,( exists $args{destructor_class} && defined $args{destructor_class} )
0.000000,0,0.000000,|| confess "The 'inline_destructor' option is present, but "
0.000000,0,0.000000,. "no destructor class was specified";
0.000000,0,0.000000,
0.000005,1,0.000005,if ( $self->has_method('DESTROY') && ! $args{replace_destructor} ) {
0.000000,0,0.000000,my $class = $self->name;
0.000000,0,0.000000,warn "Not inlining a destructor for $class since it defines"
0.000000,0,0.000000,. " its own destructor.\n";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,my $destructor_class = $args{destructor_class};
0.000000,0,0.000000,
0.000005,1,0.000005,load_class($destructor_class);
0.000000,0,0.000000,
0.000009,1,0.000009,return unless $destructor_class->is_needed($self);
0.000000,0,0.000000,
0.000022,1,0.000022,my $destructor = $destructor_class->new(
0.000000,0,0.000000,options      => \%args,
0.000000,0,0.000000,metaclass    => $self,
0.000000,0,0.000000,package_name => $self->name,
0.000000,0,0.000000,name         => 'DESTROY',
0.000000,0,0.000000,definition_context => {
0.000000,0,0.000000,description => "destructor " . $self->name . "::DESTROY",
0.000000,0,0.000000,file        => $args{file},
0.000000,0,0.000000,line        => $args{line},
0.000000,0,0.000000,},
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000018,1,0.000018,if ( $args{replace_destructor} or $destructor->can_be_inlined ) {
0.000005,1,0.000005,$self->add_method( 'DESTROY' => $destructor );
0.000005,1,0.000005,$self->_add_inlined_method($destructor);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Class Meta Object
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
