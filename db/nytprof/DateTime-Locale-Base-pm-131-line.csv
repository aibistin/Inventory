# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package DateTime::Locale::Base;
0.000000,0,0.000000,
0.000036,2,0.000018,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000033,2,0.000016,use Carp qw( carp );
0.000034,2,0.000017,use DateTime::Locale;
0.000113,2,0.000056,use List::MoreUtils ();
0.000083,2,0.000042,use Params::Validate qw( validate_pos );
0.000000,0,0.000000,
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,foreach my $field (
0.000000,0,0.000000,qw( id en_complete_name native_complete_name
0.000000,0,0.000000,en_language en_script en_territory en_variant
0.000000,0,0.000000,native_language native_script native_territory native_variant
0.000000,0,0.000000,)
0.000000,0,0.000000,) {
0.000000,0,0.000000,
0.000000,0,0.000000,# remove leading 'en_' for method name
0.000076,11,0.000007,( my $meth_name = $field ) =~ s/^en_//;
0.000000,0,0.000000,
0.000000,0,0.000000,# also remove 'complete_'
0.000061,11,0.000006,$meth_name =~ s/complete_//;
0.000000,0,0.000000,
0.000058,2,0.000029,no strict 'refs';
0.000068,11,0.000006,*{$meth_name} = sub { $_[0]->{$field} };
0.000000,0,0.000000,}
0.000429,1,0.000429,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub new {
0.000002,1,0.000002,my $class = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# By making the default format lengths part of the object's hash
0.000000,0,0.000000,# key, it allows them to be settable.
0.000027,1,0.000027,return bless {
0.000000,0,0.000000,@_,
0.000000,0,0.000000,default_date_format_length => $class->_default_date_format_length(),
0.000000,0,0.000000,default_time_format_length => $class->_default_time_format_length(),
0.000000,0,0.000000,}, $class;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub language_id  { ( DateTime::Locale::_parse_id( $_[0]->id ) )[0] }
0.000000,0,0.000000,sub script_id    { ( DateTime::Locale::_parse_id( $_[0]->id ) )[1] }
0.000000,0,0.000000,sub territory_id { ( DateTime::Locale::_parse_id( $_[0]->id ) )[2] }
0.000000,0,0.000000,sub variant_id   { ( DateTime::Locale::_parse_id( $_[0]->id ) )[3] }
0.000000,0,0.000000,
0.000003,1,0.000003,my @FormatLengths = qw( short medium long full );
0.000000,0,0.000000,
0.000000,0,0.000000,sub date_format_default {
0.000000,0,0.000000,my $meth = 'date_format_' . $_[0]->default_date_format_length();
0.000000,0,0.000000,$_[0]->$meth();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub date_formats {
0.000000,0,0.000000,return {
0.000000,0,0.000000,map {
0.000000,0,0.000000,my $meth = 'date_format_' . $_;
0.000000,0,0.000000,$_ => $_[0]->$meth()
0.000000,0,0.000000,} @FormatLengths
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub time_format_default {
0.000000,0,0.000000,my $meth = 'time_format_' . $_[0]->default_time_format_length();
0.000000,0,0.000000,$_[0]->$meth();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub time_formats {
0.000000,0,0.000000,return {
0.000000,0,0.000000,map {
0.000000,0,0.000000,my $meth = 'time_format_' . $_;
0.000000,0,0.000000,$_ => $_[0]->$meth()
0.000000,0,0.000000,} @FormatLengths
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub format_for {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my $for  = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $meth = '_format_for_' . $for;
0.000000,0,0.000000,
0.000000,0,0.000000,return unless $self->can($meth);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->$meth();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub available_formats {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# The various parens seem to be necessary to force uniq() to see
0.000000,0,0.000000,# the caller's list context. Go figure.
0.000000,0,0.000000,my @uniq
0.000000,0,0.000000,= List::MoreUtils::uniq(
0.000000,0,0.000000,map { keys %{ $_->_available_formats() || {} } }
0.000000,0,0.000000,_self_and_super_path( ref $self ) );
0.000000,0,0.000000,
0.000000,0,0.000000,# Doing the sort in the same expression doesn't work under 5.6.x.
0.000000,0,0.000000,return sort @uniq;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Copied wholesale from Class::ISA, because said module warns as deprecated
0.000000,0,0.000000,# with perl 5.11.0+, which is kind of annoying.
0.000000,0,0.000000,sub _self_and_super_path {
0.000000,0,0.000000,# Assumption: searching is depth-first.
0.000000,0,0.000000,# Assumption: '' (empty string) can't be a class package name.
0.000000,0,0.000000,# Note: 'UNIVERSAL' is not given any special treatment.
0.000000,0,0.000000,return () unless @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @out = ();
0.000000,0,0.000000,
0.000000,0,0.000000,my @in_stack = ($_[0]);
0.000000,0,0.000000,my %seen = ($_[0] => 1);
0.000000,0,0.000000,
0.000000,0,0.000000,my $current;
0.000000,0,0.000000,while(@in_stack) {
0.000000,0,0.000000,next unless defined($current = shift @in_stack) && length($current);
0.000000,0,0.000000,push @out, $current;
0.000333,2,0.000167,no strict 'refs';
0.000000,0,0.000000,unshift @in_stack,
0.000000,0,0.000000,map
0.000000,0,0.000000,{ my $c = $_; # copy, to avoid being destructive
0.000000,0,0.000000,substr($c,0,2) = "main::" if substr($c,0,2) eq '::';
0.000000,0,0.000000,# Canonize the :: -> main::, ::foo -> main::foo thing.
0.000000,0,0.000000,# Should I ever canonize the Foo'Bar = Foo::Bar thing? 
0.000000,0,0.000000,$seen{$c}++ ? () : $c;
0.000000,0,0.000000,}
0.000000,0,0.000000,@{"$current\::ISA"}
0.000000,0,0.000000,;
0.000000,0,0.000000,# I.e., if this class has any parents (at least, ones I've never seen
0.000000,0,0.000000,# before), push them, in order, onto the stack of classes I need to
0.000000,0,0.000000,# explore.
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return @out;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Just needed for the above method.
0.000000,0,0.000000,sub _available_formats { }
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_date_format_length { $_[0]->{default_date_format_length} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_default_date_format_length {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($l)
0.000000,0,0.000000,= validate_pos( @_, { regex => qr/^(?:full|long|medium|short)$/i } );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{default_date_format_length} = lc $l;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_time_format_length { $_[0]->{default_time_format_length} }
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_default_time_format_length {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($l)
0.000000,0,0.000000,= validate_pos( @_, { regex => qr/^(?:full|long|medium|short)/i } );
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{default_time_format_length} = lc $l;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,for my $length (qw( full long medium short )) {
0.000009,4,0.000002,my $key = 'datetime_format_' . $length;
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = sub {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{$key} if exists $self->{$key};
0.000000,0,0.000000,
0.000000,0,0.000000,my $date_meth = 'date_format_' . $length;
0.000000,0,0.000000,my $time_meth = 'time_format_' . $length;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{$key}
0.000000,0,0.000000,= $self->_make_datetime_format( $date_meth, $time_meth );
0.000010,4,0.000003,};
0.000000,0,0.000000,
0.001352,2,0.000676,no strict 'refs';
0.000020,4,0.000005,*{$key} = $sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub datetime_format_default {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $date_meth = 'date_format_' . $self->default_date_format_length();
0.000000,0,0.000000,my $time_meth = 'time_format_' . $self->default_time_format_length();
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->_make_datetime_format( $date_meth, $time_meth );
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_datetime_format {
0.000000,0,0.000000,my $self      = shift;
0.000000,0,0.000000,my $date_meth = shift;
0.000000,0,0.000000,my $time_meth = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $dt_format = $self->datetime_format();
0.000000,0,0.000000,
0.000000,0,0.000000,my $time = $self->$time_meth();
0.000000,0,0.000000,my $date = $self->$date_meth();
0.000000,0,0.000000,
0.000000,0,0.000000,$dt_format =~ s/\{0\}/$time/g;
0.000000,0,0.000000,$dt_format =~ s/\{1\}/$date/g;
0.000000,0,0.000000,
0.000000,0,0.000000,return $dt_format;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub prefers_24_hour_time {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{prefers_24_hour_time}
0.000000,0,0.000000,if exists $self->{prefers_24_hour_time};
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{prefers_24_hour_time}
0.000000,0,0.000000,= $self->time_format_short() =~ /h|K/ ? 0 : 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Backwards compat for DateTime.pm version <= 0.42
0.000000,0,0.000000,{
0.000003,1,0.000003,my %subs = (
0.000000,0,0.000000,month_name => sub { $_[0]->month_format_wide()->[ $_[1]->month_0 ] },
0.000000,0,0.000000,
0.000000,0,0.000000,month_abbreviation => sub {
0.000000,0,0.000000,$_[0]->month_format_abbreviated()->[ $_[1]->month_0 ];
0.000000,0,0.000000,},
0.000000,0,0.000000,month_narrow =>
0.000000,0,0.000000,sub { $_[0]->month_format_narrow()->[ $_[1]->month_0 ]; },
0.000000,0,0.000000,
0.000000,0,0.000000,month_names         => sub { $_[0]->month_format_wide() },
0.000000,0,0.000000,month_abbreviations => sub { $_[0]->month_format_abbreviated() },
0.000000,0,0.000000,month_narrows       => sub { $_[0]->month_format_narrow() },
0.000000,0,0.000000,
0.000000,0,0.000000,day_name =>
0.000000,0,0.000000,sub { $_[0]->day_format_wide()->[ $_[1]->day_of_week_0 ] },
0.000000,0,0.000000,
0.000000,0,0.000000,day_abbreviation => sub {
0.000000,0,0.000000,$_[0]->day_format_abbreviated()->[ $_[1]->day_of_week_0 ];
0.000000,0,0.000000,},
0.000000,0,0.000000,day_narrow =>
0.000000,0,0.000000,sub { $_[0]->day_format_narrow()->[ $_[1]->day_of_week_0 ]; },
0.000000,0,0.000000,
0.000000,0,0.000000,day_names         => sub { $_[0]->day_format_wide() },
0.000000,0,0.000000,day_abbreviations => sub { $_[0]->day_format_abbreviated() },
0.000000,0,0.000000,day_narrows       => sub { $_[0]->day_format_narrow() },
0.000000,0,0.000000,
0.000000,0,0.000000,quarter_name =>
0.000000,0,0.000000,sub { $_[0]->quarter_format_wide()->[ $_[1]->quarter - 1 ] },
0.000000,0,0.000000,
0.000000,0,0.000000,quarter_abbreviation => sub {
0.000000,0,0.000000,$_[0]->quarter_format_abbreviated()->[ $_[1]->quarter - 1 ];
0.000000,0,0.000000,},
0.000000,0,0.000000,quarter_narrow =>
0.000000,0,0.000000,sub { $_[0]->quarter_format_narrow()->[ $_[1]->quarter - 1 ] },
0.000000,0,0.000000,
0.000000,0,0.000000,quarter_names         => sub { $_[0]->quarter_format_wide() },
0.000000,0,0.000000,quarter_abbreviations => sub { $_[0]->quarter_format_abbreviated() },
0.000000,0,0.000000,
0.000000,0,0.000000,am_pm =>
0.000000,0,0.000000,sub { $_[0]->am_pm_abbreviated()->[ $_[1]->hour < 12 ? 0 : 1 ] },
0.000000,0,0.000000,am_pms => sub { $_[0]->am_pm_abbreviated() },
0.000000,0,0.000000,
0.000000,0,0.000000,era_name => sub { $_[0]->era_wide()->[ $_[1]->ce_year < 0 ? 0 : 1 ] },
0.000000,0,0.000000,
0.000000,0,0.000000,era_abbreviation => sub {
0.000000,0,0.000000,$_[0]->era_abbreviated()->[ $_[1]->ce_year < 0 ? 0 : 1 ];
0.000000,0,0.000000,},
0.000000,0,0.000000,era_narrow =>
0.000000,0,0.000000,sub { $_[0]->era_narrow()->[ $_[1]->ce_year < 0 ? 0 : 1 ] },
0.000000,0,0.000000,
0.000000,0,0.000000,era_names         => sub { $_[0]->era_wide() },
0.000000,0,0.000000,era_abbreviations => sub { $_[0]->era_abbreviated() },
0.000000,0,0.000000,
0.000000,0,0.000000,# ancient backwards compat
0.000000,0,0.000000,era  => sub { $_[0]->era_abbreviation },
0.000000,0,0.000000,eras => sub { $_[0]->era_abbreviations },
0.000000,0,0.000000,
0.000000,0,0.000000,date_before_time => sub {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $dt_format = $self->datetime_format();
0.000000,0,0.000000,
0.000000,0,0.000000,return $dt_format =~ /\{1\}.*\{0\}/ ? 1 : 0;
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,date_parts_order => sub {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $short = $self->date_format_short();
0.000000,0,0.000000,
0.000000,0,0.000000,$short =~ tr{dmyDMY}{}cd;
0.000000,0,0.000000,$short =~ tr{dmyDMY}{dmydmy}s;
0.000000,0,0.000000,
0.000000,0,0.000000,return $short;
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,full_date_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->date_format_full() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,long_date_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->date_format_long() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,medium_date_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->date_format_medium() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,short_date_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->date_format_short() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,default_date_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->date_format_default() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,full_time_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->time_format_full() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,long_time_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->time_format_long() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,medium_time_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->time_format_medium() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,short_time_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->time_format_short() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,default_time_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->time_format_default() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,full_datetime_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->datetime_format_full() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,long_datetime_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->datetime_format_long() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,medium_datetime_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->datetime_format_medium() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,short_datetime_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->datetime_format_short() );
0.000000,0,0.000000,},
0.000000,0,0.000000,
0.000000,0,0.000000,default_datetime_format => sub {
0.000000,0,0.000000,$_[0]->_convert_to_strftime( $_[0]->datetime_format_default() );
0.000000,0,0.000000,},
0.000046,1,0.000046,);
0.000000,0,0.000000,
0.000009,1,0.000009,for my $name ( keys %subs ) {
0.000063,43,0.000001,my $real_sub = $subs{$name};
0.000000,0,0.000000,
0.000000,0,0.000000,my $sub = sub {
0.000000,0,0.000000,carp
0.000000,0,0.000000,"The $name method in DateTime::Locale::Base has been deprecated. Please see the DateTime::Locale distribution's Changes file for details";
0.000000,0,0.000000,return shift->$real_sub(@_);
0.000109,43,0.000003,};
0.000000,0,0.000000,
0.000617,2,0.000308,no strict 'refs';
0.000178,43,0.000004,*{$name} = $sub;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Older versions of DateTime.pm will not pass in the $cldr_ok flag, so
0.000000,0,0.000000,# we will give them the converted-to-strftime pattern (bugs and all).
0.000000,0,0.000000,sub _convert_to_strftime {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my $pattern = shift;
0.000000,0,0.000000,my $cldr_ok = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return $pattern if $cldr_ok;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{_converted_patterns}{$pattern}
0.000000,0,0.000000,if exists $self->{_converted_patterns}{$pattern};
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{_converted_patterns}{$pattern}
0.000000,0,0.000000,= $self->_cldr_to_strftime($pattern);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000152,2,0.000076,my @JavaPatterns = (
0.000000,0,0.000000,qr/G/    => '{era}',
0.000000,0,0.000000,qr/yyyy/ => '{ce_year}',
0.000000,0,0.000000,qr/y/    => 'y',
0.000000,0,0.000000,qr/u/    => 'Y',
0.000000,0,0.000000,qr/MMMM/ => 'B',
0.000000,0,0.000000,qr/MMM/  => 'b',
0.000000,0,0.000000,qr/MM/   => 'm',
0.000000,0,0.000000,qr/M/    => '{month}',
0.000000,0,0.000000,qr/dd/   => 'd',
0.000000,0,0.000000,qr/d/    => '{day}',
0.000000,0,0.000000,qr/hh/   => 'l',
0.000000,0,0.000000,qr/h/    => '{hour_12}',
0.000000,0,0.000000,qr/HH/   => 'H',
0.000000,0,0.000000,qr/H/    => '{hour}',
0.000000,0,0.000000,qr/mm/   => 'M',
0.000000,0,0.000000,qr/m/    => '{minute}',
0.000000,0,0.000000,qr/ss/   => 'S',
0.000000,0,0.000000,qr/s/    => '{second}',
0.000000,0,0.000000,qr/S/    => 'N',
0.000000,0,0.000000,qr/EEEE/ => 'A',
0.000000,0,0.000000,qr/E/    => 'a',
0.000000,0,0.000000,qr/D/    => 'j',
0.000000,0,0.000000,qr/F/    => '{weekday_of_month}',
0.000000,0,0.000000,qr/w/    => 'V',
0.000000,0,0.000000,qr/W/    => '{week_month}',
0.000000,0,0.000000,qr/a/    => 'p',
0.000000,0,0.000000,qr/k/    => '{hour_1}',
0.000000,0,0.000000,qr/K/    => '{hour_12_0}',
0.000000,0,0.000000,qr/z/    => '{time_zone_long_name}',
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,sub _cldr_to_strftime {
0.000000,0,0.000000,shift;
0.000000,0,0.000000,my $simple = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$simple
0.000000,0,0.000000,=~ s/(G+|y+|u+|M+|d+|h+|H+|m+|s+|S+|E+|D+|F+|w+|W+|a+|k+|K+|z+)|'((?:[^']|'')*)'/
0.000000,0,0.000000,$2 ? _stringify($2) : $1 ? _convert($1) : "'"/eg;
0.000000,0,0.000000,
0.000000,0,0.000000,return $simple;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _convert {
0.000000,0,0.000000,my $simple = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,for ( my $x = 0; $x < @JavaPatterns; $x += 2 ) {
0.000000,0,0.000000,return '%' . $JavaPatterns[ $x + 1 ]
0.000000,0,0.000000,if $simple =~ /$JavaPatterns[$x]/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,die "**Dont know $simple***";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _stringify {
0.000000,0,0.000000,my $string = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,$string =~ s/%(?:[^%])/%%/g;
0.000000,0,0.000000,$string =~ s/\'\'/\'/g;
0.000000,0,0.000000,
0.000000,0,0.000000,return $string;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# end backwards compat
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_freeze {
0.000000,0,0.000000,my $self    = shift;
0.000000,0,0.000000,my $cloning = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,return if $cloning;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->id();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub STORABLE_thaw {
0.000000,0,0.000000,my $self       = shift;
0.000000,0,0.000000,my $cloning    = shift;
0.000000,0,0.000000,my $serialized = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,my $obj = DateTime::Locale->load($serialized);
0.000000,0,0.000000,
0.000000,0,0.000000,%$self = %$obj;
0.000000,0,0.000000,
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,1,0.000017,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
