# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,package Log::Log4perl::Appender;
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,
0.000053,2,0.000027,use 5.006;
0.000032,2,0.000016,use strict;
0.000034,2,0.000017,use warnings;
0.000000,0,0.000000,
0.000108,2,0.000054,use Log::Log4perl::Config;
0.000034,2,0.000017,use Log::Log4perl::Level;
0.000036,2,0.000018,use Carp;
0.000000,0,0.000000,
0.000637,2,0.000318,use constant _INTERNAL_DEBUG => 0;
0.000000,0,0.000000,
0.000002,1,0.000002,our $unique_counter = 0;
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub reset {
0.000000,0,0.000000,##################################################
0.000012,2,0.000006,$unique_counter = 0;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub unique_name {
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# THREADS: Need to lock here to make it thread safe
0.000002,1,0.000002,$unique_counter++;
0.000003,1,0.000003,my $unique_name = sprintf("app%03d", $unique_counter);
0.000000,0,0.000000,# THREADS: Need to unlock here to make it thread safe
0.000009,1,0.000009,return $unique_name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub new {
0.000000,0,0.000000,##################################################
0.000005,2,0.000003,my($class, $appenderclass, %params) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Pull in the specified Log::Log4perl::Appender object
0.000006,2,0.000003,eval {
0.000000,0,0.000000,
0.000000,0,0.000000,# Eval erroneously succeeds on unknown appender classes if
0.000000,0,0.000000,# the eval string just consists of valid perl code (e.g. an
0.000000,0,0.000000,# appended ';' in $appenderclass variable). Fail if we see
0.000000,0,0.000000,# anything in there that can't be class name.
0.000021,2,0.000010,die "'$appenderclass' not a valid class name " if 
0.000000,0,0.000000,$appenderclass =~ /[^:\w]/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if the class/package is already available because
0.000000,0,0.000000,# something like Class::Prototyped injected it previously.
0.000000,0,0.000000,
0.000000,0,0.000000,# Use UNIVERSAL::can to check the appender's new() method
0.000000,0,0.000000,# [RT 28987]
0.000032,2,0.000016,if( ! $appenderclass->can('new') ) {
0.000000,0,0.000000,# Not available yet, try to pull it in.
0.000000,0,0.000000,# see 'perldoc -f require' for why two evals
0.000175,1,0.000175,eval "require $appenderclass";
0.000000,0,0.000000,#unless ${$appenderclass.'::IS_LOADED'};  #for unit tests, 
0.000000,0,0.000000,#see 004Config
0.000002,1,0.000002,die $@ if $@;
0.000000,0,0.000000,}
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000003,2,0.000001,$@ and die "ERROR: can't load appenderclass '$appenderclass'\n$@";
0.000000,0,0.000000,
0.000009,2,0.000005,$params{name} = unique_name() unless exists $params{name};
0.000000,0,0.000000,
0.000000,0,0.000000,# If it's a Log::Dispatch::File appender, default to append 
0.000000,0,0.000000,# mode (Log::Dispatch::File defaults to 'clobber') -- consensus 9/2002
0.000000,0,0.000000,# (Log::Log4perl::Appender::File already defaults to 'append')
0.000003,2,0.000002,if ($appenderclass eq 'Log::Dispatch::File' &&
0.000000,0,0.000000,! exists $params{mode}) {
0.000000,0,0.000000,$params{mode} = 'append';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $appender = $appenderclass->new(
0.000000,0,0.000000,# Set min_level to the lowest setting. *we* are 
0.000000,0,0.000000,# controlling this now, the appender should just
0.000000,0,0.000000,# log it with no questions asked.
0.000000,0,0.000000,min_level => 'debug',
0.000000,0,0.000000,# Set 'name' and other parameters
0.000019,2,0.000010,map { $_ => $params{$_} } keys %params,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000008,2,0.000004,my $self = {
0.000000,0,0.000000,appender  => $appender,
0.000000,0,0.000000,name      => $params{name},
0.000000,0,0.000000,layout    => undef,
0.000000,0,0.000000,level     => $ALL,
0.000000,0,0.000000,composite => 0,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,#whether to collapse arrays, etc.
0.000004,2,0.000002,$self->{warp_message} = $params{warp_message};
0.000003,2,0.000002,if($self->{warp_message} and
0.000000,0,0.000000,my $cref = 
0.000000,0,0.000000,Log::Log4perl::Config::compile_if_perl($self->{warp_message})) {
0.000000,0,0.000000,$self->{warp_message} = $cref;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,2,0.000002,bless $self, $class;
0.000000,0,0.000000,
0.000015,2,0.000007,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub composite { # Set/Get the composite flag
0.000000,0,0.000000,##################################################
0.000004,2,0.000002,my ($self, $flag) = @_;
0.000000,0,0.000000,
0.000003,2,0.000002,$self->{composite} = $flag if defined $flag;
0.000017,2,0.000008,return $self->{composite};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub threshold { # Set/Get the appender threshold
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self, $level) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,print "Setting threshold to $level\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,
0.000000,0,0.000000,if(defined $level) {
0.000000,0,0.000000,# Checking for \d makes for a faster regex(p)
0.000000,0,0.000000,$self->{level} = ($level =~ /^(\d+)$/) ? $level :
0.000000,0,0.000000,# Take advantage of &to_priority's error reporting
0.000000,0,0.000000,Log::Log4perl::Level::to_priority($level);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{level};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub log { 
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# Relay this call to Log::Log4perl::Appender:* or
0.000000,0,0.000000,# Log::Dispatch::*
0.000000,0,0.000000,##################################################
0.000005,2,0.000003,my ($self, $p, $category, $level, $cache) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if the appender has a last-minute veto in form
0.000000,0,0.000000,# of an "appender threshold"
0.000005,2,0.000003,if($self->{level} > $
0.000000,0,0.000000,Log::Log4perl::Level::PRIORITY{$level}) {
0.000000,0,0.000000,print "$self->{level} > $level, aborting\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Run against the (yes only one) customized filter (which in turn
0.000000,0,0.000000,# might call other filters via the Boolean filter) and check if its
0.000000,0,0.000000,# ok() method approves the message or blocks it.
0.000004,2,0.000002,if($self->{filter}) {
0.000000,0,0.000000,if($self->{filter}->ok(%$p,
0.000000,0,0.000000,log4p_category => $category,
0.000000,0,0.000000,log4p_level    => $level )) {
0.000000,0,0.000000,print "Filter $self->{filter}->{name} passes\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,print "Filter $self->{filter}->{name} blocks\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,return undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000016,2,0.000008,unless($self->composite()) {
0.000000,0,0.000000,
0.000000,0,0.000000,#not defined, the normal case
0.000007,2,0.000003,if (! defined $self->{warp_message} ){
0.000000,0,0.000000,#join any message elements
0.000008,2,0.000004,if (ref $p->{message} eq "ARRAY") {
0.000009,2,0.000004,for my $i (0..$#{$p->{message}}) {
0.000008,2,0.000004,if( !defined $p->{message}->[ $i ] ) {
0.000000,0,0.000000,local $Carp::CarpLevel =
0.000000,0,0.000000,$Carp::CarpLevel + $Log::Log4perl::caller_depth + 1;
0.000000,0,0.000000,carp "Warning: Log message argument #" . 
0.000000,0,0.000000,($i+1) . " undefined";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,$p->{message} = 
0.000000,0,0.000000,join($Log::Log4perl::JOIN_MSG_ARRAY_CHAR, 
0.000008,2,0.000004,@{$p->{message}} 
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,#defined but false, e.g. Appender::DBI
0.000000,0,0.000000,} elsif (! $self->{warp_message}) {
0.000000,0,0.000000,;  #leave the message alone
0.000000,0,0.000000,
0.000000,0,0.000000,} elsif (ref($self->{warp_message}) eq "CODE") {
0.000000,0,0.000000,#defined and a subref
0.000000,0,0.000000,$p->{message} = 
0.000000,0,0.000000,[$self->{warp_message}->(@{$p->{message}})];
0.000000,0,0.000000,} else {
0.000000,0,0.000000,#defined and a function name?
0.000347,2,0.000173,no strict qw(refs);
0.000000,0,0.000000,$p->{message} = 
0.000000,0,0.000000,[$self->{warp_message}->(@{$p->{message}})];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000027,2,0.000013,$p->{message} = $self->{layout}->render($p->{message}, 
0.000000,0,0.000000,$category,
0.000000,0,0.000000,$level,
0.000000,0,0.000000,3 + $Log::Log4perl::caller_depth,
0.000000,0,0.000000,) if $self->layout();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000010,2,0.000005,my $args = [%$p, log4p_category => $category, log4p_level => $level];
0.000000,0,0.000000,
0.000007,2,0.000003,if(defined $cache) {
0.000000,0,0.000000,$$cache = $args;
0.000000,0,0.000000,} else {
0.000014,2,0.000007,$self->{appender}->log(@$args);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000017,2,0.000008,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub log_cached {
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,my ($self, $cache) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,$self->{appender}->log(@$cache);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub name { # Set/Get the name
0.000000,0,0.000000,##################################################
0.000002,1,0.000002,my($self, $name) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Somebody wants to *set* the name?
0.000001,1,0.000001,if($name) {
0.000000,0,0.000000,$self->{name} = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,1,0.000008,return $self->{name};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,###########################################
0.000000,0,0.000000,sub layout { # Set/Get the layout object
0.000000,0,0.000000,# associated with this appender
0.000000,0,0.000000,###########################################
0.000007,4,0.000002,my($self, $layout) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Somebody wants to *set* the layout?
0.000012,4,0.000003,if($layout) {
0.000000,0,0.000000,$self->{layout} = $layout;
0.000000,0,0.000000,
0.000000,0,0.000000,# somebody wants a layout, but not set yet, so give 'em default
0.000000,0,0.000000,}elsif (! $self->{layout}) {
0.000000,0,0.000000,$self->{layout} = Log::Log4perl::Layout::SimpleLayout
0.000000,0,0.000000,->new($self->{name});
0.000000,0,0.000000,
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000029,4,0.000007,return $self->{layout};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub filter { # Set filter
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my ($self, $filter) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if($filter) {
0.000000,0,0.000000,print "Setting filter to $filter->{name}\n" if _INTERNAL_DEBUG;
0.000000,0,0.000000,$self->{filter} = $filter;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{filter};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub AUTOLOAD { 
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,# Relay everything else to the underlying 
0.000000,0,0.000000,# Log::Log4perl::Appender::* or Log::Dispatch::*
0.000000,0,0.000000,#  object
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,
0.000138,2,0.000069,no strict qw(vars);
0.000000,0,0.000000,
0.000000,0,0.000000,$AUTOLOAD =~ s/.*:://;
0.000000,0,0.000000,
0.000000,0,0.000000,if(! defined $self->{appender}) {
0.000000,0,0.000000,die "Can't locate object method $AUTOLOAD() in ", __PACKAGE__;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->{appender}->$AUTOLOAD(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,##################################################
0.000000,0,0.000000,sub DESTROY {
0.000000,0,0.000000,##################################################
0.000021,2,0.000011,foreach my $key (keys %{$_[0]}) {
0.000000,0,0.000000,# print "deleting $key\n";
0.000083,10,0.000008,delete $_[0]->{$key};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
