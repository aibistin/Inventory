# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000059,2,0.000029,use 5.006;
0.000032,2,0.000016,use strict;
0.000048,2,0.000024,use warnings;
0.000000,0,0.000000,package Sub::Exporter;
0.000000,0,0.000000,{
0.000004,2,0.000002,$Sub::Exporter::VERSION = '0.986';
0.000000,0,0.000000,}
0.000000,0,0.000000,# ABSTRACT: a sophisticated exporter for custom-built routines
0.000000,0,0.000000,
0.000031,2,0.000015,use Carp ();
0.000056,3,0.000019,use Data::OptList 0.100 ();
0.000052,3,0.000017,use Params::Util 0.14 (); # _CODELIKE
0.001036,3,0.000345,use Sub::Install 0.92 ();
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Given a potential import name, this returns the group name -- if it's got a
0.000000,0,0.000000,# group prefix.
0.000000,0,0.000000,sub _group_name {
0.000111,73,0.000002,my ($name) = @_;
0.000000,0,0.000000,
0.000314,73,0.000004,return if (index q{-:}, (substr $name, 0, 1)) == -1;
0.000112,20,0.000006,return substr $name, 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# \@groups is a canonicalized opt list of exports and groups this returns
0.000000,0,0.000000,# another canonicalized opt list with groups replaced with relevant exports.
0.000000,0,0.000000,# \%seen is groups we've already expanded and can ignore.
0.000000,0,0.000000,# \%merge is merged options from the group we're descending through.
0.000000,0,0.000000,sub _expand_groups {
0.000040,20,0.000002,my ($class, $config, $groups, $collection, $seen, $merge) = @_;
0.000031,20,0.000002,$seen  ||= {};
0.000029,20,0.000001,$merge ||= {};
0.000042,20,0.000002,my @groups = @$groups;
0.000000,0,0.000000,
0.000157,20,0.000008,for my $i (reverse 0 .. $#groups) {
0.000388,63,0.000006,if (my $group_name = _group_name($groups[$i][0])) {
0.000025,10,0.000002,my $seen = { %$seen }; # faux-dynamic scoping
0.000000,0,0.000000,
0.000075,10,0.000008,splice @groups, $i, 1,
0.000000,0,0.000000,_expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# there's nothing to munge in this export's args
0.000111,53,0.000002,next unless my %merge = %$merge;
0.000000,0,0.000000,
0.000000,0,0.000000,# we have things to merge in; do so
0.000000,0,0.000000,my $prefix = (delete $merge{-prefix}) || '';
0.000000,0,0.000000,my $suffix = (delete $merge{-suffix}) || '';
0.000000,0,0.000000,
0.000000,0,0.000000,if (
0.000000,0,0.000000,Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
0.000000,0,0.000000,or
0.000000,0,0.000000,Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
0.000000,0,0.000000,) {
0.000000,0,0.000000,# this entry was build by a group generator
0.000000,0,0.000000,$groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,my $as
0.000000,0,0.000000,= ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
0.000000,0,0.000000,:     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
0.000000,0,0.000000,:                           $prefix . $groups[$i][0]      . $suffix;
0.000000,0,0.000000,
0.000000,0,0.000000,$groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000117,20,0.000006,return \@groups;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# \@group is a name/value pair from an opt list.
0.000000,0,0.000000,sub _expand_group {
0.000020,10,0.000002,my ($class, $config, $group, $collection, $seen, $merge) = @_;
0.000015,10,0.000002,$merge ||= {};
0.000000,0,0.000000,
0.000018,10,0.000002,my ($group_name, $group_arg) = @$group;
0.000048,10,0.000005,$group_name = _group_name($group_name);
0.000000,0,0.000000,
0.000021,10,0.000002,Carp::croak qq(group "$group_name" is not exported by the $class module)
0.000000,0,0.000000,unless exists $config->{groups}{$group_name};
0.000000,0,0.000000,
0.000023,10,0.000002,return if $seen->{$group_name}++;
0.000000,0,0.000000,
0.000015,10,0.000002,if (ref $group_arg) {
0.000000,0,0.000000,my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
0.000000,0,0.000000,my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
0.000000,0,0.000000,$merge = {
0.000000,0,0.000000,%$merge,
0.000000,0,0.000000,%$group_arg,
0.000000,0,0.000000,($prefix ? (-prefix => $prefix) : ()),
0.000000,0,0.000000,($suffix ? (-suffix => $suffix) : ()),
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000018,10,0.000002,my $exports = $config->{groups}{$group_name};
0.000000,0,0.000000,
0.000135,10,0.000014,if (
0.000000,0,0.000000,Params::Util::_CODELIKE($exports) ## no critic Private
0.000000,0,0.000000,or
0.000000,0,0.000000,Params::Util::_SCALAR0($exports) ## no critic Private
0.000000,0,0.000000,) {
0.000000,0,0.000000,# I'm not very happy with this code for hiding -prefix and -suffix, but
0.000000,0,0.000000,# it's needed, and I'm not sure, offhand, how to make it better.
0.000000,0,0.000000,# -- rjbs, 2006-12-05
0.000000,0,0.000000,my $group_arg = $merge ? { %$merge } : {};
0.000000,0,0.000000,delete $group_arg->{-prefix};
0.000000,0,0.000000,delete $group_arg->{-suffix};
0.000000,0,0.000000,
0.000000,0,0.000000,my $group = Params::Util::_CODELIKE($exports) ## no critic Private
0.000000,0,0.000000,? $exports->($class, $group_name, $group_arg, $collection)
0.000000,0,0.000000,: $class->$$exports($group_name, $group_arg, $collection);
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak qq(group generator "$group_name" did not return a hashref)
0.000000,0,0.000000,if ref $group ne 'HASH';
0.000000,0,0.000000,
0.000000,0,0.000000,my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
0.000000,0,0.000000,return @{
0.000000,0,0.000000,_expand_groups($class, $config, $stuff, $collection, $seen, $merge)
0.000000,0,0.000000,};
0.000000,0,0.000000,} else {
0.000055,10,0.000005,$exports
0.000000,0,0.000000,= Data::OptList::mkopt($exports, "$group_name exports");
0.000000,0,0.000000,
0.000000,0,0.000000,return @{
0.000104,10,0.000010,_expand_groups($class, $config, $exports, $collection, $seen, $merge)
0.000000,0,0.000000,};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _mk_collection_builder {
0.000018,10,0.000002,my ($col, $etc) = @_;
0.000020,10,0.000002,my ($config, $import_args, $class, $into) = @$etc;
0.000000,0,0.000000,
0.000014,10,0.000001,my %seen;
0.000000,0,0.000000,sub {
0.000000,0,0.000000,my ($collection) = @_;
0.000000,0,0.000000,my ($name, $value) = @$collection;
0.000000,0,0.000000,
0.000000,0,0.000000,Carp::croak "collection $name provided multiple times in import"
0.000000,0,0.000000,if $seen{ $name }++;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref(my $hook = $config->{collectors}{$name})) {
0.000000,0,0.000000,my $arg = {
0.000000,0,0.000000,name        => $name,
0.000000,0,0.000000,config      => $config,
0.000000,0,0.000000,import_args => $import_args,
0.000000,0,0.000000,class       => $class,
0.000000,0,0.000000,into        => $into,
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,my $error_msg = "collection $name failed validation";
0.000000,0,0.000000,if (Params::Util::_SCALAR0($hook)) { ## no critic Private
0.000000,0,0.000000,Carp::croak $error_msg unless $class->$$hook($value, $arg);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,Carp::croak $error_msg unless $hook->($value, $arg);
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,$col->{ $name } = $value;
0.000000,0,0.000000,}
0.000094,10,0.000009,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Given a config and pre-canonicalized importer args, remove collections from
0.000000,0,0.000000,# the args and return them.
0.000000,0,0.000000,sub _collect_collections {
0.000020,10,0.000002,my ($config, $import_args, $class, $into) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,my @collections
0.000000,0,0.000000,= map  { splice @$import_args, $_, 1 }
0.000054,10,0.000005,grep { exists $config->{collectors}{ $import_args->[$_][0] } }
0.000000,0,0.000000,reverse 0 .. $#$import_args;
0.000000,0,0.000000,
0.000018,10,0.000002,unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
0.000000,0,0.000000,
0.000018,10,0.000002,my $col = {};
0.000060,10,0.000006,my $builder = _mk_collection_builder($col, \@_);
0.000034,10,0.000003,for my $collection (@collections) {
0.000000,0,0.000000,$builder->($collection)
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000110,10,0.000011,return $col;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub setup_exporter {
0.000003,2,0.000002,my ($config)  = @_;
0.000000,0,0.000000,
0.000004,2,0.000002,Carp::croak 'into and into_level may not both be supplied to exporter'
0.000000,0,0.000000,if exists $config->{into} and exists $config->{into_level};
0.000000,0,0.000000,
0.000004,2,0.000002,my $as   = delete $config->{as}   || 'import';
0.000005,2,0.000003,my $into
0.000000,0,0.000000,= exists $config->{into}       ? delete $config->{into}
0.000000,0,0.000000,: exists $config->{into_level} ? caller(delete $config->{into_level})
0.000000,0,0.000000,:                                caller(0);
0.000000,0,0.000000,
0.000011,2,0.000006,my $import = build_exporter($config);
0.000000,0,0.000000,
0.000026,2,0.000013,Sub::Install::reinstall_sub({
0.000000,0,0.000000,code => $import,
0.000000,0,0.000000,into => $into,
0.000000,0,0.000000,as   => $as,
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub _key_intersection {
0.000007,4,0.000002,my ($x, $y) = @_;
0.000036,4,0.000009,my %seen = map { $_ => 1 } keys %$x;
0.000029,4,0.000007,my @names = grep { $seen{$_} } keys %$y;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Given the config passed to setup_exporter, which contains sugary opt list
0.000000,0,0.000000,# data, rewrite the opt lists into hashes, catch a few kinds of invalid
0.000000,0,0.000000,# configurations, and set up defaults.  Since the config is a reference, it's
0.000000,0,0.000000,# rewritten in place.
0.000001,1,0.000001,my %valid_config_key;
0.000000,0,0.000000,BEGIN {
0.000000,0,0.000000,%valid_config_key =
0.000016,1,0.000016,map { $_ => 1 }
0.000000,0,0.000000,qw(as collectors installer generator exports groups into into_level),
0.000000,0,0.000000,qw(exporter), # deprecated
0.001086,1,0.001086,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _assert_collector_names_ok {
0.000007,4,0.000002,my ($collectors) = @_;
0.000000,0,0.000000,
0.000051,5,0.000010,for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
0.000000,0,0.000000,Carp::croak "unknown reserved collector name: $reserved_name"
0.000000,0,0.000000,if $reserved_name ne 'INIT';
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _rewrite_build_config {
0.000007,4,0.000002,my ($config) = @_;
0.000000,0,0.000000,
0.000020,4,0.000005,if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
0.000000,0,0.000000,Carp::croak "unknown options (@keys) passed to Sub::Exporter";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000008,4,0.000002,Carp::croak q(into and into_level may not both be supplied to exporter)
0.000000,0,0.000000,if exists $config->{into} and exists $config->{into_level};
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: Remove after deprecation period.
0.000007,4,0.000002,if ($config->{exporter}) {
0.000000,0,0.000000,Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
0.000000,0,0.000000,$config->{installer} = delete $config->{exporter};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000007,4,0.000002,Carp::croak q(into and into_level may not both be supplied to exporter)
0.000000,0,0.000000,if exists $config->{into} and exists $config->{into_level};
0.000000,0,0.000000,
0.000014,4,0.000003,for (qw(exports collectors)) {
0.000076,8,0.000010,$config->{$_} = Data::OptList::mkopt_hash(
0.000000,0,0.000000,$config->{$_},
0.000000,0,0.000000,$_,
0.000000,0,0.000000,[ 'CODE', 'SCALAR' ],
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000023,4,0.000006,_assert_collector_names_ok($config->{collectors});
0.000000,0,0.000000,
0.000026,4,0.000007,if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
0.000000,0,0.000000,Carp::croak "names (@names) used in both collections and exports";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000029,4,0.000007,$config->{groups} = Data::OptList::mkopt_hash(
0.000000,0,0.000000,$config->{groups},
0.000000,0,0.000000,'groups',
0.000000,0,0.000000,[
0.000000,0,0.000000,'HASH',   # standard opt list
0.000000,0,0.000000,'ARRAY',  # standard opt list
0.000000,0,0.000000,'CODE',   # group generator
0.000000,0,0.000000,'SCALAR', # name of group generation method
0.000000,0,0.000000,]
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# by default, export nothing
0.000008,4,0.000002,$config->{groups}{default} ||= [];
0.000000,0,0.000000,
0.000000,0,0.000000,# by default, build an all-inclusive 'all' group
0.000014,4,0.000003,$config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
0.000000,0,0.000000,
0.000008,4,0.000002,$config->{generator} ||= \&default_generator;
0.000024,4,0.000006,$config->{installer} ||= \&default_installer;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub build_exporter {
0.000007,4,0.000002,my ($config) = @_;
0.000000,0,0.000000,
0.000021,4,0.000005,_rewrite_build_config($config);
0.000000,0,0.000000,
0.000000,0,0.000000,my $import = sub {
0.000020,10,0.000002,my ($class) = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: clean this up -- rjbs, 2006-03-16
0.000022,10,0.000002,my $special = (ref $_[0]) ? shift(@_) : {};
0.000019,10,0.000002,Carp::croak q(into and into_level may not both be supplied to exporter)
0.000000,0,0.000000,if exists $special->{into} and exists $special->{into_level};
0.000000,0,0.000000,
0.000018,10,0.000002,if ($special->{exporter}) {
0.000000,0,0.000000,Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
0.000000,0,0.000000,$special->{installer} = delete $special->{exporter};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000034,10,0.000003,my $into
0.000000,0,0.000000,= defined $special->{into}       ? delete $special->{into}
0.000000,0,0.000000,: defined $special->{into_level} ? caller(delete $special->{into_level})
0.000000,0,0.000000,: defined $config->{into}        ? $config->{into}
0.000000,0,0.000000,: defined $config->{into_level}  ? caller($config->{into_level})
0.000000,0,0.000000,:                                  caller(0);
0.000000,0,0.000000,
0.000023,10,0.000002,my $generator = delete $special->{generator} || $config->{generator};
0.000018,10,0.000002,my $installer = delete $special->{installer} || $config->{installer};
0.000000,0,0.000000,
0.000000,0,0.000000,# this builds a AOA, where the inner arrays are [ name => value_ref ]
0.000065,10,0.000006,my $import_args = Data::OptList::mkopt([ @_ ]);
0.000000,0,0.000000,
0.000000,0,0.000000,# is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
0.000030,10,0.000003,$import_args = [ [ -default => undef ] ] unless @$import_args;
0.000000,0,0.000000,
0.000077,10,0.000008,my $collection = _collect_collections($config, $import_args, $class, $into);
0.000000,0,0.000000,
0.000059,10,0.000006,my $to_import = _expand_groups($class, $config, $import_args, $collection);
0.000000,0,0.000000,
0.000000,0,0.000000,# now, finally $import_arg is really the "to do" list
0.000156,10,0.000016,_do_import(
0.000000,0,0.000000,{
0.000000,0,0.000000,class     => $class,
0.000000,0,0.000000,col       => $collection,
0.000000,0,0.000000,config    => $config,
0.000000,0,0.000000,into      => $into,
0.000000,0,0.000000,generator => $generator,
0.000000,0,0.000000,installer => $installer,
0.000000,0,0.000000,},
0.000000,0,0.000000,$to_import,
0.000000,0,0.000000,);
0.000018,4,0.000004,};
0.000000,0,0.000000,
0.000024,4,0.000006,return $import;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _do_import {
0.000017,10,0.000002,my ($arg, $to_import) = @_;
0.000000,0,0.000000,
0.000015,10,0.000001,my @todo;
0.000000,0,0.000000,
0.000035,10,0.000004,for my $pair (@$to_import) {
0.000087,53,0.000002,my ($name, $import_arg) = @$pair;
0.000000,0,0.000000,
0.000071,53,0.000001,my ($generator, $as);
0.000000,0,0.000000,
0.000148,53,0.000003,if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
0.000000,0,0.000000,# This is the case when a group generator has inserted name/code pairs.
0.000000,0,0.000000,$generator = sub { $import_arg };
0.000000,0,0.000000,$as = $name;
0.000000,0,0.000000,} else {
0.000085,53,0.000002,$import_arg = { $import_arg ? %$import_arg : () };
0.000000,0,0.000000,
0.000096,53,0.000002,Carp::croak qq("$name" is not exported by the $arg->{class} module)
0.000000,0,0.000000,unless exists $arg->{config}{exports}{$name};
0.000000,0,0.000000,
0.000089,53,0.000002,$generator = $arg->{config}{exports}{$name};
0.000000,0,0.000000,
0.000101,53,0.000002,$as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000383,53,0.000007,my $code = $arg->{generator}->(
0.000000,0,0.000000,{ 
0.000000,0,0.000000,class     => $arg->{class},
0.000000,0,0.000000,name      => $name,
0.000000,0,0.000000,arg       => $import_arg,
0.000000,0,0.000000,col       => $arg->{col},
0.000000,0,0.000000,generator => $generator,
0.000000,0,0.000000,}
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000201,53,0.000004,push @todo, $as, $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000109,10,0.000011,$arg->{installer}->(
0.000000,0,0.000000,{
0.000000,0,0.000000,class => $arg->{class},
0.000000,0,0.000000,into  => $arg->{into},
0.000000,0,0.000000,col   => $arg->{col},
0.000000,0,0.000000,},
0.000000,0,0.000000,\@todo,
0.000000,0,0.000000,);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,## Cute idea, possibly for future use: also supply an "unimport" for:
0.000000,0,0.000000,## no Module::Whatever qw(arg arg arg);
0.000000,0,0.000000,# sub _unexport {
0.000000,0,0.000000,#   my (undef, undef, undef, undef, undef, $as, $into) = @_;
0.000000,0,0.000000,# 
0.000000,0,0.000000,#   if (ref $as eq 'SCALAR') {
0.000000,0,0.000000,#     undef $$as;
0.000000,0,0.000000,#   } elsif (ref $as) {
0.000000,0,0.000000,#     Carp::croak "invalid reference type for $as: " . ref $as;
0.000000,0,0.000000,#   } else {
0.000000,0,0.000000,#     no strict 'refs';
0.000000,0,0.000000,#     delete &{$into . '::' . $as};
0.000000,0,0.000000,#   }
0.000000,0,0.000000,# }
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_generator {
0.000081,53,0.000002,my ($arg) = @_;
0.000108,53,0.000002,my ($class, $name, $generator) = @$arg{qw(class name generator)};
0.000000,0,0.000000,
0.000075,53,0.000001,if (not defined $generator) {
0.000032,3,0.000011,my $code = $class->can($name)
0.000000,0,0.000000,or Carp::croak "can't locate exported subroutine $name via $class";
0.000017,3,0.000006,return $code;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# I considered making this "$class->$generator(" but it seems that
0.000000,0,0.000000,# overloading precedence would turn an overloaded-as-code generator object
0.000000,0,0.000000,# into a string before code. -- rjbs, 2006-06-11
0.000697,50,0.000014,return $generator->($class, $name, $arg->{arg}, $arg->{col})
0.000000,0,0.000000,if Params::Util::_CODELIKE($generator); ## no critic Private
0.000000,0,0.000000,
0.000000,0,0.000000,# This "must" be a scalar reference, to a generator method name.
0.000000,0,0.000000,# -- rjbs, 2006-12-05
0.000000,0,0.000000,return $class->$$generator($name, $arg->{arg}, $arg->{col});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_installer {
0.000017,10,0.000002,my ($arg, $to_export) = @_;
0.000000,0,0.000000,
0.000283,10,0.000028,for (my $i = 0; $i < @$to_export; $i += 2) {
0.000103,53,0.000002,my ($as, $code) = @$to_export[ $i, $i+1 ];
0.000000,0,0.000000,
0.000000,0,0.000000,# Allow as isa ARRAY to push onto an array?
0.000000,0,0.000000,# Allow into isa HASH to install name=>code into hash?
0.000000,0,0.000000,
0.000162,53,0.000003,if (ref $as eq 'SCALAR') {
0.000000,0,0.000000,$$as = $code;
0.000000,0,0.000000,} elsif (ref $as) {
0.000000,0,0.000000,Carp::croak "invalid reference type for $as: " . ref $as;
0.000000,0,0.000000,} else {
0.000351,53,0.000007,Sub::Install::reinstall_sub({
0.000000,0,0.000000,code => $code,
0.000000,0,0.000000,into => $arg->{into},
0.000000,0,0.000000,as   => $as
0.000000,0,0.000000,});
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub default_exporter {
0.000000,0,0.000000,Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
0.000000,0,0.000000,goto &default_installer;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,setup_exporter({
0.000000,0,0.000000,exports => [
0.000000,0,0.000000,qw(setup_exporter build_exporter),
0.000000,0,0.000000,_import => sub { build_exporter($_[2]) },
0.000013,1,0.000013,],
0.000000,0,0.000000,groups  => {
0.000000,0,0.000000,all   => [ qw(setup_exporter build_export) ],
0.000000,0,0.000000,},
0.000000,0,0.000000,collectors => { -setup => \&_setup },
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,sub _setup {
0.000000,0,0.000000,my ($value, $arg) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,if (ref $value eq 'HASH') {
0.000000,0,0.000000,push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,} elsif (ref $value eq 'ARRAY') {
0.000000,0,0.000000,push @{ $arg->{import_args} },
0.000000,0,0.000000,[ _import => { -as => 'import', exports => $value } ];
0.000000,0,0.000000,return 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000006,1,0.000006,"jn8:32"; # <-- magic true value
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
