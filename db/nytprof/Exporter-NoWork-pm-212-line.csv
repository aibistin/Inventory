# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Exporter::NoWork;
0.000000,0,0.000000,
0.000061,2,0.000030,use 5.006;
0.000035,2,0.000018,use strict;
0.000032,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000044,2,0.000022,use Carp;
0.000228,2,0.000114,use Attribute::Handlers;
0.000000,0,0.000000,
0.000002,1,0.000002,our $VERSION = '0.03';
0.000000,0,0.000000,
0.000001,1,0.000001,my %Config;
0.000000,0,0.000000,
0.000000,0,0.000000,sub import {
0.000004,2,0.000002,my $from = shift;
0.000004,2,0.000002,my $to   = caller;
0.000000,0,0.000000,
0.000033,2,0.000017,no strict 'refs';
0.000590,2,0.000295,no warnings 'uninitialized';
0.000000,0,0.000000,
0.000003,2,0.000002,if ($from eq __PACKAGE__) {
0.000000,0,0.000000,
0.000000,0,0.000000,# ->isa fails on 5.6, don't know why
0.000000,0,0.000000,my $doneISA = $] < 5.008
0.000024,1,0.000024,? grep $_ eq __PACKAGE__, @{"$to\::ISA"}
0.000000,0,0.000000,: $to->isa(__PACKAGE__);
0.000000,0,0.000000,
0.000012,1,0.000012,push @{"$to\::ISA"}, __PACKAGE__ unless $doneISA;
0.000000,0,0.000000,
0.000003,1,0.000003,for (@_) {
0.000000,0,0.000000,/^-MAGIC$/ and do {
0.000000,0,0.000000,$Config{$to}{uc} = 'magic';
0.000000,0,0.000000,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,/^-CONSTS$/ and do {
0.000000,0,0.000000,$Config{$to}{uc} = 'consts';
0.000000,0,0.000000,next;
0.000000,0,0.000000,};
0.000000,0,0.000000,push @{$Config{$to}{default}}, $_;
0.000000,0,0.000000,}
0.000007,1,0.000007,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000004,1,0.000004,unless ($Config{$from}{grovelled}) {
0.000024,1,0.000024,for (keys %{"$from\::"}) {
0.000000,0,0.000000,
0.000726,118,0.000006,if (exists &{"$from\::$_"}
0.000000,0,0.000000,and not /^(?:IMPORT|CONFIG)$/
0.000000,0,0.000000,and not /^_/
0.000000,0,0.000000,and not ($Config{$from}{uc} eq 'magic' and /^[[:upper:]]+$/)
0.000000,0,0.000000,){
0.000045,28,0.000002,if ($Config{$from}{uc} eq 'consts' 
0.000000,0,0.000000,and /^[[:upper:]_\d]+$/
0.000000,0,0.000000,) {
0.000000,0,0.000000,push @{$Config{$from}{default}}, $_;
0.000000,0,0.000000,push @{$Config{$from}{consts}},  $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000060,28,0.000002,push @{$Config{$from}{all}}, $_;
0.000000,0,0.000000,}
0.000000,0,0.000000,}   
0.000002,1,0.000002,$Config{$from}{grovelled} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,@_ or @_ = @{$Config{$from}{default}};
0.000000,0,0.000000,
0.000017,1,0.000017,$from->can('IMPORT') and @_ = $from->IMPORT(@_);
0.000000,0,0.000000,
0.000002,1,0.000002,my @todo;
0.000000,0,0.000000,
0.000000,0,0.000000,SUB:
0.000008,1,0.000008,while (my $sub = shift) {
0.000000,0,0.000000,
0.000000,0,0.000000,# we have to do it like this, as C<local $_> doesn't work
0.000007,2,0.000003,for ($sub) {
0.000023,2,0.000012,/^import$/i | /^CONFIG$/ and do {
0.000000,0,0.000000,croak "Import methods can't be imported";
0.000000,0,0.000000,next SUB;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000015,2,0.000007,s/^:// and do {
0.000000,0,0.000000,/^ALL$/ and do {
0.000000,0,0.000000,push @_, @{$Config{$from}{all}};
0.000000,0,0.000000,next SUB;
0.000000,0,0.000000,};
0.000000,0,0.000000,/^DEFAULT$/ and do {
0.000000,0,0.000000,push @_, @{$Config{$from}{default}};
0.000000,0,0.000000,next SUB;
0.000000,0,0.000000,};
0.000000,0,0.000000,/^CONSTS$/ and do {
0.000000,0,0.000000,push @_, @{$Config{$from}{consts}};
0.000000,0,0.000000,next SUB;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000000,0,0.000000,if ($Config{$from}{tags}{$_}) {
0.000000,0,0.000000,push @todo, @{$Config{$from}{tags}{$_}};
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak qq{Tag ":$_" is not recognized by $from};
0.000000,0,0.000000,}
0.000000,0,0.000000,next SUB;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000013,2,0.000006,s/^-// and do {
0.000000,0,0.000000,if (${"$from\::CONFIG"}{$_}) {
0.000000,0,0.000000,${"$from\::CONFIG"}{$_}->($from, $_, \@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($from->can('CONFIG')) {
0.000000,0,0.000000,$from->CONFIG($_, \@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak qq{Config option "-$_" is not recognized by $from};
0.000000,0,0.000000,}
0.000000,0,0.000000,next SUB;
0.000000,0,0.000000,};
0.000000,0,0.000000,
0.000011,2,0.000006,s/^\&//;
0.000021,2,0.000010,/\W/ || /^_/ and croak qq{"$_" is not exported by $from};
0.000000,0,0.000000,
0.000000,0,0.000000,{
0.000297,4,0.000074,no warnings 'uninitialized';
0.000016,2,0.000008,/^[[:upper:]]+$/ and $Config{$from}{uc} eq 'magic'
0.000000,0,0.000000,and croak qq{Magic methods can't be exported};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000005,2,0.000003,if (exists &{"$from\::$sub"}) { 
0.000000,0,0.000000,#carp "copying \&$from\::$sub into $to";
0.000011,2,0.000005,*{"$to\::$sub"} = \&{"$from\::$sub"};
0.000004,2,0.000002,next SUB;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,croak qq{"$sub" is not exported by $from};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000021,1,0.000021,for (keys %{"$from\::"}) {
0.000507,120,0.000004,for my $ref (@todo) {
0.000000,0,0.000000,defined &{"$from\::$_"} or next;
0.000000,0,0.000000,#carp "ref-ifying \&$from\::$_";
0.000000,0,0.000000,if ($ref == \&{"$from\::$_"}) {
0.000000,0,0.000000,*{"$to\::$_"} = $ref;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub Tag : ATTR(CODE,BEGIN) {
0.000000,0,0.000000,my ($pkg, undef, $ref, undef, $tag, undef) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,ref $tag or $tag = [$tag];
0.000000,0,0.000000,for (@$tag) {
0.000000,0,0.000000,push @{$Config{$pkg}{tags}{$_}}, $ref;
0.000000,0,0.000000,}
0.000049,2,0.000025,}
0.000000,0,0.000000,
0.000004,1,0.000004,1;
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
