# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,# !!!!!!!   INTERNAL PERL USE ONLY   !!!!!!!
0.000000,0,0.000000,# This helper module is for internal use by core Perl only.  This module is
0.000000,0,0.000000,# subject to change or removal at any time without notice.  Don't use it
0.000000,0,0.000000,# directly.  Use the public <charnames> module instead.
0.000000,0,0.000000,
0.000000,0,0.000000,package _charnames;
0.000034,2,0.000017,use strict;
0.000031,2,0.000016,use warnings;
0.000039,2,0.000020,use File::Spec;
0.000002,1,0.000002,our $VERSION = '1.36';
0.000029,2,0.000015,use unicore::Name;    # mktables-generated algorithmically-defined names
0.000000,0,0.000000,
0.000029,2,0.000015,use bytes ();          # for $bytes::hint_bits
0.000496,2,0.000248,use re "/aa";          # Everything in here should be ASCII
0.000000,0,0.000000,
0.000002,1,0.000002,$Carp::Internal{ (__PACKAGE__) } = 1;
0.000000,0,0.000000,
0.000000,0,0.000000,# Translate between Unicode character names and their code points.  This is a
0.000000,0,0.000000,# submodule of package <charnames>, used to allow \N{...} to be autoloaded,
0.000000,0,0.000000,# but it was decided not to autoload the various functions in charnames; the
0.000000,0,0.000000,# splitting allows this behavior.
0.000000,0,0.000000,#
0.000000,0,0.000000,# The official names with their code points are stored in a table in
0.000000,0,0.000000,# lib/unicore/Name.pl which is read in as a large string (almost 3/4 Mb in
0.000000,0,0.000000,# Unicode 6.0).  Each code point/name combination is separated by a \n in the
0.000000,0,0.000000,# string.  (Some of the CJK and the Hangul syllable names are determined
0.000000,0,0.000000,# instead algorithmically via subroutines stored instead in
0.000000,0,0.000000,# lib/unicore/Name.pm).  Because of the large size of this table, it isn't
0.000000,0,0.000000,# converted into hashes for faster lookup.
0.000000,0,0.000000,#
0.000000,0,0.000000,# But, user defined aliases are stored in their own hashes, as are Perl
0.000000,0,0.000000,# extensions to the official names.  These are checked first before looking at
0.000000,0,0.000000,# the official table.
0.000000,0,0.000000,#
0.000000,0,0.000000,# Basically, the table is grepped for the input code point (viacode()) or
0.000000,0,0.000000,# name (the other functions), and the corresponding value on the same line is
0.000000,0,0.000000,# returned.  The grepping is done by turning the input into a regular
0.000000,0,0.000000,# expression.  Thus, the same table does double duty, used by both name and
0.000000,0,0.000000,# code point lookup.  (If we were to have hashes, we would need two, one for
0.000000,0,0.000000,# each lookup direction.)
0.000000,0,0.000000,#
0.000000,0,0.000000,# For loose name matching, the logical thing would be to have a table
0.000000,0,0.000000,# with all the ignorable characters squeezed out, and then grep it with the
0.000000,0,0.000000,# similiarly-squeezed input name.  (And this is in fact how the lookups are
0.000000,0,0.000000,# done with the small Perl extension hashes.)  But since we need to be able to
0.000000,0,0.000000,# go from code point to official name, the original table would still need to
0.000000,0,0.000000,# exist.  Due to the large size of the table, it was decided to not read
0.000000,0,0.000000,# another very large string into memory for a second table.  Instead, the
0.000000,0,0.000000,# regular expression of the input name is modified to have optional spaces and
0.000000,0,0.000000,# dashes between characters.  For example, in strict matching, the regular
0.000000,0,0.000000,# expression would be:
0.000000,0,0.000000,#   qr/\tDIGIT ONE$/m
0.000000,0,0.000000,# Under loose matching, the blank would be squeezed out, and the re would be:
0.000000,0,0.000000,#   qr/\tD[- ]?I[- ]?G[- ]?I[- ]?T[- ]?O[- ]?N[- ]?E$/m
0.000000,0,0.000000,# which matches a blank or dash between any characters in the official table.
0.000000,0,0.000000,#
0.000000,0,0.000000,# This is also how script lookup is done.  Basically the re looks like
0.000000,0,0.000000,#   qr/ (?:LATIN|GREEK|CYRILLIC) (?:SMALL )?LETTER $name/
0.000000,0,0.000000,# where $name is the loose or strict regex for the remainder of the name.
0.000000,0,0.000000,
0.000000,0,0.000000,# The hashes are stored as utf8 strings.  This makes it easier to deal with
0.000000,0,0.000000,# sequences.  I (khw) also tried making Name.pl utf8, but it slowed things
0.000000,0,0.000000,# down by a factor of 7.  I then tried making Name.pl store the ut8
0.000000,0,0.000000,# equivalents but not calling them utf8.  That led to similar speed as leaving
0.000000,0,0.000000,# it alone, but since that is harder for a human to parse, I left it as-is.
0.000000,0,0.000000,
0.000005,1,0.000005,my %system_aliases = (
0.000000,0,0.000000,
0.000000,0,0.000000,'SINGLE-SHIFT 2'                => pack("U", 0x8E),
0.000000,0,0.000000,'SINGLE-SHIFT 3'                => pack("U", 0x8F),
0.000000,0,0.000000,'PRIVATE USE 1'                 => pack("U", 0x91),
0.000000,0,0.000000,'PRIVATE USE 2'                 => pack("U", 0x92),
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# These are the aliases above that differ under :loose and :full matching
0.000000,0,0.000000,# because the :full versions have blanks or hyphens in them.
0.000000,0,0.000000,#my %loose_system_aliases = (
0.000000,0,0.000000,#);
0.000000,0,0.000000,
0.000000,0,0.000000,#my %deprecated_aliases;
0.000000,0,0.000000,#$deprecated_aliases{'BELL'} = pack("U", 0x07) if $^V lt v5.17.0;
0.000000,0,0.000000,
0.000000,0,0.000000,#my %loose_deprecated_aliases = (
0.000000,0,0.000000,#);
0.000000,0,0.000000,
0.000000,0,0.000000,# These are special cased in :loose matching, differing only in a medial
0.000000,0,0.000000,# hyphen
0.000002,1,0.000002,my $HANGUL_JUNGSEONG_O_E_utf8 = pack("U", 0x1180);
0.000001,1,0.000001,my $HANGUL_JUNGSEONG_OE_utf8 = pack("U", 0x116C);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000001,1,0.000001,my $txt;  # The table of official character names
0.000000,0,0.000000,
0.000001,1,0.000001,my %full_names_cache; # Holds already-looked-up names, so don't have to
0.000000,0,0.000000,# re-look them up again.  The previous versions of charnames had scoping
0.000000,0,0.000000,# bugs.  For example if we use script A in one scope and find and cache
0.000000,0,0.000000,# what Z resolves to, we can't use that cache in a different scope that
0.000000,0,0.000000,# uses script B instead of A, as Z might be an entirely different letter
0.000000,0,0.000000,# there; or there might be different aliases in effect in different
0.000000,0,0.000000,# scopes, or :short may be in effect or not effect in different scopes,
0.000000,0,0.000000,# or various combinations thereof.  This was solved in this version
0.000000,0,0.000000,# mostly by moving things to %^H.  But some things couldn't be moved
0.000000,0,0.000000,# there.  One of them was the cache of runtime looked-up names, in part
0.000000,0,0.000000,# because %^H is read-only at runtime.  I (khw) don't know why the cache
0.000000,0,0.000000,# was run-time only in the previous versions: perhaps oversight; perhaps
0.000000,0,0.000000,# that compile time looking doesn't happen in a loop so didn't think it
0.000000,0,0.000000,# was worthwhile; perhaps not wanting to make the cache too large.  But
0.000000,0,0.000000,# I decided to make it compile time as well; this could easily be
0.000000,0,0.000000,# changed.
0.000000,0,0.000000,# Anyway, this hash is not scoped, and is added to at runtime.  It
0.000000,0,0.000000,# doesn't have scoping problems because the data in it is restricted to
0.000000,0,0.000000,# official names, which are always invariant, and we only set it and
0.000000,0,0.000000,# look at it at during :full lookups, so is unaffected by any other
0.000000,0,0.000000,# scoped options.  I put this in to maintain parity with the older
0.000000,0,0.000000,# version.  If desired, a %short_names cache could also be made, as well
0.000000,0,0.000000,# as one for each script, say in %script_names_cache, with each key
0.000000,0,0.000000,# being a hash for a script named in a 'use charnames' statement.  I
0.000000,0,0.000000,# decided not to do that for now, just because it's added complication,
0.000000,0,0.000000,# and because I'm just trying to maintain parity, not extend it.
0.000000,0,0.000000,
0.000000,0,0.000000,# Like %full_names_cache, but for use when :loose is in effect.  There needs
0.000000,0,0.000000,# to be two caches because :loose may not be in effect for a scope, and a
0.000000,0,0.000000,# loose name could inappropriately be returned when only exact matching is
0.000000,0,0.000000,# called for.
0.000001,1,0.000001,my %loose_names_cache;
0.000000,0,0.000000,
0.000000,0,0.000000,# Designed so that test decimal first, and then hex.  Leading zeros
0.000000,0,0.000000,# imply non-decimal, as do non-[0-9]
0.000015,1,0.000015,my $decimal_qr = qr/^[1-9]\d*$/;
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns the hex number in $1.
0.000008,1,0.000008,my $hex_qr = qr/^(?:[Uu]\+|0[xX])?([[:xdigit:]]+)$/;
0.000000,0,0.000000,
0.000000,0,0.000000,sub croak
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp; goto &Carp::croak;
0.000000,0,0.000000,} # croak
0.000000,0,0.000000,
0.000000,0,0.000000,sub carp
0.000000,0,0.000000,{
0.000000,0,0.000000,require Carp; goto &Carp::carp;
0.000000,0,0.000000,} # carp
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias (@) # Set up a single alias
0.000000,0,0.000000,{
0.000000,0,0.000000,my @errors;
0.000000,0,0.000000,
0.000000,0,0.000000,my $alias = ref $_[0] ? $_[0] : { @_ };
0.000000,0,0.000000,foreach my $name (sort keys %$alias) {  # Sort only because it helps having
0.000000,0,0.000000,# deterministic output for
0.000000,0,0.000000,# t/lib/charnames/alias
0.000000,0,0.000000,my $value = $alias->{$name};
0.000000,0,0.000000,next unless defined $value;          # Omit if screwed up.
0.000000,0,0.000000,
0.000000,0,0.000000,# Is slightly slower to just after this statement see if it is
0.000000,0,0.000000,# decimal, since we already know it is after having converted from
0.000000,0,0.000000,# hex, but makes the code easier to maintain, and is called
0.000000,0,0.000000,# infrequently, only at compile-time
0.000000,0,0.000000,if ($value !~ $decimal_qr && $value =~ $hex_qr) {
0.000000,0,0.000000,$value = CORE::hex $1;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($value =~ $decimal_qr) {
0.000088,2,0.000044,no warnings qw(non_unicode surrogate nonchar); # Allow any of these
0.000000,0,0.000000,$^H{charnames_ord_aliases}{$name} = pack("U", $value);
0.000000,0,0.000000,
0.000000,0,0.000000,# Use a canonical form.
0.000000,0,0.000000,$^H{charnames_inverse_ords}{sprintf("%05X", $value)} = $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# This regex needs to be sync'd with the code in toke.c that checks
0.000000,0,0.000000,# for the same thing
0.000000,0,0.000000,if ($name !~ / ^
0.000000,0,0.000000,\p{_Perl_Charname_Begin}
0.000000,0,0.000000,\p{_Perl_Charname_Continue}*
0.000468,2,0.000234,$ /x) {
0.000000,0,0.000000,
0.000000,0,0.000000,push @errors, $name;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$^H{charnames_name_aliases}{$name} = $value;
0.000000,0,0.000000,
0.000000,0,0.000000,if (warnings::enabled('deprecated')) {
0.000000,0,0.000000,if ($name =~ / ( .* \s ) ( \s* ) $ /x) {
0.000000,0,0.000000,carp "Trailing white-space in a charnames alias definition is deprecated; marked by <-- HERE in '$1 <-- HERE " . $2 . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Use '+' instead of '*' in this regex, because any trailing
0.000000,0,0.000000,# blanks have already been warned about.
0.000000,0,0.000000,if ($name =~ / ( .*? \s{2} ) ( .+ ) /x) {
0.000000,0,0.000000,carp "A sequence of multiple spaces in a charnames alias definition is deprecated; marked by <-- HERE in '$1 <-- HERE " . $2 . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# We find and output all errors from this :alias definition, rather than
0.000000,0,0.000000,# failing on the first one, so fewer runs are needed to get it to compile
0.000000,0,0.000000,if (@errors) {
0.000000,0,0.000000,foreach my $name (@errors) {
0.000000,0,0.000000,my $ok = "";
0.000487,1,0.000487,$ok = $1 if $name =~ / ^ ( \p{Alpha} [-\p{XPosixWord} ():\xa0]* ) /x;
0.000000,0,0.000000,my $first_bad = substr($name, length($ok), 1);
0.000000,0,0.000000,$name = "Invalid character in charnames alias definition; marked by <-- HERE in '$ok$first_bad<-- HERE " . substr($name, length($ok) + 1) . "'";
0.000000,0,0.000000,}
0.000000,0,0.000000,croak join "\n", @errors;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return;
0.000000,0,0.000000,} # alias
0.000000,0,0.000000,
0.000000,0,0.000000,sub not_legal_use_bytes_msg {
0.000000,0,0.000000,my ($name, $utf8) = @_;
0.000000,0,0.000000,my $return;
0.000000,0,0.000000,
0.000000,0,0.000000,if (length($utf8) == 1) {
0.000000,0,0.000000,$return = sprintf("Character 0x%04x with name '%s' is", ord $utf8, $name);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$return = sprintf("String with name '%s' (and ordinals %s) contains character(s)", $name, join(" ", map { sprintf "0x%04X", ord $_ } split(//, $utf8)));
0.000000,0,0.000000,}
0.000000,0,0.000000,return $return . " above 0xFF with 'use bytes' in effect";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub alias_file ($)  # Reads a file containing alias definitions
0.000000,0,0.000000,{
0.000000,0,0.000000,my ($arg, $file) = @_;
0.000000,0,0.000000,if (-f $arg && File::Spec->file_name_is_absolute ($arg)) {
0.000000,0,0.000000,$file = $arg;
0.000000,0,0.000000,}
0.002268,1,0.002268,elsif ($arg =~ m/ ^ \p{_Perl_IDStart} \p{_Perl_IDCont}* $/x) {
0.000000,0,0.000000,$file = "unicore/${arg}_alias.pl";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,croak "Charnames alias file names can only have identifier characters";
0.000000,0,0.000000,}
0.000000,0,0.000000,if (my @alias = do $file) {
0.000000,0,0.000000,@alias == 1 && !defined $alias[0] and
0.000000,0,0.000000,croak "$file cannot be used as alias file for charnames";
0.000000,0,0.000000,@alias % 2 and
0.000000,0,0.000000,croak "$file did not return a (valid) list of alias pairs";
0.000000,0,0.000000,alias (@alias);
0.000000,0,0.000000,return (1);
0.000000,0,0.000000,}
0.000000,0,0.000000,0;
0.000000,0,0.000000,} # alias_file
0.000000,0,0.000000,
0.000000,0,0.000000,# For use when don't import anything.  This structure must be kept in
0.000000,0,0.000000,# sync with the one that import() fills up.
0.000004,1,0.000004,my %dummy_H = (
0.000000,0,0.000000,charnames_stringified_names => "",
0.000000,0,0.000000,charnames_stringified_ords => "",
0.000000,0,0.000000,charnames_scripts => "",
0.000000,0,0.000000,charnames_full => 1,
0.000000,0,0.000000,charnames_loose => 0,
0.000000,0,0.000000,charnames_short => 0,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,sub lookup_name ($$$) {
0.000000,0,0.000000,my ($name, $wants_ord, $runtime) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# Lookup the name or sequence $name in the tables.  If $wants_ord is false,
0.000000,0,0.000000,# returns the string equivalent of $name; if true, returns the ordinal value
0.000000,0,0.000000,# instead, but in this case $name must not be a sequence; otherwise undef is
0.000000,0,0.000000,# returned and a warning raised.  $runtime is 0 if compiletime, otherwise
0.000000,0,0.000000,# gives the number of stack frames to go back to get the application caller
0.000000,0,0.000000,# info.
0.000000,0,0.000000,# If $name is not found, returns undef in runtime with no warning; and in
0.000000,0,0.000000,# compiletime, the Unicode replacement character, with a warning.
0.000000,0,0.000000,
0.000000,0,0.000000,# It looks first in the aliases, then in the large table of official Unicode
0.000000,0,0.000000,# names.
0.000000,0,0.000000,
0.000000,0,0.000000,my $utf8;       # The string result
0.000000,0,0.000000,my $save_input;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($runtime) {
0.000000,0,0.000000,
0.000000,0,0.000000,my $hints_ref = (caller($runtime))[10];
0.000000,0,0.000000,
0.000000,0,0.000000,# If we didn't import anything (which happens with 'use charnames ()',
0.000000,0,0.000000,# substitute a dummy structure.
0.000000,0,0.000000,$hints_ref = \%dummy_H if ! defined $hints_ref
0.000000,0,0.000000,|| (! defined $hints_ref->{charnames_full}
0.000000,0,0.000000,&& ! defined $hints_ref->{charnames_loose});
0.000000,0,0.000000,
0.000000,0,0.000000,# At runtime, but currently not at compile time, $^H gets
0.000000,0,0.000000,# stringified, so un-stringify back to the original data structures.
0.000000,0,0.000000,# These get thrown away by perl before the next invocation
0.000000,0,0.000000,# Also fill in the hash with the non-stringified data.
0.000000,0,0.000000,# N.B.  New fields must be also added to %dummy_H
0.000000,0,0.000000,
0.000000,0,0.000000,%{$^H{charnames_name_aliases}} = split ',',
0.000000,0,0.000000,$hints_ref->{charnames_stringified_names};
0.000000,0,0.000000,%{$^H{charnames_ord_aliases}} = split ',',
0.000000,0,0.000000,$hints_ref->{charnames_stringified_ords};
0.000000,0,0.000000,$^H{charnames_scripts} = $hints_ref->{charnames_scripts};
0.000000,0,0.000000,$^H{charnames_full} = $hints_ref->{charnames_full};
0.000000,0,0.000000,$^H{charnames_loose} = $hints_ref->{charnames_loose};
0.000000,0,0.000000,$^H{charnames_short} = $hints_ref->{charnames_short};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $loose = $^H{charnames_loose};
0.000000,0,0.000000,my $lookup_name;  # Input name suitably modified for grepping for in the
0.000000,0,0.000000,# table
0.000000,0,0.000000,
0.000000,0,0.000000,# User alias should be checked first or else can't override ours, and if we
0.000000,0,0.000000,# were to add any, could conflict with theirs.
0.000000,0,0.000000,if (exists $^H{charnames_ord_aliases}{$name}) {
0.000000,0,0.000000,$utf8 = $^H{charnames_ord_aliases}{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (exists $^H{charnames_name_aliases}{$name}) {
0.000000,0,0.000000,$name = $^H{charnames_name_aliases}{$name};
0.000000,0,0.000000,$save_input = $lookup_name = $name;  # Cache the result for any error
0.000000,0,0.000000,# message
0.000000,0,0.000000,# The aliases are documented to not match loosely, so change loose match
0.000000,0,0.000000,# into full.
0.000000,0,0.000000,if ($loose) {
0.000000,0,0.000000,$loose = 0;
0.000000,0,0.000000,$^H{charnames_full} = 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, not a user alias.  That means that loose matching may be in
0.000000,0,0.000000,# effect; will have to modify the input name.
0.000000,0,0.000000,$lookup_name = $name;
0.000000,0,0.000000,if ($loose) {
0.000000,0,0.000000,$lookup_name = uc $lookup_name;
0.000000,0,0.000000,
0.000000,0,0.000000,# Squeeze out all underscores
0.000000,0,0.000000,$lookup_name =~ s/_//g;
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove all medial hyphens
0.000000,0,0.000000,$lookup_name =~ s/ (?<= \S  ) - (?= \S  )//gx;
0.000000,0,0.000000,
0.000000,0,0.000000,# Squeeze out all spaces
0.000000,0,0.000000,$lookup_name =~ s/\s//g;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, $lookup_name has been modified as necessary for looking in the
0.000000,0,0.000000,# hashes.  Check the system alias files next.  Most of these aliases are
0.000000,0,0.000000,# the same for both strict and loose matching.  To save space, the ones
0.000000,0,0.000000,# which differ are in their own separate hash, which is checked if loose
0.000000,0,0.000000,# matching is selected and the regular match fails.  To save time, the
0.000000,0,0.000000,# loose hashes could be expanded to include all aliases, and there would
0.000000,0,0.000000,# only have to be one check.  But if someone specifies :loose, they are
0.000000,0,0.000000,# interested in convenience over speed, and the time for this second check
0.000000,0,0.000000,# is miniscule compared to the rest of the routine.
0.000000,0,0.000000,if (exists $system_aliases{$lookup_name}) {
0.000000,0,0.000000,$utf8 = $system_aliases{$lookup_name};
0.000000,0,0.000000,}
0.000000,0,0.000000,# There are currently no entries in this hash, so don't waste time looking
0.000000,0,0.000000,# for them.  But the code is retained for the unlikely possibility that
0.000000,0,0.000000,# some will be added in the future.
0.000000,0,0.000000,#    elsif ($loose && exists $loose_system_aliases{$lookup_name}) {
0.000000,0,0.000000,#      $utf8 = $loose_system_aliases{$lookup_name};
0.000000,0,0.000000,#    }
0.000000,0,0.000000,#    if (exists $deprecated_aliases{$lookup_name}) {
0.000000,0,0.000000,#      require warnings;
0.000000,0,0.000000,#      warnings::warnif('deprecated',
0.000000,0,0.000000,#                       "Unicode character name \"$name\" is deprecated, use \""
0.000000,0,0.000000,#                       . viacode(ord $deprecated_aliases{$lookup_name})
0.000000,0,0.000000,#                       . "\" instead");
0.000000,0,0.000000,#      $utf8 = $deprecated_aliases{$lookup_name};
0.000000,0,0.000000,#    }
0.000000,0,0.000000,# There are currently no entries in this hash, so don't waste time looking
0.000000,0,0.000000,# for them.  But the code is retained for the unlikely possibility that
0.000000,0,0.000000,# some will be added in the future.
0.000000,0,0.000000,#    elsif ($loose && exists $loose_deprecated_aliases{$lookup_name}) {
0.000000,0,0.000000,#      require warnings;
0.000000,0,0.000000,#      warnings::warnif('deprecated',
0.000000,0,0.000000,#                       "Unicode character name \"$name\" is deprecated, use \""
0.000000,0,0.000000,#                       . viacode(ord $loose_deprecated_aliases{$lookup_name})
0.000000,0,0.000000,#                       . "\" instead");
0.000000,0,0.000000,#      $utf8 = $loose_deprecated_aliases{$lookup_name};
0.000000,0,0.000000,#    }
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my @off;  # Offsets into table of pattern match begin and end
0.000000,0,0.000000,
0.000000,0,0.000000,# If haven't found it yet...
0.000000,0,0.000000,if (! defined $utf8) {
0.000000,0,0.000000,
0.000000,0,0.000000,# See if has looked this input up earlier.
0.000000,0,0.000000,if (! $loose && $^H{charnames_full} && exists $full_names_cache{$name}) {
0.000000,0,0.000000,$utf8 = $full_names_cache{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ($loose && exists $loose_names_cache{$name}) {
0.000000,0,0.000000,$utf8 = $loose_names_cache{$name};
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # Here, must do a look-up
0.000000,0,0.000000,
0.000000,0,0.000000,# If full or loose matching succeeded, points to where to cache the
0.000000,0,0.000000,# result
0.000000,0,0.000000,my $cache_ref;
0.000000,0,0.000000,
0.000000,0,0.000000,## Suck in the code/name list as a big string.
0.000000,0,0.000000,## Lines look like:
0.000000,0,0.000000,##     "00052\tLATIN CAPITAL LETTER R\n"
0.000000,0,0.000000,# or
0.000000,0,0.000000,#      "0052 0303\tLATIN CAPITAL LETTER R WITH TILDE\n"
0.000000,0,0.000000,$txt = do "unicore/Name.pl" unless $txt;
0.000000,0,0.000000,
0.000000,0,0.000000,## @off will hold the index into the code/name string of the start and
0.000000,0,0.000000,## end of the name as we find it.
0.000000,0,0.000000,
0.000000,0,0.000000,## If :loose, look for a loose match; if :full, look for the name
0.000000,0,0.000000,## exactly
0.000000,0,0.000000,# First, see if the name is one which is algorithmically determinable.
0.000000,0,0.000000,# The subroutine is included in Name.pl.  The table contained in
0.000000,0,0.000000,# $txt doesn't contain these.  Experiments show that checking
0.000000,0,0.000000,# for these before checking for the regular names has no
0.000000,0,0.000000,# noticeable impact on performance for the regular names, but
0.000000,0,0.000000,# the other way around slows down finding these immensely.
0.000000,0,0.000000,# Algorithmically determinables are not placed in the cache because
0.000000,0,0.000000,# that uses up memory, and finding these again is fast.
0.000000,0,0.000000,if (($loose || $^H{charnames_full})
0.000000,0,0.000000,&& (defined (my $ord = charnames::name_to_code_point_special($lookup_name, $loose))))
0.000000,0,0.000000,{
0.000000,0,0.000000,$utf8 = pack("U", $ord);
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Not algorithmically determinable; look up in the table.  The name
0.000000,0,0.000000,# will be turned into a regex, so quote any meta characters.
0.000000,0,0.000000,$lookup_name = quotemeta $lookup_name;
0.000000,0,0.000000,
0.000000,0,0.000000,if ($loose) {
0.000000,0,0.000000,
0.000000,0,0.000000,# For loose matches, $lookup_name has already squeezed out the
0.000000,0,0.000000,# non-essential characters.  We have to add in code to make the
0.000000,0,0.000000,# squeezed version match the non-squeezed equivalent in the table.
0.000000,0,0.000000,# The only remaining hyphens are ones that start or end a word in
0.000000,0,0.000000,# the original.  They have been quoted in $lookup_name so they look
0.000000,0,0.000000,# like "\-".  Change all other characters except the backslash
0.000000,0,0.000000,# quotes for any metacharacters, and the final character, so that
0.000000,0,0.000000,# e.g., COLON gets transformed into: /C[- ]?O[- ]?L[- ]?O[- ]?N/
0.000000,0,0.000000,$lookup_name =~ s/ (?! \\ -)    # Don't do this to the \- sequence
0.000000,0,0.000000,( [^-\\] )   # Nor the "-" within that sequence,
0.000000,0,0.000000,# nor the "\" that quotes metachars,
0.000000,0,0.000000,# but otherwise put the char into $1
0.000000,0,0.000000,(?=.)        # And don't do it for the final char
0.000000,0,0.000000,/$1\[- \]?/gx; # And add an optional blank or
0.000000,0,0.000000,# '-' after each $1 char
0.000000,0,0.000000,
0.000000,0,0.000000,# Those remaining hyphens were originally at the beginning or end of
0.000000,0,0.000000,# a word, so they can match either a blank before or after, but not
0.000000,0,0.000000,# both.  (Keep in mind that they have been quoted, so are a '\-'
0.000000,0,0.000000,# sequence)
0.000000,0,0.000000,$lookup_name =~ s/\\ -/(?:- | -)/xg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Do the lookup in the full table if asked for, and if succeeds
0.000000,0,0.000000,# save the offsets and set where to cache the result.
0.000000,0,0.000000,if (($loose || $^H{charnames_full}) && $txt =~ /\t$lookup_name$/m) {
0.000000,0,0.000000,@off = ($-[0] + 1, $+[0]);    # The 1 is for the tab
0.000000,0,0.000000,$cache_ref = ($loose) ? \%loose_names_cache : \%full_names_cache;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, didn't look for, or didn't find the name.
0.000000,0,0.000000,# If :short is allowed, see if input is like "greek:Sigma".
0.000000,0,0.000000,# Keep in mind that $lookup_name has had the metas quoted.
0.000000,0,0.000000,my $scripts_trie = "";
0.000000,0,0.000000,my $name_has_uppercase;
0.000000,0,0.000000,if (($^H{charnames_short})
0.000000,0,0.000000,&& $lookup_name =~ /^ (?: \\ \s)*   # Quoted space
0.000000,0,0.000000,(.+?)         # $1 = the script
0.000000,0,0.000000,(?: \\ \s)*
0.000000,0,0.000000,\\ :          # Quoted colon
0.000000,0,0.000000,(?: \\ \s)*
0.000000,0,0.000000,(.+?)         # $2 = the name
0.000000,0,0.000000,(?: \\ \s)* $
0.000000,0,0.000000,/xs)
0.000000,0,0.000000,{
0.000000,0,0.000000,# Even in non-loose matching, the script traditionally has been
0.000000,0,0.000000,# case insensitve
0.000000,0,0.000000,$scripts_trie = "\U$1";
0.000000,0,0.000000,$lookup_name = $2;
0.000000,0,0.000000,
0.000000,0,0.000000,# Use original name to find its input casing, but ignore the
0.000000,0,0.000000,# script part of that to make the determination.
0.000000,0,0.000000,$save_input = $name if ! defined $save_input;
0.000000,0,0.000000,$name =~ s/.*?://;
0.000000,0,0.000000,$name_has_uppercase = $name =~ /[[:upper:]]/;
0.000000,0,0.000000,}
0.000000,0,0.000000,else { # Otherwise look in allowed scripts
0.000000,0,0.000000,$scripts_trie = $^H{charnames_scripts};
0.000000,0,0.000000,
0.000000,0,0.000000,# Use original name to find its input casing
0.000000,0,0.000000,$name_has_uppercase = $name =~ /[[:upper:]]/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $case = $name_has_uppercase ? "CAPITAL" : "SMALL";
0.000000,0,0.000000,return if (! $scripts_trie || $txt !~
0.000000,0,0.000000,/\t (?: $scripts_trie ) \ (?:$case\ )? LETTER \ \U$lookup_name $/xm);
0.000000,0,0.000000,
0.000000,0,0.000000,# Here have found the input name in the table.
0.000000,0,0.000000,@off = ($-[0] + 1, $+[0]);  # The 1 is for the tab
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, the input name has been found; we haven't set up the output,
0.000000,0,0.000000,# but we know where in the string
0.000000,0,0.000000,# the name starts.  The string is set up so that for single characters
0.000000,0,0.000000,# (and not named sequences), the name is preceded immediately by a
0.000000,0,0.000000,# tab and 5 hex digits for its code, with a \n before those.  Named
0.000000,0,0.000000,# sequences won't have the 7th preceding character be a \n.
0.000000,0,0.000000,# (Actually, for the very first entry in the table this isn't strictly
0.000000,0,0.000000,# true: subtracting 7 will yield -1, and the substr below will
0.000000,0,0.000000,# therefore yield the very last character in the table, which should
0.000000,0,0.000000,# also be a \n, so the statement works anyway.)
0.000000,0,0.000000,if (substr($txt, $off[0] - 7, 1) eq "\n") {
0.000000,0,0.000000,$utf8 = pack("U", CORE::hex substr($txt, $off[0] - 6, 5));
0.000000,0,0.000000,
0.000000,0,0.000000,# Handle the single loose matching special case, in which two names
0.000000,0,0.000000,# differ only by a single medial hyphen.  If the original had a
0.000000,0,0.000000,# hyphen (or more) in the right place, then it is that one.
0.000000,0,0.000000,$utf8 = $HANGUL_JUNGSEONG_O_E_utf8
0.000000,0,0.000000,if $loose
0.000000,0,0.000000,&& $utf8 eq $HANGUL_JUNGSEONG_OE_utf8
0.000000,0,0.000000,&& $name =~ m/O \s* - [-\s]* E/ix;
0.000000,0,0.000000,# Note that this wouldn't work if there were a 2nd
0.000000,0,0.000000,# OE in the name
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, is a named sequence.  Need to go looking for the beginning,
0.000000,0,0.000000,# which is just after the \n from the previous entry in the table.
0.000000,0,0.000000,# The +1 skips past that newline, or, if the rindex() fails, to put
0.000000,0,0.000000,# us to an offset of zero.
0.000000,0,0.000000,my $charstart = rindex($txt, "\n", $off[0] - 7) + 1;
0.000000,0,0.000000,$utf8 = pack("U*", map { CORE::hex }
0.000000,0,0.000000,split " ", substr($txt, $charstart, $off[0] - $charstart - 1));
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Cache the input so as to not have to search the large table
0.000000,0,0.000000,# again, but only if it came from the one search that we cache.
0.000000,0,0.000000,# (Haven't bothered with the pain of sorting out scoping issues for the
0.000000,0,0.000000,# scripts searches.)
0.000000,0,0.000000,$cache_ref->{$name} = $utf8 if defined $cache_ref;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, have the utf8.  If the return is to be an ord, must be any single
0.000000,0,0.000000,# character.
0.000000,0,0.000000,if ($wants_ord) {
0.000000,0,0.000000,return ord($utf8) if length $utf8 == 1;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, wants string output.  If utf8 is acceptable, just return what
0.000000,0,0.000000,# we've got; otherwise attempt to convert it to non-utf8 and return that.
0.000000,0,0.000000,my $in_bytes = ($runtime)
0.000000,0,0.000000,? (caller $runtime)[8] & $bytes::hint_bits
0.000000,0,0.000000,: $^H & $bytes::hint_bits;
0.000000,0,0.000000,return $utf8 if (! $in_bytes || utf8::downgrade($utf8, 1)) # The 1 arg
0.000000,0,0.000000,# means don't die on failure
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here, there is an error:  either there are too many characters, or the
0.000000,0,0.000000,# result string needs to be non-utf8, and at least one character requires
0.000000,0,0.000000,# utf8.  Prefer any official name over the input one for the error message.
0.000000,0,0.000000,if (@off) {
0.000000,0,0.000000,$name = substr($txt, $off[0], $off[1] - $off[0]) if @off;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,$name = (defined $save_input) ? $save_input : $_[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,if ($wants_ord) {
0.000000,0,0.000000,# Only way to get here in this case is if result too long.  Message
0.000000,0,0.000000,# assumes that our only caller that requires single char result is
0.000000,0,0.000000,# vianame.
0.000000,0,0.000000,carp "charnames::vianame() doesn't handle named sequences ($name).  Use charnames::string_vianame() instead";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Only other possible failure here is from use bytes.
0.000000,0,0.000000,if ($runtime) {
0.000000,0,0.000000,carp not_legal_use_bytes_msg($name, $utf8);
0.000000,0,0.000000,return;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,croak not_legal_use_bytes_msg($name, $utf8);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,} # lookup_name
0.000000,0,0.000000,
0.000000,0,0.000000,sub charnames {
0.000000,0,0.000000,
0.000000,0,0.000000,# For \N{...}.  Looks up the character name and returns the string
0.000000,0,0.000000,# representation of it.
0.000000,0,0.000000,
0.000000,0,0.000000,# The first 0 arg means wants a string returned; the second that we are in
0.000000,0,0.000000,# compile time
0.000000,0,0.000000,return lookup_name($_[0], 0, 0);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub import
0.000000,0,0.000000,{
0.000001,1,0.000001,shift; ## ignore class name
0.000000,0,0.000000,
0.000002,1,0.000002,if (not @_) {
0.000000,0,0.000000,carp("'use charnames' needs explicit imports list");
0.000000,0,0.000000,}
0.000005,1,0.000005,$^H{charnames} = \&charnames ;
0.000003,1,0.000003,$^H{charnames_ord_aliases} = {};
0.000003,1,0.000003,$^H{charnames_name_aliases} = {};
0.000003,1,0.000003,$^H{charnames_inverse_ords} = {};
0.000000,0,0.000000,# New fields must be added to %dummy_H, and the code in lookup_name()
0.000000,0,0.000000,# that copies fields from the runtime structure
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## fill %h keys with our @_ args.
0.000000,0,0.000000,##
0.000002,1,0.000002,my ($promote, %h, @args) = (0);
0.000009,1,0.000009,while (my $arg = shift) {
0.000003,2,0.000002,if ($arg eq ":alias") {
0.000000,0,0.000000,@_ or
0.000000,0,0.000000,croak ":alias needs an argument in charnames";
0.000000,0,0.000000,my $alias = shift;
0.000000,0,0.000000,if (ref $alias) {
0.000000,0,0.000000,ref $alias eq "HASH" or
0.000000,0,0.000000,croak "Only HASH reference supported as argument to :alias";
0.000000,0,0.000000,alias ($alias);
0.000000,0,0.000000,$promote = 1;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,if ($alias =~ m{:(\w+)$}) {
0.000000,0,0.000000,$1 eq "full" || $1 eq "loose" || $1 eq "short" and
0.000000,0,0.000000,croak ":alias cannot use existing pragma :$1 (reversed order?)";
0.000000,0,0.000000,alias_file ($1) and $promote = 1;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000000,0,0.000000,alias_file ($alias) and $promote = 1;
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000005,2,0.000002,if (substr($arg, 0, 1) eq ':'
0.000000,0,0.000000,and ! ($arg eq ":full" || $arg eq ":short" || $arg eq ":loose"))
0.000000,0,0.000000,{
0.000000,0,0.000000,warn "unsupported special '$arg' in charnames";
0.000000,0,0.000000,next;
0.000000,0,0.000000,}
0.000004,2,0.000002,push @args, $arg;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000002,1,0.000002,@args == 0 && $promote and @args = (":full");
0.000004,1,0.000004,@h{@args} = (1) x @args;
0.000000,0,0.000000,
0.000000,0,0.000000,# Don't leave these undefined as are tested for in lookup_names
0.000004,1,0.000004,$^H{charnames_full} = delete $h{':full'} || 0;
0.000003,1,0.000003,$^H{charnames_loose} = delete $h{':loose'} || 0;
0.000004,1,0.000004,$^H{charnames_short} = delete $h{':short'} || 0;
0.000003,1,0.000003,my @scripts = map { uc quotemeta } keys %h;
0.000000,0,0.000000,
0.000000,0,0.000000,##
0.000000,0,0.000000,## If utf8? warnings are enabled, and some scripts were given,
0.000000,0,0.000000,## see if at least we can find one letter from each script.
0.000000,0,0.000000,##
0.000006,1,0.000006,if (warnings::enabled('utf8') && @scripts) {
0.000000,0,0.000000,$txt = do "unicore/Name.pl" unless $txt;
0.000000,0,0.000000,
0.000000,0,0.000000,for my $script (@scripts) {
0.000000,0,0.000000,if (not $txt =~ m/\t$script (?:CAPITAL |SMALL )?LETTER /) {
0.000000,0,0.000000,warnings::warn('utf8',  "No such script: '$script'");
0.000000,0,0.000000,$script = quotemeta $script;  # Escape it, for use in the re.
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# %^H gets stringified, so serialize it ourselves so can extract the
0.000000,0,0.000000,# real data back later.
0.000005,1,0.000005,$^H{charnames_stringified_ords} = join ",", %{$^H{charnames_ord_aliases}};
0.000004,1,0.000004,$^H{charnames_stringified_names} = join ",", %{$^H{charnames_name_aliases}};
0.000003,1,0.000003,$^H{charnames_stringified_inverse_ords} = join ",", %{$^H{charnames_inverse_ords}};
0.000000,0,0.000000,
0.000000,0,0.000000,# Modify the input script names for loose name matching if that is also
0.000000,0,0.000000,# specified, similar to the way the base character name is prepared.  They
0.000000,0,0.000000,# don't (currently, and hopefully never will) have dashes.  These go into a
0.000000,0,0.000000,# regex, and have already been uppercased and quotemeta'd.  Squeeze out all
0.000000,0,0.000000,# input underscores, blanks, and dashes.  Then convert so will match a blank
0.000000,0,0.000000,# between any characters.
0.000002,1,0.000002,if ($^H{charnames_loose}) {
0.000000,0,0.000000,for (my $i = 0; $i < @scripts; $i++) {
0.000000,0,0.000000,$scripts[$i] =~ s/[_ -]//g;
0.000000,0,0.000000,$scripts[$i] =~ s/ ( [^\\] ) (?= . ) /$1\\ ?/gx;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000009,1,0.000009,$^H{charnames_scripts} = join "|", @scripts;  # Stringifiy them as a trie
0.000000,0,0.000000,} # import
0.000000,0,0.000000,
0.000000,0,0.000000,# Cache of already looked-up values.  This is set to only contain
0.000000,0,0.000000,# official values, and user aliases can't override them, so scoping is
0.000000,0,0.000000,# not an issue.
0.000001,1,0.000001,my %viacode;
0.000000,0,0.000000,
0.000000,0,0.000000,sub viacode {
0.000000,0,0.000000,
0.000000,0,0.000000,# Returns the name of the code point argument
0.000000,0,0.000000,
0.000000,0,0.000000,if (@_ != 1) {
0.000000,0,0.000000,carp "charnames::viacode() expects one argument";
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my $arg = shift;
0.000000,0,0.000000,
0.000000,0,0.000000,# This is derived from Unicode::UCD, where it is nearly the same as the
0.000000,0,0.000000,# function _getcode(), but here it makes sure that even a hex argument
0.000000,0,0.000000,# has the proper number of leading zeros, which is critical in
0.000000,0,0.000000,# matching against $txt below
0.000000,0,0.000000,# Must check if decimal first; see comments at that definition
0.000000,0,0.000000,my $hex;
0.000000,0,0.000000,if ($arg =~ $decimal_qr) {
0.000000,0,0.000000,$hex = sprintf "%05X", $arg;
0.000000,0,0.000000,} elsif ($arg =~ $hex_qr) {
0.000000,0,0.000000,# Below is the line that differs from the _getcode() source
0.000000,0,0.000000,$hex = sprintf "%05X", hex $1;
0.000000,0,0.000000,} else {
0.000000,0,0.000000,carp("unexpected arg \"$arg\" to charnames::viacode()");
0.000000,0,0.000000,return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,return $viacode{$hex} if exists $viacode{$hex};
0.000000,0,0.000000,
0.000000,0,0.000000,my $return;
0.000000,0,0.000000,
0.000000,0,0.000000,# If the code point is above the max in the table, there's no point
0.000000,0,0.000000,# looking through it.  Checking the length first is slightly faster
0.000000,0,0.000000,if (length($hex) <= 5 || CORE::hex($hex) <= 0x10FFFF) {
0.000000,0,0.000000,$txt = do "unicore/Name.pl" unless $txt;
0.000000,0,0.000000,
0.000000,0,0.000000,# See if the name is algorithmically determinable.
0.000000,0,0.000000,my $algorithmic = charnames::code_point_to_name_special(CORE::hex $hex);
0.000000,0,0.000000,if (defined $algorithmic) {
0.000000,0,0.000000,$viacode{$hex} = $algorithmic;
0.000000,0,0.000000,return $algorithmic;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Return the official name, if exists.  It's unclear to me (khw) at
0.000000,0,0.000000,# this juncture if it is better to return a user-defined override, so
0.000000,0,0.000000,# leaving it as is for now.
0.000000,0,0.000000,if ($txt =~ m/^$hex\t/m) {
0.000000,0,0.000000,
0.000000,0,0.000000,# The name starts with the next character and goes up to the
0.000000,0,0.000000,# next new-line.  Using capturing parentheses above instead of
0.000000,0,0.000000,# @+ more than doubles the execution time in Perl 5.13
0.000000,0,0.000000,$return = substr($txt, $+[0], index($txt, "\n", $+[0]) - $+[0]);
0.000000,0,0.000000,
0.000000,0,0.000000,# If not one of these 4 code points, return what we've found.
0.000000,0,0.000000,if ($hex !~ / ^ 000 (?: 8[014] | 99 ) $ /x) {
0.000000,0,0.000000,$viacode{$hex} = $return;
0.000000,0,0.000000,return $return;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# For backwards compatibility, we don't return the official name of
0.000000,0,0.000000,# the 4 code points if there are user-defined aliases for them -- so
0.000000,0,0.000000,# continue looking.
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# See if there is a user name for it, before giving up completely.
0.000000,0,0.000000,# First get the scoped aliases, give up if have none.
0.000000,0,0.000000,my $H_ref = (caller(1))[10];
0.000000,0,0.000000,return if ! defined $return
0.000000,0,0.000000,&& (! defined $H_ref
0.000000,0,0.000000,|| ! exists $H_ref->{charnames_stringified_inverse_ords});
0.000000,0,0.000000,
0.000000,0,0.000000,my %code_point_aliases;
0.000000,0,0.000000,if (defined $H_ref->{charnames_stringified_inverse_ords}) {
0.000000,0,0.000000,%code_point_aliases = split ',',
0.000000,0,0.000000,$H_ref->{charnames_stringified_inverse_ords};
0.000000,0,0.000000,return $code_point_aliases{$hex} if exists $code_point_aliases{$hex};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Here there is no user-defined alias, return any official one.
0.000000,0,0.000000,return $return if defined $return;
0.000000,0,0.000000,
0.000000,0,0.000000,if (CORE::hex($hex) > 0x10FFFF
0.000000,0,0.000000,&& warnings::enabled('non_unicode'))
0.000000,0,0.000000,{
0.000000,0,0.000000,carp "Unicode characters only allocated up to U+10FFFF (you asked for U+$hex)";
0.000000,0,0.000000,}
0.000000,0,0.000000,return;
0.000000,0,0.000000,
0.000000,0,0.000000,} # _viacode
0.000000,0,0.000000,
0.000009,1,0.000009,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ex: set ts=8 sts=2 sw=2 et:
