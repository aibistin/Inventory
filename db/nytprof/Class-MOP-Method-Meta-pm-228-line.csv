# Profile data generated by Devel::NYTProf::Reader
# Version: v5.06
# More information at http://search.cpan.org/dist/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,
0.000000,0,0.000000,package Class::MOP::Method::Meta;
0.000000,0,0.000000,BEGIN {
0.000008,1,0.000008,$Class::MOP::Method::Meta::AUTHORITY = 'cpan:STEVAN';
0.000034,1,0.000034,}
0.000000,0,0.000000,{
0.000005,2,0.000002,$Class::MOP::Method::Meta::VERSION = '2.1005';
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000031,2,0.000016,use strict;
0.000033,2,0.000016,use warnings;
0.000000,0,0.000000,
0.000039,2,0.000020,use Carp         'confess';
0.000044,2,0.000022,use Scalar::Util 'blessed', 'weaken';
0.000000,0,0.000000,
0.000041,2,0.000021,use constant DEBUG_NO_META => $ENV{DEBUG_NO_META} ? 1 : 0;
0.000000,0,0.000000,
0.000293,2,0.000146,use base 'Class::MOP::Method';
0.000000,0,0.000000,
0.000000,0,0.000000,sub _is_caller_mop_internal {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($caller) = @_;
0.000000,0,0.000000,return $caller =~ /^(?:Class::MOP|metaclass)(?:::|$)/;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _generate_meta_method {
0.000043,25,0.000002,my $method_self = shift;
0.000038,25,0.000002,my $metaclass   = shift;
0.000179,25,0.000007,weaken($metaclass);
0.000000,0,0.000000,
0.000000,0,0.000000,sub {
0.000000,0,0.000000,# this will be compiled out if the env var wasn't set
0.000000,0,0.000000,if (DEBUG_NO_META) {
0.000000,0,0.000000,confess "'meta' method called by MOP internals"
0.000000,0,0.000000,# it's okay to call meta methods on metaclasses, since we
0.000000,0,0.000000,# explicitly ask for them
0.000000,0,0.000000,if !$_[0]->isa('Class::MOP::Object')
0.000000,0,0.000000,&& !$_[0]->isa('Class::MOP::Mixin')
0.000000,0,0.000000,# it's okay if the test itself calls ->meta, we only care about
0.000000,0,0.000000,# if the mop internals call ->meta
0.000000,0,0.000000,&& $method_self->_is_caller_mop_internal(scalar caller);
0.000000,0,0.000000,}
0.000000,0,0.000000,# we must re-initialize so that it
0.000000,0,0.000000,# works as expected in subclasses,
0.000000,0,0.000000,# since metaclass instances are
0.000000,0,0.000000,# singletons, this is not really a
0.000000,0,0.000000,# big deal anyway.
0.003363,223,0.000015,$metaclass->initialize(blessed($_[0]) || $_[0])
0.000194,25,0.000008,};
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub wrap {
0.000073,25,0.000003,my ($class, @args) = @_;
0.000000,0,0.000000,
0.000046,25,0.000002,unshift @args, 'body' if @args % 2 == 1;
0.000080,25,0.000003,my %params = @args;
0.000041,25,0.000002,confess "Overriding the body of meta methods is not allowed"
0.000000,0,0.000000,if $params{body};
0.000000,0,0.000000,
0.000144,25,0.000006,my $metaclass_class = $params{associated_metaclass}->meta;
0.000172,25,0.000007,$params{body} = $class->_generate_meta_method($metaclass_class);
0.000295,25,0.000012,return $class->SUPER::wrap(%params);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub _make_compatible_with {
0.000000,0,0.000000,my $self = shift;
0.000000,0,0.000000,my ($other) = @_;
0.000000,0,0.000000,
0.000000,0,0.000000,# XXX: this is pretty gross. the issue here is that CMOP::Method::Meta
0.000000,0,0.000000,# objects are subclasses of CMOP::Method, but when we get to moose, they'll
0.000000,0,0.000000,# need to be compatible with Moose::Meta::Method, which isn't possible. the
0.000000,0,0.000000,# right solution here is to make ::Meta into a role that gets applied to
0.000000,0,0.000000,# whatever the method_metaclass happens to be and get rid of
0.000000,0,0.000000,# _meta_method_metaclass entirely, but that's not going to happen until
0.000000,0,0.000000,# we ditch cmop and get roles into the bootstrapping, so. i'm not
0.000000,0,0.000000,# maintaining the previous behavior of turning them into instances of the
0.000000,0,0.000000,# new method_metaclass because that's equally broken, and at least this way
0.000000,0,0.000000,# any issues will at least be detectable and potentially fixable. -doy
0.000000,0,0.000000,return $self unless $other->_is_compatible_with($self->_real_ref_name);
0.000000,0,0.000000,
0.000000,0,0.000000,return $self->SUPER::_make_compatible_with(@_);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000003,1,0.000003,1;
0.000000,0,0.000000,
0.000000,0,0.000000,# ABSTRACT: Method Meta Object for C<meta> methods
0.000000,0,0.000000,
0.000000,0,0.000000,__END__
